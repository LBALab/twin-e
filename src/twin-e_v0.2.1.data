/** @file actor.c
	@brief
	This file contains scene actor routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "actor.h"
#include "lbaengine.h"
#include "scene.h"
#include "hqrdepack.h"
#include "resources.h"
#include "renderer.h"
#include "grid.h"
#include "animations.h"
#include "renderer.h"
#include "movements.h"
#include "gamestate.h"
#include "sound.h"
#include "extra.h"

/** Actors 3D body table - size of NUM_BODIES */
uint8 *bodyTable[NUM_BODIES];

/** Restart hero variables while opening new scenes */
void restartHeroScene() {
	sceneHero->controlMode = 1;
	memset(&sceneHero->dynamicFlags, 0, 2);
	memset(&sceneHero->staticFlags, 0, 2);

	sceneHero->staticFlags.bComputeCollisionWithObj = 1;
	sceneHero->staticFlags.bComputeCollisionWithBricks = 1;
	sceneHero->staticFlags.bIsZonable = 1;
	sceneHero->staticFlags.bCanDrown = 1;
	sceneHero->staticFlags.bCanFall = 1;

	sceneHero->armor = 1;
	sceneHero->positionInMoveScript = -1;
	sceneHero->labelIdx = -1;
	sceneHero->positionInLifeScript = 0;
	sceneHero->zone = -1;
	sceneHero->angle = previousHeroAngle;

	setActorAngleSafe(sceneHero->angle, sceneHero->angle, 0, &sceneHero->move);
	setBehaviour(previousHeroBehaviour);
	
	cropBottomScreen = 0;
}

/** Load hero 3D body and animations */
void loadHeroEntities() {
	hqrGetallocEntry(&heroEntityATHLETIC, HQR_FILE3D_FILE, FILE3DHQR_HEROATHLETIC);
	sceneHero->entityDataPtr = heroEntityATHLETIC;
	heroAnimIdxATHLETIC = getBodyAnimIndex(0, 0);

	hqrGetallocEntry(&heroEntityAGGRESSIVE, HQR_FILE3D_FILE, FILE3DHQR_HEROAGGRESSIVE);
	sceneHero->entityDataPtr = heroEntityAGGRESSIVE;
	heroAnimIdxAGGRESSIVE = getBodyAnimIndex(0, 0);

	hqrGetallocEntry(&heroEntityDISCRETE, HQR_FILE3D_FILE, FILE3DHQR_HERODISCRETE);
	sceneHero->entityDataPtr = heroEntityDISCRETE;
	heroAnimIdxDISCRETE = getBodyAnimIndex(0, 0);

	hqrGetallocEntry(&heroEntityPROTOPACK, HQR_FILE3D_FILE, FILE3DHQR_HEROPROTOPACK);
	sceneHero->entityDataPtr = heroEntityPROTOPACK;
	heroAnimIdxPROTOPACK = getBodyAnimIndex(0, 0);

	hqrGetallocEntry(&heroEntityNORMAL, HQR_FILE3D_FILE, FILE3DHQR_HERONORMAL);
	sceneHero->entityDataPtr = heroEntityNORMAL;
	heroAnimIdxNORMAL = getBodyAnimIndex(0, 0);

	sceneHero->animExtraPtr = currentActorAnimExtraPtr;
}

/** Set hero behaviour
	@param behaviour behaviour value to set */
void setBehaviour(int32 behaviour) {
	int32 bodyIdx;

	switch (behaviour) {
	case kNormal:
		heroBehaviour = kNormal;
		sceneHero->entityDataPtr = heroEntityNORMAL;
		break;
	case kAthletic:
		heroBehaviour = kAthletic;
		sceneHero->entityDataPtr = heroEntityATHLETIC;
		break;
	case kAggressive:
		heroBehaviour = kAggressive;
		sceneHero->entityDataPtr = heroEntityAGGRESSIVE;
		break;
	case kDiscrete:
		heroBehaviour = kDiscrete;
		sceneHero->entityDataPtr = heroEntityDISCRETE;
		break;
	case kProtoPack:
		heroBehaviour = kProtoPack;
		sceneHero->entityDataPtr = heroEntityPROTOPACK;
		break;
	};

	bodyIdx = sceneHero->body;

	sceneHero->entity = -1;
	sceneHero->body = -1;

	initModelActor(bodyIdx, 0);

	sceneHero->anim = -1;
	sceneHero->animType = 0;

	initAnim(kStanding, 0, 255, 0);
}

/** Initialize sprite actor
	@param actorIdx sprite actor index */
void initSpriteActor(int32 actorIdx) {
	ActorStruct *localActor = &sceneActors[actorIdx];

	if (localActor->staticFlags.bIsSpriteActor && localActor->sprite != -1 && localActor->entity != localActor->sprite) {
		int16 *ptr = (int16 *)(spriteBoundingBoxPtr + localActor->sprite * 16 + 4);

		localActor->entity = localActor->sprite;
		localActor->boudingBox.X.bottomLeft = *(ptr++);
		localActor->boudingBox.X.topRight = *(ptr++);
		localActor->boudingBox.Y.bottomLeft = *(ptr++);
		localActor->boudingBox.Y.topRight = *(ptr++);
		localActor->boudingBox.Z.bottomLeft = *(ptr++);
		localActor->boudingBox.Z.topRight = *(ptr++);
	}
}

/** Initialize 3D actor body
	@param bodyIdx 3D actor body index
	@param actorIdx 3D actor index */
int32 initBody(int32 bodyIdx, int32 actorIdx) {
	ActorStruct *localActor;
	uint8 *bodyPtr;
	uint8 var1;
	uint8 var2;
	uint8 *bodyPtr2;
	uint8 *bodyPtr3;
	uint8 *bodyPtr4;
//	int16 *bodyPtr5;
	int16 flag;
	int32 index;

	localActor = &sceneActors[actorIdx];
	bodyPtr = localActor->entityDataPtr;

	do {
		var1 = *(bodyPtr++);

		if (var1 == 0xFF)
			return (-1);

		bodyPtr2 = bodyPtr + 1;

		if (var1 == 1) {
			var2 = *(bodyPtr);

			if (var2 == bodyIdx) {
				bodyPtr3 = bodyPtr2 + 1;
				flag = *((uint16*)bodyPtr3);

				if (!(flag & 0x8000)) {
					hqrGetallocEntry(&bodyTable[currentPositionInBodyPtrTab], HQR_BODY_FILE, flag & 0xFFFF);

					if (!bodyTable[currentPositionInBodyPtrTab]) {
						printf("HQR ERROR: Loading body entities\n");
						exit(1);
					}
					prepareIsoModel(bodyTable[currentPositionInBodyPtrTab]);
					*((uint16*)bodyPtr3) = currentPositionInBodyPtrTab + 0x8000;
					index = currentPositionInBodyPtrTab;
					currentPositionInBodyPtrTab++;
				} else {
					flag &= 0x7FFF;
					index = flag;
				}

				bodyPtr3 += 2;
				bottomLeftX = -32000;

				bodyPtr4 = bodyPtr3;
				bodyPtr3++;

				if (!*bodyPtr4)
					return (index);

				bodyPtr4 = bodyPtr3;
				bodyPtr3++;

				if (*bodyPtr4 != 14)
					return (index);

//				bodyPtr5 = (int16 *) bodyPtr3;

				bottomLeftX = *((uint16*)bodyPtr3);
				bodyPtr3 += 2;
				bottomLeftY = *((uint16*)bodyPtr3);
				bodyPtr3 += 2;
				bottomLeftZ = *((uint16*)bodyPtr3);
				bodyPtr3 += 2;

				topRightX = *((uint16*)bodyPtr3);
				bodyPtr3 += 2;
				topRightY = *((uint16*)bodyPtr3);
				bodyPtr3 += 2;
				topRightZ = *((uint16*)bodyPtr3);
				bodyPtr3 += 2;

				return (index);
			}
		}

		bodyPtr = *bodyPtr2 + bodyPtr2;
	} while (1);
}

/** Initialize 3D actor
	@param bodyIdx 3D actor body index
	@param actorIdx 3D actor index */
void initModelActor(int32 bodyIdx, int16 actorIdx) {
	ActorStruct *localActor;
	int32  entityIdx;
	int    currentIndex;
	uint16 *ptr;
	int16  var1, var2, var3, var4;

	int32 result, result1, result2;

	result = 0;

	localActor = &sceneActors[actorIdx];

	if (localActor->staticFlags.bIsSpriteActor)
		return;

	if (actorIdx == 0 && heroBehaviour == kProtoPack && localActor->armor != 0 && localActor->armor != 1) { // if hero
		setBehaviour(kNormal);
	}

	if (bodyIdx != -1) {
		entityIdx = initBody(bodyIdx, actorIdx);
	} else {
		entityIdx = -1;
	}

	if (entityIdx != -1) {
		if (localActor->entity == entityIdx)
			return;

		localActor->entity = entityIdx;
		localActor->body = bodyIdx;
		currentIndex = localActor->entity;

		if (bottomLeftX == -32000) {
			ptr = (uint16 *) bodyTable[localActor->entity];
			ptr++;

			var1 = *((int16 *)ptr++);
			var2 = *((int16 *)ptr++);
			localActor->boudingBox.Y.bottomLeft = *((int16 *)ptr++);
			localActor->boudingBox.Y.topRight = *((int16 *)ptr++);
			var3 = *((int16 *)ptr++);
			var4 = *((int16 *)ptr++);

			if (localActor->staticFlags.bUseMiniZv) {
				result1 = var2 - var1; // take smaller for bound
				result2 = var4 - var3;

				if (result1 < result2)
					result = result1;
				else
					result = result2;

				result = abs(result);
				result >>= 1;
			} else {
				result1 = var2 - var1; // take average for bound
				result2 = var4 - var3;

				result = result2 + result1;
				result = abs(result);
				result >>= 2;
			}

			localActor->boudingBox.X.bottomLeft = -result;
			localActor->boudingBox.X.topRight = result;
			localActor->boudingBox.Z.bottomLeft = -result;
			localActor->boudingBox.Z.topRight = result;
		} else {
			localActor->boudingBox.X.bottomLeft = bottomLeftX;
			localActor->boudingBox.X.topRight = topRightX;
			localActor->boudingBox.Y.bottomLeft = bottomLeftY;
			localActor->boudingBox.Y.topRight = topRightY;
			localActor->boudingBox.Z.bottomLeft = bottomLeftZ;
			localActor->boudingBox.Z.topRight = topRightZ;
		}

		if (currentIndex == -1)
			return;

		if (localActor->previousAnimIdx == -1)
			return;

		copyActorInternAnim(bodyTable[currentIndex], bodyTable[localActor->entity]);

		return;
	}

	localActor->body = -1;
	localActor->entity = -1;

	localActor->boudingBox.X.bottomLeft = 0;
	localActor->boudingBox.X.topRight = 0;
	localActor->boudingBox.Y.bottomLeft = 0;
	localActor->boudingBox.Y.topRight = 0;
	localActor->boudingBox.Z.bottomLeft = 0;
	localActor->boudingBox.Z.topRight = 0;
}

/** Initialize actors
	@param actorIdx actor index to init */
void initActor(int16 actorIdx) {
	ActorStruct *actor = &sceneActors[actorIdx];

	if (actor->staticFlags.bIsSpriteActor) { // if sprite actor
		if (actor->strengthOfHit != 0) {
			actor->dynamicFlags.bIsHitting = 1;
		}

		actor->entity = -1;

		initSpriteActor(actorIdx);

		setActorAngleSafe(0, 0, 0, &actor->move);

		if (actor->staticFlags.bUsesClipping) {
			actor->lastX = actor->X;
			actor->lastY = actor->Y;
			actor->lastZ = actor->Z;
		}

	} else {
		actor->entity = -1;

		initModelActor(actor->body, actorIdx);

		actor->previousAnimIdx = -1;
		actor->animType = 0;

		if (actor->entity != -1) {
			initAnim(actor->anim, 0, 255, actorIdx);
		}

		setActorAngleSafe(actor->angle, actor->angle, 0, &actor->move);
	}

	actor->positionInMoveScript = -1;
	actor->labelIdx = -1;
	actor->positionInLifeScript = 0;
}

/** Reset actor
	@param actorIdx actor index to init */
void resetActor(int16 actorIdx) {
	ActorStruct *actor = &sceneActors[actorIdx];

	actor->body = 0;
	actor->anim = 0;
	actor->X = 0;
	actor->Y = -1;
	actor->Z = 0;

	actor->boudingBox.X.bottomLeft = 0;
	actor->boudingBox.X.topRight = 0;
	actor->boudingBox.Y.bottomLeft = 0;
	actor->boudingBox.Y.topRight = 0;
	actor->boudingBox.Z.bottomLeft = 0;
	actor->boudingBox.Z.topRight = 0;

	actor->angle = 0;
	actor->speed = 40;
	actor->controlMode = 0;

	actor->info0 = 0;
	actor->info1 = 0;
	actor->info2 = 0;
	actor->info3 = 0;

	actor->brickShape = 0;
	actor->collision = -1;
	actor->standOn = -1;
	actor->zone = -1;
	
	memset(&actor->staticFlags,0,2);
	memset(&actor->dynamicFlags,0,2);

	actor->life = 50;
	actor->armor = 1;
	actor->hitBy = -1;
	actor->lastRotationAngle = 0;
	actor->lastX = 0;
	actor->lastY = 0;
	actor->lastZ = 0;
	actor->entity = -1;
	actor->previousAnimIdx = -1;
	actor->animType = 0;
	actor->animPosition = 0;

	setActorAngleSafe(0, 0, 0, &actor->move);

	actor->positionInMoveScript = -1;
	actor->positionInLifeScript = 0;
}

/** Process hit actor
	@param actorIdx actor hitting index
	@param actorIdxAttacked actor attacked index
	@param strengthOfHit actor hitting strength of hit
	@param angle angle of actor hitting */
void hitActor(int32 actorIdx, int32 actorIdxAttacked, int32 strengthOfHit, int32 angle) {
	ActorStruct *actor = &sceneActors[actorIdxAttacked];

	if (actor->life <= 0) {
		return;
	}

	actor->hitBy = actorIdx;

	if (actor->armor <= strengthOfHit) {
		if (actor->anim == kBigHit || actor->anim == kHit2) {
			int32 tmpAnimPos;
			tmpAnimPos = actor->animPosition;
			if (actor->animExtra) {
				processAnimActions(actorIdxAttacked);
			}

			actor->animPosition = tmpAnimPos;
		} else {
			if (angle != -1) {
				setActorAngleSafe(angle, angle, 0, &actor->move);
			} 
			
			if (rand() & 1) {
				initAnim(kHit2, 3, 255, actorIdxAttacked);
			} else {
				initAnim(kBigHit, 3, 255, actorIdxAttacked);
			}
		}

		addExtraSpecial(actor->X, actor->Y + 1000, actor->Z, kHitStars);

		if (!actorIdxAttacked) {
			heroMoved = 1;
		}

		actor->life -= strengthOfHit;

		if (actor->life < 0) {
			actor->life = 0;
		}
	} else {
		initAnim(kHit, 3, 255, actorIdxAttacked);
	}
}

/** Process actor carrier */
void processActorCarrier(int32 actorIdx) { // CheckCarrier
	int32 a;
	ActorStruct *actor = &sceneActors[actorIdx];

	if (actor->staticFlags.bIsCarrierActor) {
		for (a = 0; a < sceneNumActors; a++) {
			if (actor->standOn == actorIdx) {
				actor->standOn = -1;
			}
		}
	}
}

/** Process actor extra bonus */
void processActorExtraBonus(int32 actorIdx) { // GiveExtraBonus
	int32 a, numBonus;
	int8 bonusTable[8], currentBonus;
	ActorStruct *actor = &sceneActors[actorIdx];

	numBonus = 0;

	for (a = 0; a < 5; a++) {
		if (actor->bonusParameter & (1 << (a + 4))) {
			bonusTable[numBonus++] = a;
		}
	}

	if (numBonus) {
		currentBonus = bonusTable[Rnd(numBonus)];
		// if bonus is magic an no magic level yet, then give life points
		if (!magicLevelIdx && currentBonus == 2) {
			currentBonus = 1;
		}
		currentBonus += 3;

		if (actor->dynamicFlags.bIsDead) {
			addExtraBonus(actor->X, actor->Y, actor->Z, 0x100, 0, currentBonus, actor->bonusAmount);
			// FIXME add constant for sample index
			playSample(11, 0x1000, 1, actor->X, actor->Y, actor->Z, actorIdx);
		} else {
			int32 angle = getAngleAndSetTargetActorDistance(actor->X, actor->Z, sceneHero->X, sceneHero->Z);
			addExtraBonus(actor->X, actor->Y + actor->boudingBox.Y.topRight, actor->Z, 200, angle, currentBonus, actor->bonusAmount);
			// FIXME add constant for sample index
			playSample(11, 0x1000, 1, actor->X, actor->Y + actor->boudingBox.Y.topRight, actor->Z, actorIdx);
		}
	}
}
/** @file actor.h
	@brief
	This file contains scene actor routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef ACTOR_H
#define ACTOR_H

#include "sys.h"

/** Total number of sprites allowed in the game */
#define NUM_SPRITES 200

/** Total number of bodies allowed in the game */
#define NUM_BODIES 200

enum HeroBehaviourType {
	kNormal		= 0,
	kAthletic	= 1,
	kAggressive = 2,
	kDiscrete	= 3,
	kProtoPack	= 4
};


/** Table with all loaded sprites */
uint8* spriteTable[NUM_SPRITES];
/** Table with all loaded sprite sizes */
uint32   spriteSizeTable[NUM_SPRITES];

/** Actors move structure */
typedef struct ActorMoveStruct {
	int16 from;
	int16 to;
	int16 numOfStep;
	int32 timeOfChange;
} ActorMoveStruct;

/** Actors zone volumique points structure */
typedef struct ZVPoint {
	int16 bottomLeft;
	int16 topRight;
} ZVPoint;

/** Actors zone volumique box structure */
typedef struct ZVBox {
	ZVPoint X;
	ZVPoint Y;
	ZVPoint Z;
} ZVBox;

/** Actors animation timer structure */
typedef struct AnimTimerDataStruct {
	uint8* ptr;
	int32 time;
} AnimTimerDataStruct;

/** Actors static flags structure */
typedef struct StaticFlagsStruct {
	uint16 bComputeCollisionWithObj				: 1; // 0x0001
	uint16 bComputeCollisionWithBricks			: 1; // 0x0002
	uint16 bIsZonable							: 1; // 0x0004
	uint16 bUsesClipping						: 1; // 0x0008
	uint16 bCanBePushed							: 1; // 0x0010
	uint16 bComputeLowCollision					: 1; // 0x0020
	uint16 bCanDrown							: 1; // 0x0040
	uint16 bUnk80								: 1; // 0x0080
	uint16 bUnk0100								: 1; // 0x0100
	uint16 bIsHidden							: 1; // 0x0200
	uint16 bIsSpriteActor						: 1; // 0x0400
	uint16 bCanFall								: 1; // 0x0800
	uint16 bDoesntCastShadow					: 1; // 0x1000
	uint16 bIsBackgrounded						: 1; // 0x2000
	uint16 bIsCarrierActor						: 1; // 0x4000
	uint16 bUseMiniZv							: 1; // 0x8000
} StaticFlagsStruct;

/** Actors dynamic flags structure */
typedef struct DynamicFlagsStruct {
	uint16 bWaitHitFrame						: 1; // 0x0001 wait for hit frame
	uint16 bIsHitting							: 1; // 0x0002 hit frame anim
	uint16 bAnimEnded							: 1; // 0x0004 anim ended in the current loop (will be looped in the next engine loop)
	uint16 bAnimFrameReached					: 1; // 0x0008 new frame anim reached
	uint16 bIsVisible							: 1; // 0x0010 actor has been drawn in this loop
	uint16 bIsDead								: 1; // 0x0020 is dead
	uint16 bIsSpriteMoving						: 1; // 0x0040 door is opening or closing (wait to reach the destination position)
	uint16 bIsRotationByAnim					: 1; // 0x0080 actor rotation is managed by its animaation not by the engine
	uint16 bIsFalling							: 1; // 0x0100 is falling on scene
	uint16 bUnk0200								: 1; // 0x0200 unused
	uint16 bUnk0400								: 1; // 0x0400 unused
	uint16 bUnk0800								: 1; // 0x0800 unused
	uint16 bUnk1000								: 1; // 0x1000 unused
	uint16 bUnk2000								: 1; // 0x2000 unused
	uint16 bUnk4000								: 1; // 0x4000 unused
	uint16 bUnk8000								: 1; // 0x8000 unused
} DynamicFlagsStruct;

/** Actors structure */
typedef struct ActorStruct {
	StaticFlagsStruct staticFlags;
	DynamicFlagsStruct dynamicFlags;

	int32 entity; // costumeIndex
	int32 body;
	int32 anim;
	int32 animExtra; //field_2
	int32 brickShape; // field_3
	uint8 *animExtraPtr;
	int32 sprite; // field_8
	uint8 *entityDataPtr;

	int32 X;
	int32 Y;
	int32 Z;
	int32 strengthOfHit; // field_66
	int32 hitBy;
	int32 bonusParameter; // field_10
	int32 angle;
	int32 speed;
	int32 controlMode;
	int32 info0; // cropLeft
	int32 info1; // cropTop
	int32 info2; // cropRight
	int32 info3; // cropBottom
	int32 followedActor; // same as info3
	int32 bonusAmount; // field_12
	int32 talkColor;
	int32 armor; // field_14
	int32 life;

	int32 collisionX; // field_20
	int32 collisionY; // field_22
	int32 collisionZ; // field_24

	int32 positionInMoveScript;
	uint8 *moveScript;

	int32 positionInLifeScript;
	uint8 *lifeScript;

	int32 labelIdx;			// script label index
	int32 currentLabelPtr;	// pointer to LABEL offset
	int32 pausedTrackPtr;

	//int costumeIndex;
	int32 collision;
	int32 standPosition;
	int32 standOn;
	int32 zone;

	int32 lastRotationAngle;
	int32 lastX;
	int32 lastZ;
	int32 lastY;
	int32 previousAnimIdx;
	int32 doorStatus;
	int32 animPosition;
	int32 animType;   // field_78
	int32 brickSound; // field_7A

	ZVBox boudingBox;
	ActorMoveStruct move;
	AnimTimerDataStruct animTimerData;
} ActorStruct;

/** Actor shadow X coordinate */
int32 shadowX;
/** Actor shadow Y coordinate */
int32 shadowY;
/** Actor shadow Z coordinate */
int32 shadowZ;
/** Actor shadow collition type */
int8 shadowCollisionType; // shadowVar

/** Hero behaviour */
int16 heroBehaviour;
/** Hero auto agressive mode */
int16 autoAgressive;
/** Previous Hero behaviour */
int16 previousHeroBehaviour;
/** Previous Hero angle */
int16 previousHeroAngle;

int16 cropBottomScreen;

/** Hero 3D entity for normal behaviour */
uint8 *heroEntityNORMAL;	 // file3D0
/** Hero 3D entity for athletic behaviour */
uint8 *heroEntityATHLETIC;	 // file3D1
/** Hero 3D entity for aggressive behaviour */
uint8 *heroEntityAGGRESSIVE; // file3D2
/** Hero 3D entity for discrete behaviour */
uint8 *heroEntityDISCRETE;	 // file3D3
/** Hero 3D entity for protopack behaviour */
uint8 *heroEntityPROTOPACK;  // file3D4

/** Hero current anim for normal behaviour */
int16 heroAnimIdxNORMAL;	 // TCos0Init
/** Hero current anim for athletic behaviour */
int16 heroAnimIdxATHLETIC;	 // TCos1Init
/** Hero current anim for aggressive behaviour */
int16 heroAnimIdxAGGRESSIVE; // TCos2Init
/** Hero current anim for discrete behaviour */
int16 heroAnimIdxDISCRETE;	 // TCos3Init
/** Hero current anim for protopack behaviour */
int16 heroAnimIdxPROTOPACK;  // TCos4Init

/** Hero anim for behaviour menu */
int16 heroAnimIdx[4]; // TCOS

/** Actors 3D body table - size of NUM_BODIES */
extern uint8 *bodyTable[NUM_BODIES];

/** Current position in body table */
int32 currentPositionInBodyPtrTab;

/** Actor bounding box bottom left X coordinate */
int16 bottomLeftX; // loadCostumeVar
/** Actor bounding box bottom left Y coordinate */
int16 bottomLeftY; // loadCostumeVar2
/** Actor bounding box bottom left Z coordinate */
int16 bottomLeftZ; // loadCostumeVar3
/** Actor bounding box top left X coordinate */
int16 topRightX;   // loadCostumeVar4
/** Actor bounding box top left Y coordinate */
int16 topRightY;   // loadCostumeVar5
/** Actor bounding box top left Z coordinate */
int16 topRightZ;   // loadCostumeVar6

/** Restart hero variables while opening new scenes */
void restartHeroScene();

/** Load hero 3D body and animations */
void loadHeroEntities();

/** Set hero behaviour
	@param behaviour behaviour value to set */
void setBehaviour(int32 behaviour);

/** Initialize 3D actor body
	@param bodyIdx 3D actor body index
	@param actorIdx 3D actor index */
int32 initBody(int32 bodyIdx, int32 actorIdx);

/** Preload all sprites */
void preloadSprites();

/** Initialize 3D actor
	@param bodyIdx 3D actor body index
	@param actorIdx 3D actor index */
void initModelActor(int32 bodyIdx, int16 actorIdx);

/** Initialize actors
	@param actorIdx actor index to init */
void initActor(int16 actorIdx);

/** Reset actor
	@param actorIdx actor index to init */
void resetActor(int16 actorIdx);

/** Process hit actor
	@param actorIdx actor hitting index
	@param actorIdxAttacked actor attacked index
	@param strengthOfHit actor hitting strength of hit
	@param angle angle of actor hitting */
void hitActor(int32 actorIdx, int32 actorIdxAttacked, int32 strengthOfHit, int32 angle);

/** Process actor carrier */
void processActorCarrier(int32 actorIdx);

/** Process actor extra bonus */
void processActorExtraBonus(int32 actorIdx);

#endif
BCÀŞ!  M  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  >  f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØ@°l †ÿÿÿÿ iA ¶( Û@€mˆãÿÿÿÿ‚Êaæ¡àAÊaÒaÊ¡ÌÚ!È0‡p`‡y(€p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th€ä¡ÊÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú¡ÜáÜ¡Ø¡ÂÁ ÂŞ¡ÒÁÌaÚÀà¡Ú!è sv˜‡r wx‡6p‡pp‡yhs€‡6h‡p t Ì!ØaÊ æÂaÖ¡àAŞÊaèáä¡Ä¡ÌÁÊAÚ`ÒAÊÀ€¨w˜‡p0‡rhs€‡6h‡p t Ì!ØaÊ êaÊ¡æáÌÚÀØáÂ sv˜‡r 6È ˆÁ†ÙHşÿÿÿ "‚Êaæ¡àAÊaÒaÊ¡ÌÚ!È0‡p`‡y(€p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th€ä¡ÊÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú¡ÜáÜ¡Ø¡ÂÁ ÂŞ¡ÒÁÌaÚÀà¡Ú!è sv˜‡r wx‡6p‡pp‡yhs€‡6h‡p t Ì!ØaÊ æÂaÖ¡àAŞÊaèáä¡Ä¡ÌÁÊAÚ`ÒAÊÀ€¨w˜‡p0‡rhs€‡6h‡p t Ì!ØaÊ êaÊ¡æáÌÚÀØáÂ sv˜‡r 6Ô†òÿÿÿÿ Áå0óĞğ å0é0åĞæ íä ˜C8°Ã<”@¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´@òPå îğm`òíPm ïî@å mPìíĞîğîĞìPá` áïĞéàæ0m`ğĞíô€€9„;ÌC9 „;¼C¸C8¸Ã<´9ÀC´C8Ğ: æì0å ó@á0ëĞğ ï@å0ôğòĞâPæ`å m0é å à@Ôƒ;ÌC8˜C9´9ÀC´C8Ğ: æì0å õ0åĞóğæ@m`ìğá@€9„;ÌC9 Œåÿÿÿÿ@¨óÿÿÿÿ   I     ‚`‚ ¢0	Á1A(‚	C‚dB Lˆ`Â@Æ„ ˜ È„`™0   ‰      2"È	 d…“#¤„“#ã„¡LŒ„äLØÃ’€Ã¤)¢„Ég'`B„o‰"J˜P¸Lš"J˜ük ¾0$vŠ(aBA` 0G #M%Lşü¦ÒLH0‘¦ˆ&~7çBÃáp8Kš"J˜|M˜œÈt*‚"J˜a0§ISD	“¯5Ó"uÀ°SD	
„“¤)¢„É×„É‰Ø)¢„	Ù`@ „¡@ @ @ BP @ @@$´ ¨d‚!‘
4I U9€@—$0P&¡´¡ÄEÒQÂä³Ñ©ƒ4Ã-ÒQÂäÓ Â`0N¡Äi| q|.’¦ˆ&v‚"J˜Páñ@†$‘(‘<DJ( ™P @¨ä *- ÄJ ¹R@°”0,9
DKÙÈ‘ÁÊ%6Av‰M@ ^Îè—ó
&†gISD	“ï]S”ˆ4±SD	ŠƒÁ`0$ƒÁ@0)S$ã@	”œ#Š, „%1K4rI h!¤e D-’` k)€@Ø*
¤-²@Ü"ä-²P p—I D.Ì!@ tA@ H]
@ { €$˜ @t   °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD 6¤NÓ@é`(LåÃià|  :˜Ê‡ÓÀé`(N§ƒi |8œ¦òá4p:˜Ê‡ÓÀé`(#VçÃià”(œ¬ó v(VĞI  @ ĞÁ4P:˜JÓ@é`(L¥ƒi t0”¥ÓÁ4PR°N×À)Q8%J§Dià, Œ¦Rã5PJ”N‰ÒÀé`(LåÃià|8œ§“6pv N‰ÒÀ)Q8%J§Dià”(œ¦R¢4pJ”N‰ÒÀ)Q8N§Dià”(œ¥S¢4pj¼J×@©ñ(L¥ƒi t0”¦ÒÁ4P:˜JÓ@é`(L¥ƒi t0”¦ÒÁ4P:˜JÓ@é`(L¥ƒi t0”¦R¢4pÄJ‰ÒÀY"(L¥ƒi <™Œ)´ÑÁ4P:˜JÓ@é`(L¥ƒi t0”¦ÒÁ4P:˜JÓ@¹R[lãËm`ŒÁœ¥s&7PJ”ÎİÀy³8%J§ƒi t0”¦ÒÁ4P:˜JÓ@)Q8%J§Dià”(œ¥S¢4pâ¨NÓ@)Q8ux%jà”(œ¥S¢4pJ”N‰ÒÀ)Q8N§ƒi t0”<½ÓÇ7p:˜JÓ@é`(L¥ƒi t0”§óá4p>œÎ‡ÓÀé`(L¥ƒi t0”©ÓÁ4P:˜JÓ@)Q8~§xà$
œDáóH<ğ!‹*      À¥€     `Èò
@     0d‰      ²¨      Yf     †,µ      C–[       €!K. `    À%      `ÈR      0dÙ      ²Ä     Yz     †,¿      C–p €    €!Ë8      Àe  H    `ÈR      0d‰      ²œ     YÊ     †,±  @     C–X       €!K: @    Àe€      `ÈÒ@        &   2˜ LŒ	&GÆCŒ a€# T Ä 1F È1@ šŒ PEÃ •‚ŠRéSª1ßarÚ}‰ßä<¨ì¦§ééò\A— ÊŒ Ğf€D# D Ó ¡F H5@¬ r l€d# D Û åF h7@½ ú Pp€†# d    y     CwHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   k  fAøÒu‘£5#Wº¢-šji	Ğ Lai
%!ÁAD˜ËTDN3½È@8UD ’¡=HSÍäDØI1  Yj µ,ã3#“ÿĞï#·muÎ9IêH2+DÑBu‘£5#—‚«Ç²âë™Ğ"Ì³«C5ƒ18”DpÄ² FÈ`,åDÊ‹„³QEAD6äH ó,„‰4± ˜UIED3±B„<Ó,a°Ò “Ö ŒE,’@4„&LN$YŒ³8Î“F„$I`¶0DäxÍ„LXº¢-šji²Ò Óæ˜1À<±L¦IÄ¤	“i±,PvF!ME4“a&` Bê Í$Y…4ÑLN„S@!mÎe»Ò9!IZƒ0š0!N#Yœƒ4ÑLN„µ@°6W!’+!F‡“FNBâ4õDäÈQ8ñËbpŒp8ˆ@hd‘1À<‘. Fö`=‘#’¤	“y×›ÓP’ñĞö#I ó,„ÆÑD‹0„8³`+ÑDÔba‹K°8‚²QEADVÓ,óhÂäDìD<&'!ME4“a,’-,„(Ï`,À<aS–@EÑLö9ËâXÄ 	“Yi€#Ì³Rº Ò6±	TÍ”:2!N#6›3`éµ@`µÏ¢ä˜Î@,& 	TÍ´`iä„$ƒ&LN$—}8ODTˆCIš09Ql¡ÎâP’&LN4›ôDD…8”Ä
DCˆÃe ÎâP’&LN$Û‘"	DC„DäÄ†¤HÑ!9²%)’@4DHDÎlZ‹$ÑF€ Hv±Î49LISlKàL“Ã”D1É–±Î49LIÓljÒTD39ö-€!`€#À@h±-Ü²HO„LDa`ˆ°Ë"—5%™Ó!9±9%™Ó!9²=%™Ó!9³%À ›bÀ! ³!À[k t@HLÀ²8‚×Lf…JCXÀ›M5 ,+DÑ¬„@4n@‚4È¤	“YoÀƒwMÀ>„€ ‹)’@4„IIˆ`T’@EÑLš09‘ØÌNC˜a€Ò0DÈv 4„Å³ATOä„$­ÎLˆÓl˜Ö Œ$ÏJ4½µ,9Zƒ0âpm A\ÈdÔAD×LÈ„i ¸z,+¾å(!“&LNd ‰$‘c"‡t ƒcÅ6rH08–l$‡t ƒcÍæáHÑ'ÅhÂäD’i(9š0!Nc%“t ƒcqÎ² â4-ö¦’,D1™%–óTÍÄ
DCˆÃe4Ñâ8ØTD39&Nc)Ç -ÂæDähÂˆÃu¢«©•&°4ƒ/MÄe^‰0Ä· †dvÎ9IêH3+DÑØ $DÎ³9Óä0¬Dc@,Ò`„âp™k dÓæ˜Ö ŒØÄe˜Ğ ÌFÕ–° ÂlTQ‘m@0ÏBhL€ @Øl€ñDH3F I ó,„Ä"ÑÁBØ„4ÑLN„C˜d˜@EÑLš09‘Ö ŒwMN‘u)’@4Ä· †d	ÒAD×LÈ„u"Ë­^ëÙ×b ÁÀ3‘™4 59š’„T„Í8‹ã<ED3‘fo“0w8ˆ@H,1MHcHf°(öE C¤Sd¢ÓD1iÂäD"M@#æğ<‘#’¤	“¥Sdm‹0w8ˆ@H† E„4Ñ‘Ã
DCX–#	DCœÓF€ H&&1€°,umÕ„õ!M±u$9¦Sƒı!M³)L9Zƒ0âpu"Ë­^ë™%=2›C5Ò›s¥Sd~Å@H“lÕâPRHDÎF@…8TdÑâPRHDÖaÀ0Ş5EÀæ4”d“Œ@EÑLìD<±Q0ED3±ñÈVÀTÍÄNÄ3[È#=2,’-,„a)’@4Äì4„d—ÏHI`_0D:Ev£dÃ°BDİ!Oä$©#Å†‡<‘“¤$[òDN’:ÒlÍADÎF@…8Td;ôDÈD°08V:Ef@I ó,„”. †4†&LN$›#‘. FD'À6ÀH ó,„ÔÁB˜3‹‚4†&LNdtÎ9IêH1+DÑ˜Y„4ÑLN„S@!Yd öD@HR	HÓêLÀ„8Öa[p A¬Ã¼@TÓÆõĞÄê8ÌDum8OCw A°ÑFI ó,„‰4± ØÚÖ‘ÓL/2ÎFÙk€ƒ4Èd:±hÂäDöIBDMé8
õ´@°v0	ÎƒiÂäDb3Q£5c«ŒDLq âP‘±@‹!9^3!BHöÑ0€%Q‹8\¦§8Ñt8iä$±ùLOä„$iÂäDEÙâDÓá¤‘“ÈÆ§8Ñt8iä$³$Ä5E@‰H“EA9©#!â4-öÆC	TÍVDÄ
DCØc@4Ã"ÑÁB˜F29ÏŠÇÛF29ÏŠÇ$G29ÏŠÇ4››ÒPw8ˆ@H¶Ğ<‘#’¤	“ÅÆĞ<‘#’¤	“ÉÖĞ<‘#’¤	“Í&1i±Z3°ÄÔ‘ALš09Q‡HĞ„ù$1%b“I9! )ÒÒˆÃe¶HF‘Î€µ@°F DäxÍ„L˜Ö†¥×ŠœÉXODTˆCI¥ã<iDH1f+J„Çd:”DØU#	DCœ3;!™ÒVHDNlKHCX!9²1!a…DäÌF&!ME4“a'Å€t’õ(Àò@‰ÇdO¨®ÿ'–ŞİıŸXz¶ÆÎâ0Àó-€!YlÀƒ4ÈÄ>2š09‘L9Zƒ0âpimXz­ÈÌ²8Îc:‘N‘…I` Â,ËI1›C5aĞAD×LÈ„èjj¥U4¡ºşÚÉÿ'–DMÄÅ9N4 0’¡ …L À¦€È¤	“   a   _   A,      D(‚¨)’¢)Ÿ2*¡’*42TA	ÔAÔB!Ô`@Ô H‚Ğr   „c¼!¨ƒi0"¸€ôcŒ7w€]PØ h!Ğƒm3¨?ÆxC zpAaG ¸… </!ãAôÁ¥@Tpi×F ‰Œñ†`FáÇR *Ø´‚m#ˆ@ ˆEÆxC
©pc)|ZÁ·ƒD  $#c¼!x…W¸À±ˆ
Æ@+ƒŒ  ãA-ÔÂ¥@TpZÁì` ùÈov#‚> “1ŞôBF~0 $&c¼!ø=Œ@a ˆLÆxC{0ˆÃ ™Œñ†`ø`0" … 3„ÔdŒ7ç`
ƒÁ0 Ä&c¼!HT `\` ‚“1Ş´+P0.0 ÑÉoâ!F`‰cˆ‡€èD\@ Z"Œ¨“y a   N   G,      ¨"”D	”AA!”J Ê   3QÃL„D”Ç0!<@Â¦!ƒ4‚òĞc0"=ŠÁñh ò4c¼!€h0"`–ÀŒ(E (>ÙÇoæ`Œ†˜%0#Ğƒ ŠAù1Æ;°#‚a f	ŒÁˆõp€äcŒñ† ²Áˆ`€Yc0Â=  ùôc¼!àn0"`–À ãpŒÁ* "‘1Ş„B7|@&2Æ‚QƒÁˆ €°1bP,€.¤@)2ÆSƒÁˆ€€VdŒ7¨ ƒA*ÀˆÁÁ ½
¨ ©€á@    pÎ€‰ÃeâI@@…8T     a   B   A,      D(‰(‚2(„r  4cÄÀ  >(À ó´c¼!@e0"`Ä  €?Hƒ4¸À ƒé ©Ç10 `Ò#`H=ÉÇoŞ Œ†1( Àà .0À`„{@ñ1F P÷$zAù1Æ;À#‚a F
 h…;¸ƒ01 ~Œ ba>ŒècˆŒñ† ¾Áˆ`€ƒ hÁüàFàG  ôcÄÀ  \À (?ÈoHÁ#‚a F
 Ø…R(…0Ñ b‘1Ş¤‚FÃ     a   u  ],      D(2+‚(š2(„
¤(.2E	” 3AÃL„C‡0Ñä1ÌDHy3AÃLä1ÌD8y3AÂL„C‡0áä!ÌDHy3AÃL„DÇ0Ñl0Áh01äÁ #. Èxƒ{ìA0á@Îoú .p,¢‚+¸t¸!…0˜e„`–€#K\@á† À`–a8ÒqA†1 ƒYâhã*˜c¸!`…0˜e(€¾1Ş¸‚P0†8ƒYãF P‡X˜%8¨ÆpCğa0Ë€$Á 3dÄ   t‚Á4`–@Œ@:€Y…Ğ`7u³ËĞŒñ†@ğ€‚Am0†„ f˜&˜%àèÅÁoÀÁ#‚a ¨ÑÁoÆÁ#‚a ÈÆxCP£@ÁŒ¸ƒ` ˆFÄnDfœ* >ãÁ:¤c¼¡GÚ! `\àØÁˆ?€ş`Œ'±0
Á P(Œñ„`#F! Ä`Ä(@¤0Æ[Œ0…` Hƒ¥ ÂOra0"‚ AP+Œñ†€va¼!è‡^oüÁ#‚B ÈÆxB ƒ° 	‚haŒ7#!ãIÃxCPå0@µ0Æ‚sŒ¸…` Hƒµ áÂOÔa0B‚ AFÜB  äc¼!h‰–¸À±ˆ
Ê‡˜ƒY†g
èÄ!qÄ† ƒà ‰ƒ¸€ Tâ‚Ø„`0‚‚ rTc¸AĞ`–ŠB‡1¡Á ÌH„c0b‚˜%hÆˆÑ pF´C0 Ô£’ÈÁˆw`–€"y„êA\@‚FÌC0 Tâ‚>ˆbC‚Áˆ{€îaP>FğC0 ÄcÄ€h€Ğ#ü! ò‡QÁLä`H0K@H»‹ €VbŒ7z‘ãÁ^ìÅxCÀ|1@'1.0 ÅÄo@ã'Æ‚Ğñ†@4Äb0"(€Zbi!¸À „c¼!8³oPÃ,Æ‚ÔHÁˆ  ¢‰qÈ'ÆxCĞl1Ş¸[Œ7¯ñƒA! ³õ‹ ±ãlÄÅxC0³1ŞĞmF… Ğ¿B‹1ŞÜ†]Œ7¸ãAnäÅ`DP ™Œ ¶ãoìÅxCĞ}1Şø†oF… Ê’‹1Ş„hŒ7â!ãÁxŒÆ`DP ½Œ »ãy”ÆxCp¥1Ş zF… PÌâ‹1Ş¬‡jŒ7ì¡ãA{´Æ`DPÀ,E~1†Ö ƒY†f	81ŞÄGjP0†Ø ƒY†Lf	8"1ŞP6õP0(5ÆxC€¶AÁoPı(# ¤ˆÌpäc¼!èÜŒvc 6ÆxCğ½1ôÆ lŒñ† DÀc¼!oFdD#‚ ²1Ş”yŒ7&b"ãÁ‰œÇ`Dp"@º1Æ‚Añ†@EÔc¼!X‘ŒVD È7ÆxCĞ"ì1Ş¸ˆ{Œ7/òƒÁ‹ ‰Çob>Æñ†`Ffd0"˜ óãAĞÇxC`#ô1ŞÜÈ}F7" ³†     ¦`D„D-“Í$D3!&—É(‹# ‹&LNdûGDHÔ2ÕÆpD„D-“mâGà˜8\V0<SdöDDµÑ0ED3‰Í@\v@T@d[~ Qnã LN$—áİ      a   w   E,      D(2+ˆ"¨)2E	    31ÃLDCŒÇ0ÄxƒC3 4Œñ†ß`ƒ`0‚€ˆ1Ş¸\àX
DV°è„nè f" fŒ7vPQ0†‚*f" hŒ7z€Q0hãApŒá"ƒY†H>ac¼!…0 `X "O(‚ñ„ .pì`„ }c¼!H4 `Œñ†€Ô`0"€Æ`Œ'o0QÁ  èÆxCq0ŞÈ‚,Œ7³0ƒA! ¤c<!°ƒÁ6€An0Æ\Àƒñ† ra¼!Ğ…=Œ
 8ã	AFÌA0 $ªƒ1ŞüÂŒ7à
ãA8„Ã`DP áÁOHa0B‚ AŒñ†ÀLa¼!8ToĞ!#‚B èÆxB°
ƒ¡ 	‚FaŒ7íĞ
ã;°ÂxCğï0@¦0ÆYŒ@…` H¤
c¼! ZoêaÆ{¸…Áˆ €YÃ     Ö , ,š09‘¹Ï™x “‰Ã      a   ×   S,   
   D("(@@‚’(ÿ(ÿÿƒòÿ(ZÖ *~€
C–EA 3AÃL„DÇ0!ä1ÌD4y3AÃLDAG0QäÌD<y3AÃLÄCÇ0áä!ÌDHyƒ‹6 ƒJ6 ¤ŒñöÈƒ`0b	€–1ŞìFÁŒh‚˜%¨ã	7ñ@BŒx‚  '\@ˆá†ÀƒYa#. f	$šÆxB@ƒR0 D…1ÜœÌ2P@Ø  F`A . }c¸AÀ`–¡xÚÆxBğƒ\0 ÄKŒè N\@
æ@‡[ƒY†ÄEÆxŠàB@(2ˆÄ©ÀtÄÀ  z(ˆ€^dŒ7¼È/Œá†àÂ`–9‚ æáF˜‡QP¢‘1Ş@#äP0F ¨‡€ndXP
 ¸À TãÇFƒ ŒÁˆ:€zdXĞ
 Œø‘` f	ÂqA*H½À ƒ| ñ¸€ ƒ}À,B 0ÆZŒ…` #Æ„€DaFˆB0 4
c<!À…ÁˆR€HaP†~ƒYf	¨Æ`D, 0K Q*ŒÁˆT€TaŒ'¿0Á
Á Ğ*
Â„nv!f' Vƒ¹ À,D±0.p,b0¢N Zã	:FØB0 dãÇR #ò$ Ê…1´Ã`Ä.@»0.p,b0¢O _ã	<F€C0 ãÇR #B% ‡1ÜÃ`D9@å0.p,b0¢T tã	?F¨C0 ¤ãÇR #R% j‡1„Ä`Ä;@ì0#ğ! €Yi– ¢x„Aô0Æa0"‚˜%ˆf	$¨@á@      &pÎ€‰ÃeóÊâÀ¢	“}À8–N‘İ 3`éÙ†€Î€¥St[~ 8–NnûÒÄeõDDµÙÙ¦@`Øx “‰Ã     a   ‡   J,      ¨"Ô@	A¡HiEY•EiFa•Aq•X!”O•J (ê Ê   3QÂLDC”Ç0!p@‚¸€ ãïÁÁ` c¼!ğ?¸À±ˆ
¬àÑá†@Â`–!0ZÆxCP
`@ÁnN!f„! gŒ7©€8–QÁ¥\;A0K0P5Æ‚WhƒÁˆ €0qAF (‡€²1ŞÌŒ
à³0³Ğ6Æ‚Z¨…K¨ °3Ğá† Â`–(ƒ1Şğ‚P0¨ÆxCğx0@g0Æ‚pÈ
©ÁoÈa#‚a ˆÆxC`|@Á 7ãA:øÁ`D0À,A1KPŒñ†`Ra0"`… 9ãA;„ƒî@ŒPB@w0Æ‚x …Áˆ@€ò`Œ7óP
ƒ= íÁoêa(ÃÁ-„Á,Ãôc¼!ÈU `Ğ(ˆ2bp0@LüàÁ,B¥0Æ‚Ø
Æ TãÁHüãP+Œñ†à$ÈaÄàP ±8†“f	z…1Ş¤D.Fê0 c¼!X	]ŒØa hÆxCĞ»0¸Ä `8     ÖP ÂäD&€ ÂäDâp       a   ¾   A,      D((‚2+¨2(„¢(‹Â()’2)”R)–b(¦’*›"+šâ(ª²*­Â*®+°B+Ÿ¢å     31ÂLDCŒÇ0!˜  . ÈxC~˜B0A@ÄoP#‚T 2ÆxC 
e0¬Â 2ÆV0ƒÁˆ €”1Ş¸ÂFo0 ÄŒñ† Ğ`0"ˆ… gŒ7² ãÁ,ÌÂxC@´0Ğ‚ 4Æ[ ƒñ†àna¼!À…<ŒpA Èã.àÁxC°|0Şğ/F¼  ¤ñ†Àø`¼!øPoÀ!#p òÆxC  0ŞŒƒ(Œ7ä@ƒ9 ‰ÁoÌÆ‚s0…ñ† Ra0"@ 3ã:„Â`D°@h0Æv…Áˆ@€Ô`Œ7î0
ƒÁ; ±Áoà#‚x rƒ1ŞÈC)Fó0 c¼! SŒêa HÆxC`§0ÜÃ Œñ† Pa0"È‡ ;ã>¤Â`D°@x0Æ~È…Áˆ €ô`Œ7şÀ
ƒÁ/ ñÁo@$.(ìˆ =ŒD8„C(ĞŒñ†`$Èá‚Â   I9‰ÂoLb#‚Y "…1Ş Ä,Fê0 d
c¼!P	ZŒÖa ÆxCÀµ0´Ä *Œñ†À%la0"x‰ VãLÜÂ`D@®0Æ™À…Áˆ`&€`aŒ741ƒA= ÉÂolb#‚{ ¢…1Şà/F91 dc¼!Ğ‰^Œvb ÆxCÀ¾0bp(À]ğOğD@º0ÆŸø…Áˆà€xaŒ7`ƒAX †     v(P ÂäD&€ ÂäDâp       a   ”   U,   	   ¨"”@ÙB1K•BqMZQ”EA?Ê     3qÃL„DœÇ0!ç1ÌDHÄy3qÃL„DœÇ0ap0Ql0Ah01d@Åop=#ˆ` ˆãAdŒá†àÒ`–!‚YŠ˜AÉoDŒ† eŒ7¤Q0ÃB³Ã4Æ‚T 
ÆpCP`0ËPQc¼!h4 `7h ³6Æ‚XH
Æ`„ mc¼! …5 `7¶³ÆŒ Â!˜%8èc¼!Ğ9Œ†˜%pˆÆpC a0Ë(™Á¸À „ãPŒñ†@ê`ÄàP€~(qf	”ƒ Ö¡‚PĞá† Â`–aaŠƒ1bp0À>€B”B0KĞĞŒƒƒúaîà‚Y‚f–À!9ãÁ:ôƒê`Œ7îğ@”c¼!‡P `Œ °ĞıÁnê!f 'Œè‘Q€Yˆ@aĞŒñ† h‚a‚Áˆ! …1Şğ.P0†@ƒY†H
èÆxC ¼0„Ä ÌH³±Â18À&rÀ!˜% 0     VP ±Ö LÌ£5“:’‘4Ò1h"“ñ€09‘‰ €09‘8\6 ÂäDâpiÓ
1      a   1   I,      D(‚ª2G	  31ÃL„DŒÇ0Ñã1FÉ Ğ0Æv‚Áˆ! ÆxC jpc),XÁ¢Ã„Á,C€ƒÀ,@Ë ÛÃB€³ÃP3Æ: ($á! ƒY¢HãAdƒA6 ³Å,AÕ°€Á`ÄÀ,0K€`8   – ¦P ÂäD&€ ÂäDâp       a   ¶   O,   	   ("”@Q”EaL•Y)”G!A AA¡J    3AÃL„DÇ0!ä1ÌDÔAÁLDAG0Ñä1ÌDHyƒG6 tŒñ†õÀƒ`0‚`0âÈƒŒ@ò` f	BÆpC0¡Á,ƒ`dŒñ†€(
5ÃÁèpC 
a0Ë0Iã Ğ4,0FTÁ Œ7P§ FD Ì³]Ã‚4 Á`DÀ,A@ØnV!f'1 €h%6ŞÀ½B@AŒè‚  ûÃA,„Á,ƒ‚ô…2Ü¬Ì2$J0!w ³
‰A¸€ ´. À`„@e0Æ‚]ØƒK¨ °8Ğá†àÂ`–aabƒ1ŞˆC(P0èÆxCP£@Á 9ã:”ƒì \@ºƒ1Ş´C*P0F ˜&1Fáˆ€ö`Œ7ñ òƒ1ŞĞƒ,P0(ÆxCp´@Á T#
 ô.Ô‚. …Ì4T
c¼!Ø] `*Œñ†Àv‚A¤2Æ‚ 
ÊoH"(#  „rÁ`D,@²0Æ”8
ÕÂoV"(„c¼!p	to^âÆ˜€
Ä±# ıÂojB(ƒÈ!\@*‡1ŞìÄ=P0F J9àÁ J‡1Şü„?P0ˆÆxC  AÁ wãAYüÃxC`&1ŞœÅIP . ˆÈÆxCÀ)AÁ #
 ÈEK¨ÄK<…Ì4³†    V f€4³9%™~@4ÆBX~@“~ #PQD4Óæ4”dâ LN$—İ(ÓPR        /** @file animations.c
	@brief
	This file contains 3D actors animations routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "animations.h"
#include "lbaengine.h"
#include "resources.h"
#include "scene.h"
#include "actor.h"
#include "renderer.h"
#include "movements.h"
#include "sound.h"
#include "gamestate.h"
#include "collision.h"
#include "grid.h"
#include "main.h"

enum ActionType {
	ACTION_HITTING           = 0,
	ACTION_SAMPLE            = 1,
    ACTION_SAMPLE_FREQ       = 2,
    ACTION_THROW_EXTRA_BONUS = 3,
	ACTION_THROW_MAGIC_BALL  = 4,
	ACTION_SAMPLE_REPEAT     = 5,
	ACTION_UNKNOWN_6         = 6,
	ACTION_UNKNOWN_7         = 7,
	ACTION_SAMPLE_STOP       = 8,
	ACTION_UNKNOWN_9         = 9, // unused
	ACTION_SAMPLE_BRICK_1    = 10,
	ACTION_SAMPLE_BRICK_2    = 11,
	ACTION_HERO_HITTING      = 12,
	ACTION_UNKNOWN_13        = 13,
	ACTION_UNKNOWN_14        = 14,
	ACTION_UNKNOWN_15        = 15,
    ACTION_LAST
};

/** Set animation keyframe
	@param keyframIdx Animation keyframe index
	@param animPtr Pointer to animation
	@param bodyPtr Body model poitner
	@param animTimerDataPtr Animation time data */
int setAnimAtKeyframe(int32 keyframeIdx, uint8 *animPtr, uint8 *bodyPtr, AnimTimerDataStruct* animTimerDataPtr) {
	int16 numOfKeyframeInAnim;
	int16 numOfBonesInAnim;
	uint8 *ptrToData;
	uint8 *ptrToDataBackup;
	uint8 *ptrToBodyData;
	int16 bodyHeader;
	int16 numOfElementInBody;
	int16 numOfPointInBody;
	int32 i;

	numOfKeyframeInAnim = *(int16 *)(animPtr);

	if (keyframeIdx >= numOfKeyframeInAnim)
		return numOfKeyframeInAnim;

	numOfBonesInAnim = *(int16 *)(animPtr + 2);

	ptrToData = (uint8 *)((numOfBonesInAnim * 8 + 8) * keyframeIdx + animPtr + 8);

	bodyHeader = *(int16 *)(bodyPtr);

	if (!(bodyHeader & 2))
		return 0;

	ptrToBodyData = bodyPtr + 14;

	animTimerDataPtr->ptr = ptrToData;
	animTimerDataPtr->time = lbaTime;

	ptrToBodyData = ptrToBodyData + *(int16 *)(ptrToBodyData) + 2;

	numOfElementInBody = *(int16 *)(ptrToBodyData);

	ptrToBodyData = ptrToBodyData + numOfElementInBody * 6 + 12;

	numOfPointInBody = *(int16 *)(ptrToBodyData - 10); // num elements

	if (numOfBonesInAnim > numOfPointInBody) {
		numOfBonesInAnim = numOfPointInBody;
	}

	ptrToDataBackup = ptrToData;

	ptrToData += 8;

	do {
		for (i = 0; i < 8; i++) {
			*(ptrToBodyData++) = *(ptrToData++);
		}

		ptrToBodyData += 30;

	} while (--numOfBonesInAnim);

	ptrToData = ptrToDataBackup + 2;

	currentStepX = *(int16 *)(ptrToData);
	currentStepY = *(int16 *)(ptrToData + 2);
	currentStepZ = *(int16 *)(ptrToData + 4);

	processRotationByAnim    = *(int16 *)(ptrToData + 6);
	processLastRotationAngle = *(int16 *)(ptrToData + 10);

	return 1;
}

/** Get total number of keyframes in animation
	@param animPtr Pointer to animation */
int32 getNumKeyframes(uint8 *animPtr) {
	return (*(int16 *)(animPtr));
}

/** Get first keyframes in animation
	@param animPtr Pointer to animation */
int32 getStartKeyframe(uint8 *animPtr) {
	return (*(int16 *)(animPtr + 4));
}

/** Apply animation step rotation */
void applyAnimStepRotation(uint8 **ptr, int32 bp, int32 bx) {
	int16 *dest;
	int16 lastAngle;
	int16 newAngle;
	int16 angleDif;
	int16 computedAngle;

	lastAngle = *(int16 *)(lastKeyFramePtr);
	lastKeyFramePtr += 2;

	newAngle = *(int16 *)(keyFramePtr);
	keyFramePtr += 2;

	lastAngle &= 0x3FF;
	newAngle &= 0x3FF;

	angleDif = newAngle - lastAngle;

	if (angleDif) {
		if (angleDif < -0x200) {
			angleDif += 0x400;
		} else if (angleDif > 0x200) {
			angleDif -= 0x400;
		}

		computedAngle = lastAngle + (angleDif * bp) / bx;
	} else {
		computedAngle = lastAngle;
	}

	dest = (int16 *) * (ptr);
	*dest = computedAngle & 0x3FF;
	*(ptr) = *(ptr) + 2;
}

/** Apply animation step */
void applyAnimStep(uint8 **ptr, int32 bp, int32 bx) {
	int16 *dest;
	int16 lastAngle;
	int16 newAngle;
	int16 angleDif;
	int16 computedAngle;

	lastAngle = *(int16 *) lastKeyFramePtr;
	lastKeyFramePtr += 2;

	newAngle = *(int16 *) keyFramePtr;
	keyFramePtr += 2;

	angleDif = newAngle - lastAngle;

	if (angleDif) {
		computedAngle = lastAngle + (angleDif * bp) / bx;
	} else {
		computedAngle = lastAngle;
	}

	dest = (int16 *) * (ptr);
	*dest = computedAngle;
	*(ptr) = *(ptr) + 2;
}

/** Get animation mode */
int32 getAnimMode(uint8 **ptr) {
	int16 *lptr;
	int16 opcode;

	lptr = (int16 *) * ptr;

	opcode = *(int16 *)(keyFramePtr);
	*(int16 *)(lptr) = opcode;

	keyFramePtr += 2;
	*(ptr) = *(ptr) + 2;
	lastKeyFramePtr += 2;

	return opcode;
}

/** Set new body animation
	@param animIdx Animation index
	@param animPtr Animation pointer
	@param bodyPtr Body model poitner 
	@param animTimerDataPtr Animation time data */
int32 setModelAnimation(int32 animState, uint8 *animPtr, uint8 *bodyPtr, AnimTimerDataStruct* animTimerDataPtr) {
	int16 animOpcode;

	int16 bodyHeader;

	uint8 *edi;
	uint8 *ebx;
	int32 ebp;
	int32 eax;
	int32 keyFrameLength;
	int32 numOfPointInBody;
	int32 numOfPointInAnim;
	uint8 *keyFramePtrOld;

	numOfPointInAnim = *(int16 *)(animPtr + 2);

	keyFramePtr = ((numOfPointInAnim * 8 + 8) * animState) + animPtr + 8;

	keyFrameLength = *(int16 *)(keyFramePtr);

	bodyHeader = *(int16 *)(bodyPtr);

	if (!(bodyHeader & 2)) {
		return 0;
	}

	edi = bodyPtr + 16;

	ebx = animTimerDataPtr->ptr;
	ebp = animTimerDataPtr->time;

	if (!ebx) {
		ebx = keyFramePtr;
		ebp = keyFrameLength;
	}

	lastKeyFramePtr = ebx;

	eax = *(int16 *)(edi - 2);
	edi += eax;

	eax = *(int16 *)(edi);
	eax = eax + eax * 2;
	edi = edi + eax * 2 + 12;

	numOfPointInBody = *(int16 *)(edi - 10);

	if (numOfPointInAnim > numOfPointInBody) {
		numOfPointInAnim = numOfPointInBody;
	}

	eax = lbaTime - ebp;

	if (eax >= keyFrameLength) {
		int32 *destPtr; // keyFrame
		int32 *sourcePtr;

		sourcePtr = (int32 *)(keyFramePtr + 8);
		destPtr = (int32 *) edi;

		do {
			*(destPtr++) = *(sourcePtr++);
			*(destPtr++) = *(sourcePtr++);
			destPtr = (int32 *)(((int8 *)destPtr) + 30);
		} while (--numOfPointInAnim);

		animTimerDataPtr->ptr = keyFramePtr;
		animTimerDataPtr->time = lbaTime;

		currentStepX = *(int16 *)(keyFramePtr + 2);
		currentStepY = *(int16 *)(keyFramePtr + 4);
		currentStepZ = *(int16 *)(keyFramePtr + 6);

		processRotationByAnim    = *(int16 *)(keyFramePtr + 8);
		processLastRotationAngle = *(int16 *)(keyFramePtr + 12);

		return 1;
	} else {
		keyFramePtrOld = keyFramePtr;

		lastKeyFramePtr += 8;
		keyFramePtr += 8;

		processRotationByAnim    = *(int16 *)(keyFramePtr);
		processLastRotationAngle = (*(int16 *)(keyFramePtr + 4) * eax) / keyFrameLength;

		lastKeyFramePtr += 8;
		keyFramePtr += 8;

		edi += 38;

		if (--numOfPointInAnim) {
			int16 tmpNumOfPoints = numOfPointInAnim;

			do {
				animOpcode = getAnimMode(&edi);

				switch (animOpcode) {
				case 0: {	// allow global rotate
					applyAnimStepRotation(&edi, eax, keyFrameLength);
					applyAnimStepRotation(&edi, eax, keyFrameLength);
					applyAnimStepRotation(&edi, eax, keyFrameLength);
					break;
				}
				case 1: {	// dissallow global rotate
					applyAnimStep(&edi, eax, keyFrameLength);
					applyAnimStep(&edi, eax, keyFrameLength);
					applyAnimStep(&edi, eax, keyFrameLength);
					break;
				}
				case 2: {	// dissallow global rotate + hide
					applyAnimStep(&edi, eax, keyFrameLength);
					applyAnimStep(&edi, eax, keyFrameLength);
					applyAnimStep(&edi, eax, keyFrameLength);
					break;
				}
				default: {
					printf("Unsupported animation rotation mode %d!\n", animOpcode);
					exit(1);
				}
				}

				edi += 30;
			} while (--tmpNumOfPoints);
		}

		currentStepX = (*(int16 *)(keyFramePtrOld + 2) * eax) / keyFrameLength;
		currentStepY = (*(int16 *)(keyFramePtrOld + 4) * eax) / keyFrameLength;
		currentStepZ = (*(int16 *)(keyFramePtrOld + 6) * eax) / keyFrameLength;
	}

	return 0;
}

/** Get entity anim index (This is taken from File3D entities)
	@param anim Entity animation index
	@param actorIdx Actor index */
int32 getBodyAnimIndex(int32 animIdx, int32 actorIdx) {
	int8 type;
	uint16 realAnimIdx;
	uint8 *bodyPtr;
	uint8 *ptr, *ptr2;
	uint8 *costumePtr = NULL;
	ActorStruct *actor;

	actor = &sceneActors[actorIdx];
	bodyPtr = actor->entityDataPtr;

	do {
		type = *(bodyPtr++);

		if (type == -1) {
			currentActorAnimExtraPtr = NULL;
			return -1;
		}

		ptr = (bodyPtr + 1);

		if (type == 3) {
			if (animIdx == *bodyPtr) {
				ptr++;
				realAnimIdx = *(int16 *)(ptr);
				ptr += 2;
				ptr2 = ptr;
				ptr++;
				if (*ptr2 != 0) {
					costumePtr = ptr - 1;
				}
				currentActorAnimExtraPtr = costumePtr;
				return realAnimIdx;
			}
		}

		bodyPtr = *ptr + ptr;

	} while (1);

	return 0;
}

/** Stock animation - copy the next keyFrame from a different buffer
	@param animPtr Animation pointer
	@param bodyPtr Body model poitner 
	@param animTimerDataPtr Animation time data */
int32 stockAnimation(uint8 *animPtr, uint8 *bodyPtr, AnimTimerDataStruct* animTimerDataPtr) {
	int32 playAnim;
	uint8 *ptr;
	int32 *edi;
	int32 *esi;
	int32 var0;
	int32 var1;
	int32 var2;
	int32 counter;

	playAnim = *(int16 *)(bodyPtr);

	if (playAnim & 2) {
		ptr = (bodyPtr + 0x10);

		animTimerDataPtr->time = lbaTime;
		animTimerDataPtr->ptr = animPtr;

		var0 = *(int16 *)(ptr - 2);
		ptr = ptr + var0;

		var1 = *(int16 *)(ptr);
		var1 = var1 + var1 * 2;

		ptr = ptr + var1 * 2 + 2;

		var2 = *(int16 *)(ptr);
		counter = var2;
		var2 = (var2 * 8) + 8;

		edi = (int32 *)(animPtr + 8);
		esi = (int32 *)(ptr + 10);

		do {
			*(edi++) = *(esi++);
			*(edi++) = *(esi++);

			esi = (int32 *)(((int8 *) esi) + 30);
		} while (counter--);

		return var2;
	}
	return 0;
}

/** Verify animation at keyframe
	@param animIdx Animation index
	@param animPtr Animation pointer
	@param bodyPtr Body model poitner 
	@param animTimerDataPtr Animation time data */
int32 verifyAnimAtKeyframe(int32 animIdx, uint8 *animPtr, uint8 *bodyPtr, AnimTimerDataStruct* animTimerDataPtr) {
	int16 bodyHeader;

	uint8 *ebx;
	int32 ebp;
	int32 eax;
	int32 keyFrameLength;
	int32 numOfPointInAnim = -1;
	uint8 *keyFramePtrOld;

	numOfPointInAnim = *(int16 *)(animPtr + 2);

	keyFramePtr = ((numOfPointInAnim * 8 + 8) * animIdx) + animPtr + 8;

	keyFrameLength = *(int16 *)(keyFramePtr);

	bodyHeader = *(int16 *)(bodyPtr);

	if (!(bodyHeader & 2)) {
		return 0;
	}

	ebx = animTimerDataPtr->ptr;
	ebp = animTimerDataPtr->time;

	if (!ebx) {
		ebx = keyFramePtr;
		ebp = keyFrameLength;
	}

	lastKeyFramePtr = ebx;

	eax = lbaTime - ebp;

	if (eax >= keyFrameLength) {
		animTimerDataPtr->ptr = keyFramePtr;
		animTimerDataPtr->time = lbaTime;

		currentStepX = *(int16 *)(keyFramePtr + 2);
		currentStepY = *(int16 *)(keyFramePtr + 4);
		currentStepZ = *(int16 *)(keyFramePtr + 6);

		processRotationByAnim    = *(int16 *)(keyFramePtr + 8);
		processLastRotationAngle = *(int16 *)(keyFramePtr + 12);

		return 1;
	} else {
		keyFramePtrOld = keyFramePtr;

		lastKeyFramePtr += 8;
		keyFramePtr += 8;

		processRotationByAnim    = *(int16 *)(keyFramePtr);
		processLastRotationAngle = (*(int16 *)(keyFramePtr + 4) * eax) / keyFrameLength;

		lastKeyFramePtr += 8;
		keyFramePtr += 8;

		currentStepX = (*(int16 *)(keyFramePtrOld + 2) * eax) / keyFrameLength;
		currentStepY = (*(int16 *)(keyFramePtrOld + 4) * eax) / keyFrameLength;
		currentStepZ = (*(int16 *)(keyFramePtrOld + 6) * eax) / keyFrameLength;
	}

	return 0;
}

//--------------------------------
//helper class
struct _DataReader {
    uint8* ptr;
};
typedef struct _DataReader DataReader;

int8 readByte(DataReader* data){
    return *(data->ptr++);
}

int16 readWord(DataReader* data){
    int16 result;
    result = *(int16 *)(data->ptr);
    data->ptr += 2;
    return result;
}
//--------------------------------

void skipBytes(DataReader* data, int n){
    data->ptr += n;
}

/** Process acotr animation actions
	@param actorIdx Actor index */
void processAnimActions(int32 actorIdx) {
	int32 index=0, endAnimEntityIdx, actionType, animPos;
	ActorStruct *actor;
	DataReader* data;

	actor = &sceneActors[actorIdx];
	if (!actor->animExtraPtr) return; // avoid null pointers

	data = (DataReader*) malloc(sizeof(DataReader));
    data->ptr = actor->animExtraPtr;

	endAnimEntityIdx = readByte(data);
	while (index++ < endAnimEntityIdx) {
		actionType = readByte(data) - 5;
		if (actionType >= ACTION_LAST) return;

		switch (actionType) {
		    case ACTION_HITTING:
                {
                    int8 strength;

			        animPos = readByte(data) - 1;
                    strength = readByte(data);

		            if (animPos == actor->animPosition) {
			            actor->strengthOfHit = strength;
			            actor->dynamicFlags.bIsHitting = 1;
		            }
                }
			    break;
		    case ACTION_SAMPLE:
                {
    			    int16 sampleIdx;

    			    animPos = readByte(data);
                    sampleIdx = readWord(data);

    			    if (animPos == actor->animPosition)
	    			    playSample(sampleIdx, 0x1000, 1, actor->X, actor->Y, actor->Z, actorIdx);
                }
			    break;
		    case ACTION_SAMPLE_FREQ:
                {
    			    int16 sampleIdx, frequency;
				    
                    animPos = readByte(data);
				    sampleIdx = readWord(data);
				    frequency = readWord(data);

			        if (animPos == actor->animPosition) {
				        frequency = Rnd(frequency) + 0x1000 - (Abs(frequency) >> 1);
				        playSample(sampleIdx, frequency, 1, actor->X, actor->Y, actor->Z, actorIdx);
			        }
			    }
			    break;
		    case ACTION_THROW_EXTRA_BONUS:
                {
				    int32 yHeight, var_C, var_24, var_14, cx, dx, var;

    			    animPos = readByte(data);
				    yHeight = readWord(data);
				    var_C = readByte(data);
				    cx = readWord(data);
				    dx = actor->angle + readWord(data);
				    var_24 = readWord(data);
				    var_14 = readByte(data);
				    var = readByte(data);

    			    if (animPos == actor->animPosition)
    				    addExtraThrow(actorIdx, actor->X, actor->Y + yHeight, actor->Z, var_C, cx, dx, var_24, var_14, var);
			    }
			    break;
		    case ACTION_THROW_MAGIC_BALL:
                {
				    int32 var_8, dx, var_24, var_14;

				    animPos = readByte(data);
				    var_8 = readWord(data);
				    dx = readWord(data);
				    var_24 = readWord(data);
				    var_14 = readByte(data);

			        if (magicBallIdx == -1 && animPos == actor->animPosition)
					        addExtraThrowMagicball(actor->X, actor->Y + var_8, actor->Z, dx, actor->angle, var_24, var_14);
			    }
    			break;
		    case ACTION_SAMPLE_REPEAT:
                {
				    int16 sampleIdx, repeat;

    			    animPos = readByte(data);
				    sampleIdx = readWord(data);
				    repeat = readWord(data);

    			    if (animPos == actor->animPosition)
    				    playSample(sampleIdx, 0x1000, repeat, actor->X, actor->Y, actor->Z, actorIdx);
			    }
    			break;
		    case ACTION_UNKNOWN_6:
			    animPos = readByte(data);
			    if (animPos == actor->animPosition) {
				    int32 var_8, var_C, dx, var_24, temp;

                    //The folowing fetches 7 bytes, but the else block skips only 6 bytes.
                    // Please check if that's correct.
				    var_8 = readWord(data);
				    var_C = readByte(data);
				    dx = readByte(data);
				    var_24 = readWord(data);
				    temp = readByte(data);

				    addExtraAiming(actorIdx, actor->X, actor->Y + var_8, actor->Z, var_C, dx, var_24, temp);
			    } else {
				    skipBytes(data, 6);
			    }
			    break;
		    case ACTION_UNKNOWN_7:
                {
    			    int32 yHeight, var_C, var_24, var_14, cx, dx, var;

				    animPos = readByte(data);
				    yHeight = readWord(data);
				    var_C = readByte(data);
				    dx = readWord(data);
				    cx = actor->angle + readWord(data);
				    var_24 = readWord(data);
				    var_14 = readByte(data);
				    var = readByte(data);

    			    if (animPos == actor->animPosition)
	    			    addExtraThrow(actorIdx, actor->X, actor->Y + yHeight, actor->Z, var_C, dx, cx, var_24, var_14, var);
			    }
    			break;
            case ACTION_SAMPLE_STOP:
                {
                    int32 sampleIdx;

                    animPos = readByte(data);
                    sampleIdx = readByte(data); //why is it reading a byte but saving it in a 32bit variable?
		            skipBytes(data, 1); //what is the meaning of this extra byte?
		                
		            if (animPos == actor->animPosition) {
			            stopSample(sampleIdx);
		            }
                }
			    break;
		    case ACTION_SAMPLE_BRICK_1:
			    animPos = readByte(data);
			    if (animPos == actor->animPosition && (actor->brickSound & 0x0F0) != 0x0F0) {
				    int16 sampleIdx = (actor->brickSound & 0x0F) + 126;
				    playSample(sampleIdx, Rnd(1000) + 3596, 1, actor->X, actor->Y, actor->Z, actorIdx);
			    }
			    break;
		    case ACTION_SAMPLE_BRICK_2:
			    animPos = readByte(data);
			    if (animPos == actor->animPosition && (actor->brickSound & 0x0F0) != 0x0F0) {
				    int16 sampleIdx = (actor->brickSound & 0x0F) + 126;
				    playSample(sampleIdx, Rnd(1000) + 3596, 1, actor->X, actor->Y, actor->Z, actorIdx);
			    }
			    break;
		    case ACTION_HERO_HITTING:
			    animPos = readByte(data) - 1;
			    if (animPos == actor->animPosition) {
				    actor->strengthOfHit = magicLevelStrengthOfHit[magicLevelIdx];
				    actor->dynamicFlags.bIsHitting = 1;
			    }
			    break;
		    case ACTION_UNKNOWN_13:
                {
			        int32 throwX, throwY, throwZ;
			        int32 distanceX, distanceY, distanceZ;
			        int32 spriteIdx, strength;
			        int32 param1, param2, param3, param4;

			        animPos = readByte(data);
			        distanceX = readWord(data);
			        distanceY = readWord(data);
			        distanceZ = readWord(data);

			        spriteIdx = readByte(data);

			        param1 = readWord(data);
			        param2 = readWord(data);
			        param3 = readWord(data);
			        param4 = readByte(data);

			        strength = readByte(data);

			        if (animPos == actor->animPosition) {
				        rotateActor(distanceX, distanceZ, actor->angle);

				        throwX = destX + actor->X;
				        throwY = distanceY + actor->Y;
				        throwZ = destZ + actor->Z;

				        addExtraThrow(actorIdx, throwX, throwY, throwZ, spriteIdx,
                                      param1, param2 + actor->angle, param3, param4, strength);
			        }
                }
			    break;
		    case ACTION_UNKNOWN_14:
                {
			        int32 newAngle, throwX, throwY, throwZ;
			        int32 distanceX, distanceY, distanceZ;
			        int32 spriteIdx, strength;
			        int32 param1, param2, param3, param4;

			        animPos = readByte(data);
			        distanceX = readWord(data);
			        distanceY = readWord(data);
			        distanceZ = readWord(data);

			        spriteIdx = readByte(data);

			        param1 = readWord(data);
			        param2 = readWord(data);
			        param3 = readWord(data);
			        param4 = readByte(data);

			        strength = readByte(data);

			        if (animPos == actor->animPosition) {
				        newAngle = getAngleAndSetTargetActorDistance(actor->Y, 0, sceneHero->Y, getDistance2D(actor->X, actor->Z, sceneHero->X, sceneHero->Z));

				        rotateActor(distanceX, distanceZ, actor->angle);

				        throwX = destX + actor->X;
				        throwY = distanceY + actor->Y;
				        throwZ = destZ + actor->Z;

				        addExtraThrow(actorIdx, throwX, throwY, throwZ, spriteIdx,
                                      param1 + newAngle, param2 + actor->angle, param3, param4, strength);
			        }
			    }
			    break;
		    case ACTION_UNKNOWN_15:
                {
			        int32 distanceX, distanceY, distanceZ;
			        int32 spriteIdx, targetActor, param3, param4;

			        animPos = readByte(data);
			        distanceX = readWord(data);
			        distanceY = readWord(data);
			        distanceZ = readWord(data);
			        spriteIdx = readByte(data);
			        targetActor = readByte(data);
			        param3 = readWord(data);
			        param4 = readByte(data);

			        if (animPos == actor->animPosition) {
				        rotateActor( distanceX, distanceZ, actor->angle);
				        addExtraAiming(actorIdx, actor->X + destX, actor->Y + distanceY, actor->Z + distanceZ, spriteIdx,
                                       targetActor, param3, param4);
			        }
			    }
			    break;
		    case ACTION_UNKNOWN_9:
			    break;
		    default:
			    break;
		}
	}
    free(data);
}

/** Initialize animation
	@param newAnim animation to init
	@param animType animation type
	@param animExtra animation actions extra data
	@param actorIdx actor index */
int32 initAnim(int32 newAnim, int16 animType, uint8 animExtra, int32 actorIdx) {
	ActorStruct *actor;
	int32 animIndex;

	actor = &sceneActors[actorIdx];

	if (actor->entity == -1)
		return 0;

	if (actor->staticFlags.bIsSpriteActor)
		return 0;

	if (newAnim == actor->anim && actor->previousAnimIdx != -1)
		return 1;

	if (animExtra == 255 && actor->animType != 2)
		animExtra = actor->anim;

	animIndex = getBodyAnimIndex(newAnim, actorIdx);

	if (animIndex == -1)
		animIndex = getBodyAnimIndex(0, actorIdx);

	if (animType != 4 && actor->animType == 2) {
		actor->animExtra = newAnim;
		return 0;
	}

	if (animType == 3) {
		animType = 2;

		animExtra = actor->anim;

		if (animExtra == 15 || animExtra == 7 || animExtra == 8 || animExtra == 9) {
			animExtra = 0;
		}
	}

	if (animType == 4)
		animType = 2;

	if (actor->previousAnimIdx == -1) {	// if no previous animation
		setAnimAtKeyframe(0, animTable[animIndex], bodyTable[actor->entity], &actor->animTimerData);
	} else { // interpolation between animations
		animBuffer2 += stockAnimation(animBuffer2, bodyTable[actor->entity], &actor->animTimerData);
		if (animBuffer1 + 4488 < animBuffer2)
			animBuffer2 = animBuffer1;
	}

	actor->previousAnimIdx = animIndex;
	actor->anim = newAnim;
	actor->animExtra = animExtra;
	actor->animExtraPtr = currentActorAnimExtraPtr;
	actor->animType = animType;
	actor->animPosition = 0;
	actor->dynamicFlags.bIsHitting = 0;
	actor->dynamicFlags.bAnimEnded = 0;
	actor->dynamicFlags.bAnimFrameReached = 1;

	if (actor->animExtraPtr) {
		processAnimActions(actorIdx);
	}

	actor->lastRotationAngle = 0;
	actor->lastX = 0;
	actor->lastY = 0;
	actor->lastZ = 0;

	return 1;
}

/** Process main loop actor animations
	@param actorIdx Actor index */
void processActorAnimations(int32 actorIdx) { // DoAnim
	int16 numKeyframe;
	uint8 *animPtr;
	ActorStruct *actor;

	actor = &sceneActors[actorIdx];

	currentlyProcessedActorIdx = actorIdx;
	processActorPtr = actor;

	if (actor->entity == -1)
		return;

	previousActorX = actor->collisionX;
	previousActorY = actor->collisionY;
	previousActorZ = actor->collisionZ;

	if (actor->staticFlags.bIsSpriteActor) { // is sprite actor
		if (actor->strengthOfHit) {
			actor->dynamicFlags.bIsHitting = 1;
		}

		processActorX = actor->X;
		processActorY = actor->Y;
		processActorZ = actor->Z;

		if (!actor->dynamicFlags.bIsFalling) {
			if (actor->speed) {
				int32 angle = getRealValue(&actor->move);
				if (!angle) {
					if (actor->move.to > 0) {
						angle = 1;
					} else {
						angle = -1;
					}
				}
				
				rotateActor(angle, 0, actor->animType);

				processActorY = actor->Y - destZ;

				rotateActor(0, destX, actor->angle);

				processActorX = actor->X + destX;
				processActorZ = actor->Z + destZ;

				setActorAngle(0, actor->speed, 50, &actor->move);

				if (actor->dynamicFlags.bIsSpriteMoving) {
					if (actor->doorStatus) { // open door
						if (getDistance2D(processActorX, processActorZ, actor->lastX, actor->lastZ) >= actor->doorStatus) {
							if (actor->angle == 0) {
								processActorZ = actor->lastZ + actor->doorStatus;
							} else if (actor->angle == 0x100) {
								processActorX = actor->lastX + actor->doorStatus;
							} else if (actor->angle == 0x200) {
								processActorZ = actor->lastZ - actor->doorStatus;
							} else if (actor->angle == 0x300) {
								processActorX = actor->lastX - actor->doorStatus;
							}

							actor->dynamicFlags.bIsSpriteMoving = 0;
							actor->speed = 0;
						}
					} else { // close door
						int16 updatePos = 0;

						if (actor->angle == 0) {
							if (processActorZ <= actor->lastZ) {
								updatePos = 1;
							}
						} else if (actor->angle == 0x100) {
							if (processActorX <= actor->lastX) {
								updatePos = 1;
							}
						} else if (actor->angle == 0x200) {
							if (processActorZ >= actor->lastZ) {
								updatePos = 1;
							}
						} else if (actor->angle == 0x300) {
							if (processActorX >= actor->lastX) {
								updatePos = 1;
							}
						}

						if (updatePos) {
							processActorX = actor->lastX;
							processActorY = actor->lastY;
							processActorZ = actor->lastZ;

							actor->dynamicFlags.bIsSpriteMoving = 0;
							actor->speed = 0;
						}
					}
				}
			}

			if (actor->staticFlags.bCanBePushed) {
				processActorX += actor->lastX;
				processActorY += actor->lastY;
				processActorZ += actor->lastZ;

				if (actor->staticFlags.bUseMiniZv) {
					processActorX = ((processActorX / 128) * 128);
					processActorZ = ((processActorZ / 128) * 128);
				}

				actor->lastX = 0;
				actor->lastY = 0;
				actor->lastZ = 0;
			}
		}
	} else { // 3D actor
		if (actor->previousAnimIdx != -1) {
			int32 keyFramePassed;
			animPtr = animTable[actor->previousAnimIdx];

			keyFramePassed = verifyAnimAtKeyframe(actor->animPosition, animPtr, bodyTable[actor->entity], &actor->animTimerData);

			if (processRotationByAnim) {
				actor->dynamicFlags.bIsRotationByAnim = 1;
			} else {
				actor->dynamicFlags.bIsRotationByAnim = 0;
			}

			actor->angle = (actor->angle + processLastRotationAngle - actor->lastRotationAngle) & 0x3FF;
			actor->lastRotationAngle = processLastRotationAngle;

			rotateActor(currentStepX, currentStepZ, actor->angle);

			currentStepX = destX;
			currentStepZ = destZ;

			processActorX = actor->X + currentStepX - actor->lastX;
			processActorY = actor->Y + currentStepY - actor->lastY;
			processActorZ = actor->Z + currentStepZ - actor->lastZ;

			actor->lastX = currentStepX;
			actor->lastY = currentStepY;
			actor->lastZ = currentStepZ;

			actor->dynamicFlags.bAnimEnded = 0;
			actor->dynamicFlags.bAnimFrameReached = 0;

			if (keyFramePassed) {
				actor->animPosition++;

				// if actor have animation actions to process
				if (actor->animExtraPtr) {
					processAnimActions(actorIdx);
				}

				numKeyframe = actor->animPosition;
				if (numKeyframe == getNumKeyframes(animPtr)) {
					actor->dynamicFlags.bIsHitting = 0;

					if (actor->animType == 0) {
						actor->animPosition = getStartKeyframe(animPtr);
					} else {
						actor->anim = actor->animExtra;
						actor->previousAnimIdx = getBodyAnimIndex(actor->anim, actorIdx);

						if (actor->previousAnimIdx == -1) {
							actor->previousAnimIdx = getBodyAnimIndex(0, actorIdx);
							actor->anim = 0;
						}

						actor->animExtraPtr = currentActorAnimExtraPtr;

						actor->animType = 0;
						actor->animPosition = 0;
						actor->strengthOfHit = 0;
					}

					if (actor->animExtraPtr) {
						processAnimActions(actorIdx);
					}

					actor->dynamicFlags.bAnimEnded = 1;
				}

				actor->lastRotationAngle = 0;

				actor->lastX = 0;
				actor->lastY = 0;
				actor->lastZ = 0;
			}
		}
	}

	// actor standing on another actor
	if (actor->standOn != -1) {
		processActorX -= sceneActors[actor->standOn].collisionX;
		processActorY -= sceneActors[actor->standOn].collisionY;
		processActorZ -= sceneActors[actor->standOn].collisionZ;

		processActorX += sceneActors[actor->standOn].X;
		processActorY += sceneActors[actor->standOn].Y;
		processActorZ += sceneActors[actor->standOn].Z;

		if (!standingOnActor(actorIdx, actor->standOn)) {
			actor->standOn = -1; // no longer standing on other actor
		}
	}

	// actor falling Y speed
	if (actor->dynamicFlags.bIsFalling) {
		processActorX = previousActorX;
		processActorY = previousActorY + loopActorStep; // add step to fall
		processActorZ = previousActorZ;
	}

	// actor collisions with bricks
	if (actor->staticFlags.bComputeCollisionWithBricks) {
		int32 brickShape;
		collisionY = 0;
		
		brickShape = getBrickShape(previousActorX, previousActorY, previousActorZ);

		if (brickShape) {
			if (brickShape != kSolid) {
				reajustActorPosition(brickShape);
			} /*else { // this shouldn't happen (collision should avoid it)
				actor->Y = processActorY = (processActorY / 256) * 256 + 256; // go upper
			}*/
		}

		if (actor->staticFlags.bComputeCollisionWithObj) {
			checkCollisionWithActors(actorIdx);
		}

		if (actor->standOn != -1 && actor->dynamicFlags.bIsFalling) {
			stopFalling();
		}

		causeActorDamage = 0;

		processCollisionX = processActorX;
		processCollisionY = processActorY;
		processCollisionZ = processActorZ;

		if (!actorIdx && !actor->staticFlags.bComputeLowCollision) {
			// check hero collisions with bricks
			checkHeroCollisionWithBricks(actor->boudingBox.X.bottomLeft, actor->boudingBox.Y.bottomLeft, actor->boudingBox.Z.bottomLeft, 1);
			checkHeroCollisionWithBricks(actor->boudingBox.X.topRight,   actor->boudingBox.Y.bottomLeft, actor->boudingBox.Z.bottomLeft, 2);
			checkHeroCollisionWithBricks(actor->boudingBox.X.topRight,   actor->boudingBox.Y.bottomLeft, actor->boudingBox.Z.topRight,   4);
			checkHeroCollisionWithBricks(actor->boudingBox.X.bottomLeft, actor->boudingBox.Y.bottomLeft, actor->boudingBox.Z.topRight,   8);
		} else {
			// check other actors collisions with bricks
			checkActorCollisionWithBricks(actor->boudingBox.X.bottomLeft, actor->boudingBox.Y.bottomLeft, actor->boudingBox.Z.bottomLeft, 1);
			checkActorCollisionWithBricks(actor->boudingBox.X.topRight,   actor->boudingBox.Y.bottomLeft, actor->boudingBox.Z.bottomLeft, 2);
			checkActorCollisionWithBricks(actor->boudingBox.X.topRight,   actor->boudingBox.Y.bottomLeft, actor->boudingBox.Z.topRight,   4);
			checkActorCollisionWithBricks(actor->boudingBox.X.bottomLeft, actor->boudingBox.Y.bottomLeft, actor->boudingBox.Z.topRight,   8);
		}

		// process wall hit while running
		if (causeActorDamage && !actor->dynamicFlags.bIsFalling && !currentlyProcessedActorIdx && heroBehaviour == kAthletic && actor->anim == kForward) {
			rotateActor(actor->boudingBox.X.bottomLeft, actor->boudingBox.Z.bottomLeft, actor->angle + 0x580);

			destX += processActorX;
			destZ += processActorZ;

			if (destX >= 0 && destZ >= 0 && destX <= 0x7E00 && destZ <= 0x7E00) {
				if (getBrickShape(destX, processActorY + 0x100, destZ) && cfgfile.WallCollision == 1) { // avoid wall hit damage
					addExtraSpecial(actor->X, actor->Y + 1000, actor->Z, kHitStars);
					initAnim(kBigHit, 2, 0, currentlyProcessedActorIdx);

					if (currentlyProcessedActorIdx == 0) {
						heroMoved = 1;
					}
					
					actor->life--;
				}
			}
		}

		brickShape = getBrickShape(processActorX, processActorY, processActorZ);
		actor->brickShape = brickShape;

		if (brickShape) {
			if (brickShape == kSolid) {
				if (actor->dynamicFlags.bIsFalling) {
					stopFalling();
					processActorY = (collisionY << 8) + 0x100;
				} else {
					if (!actorIdx && heroBehaviour == kAthletic && actor->anim == brickShape && cfgfile.WallCollision == 1) { // avoid wall hit damage
						addExtraSpecial(actor->X, actor->Y + 1000, actor->Z, kHitStars);
						initAnim(kBigHit, 2, 0, currentlyProcessedActorIdx);	

						if (!actorIdx) {
							heroMoved = 1;
						}
						
						actor->life--;
					}

					// no Z coordinate issue
					if (!getBrickShape(processActorX, processActorY, previousActorZ)) {
						processActorZ = previousActorZ;
					}

					// no X coordinate issue
					if (!getBrickShape(previousActorX, processActorY, processActorZ)) {
						processActorX = previousActorX;
					}

					// X and Z with issue, no move
					if (getBrickShape(processActorX, processActorY, previousActorZ) && getBrickShape(previousActorX, processActorY, processActorZ)) {
						return;
					}
				}
			} else {
				if (actor->dynamicFlags.bIsFalling) {
					stopFalling();
				}

				reajustActorPosition(brickShape);
			}

			actor->dynamicFlags.bIsFalling = 0;
		} else {
			if (actor->staticFlags.bCanFall && actor->standOn == -1) {
				brickShape = getBrickShape(processActorX, processActorY - 1, processActorZ);

				if (brickShape) {
					if (actor->dynamicFlags.bIsFalling) {
						stopFalling();
					}

					reajustActorPosition(brickShape);
				} else {
					if (!actor->dynamicFlags.bIsRotationByAnim) {
						actor->dynamicFlags.bIsFalling = 1;

						if (!actorIdx && heroYBeforeFall == 0) {
							heroYBeforeFall = processActorY;
						}

						initAnim(kFall, 0, 255, actorIdx);
					}
				}
			}
		}

		// if under the map, than die
		if (collisionY == -1) {
			actor->life = 0;
		}
	} else {
		if (actor->staticFlags.bComputeCollisionWithObj) {
			checkCollisionWithActors(actorIdx);
		}
	}

	if (causeActorDamage) {
		actor->brickShape |= 0x80;
	}

	// check and fix actor bounding position
	if (processActorX < 0) {
		processActorX = 0;
	}

	if (processActorY < 0) {
		processActorY = 0;
	}

	if (processActorZ < 0) {
		processActorZ = 0;
	}

	if (processActorX > 0x7E00) {
		processActorX = 0x7E00;
	}

	if (processActorZ > 0x7E00) {
		processActorZ = 0x7E00;
	}

	actor->X = processActorX;
	actor->Y = processActorY;
	actor->Z = processActorZ;
}
/** @file animations.h
	@brief
	This file contains 3D actors animations routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef ANIMATIONS_H
#define ANIMATIONS_H

#include "sys.h"
#include "actor.h"

/** Total number of animations allowed in the game */
#define NUM_ANIMS 600

enum AnimationTypes {
	kStanding			= 0,
	kForward			= 1,
	kBackward			= 2,
	kTurnLeft			= 3,
	kTurnRight			= 4,
	kHit				= 5,
	kBigHit				= 6,
	kFall				= 7,
	kLanding			= 8,
	kLandingHit			= 9,
	kLandDeath			= 10,
	kAction				= 11,
	kClimbLadder		= 12,
	kTopLadder			= 13,
	kJump				= 14,
	kThrowBall			= 15,
	kHide				= 16,
	kKick				= 17,
	kRightPunch			= 18,
	kLeftPunch			= 19,
	kFoundItem			= 20,
	kDrawn				= 21,
	kHit2				= 22,
	kSabreAttack		= 23
};


/** Table with all loaded animations */
uint8* animTable[NUM_ANIMS];
/** Table with all loaded animations sizes */
uint32 animSizeTable[NUM_ANIMS];

/** Rotation by anim and not by engine */
int16 processRotationByAnim;    // processActorVar5
/** Last rotation angle */
int16 processLastRotationAngle; // processActorVar6
/** Current process actor index */
int16 currentlyProcessedActorIdx;

/** Current step X coornidate */
int16 currentStepX;
/** Current step Y coornidate */
int16 currentStepY;
/** Current step Z coornidate */
int16 currentStepZ;
/** Current actor anim extra pointer */
uint8 *currentActorAnimExtraPtr;

/** Pointer to current animation keyframe */
uint8 *keyFramePtr;
/** Pointer to last animation keyframe */
uint8 *lastKeyFramePtr;

uint8 *animBuffer1;
uint8 *animBuffer2;

/** Set animation keyframe
	@param keyframIdx Animation keyframe index
	@param animPtr Pointer to animation
	@param bodyPtr Body model poitner
	@param animTimerDataPtr Animation time data */
int32 setAnimAtKeyframe(int32 keyframeIdx, uint8 *animPtr, uint8 *bodyPtr, AnimTimerDataStruct* animTimerDataPtr);

/** Get total number of keyframes in animation
	@param animPtr Pointer to animation */
int32 getNumKeyframes(uint8 *animPtr);

/** Get first keyframes in animation
	@param animPtr Pointer to animation */
int32 getStartKeyframe(uint8 *animPtr);

/** Set new body animation
	@param animIdx Animation index
	@param animPtr Animation pointer
	@param bodyPtr Body model poitner 
	@param animTimerDataPtr Animation time data */
int32 setModelAnimation(int32 animIdx, uint8 *animPtr, uint8 *bodyPtr, AnimTimerDataStruct* animTimerDataPtr);

/** Get entity anim index (This is taken from File3D entities)
	@param animIdx Entity animation index
	@param actorIdx Actor index */
int32 getBodyAnimIndex(int32 animIdx, int32 actorIdx);

/** Stock animation - copy the next keyFrame from a different buffer
	@param animPtr Animation pointer
	@param bodyPtr Body model poitner 
	@param animTimerDataPtr Animation time data */
int32 stockAnimation(uint8 *animPtr, uint8 *bodyPtr, AnimTimerDataStruct* animTimerDataPtr);

/** Verify animation at keyframe
	@param animIdx Animation index
	@param animPtr Animation pointer
	@param bodyPtr Body model poitner 
	@param animTimerDataPtr Animation time data */
int32 verifyAnimAtKeyframe(int32 animPos, uint8 *animPtr, uint8 *bodyPtr, AnimTimerDataStruct* animTimerDataPtr);

/** Initialize animation
	@param newAnim animation to init
	@param animType animation type
	@param animExtra animation actions extra data
	@param actorIdx actor index */
int32 initAnim(int32 newAnim, int16 animType, uint8 animExtra, int32 actorIdx);

/** Process acotr animation actions
	@param actorIdx Actor index */
void processAnimActions(int32 actorIdx);

/** Process main loop actor animations
	@param actorIdx Actor index */
void processActorAnimations(int32 actorIdx);

#endif
BCÀŞ!  Ú  ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q  ;  f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l˜áÿÿÿÿ "Ø¡æaÚ ä¡Æ!æ¡ÚÀà¡Â sv˜‡r wx‡60y‡v(‡6€‡wHw ‡r‡6(vH‡v èAê¡€ÁŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ÚÀŞÁÚ€Ê!Ì ÜáÚ ÜÁæ¡ÌÚ ÂĞ0‡p`‡y(€p‡whww˜‡60xhƒvz@ÀÂæ¡ bè!ÆaÚ äáè¡ÆŞAÚ@êÁÌ¡ä¡æ!ô¡ < ˆzp‡ys(‡60xhƒvz@ÀÂæ¡ ¢æ¡Ú`ŞÁè¡ÌŞ!è0‡p`‡y(`A  ¶¡6Šÿÿÿÿ 	 v(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØ@€m ƒ Ø" l¡üÿÿÿÿ DŒåÿÿÿÿ@( I  
   ‚`B L†	LŠ	ƒqÄH„	2! &Ë„1’	‚q  ‰   ¶   2"
 d…$¤„$ã„¡LŒ„MÌÄÀDsPA¦ĞA
&M%L>;"|`HìQÂ„‚„Ë¤)¢„Éï°`á[ Cb§ˆ&$œ#M%Lşü¦ÒLH8Fš"J˜üùİœgISD	“¯	“™NE°SD	" N“¦ˆ&_k¦E"ê€	`§ˆ&$ œ$M%L¾&LNÄN%LÈ     
 
                      
 
                ’‚" €&‚*› €.9 €2R .’¦ˆ&Ÿsš1>d!Ğ·± ÀÀ@                      @‰ @I @!‰M @#	ı @%ä€„’¤’–Ä’ä’
 “$“D“ ds‘4E”0ù¬@4Dê Í„[¤)¢„É§A„€€€À)Tƒ84Nƒ‚œ‹¤)¢„ÉŸ†`§ˆ&Tààè$Ùñ$r ù$Ñ@ĞPÎPQÎ ĞQ‚ PÒYÒQÂä{×%"MìQÂ„" ”Y"&z( @A= €¢F 
1e  @TE 0 «* V¦ H«   ÄU€‚'ò:Iš"J˜ü¿&`%€ˆPP@`E #±"„Y¦Â È¬ „V)       R+ ± €ÜÊ          @p%         ¹BL  ])     È®S„W
   Ò+À	ñ•bJ@@à„ü
   @€5˜"ÁRL   á@ 9ÍS d@F¤P‚)z¤b °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD äÎİ@9 (tå€n Ğ”½Ó 7ğ
øF   ” œ½s@7PèJ
 `@nàÈœáC<pj  z§AoàĞ”ás@7PèÊİ@9 (tå€n Èœ¹3 7päÎ€ÜÀ8t¥ p@7PèJñÀ	B8rg@nàÈœ»q@7PèÊİ@9 (z§Aoà4èœ½Ó 7pèÊİ@9 (tå€n )”¹s@7PèÊİ@9 (tå€n $1œ¹s@7PèJƒŞÀiĞ8z§Éyà<ùœ¹3 7päÎ€ÜÀ9 (rg
z`Ğ”ºr@7PèÊİ@9 (tå€n Ğ”ºr%=0¶¨Æ—õÀÃ8rçL{ Èœ5îóæ=päÎ€ÜÀ8z§AoàÈœ¹3 7päN‘ò@)R(EÊå€n Ğ”ºr@7PèÊİ@9 (tå€n Ğ”ºr@7PèÊİ@8tå€n Ğ”ºr@7PäÎø@8âå€n Ğ”Aò1 7pèÊİ@9 (tå€n Ğ”¹3 7päÎ€ÜÀ)Ä8te@nà$š”B¼s@7PäN#úÀ‰T8•ì§’}àlºœ¹3 7päÎ€ÜÀ8rg@nàÈœ½s@7PèJƒŞÀ‡,°  @     CY       €!‹,      À¥      `ÈR      0d¹      ²À      Yr     †,» À     C–^       €!Ë/      À      `È2      0d)      ²œ      Yv €     †,é €     C–u @    €!K;      Àå€ (    `È@     0dY      ²Ì     Yv     †,õ €     C–{ @    €!Ë=      À%€     `È²      0dÙ      ²ô     Yş€    †,½ €     C– @    €!Ë.      Àå€     `È2@     0d)	      ²”     YJ     ²@  (   2˜ LŒ	&GÆC  "  * Eƒª{^‡Ãßrz™
»Óí0=ıvƒäoz˜~»Aí7¹*‘C
r ˆ ª ‹ Ê  
 ‘ * ” R – r ˜ ’ š ²  ò    ¢ : ¤ b  y     C“HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   µ  F Î² â4±y(‚³,ˆ„8l¥Šà,"!N3áKSd:ÔADÖ Œ8\éŠ¶hªq¤E$@ƒ0-,„q)”„4aIS9Íô"álTQQ€H¶õ ME4“a'Å€€d°‘DLZƒ0ÚDXaÎ9IêH2+DÑNu‘£5#—‚«Ç²âëYÜ"Ì³«C5ƒµ8”DpÄ² FÈ`GåDÊ‹„³QEAD&çH ó,„‰4± ˜HED3±B„<Ó,aÌÒ “Ö Œ%,’@4„&LN$“³8Î“F„$I`V3DäxÍ„LXº¢-šjipŒ0ÏB¬ÄC “IP$”4iÂäD©#!â4¦E!ME4“a&` Bê Í$tÀ#M@3 6š09‘‘BaÈB…4ÑLN„S@!mÎe¿Ò9!IZƒ0š0!N#™ƒ4ÑLN„µ@°ÖP!’+!F‡“FNBâ4fòDäÈQ8ñËbcŒp8ˆ@hd‘ÙD1™Î@,Zƒ0À„8Ñ1À<‘. Ffà Ãà]Shƒ4†	Ğæ&I ó,„ÆÑD‹0„e8³`+ÑDÔba¬K°8‚²QEADÖÑ,óhÂäDìD<V&!ME4“a,’-,„M`ÂA
ç,"!N#Ó¡	“I`0À²8‚(Ï`,À<a‚–@EÑLö9ËâXÄ 	“Yh€#Ì³Rº ÒÆ³	TÍ”:2!N#6›3`éµ@`š@EÑL–F@H1hÂäDâp†óDD…8”¤	“É–á<Q!%iÂäD³]8ODTˆCIš09QlhĞâP+!—Ù)’@4DHDNlwŠ$‘#"	DC„DäÌ–°HÑmŠd=KàL“Ã”D1Åæ³Î49LI“l?KàL“Ã”D1ÍÖå ME4“aß’a8Ò„ÖÑÁm'‹ôDÈD´@°¶À0€°,âp™r@cS‡HĞ„İ_’9‘›_’9‘3›jÀ! ²õ%™Ó!9²¥ÀÛjÀ! ³5XOä„$iÂäDZƒ0À„8dÏDLš09‘ÖaPÕ€H@°¬D³ÑLDd×0Ş5E û,FP=‘#’´:0!N³aZƒ0V§HÑ&%!‚™(aq CD@lƒ’@EÑLš09‘ØÌNCj€Ò0DÌv 4„Å²q$ÏJ4½µí,9Zƒ0âpn A\Èd3ÔAD×LÈ„i ¸z,+¾A$’@4DHD¥Ò›Ê!ÀàX²­Ò5›s cÓJ Ë,a€$qRŒ&LN$Yg€r‘£	â4Æ€D0lØDXu '„ „DäpÎ² â402[„Šd,“t ƒcqÎ² â4-öV”,D1™%vöTÍÄ
DCˆÃeOÑâ8ØTD39&Nc Ç -ÂfDähÂˆÃu¢«©•¦°4ƒ/MÄeR‰0Ä· †dÎ9IêH3+DÑ$DÎ³9Óä0¬Dc®@,Ò`„âpYn dÓæ˜Ö ŒØÄeĞ ÌFÕ6± ÂlTQ‘mo0ÏBhL€ @Øm€ñDH3 I ó,„Ä"ÑÁB˜„4ÑLN„C˜d
˜@EÑLš09‘Ö ŒwMN‘1(’@4Ä· †d4ÒAD×LÈ„u"Ë­^ëÙÔb ÁÀ3‘É@1±M$À¶@AXKP“£!IHE˜“³8ÎÃQQD4I`öPC‡D&6 Cp‡ƒ„ÄÓ„4†d‹B`_0D:Eæ0M@d“&LNÔ!Ò4aÏ9!Iš09Q:E¶ Cp‡ƒ„dÖp‚¢	“qÎ² â402[„Šd¾‰¤ Ï†M„d Ñ9!Iœ³,ˆ„8Ml!Ñ9!Iœ³,ˆ„8l"Ñ9!Iœ³,ˆ„8ÍlUˆ°Ë¢Q×æP@b€#	DCœÓF€ HæP„4ÅV’Dä˜NEöP„4Í–3DähÂˆÃÕ‰,·z­gj”ôDÈDlÕHclÎ•N‘]!M²¹TODTˆCI!9q âP‘½DODTˆCI!9Zc,„0ED3±ñÄ&ÀTÍÄNÄ#Û #PQD4;Ïl(ôDÈD°HF´@°V`Ãà]S´GäX&` B ,‹< M$}ÀéÙa€"	DCÌNCHÖp1€%Q;EDcLZ„ÈdQJæ8+DÑ˜d òDN’:’l“È9IêH³E Oä$©#ÅV°Ä¤5c:a#ÍADÎF@…8TdiôDÈD°08V:E&@I ó,„”. †4†&LN$Ù—#‘. FD'ÀöÀH ó,„ÔÁBuÀ"MÎóË‚4†0°(HchÂäDæà<‘“¤³BD(Òä<,À<aÈKäLÀDhÂäDV€=‘#’TÒ´:0!N£5ÆBØ$ ”DhÂäDÀ aŠp A¬Ã¼@TÓ¶ğĞÄê8ÌDumYÒTD39vRLI …dfOCw A°Ñ6PÏ³`Zƒ0ìD<«3â46I ó,„‰4± ØÚ†‘ÓL/2ÎFYt@cÓ!‚ÂÀC˜R$	A4¥ã(ÔÓÁBm@<Ï‚iÂ°ñCÃ "”DE,âpe€âDÓá¤‘“ÄV 8Ñt8iä$²Y(N4N9Él£	qMP"Òdº49‚¢5LˆÓØt‘“:2!NÓbak”@EÑL ÀhED¬@4„5@ƒ0,’-,„%“ó¬ˆqL±%“ó¬ˆqL²	%“ó¬ˆqL³…)Åp‡ƒ„dÍ9!Iš09QlÉa`“Ö¡5KL-Ä¤	“uˆ4@ØFóD@H’&LN$GóD@H’&LN4[[P"Æ1Y`€Ã"A!8\&‘Î€µ@°ğÄtRI`E0„dÃH&#DäxÍ„L˜Ö†¥×Šœ5YODTˆCI¥ã<iDH1f»TEDHiÂhI`E0„)b“éPa†$qRÌì4„dyHCX!9±é!a…DäÈ¶‡4„‘3Û•„4ÑLN„CÒAHÆ¦ Ës %b“y1‡³8ğ|`HFĞ Ãà]S´GäXv3DähÂˆÃ¥µaéµ"gKËâ8éTD:EF%1€°,'ÅlÕ„Å@9^3!v¢«©•Ö€D0ÀN4Øf@TÑD\œãDÒ !QÈ   a   Ñ   O,      PEPÅP…QÅSEA5 3°ÃLD ìÇ0a û1ÌDÀ~3'ìÇ01 û!ÌDÀ~3°ÃL„ìÇ0a û1ÌDÀ~3°ÂLÄ ì‡0 û1F4İ F0Ü F,Û F(Ú 3.X
Ä` Aƒq€7ÁÌ2B@¸ @#®  f	ªÆxB ,b0¢
€*q€X`"°à@@Ş0!}c<!Æ6Œè‚ 0,b0¢€:q€T0:ÜàBÌ2C0±¹  ³¡ÁOæ`0‚‚ 3¤c¼!è…^Œ† ;™Ôc¼! ‡>Œ† 5´ã‚¥@\  ã	E0ŒÂ`D@q0.X
Ä`„@t0hÄ b*ˆ`<ÆTŒĞƒ` HÆxB
,b0b P õ¸ @††Àf
# Pƒ§À,A¦0#L! :…1àÂ`D*0KpFŒ‚?À,B£0†]@ƒY†d	hÆxBàƒ­ 	XaŒ'á0á
Á FC Ì(¤
Ã‚q Á`+0K€,Œñ„À#d!€Y†jATĞ0q 7*³G-Œñ„ #r! Ê…qÁÀR #Ğ% â…1¸ÃKŒX—@ ÆxB°,b0Â] rã	=\0°ˆÁˆx	€ĞaŒ'òpÁÀR #è%€Áˆyğ ˜%ph@á@   )   ö(Ğ<SÔ:›3`0–pÎ€¥SdÏ3E­Ó°‚B=6) Ö(<SÔ:0&) 5ƒ©ƒ4“ØlÎ€Ù¢ÀÔPZVD CˆÖ Œé@@ƒ0-ÂQL@:E) Î€…0‘1
@Å Åæ4„$6Zƒ0v°(VD CˆÃe‘RC1há-C4“ØlÎ€~À4“N       a      A,      P 3€Ã`D0 ã‚¥@\  „   vp Â¤S       a      A,      P…    3€Ã`D@ c<!.X
Ä ’A8    vp Â¤S       a   p   I,      PEPşQˆ  3*èÇ0 ú1ÌD€~3¢ èÇ01 ú!ÌD€~3 ÂLÄ è‡0D0q@0a<@"2.X
Ä`Ä •ÈO¢Áˆ	€Ld\0°ˆÁˆ% J‘1Xƒ+ 9â © Ó`0B
€"q€TÀé0Q@•¸ @ ˆA.€Á- ÒÄpC€
a0Ëqâ nÌ f„! O\  ¨.€Áˆ1`–À 1 ÈpCÀf0Ë@™¸ @,ˆƒ\  ƒjÀ,A1K`ˆ „Ø@\  4Ã„@D£„€ì@p FÌA  ³ÙŒ ƒ@ f	ÚƒAÁ¸``#ö  ºq€T@
z ĞŒÁˆ@ …AÁOTLaFÂ `8      6(@„4Y¡ Ò–ÖaøBğØ}ÀğL‘
4‚Ã<ÔDZc,„åÁe„ÉH“Öa†ĞÑ!     a   Q   D,      PE    3*èÇ0 ú1ÌD€~3¢ èÇ01 ú!ÌD€~3 ÂLÄ è‡040q00a,@ş1.X
Ä`Ä …ÈOšÁˆ	€Dd\0°ˆÁˆ% *‘1Hƒ' 5â !H\  6!¸@ #¤@ HÃ„Á,C d‰ „,q€P7LD@Ş(! ;\  ƒ]  ³Œğ˜%¨ã‚Œ(ƒ` (™ÁŒ 5Œñ„ ¨Æ`D  †      ö@„4Y  Ò–ÖaøBğØ}ÀğL‘
4‚Ã<ÔDZc,„åÁe€ÉH“Öa‚ĞÑ!     a   &   A,      PE    3*àÇ0!
 ~3€Â`Ä` ƒ‚qÁÀFÁ P~Œ–1q@‡ dF‚ Œñ„ Œ ‘` ¨Œñ„ "hFÂ P‰Œñ„`Œ8‘` ( Há@     ¶@,ÏÙ}ÀğL‘ñÎ#8    a   t  X,   	   PQ…PÅSÅP UPÅD5@Cà€    3°ÃLD ìÇ0a û1ÌDÀ~3'ìÇ01 û!ÌDÀ~3°ÃL„ìÇ0 û1ÌDÀ~3°ÃLD ìÇ0 û1ÌDÀ~3+ìÇ0±À~3°Â`DD0Á F<b0 ƒN Ac<!ø.X
Ä 2¡@Ê° D`€€²aB ÒÆxB Œ'k0&Á P˜Œ–q€F`Á Œ–1 ˆ ¤:Ğá†@Â`–A‚Á5Ø ˜%¸èÆxBƒe ¡Áo|Á(ƒg ­ÁoÂÁ(ƒi ©ÁnÀ!fˆ! ;ƒm ©ÁŒhƒ` f	rƒ1¡'Á Œñ„ .X
Ä 2!Á ²ƒ1ƒx áÁ¸``) È`D@y0H†± FôA0 
ƒü`XP"O‚ñ„ #J! *…1ÄÂK¸ @#J! "…A¦0†„Àf
# Tƒ¨À,A¾2©†	A#\! r…A®0†„àf% ^ã	A:\°ƒ® İÂ¸ `#b!€Y„`aŒ'ï0!Á 0ˆÆxB ƒ¶À`„0 ÕÂOèa0â‚ aP.Œñ„à#v!€Áa Ú…qAÁ'õpAÀFüB0 ³	…Ã°à@01Á 7a³ˆĞ¼r‡1ŞYFÃ P¿LŠ‡1ŞœIFÃ P¾Œñ„€$.X
Ä`ÄÈ@ı2Æ‚“¸``)ƒ& …ÌONâ‚¥@F¤L  T2c<!ˆ‰–1Á2 PÊŒñ„@&.X
Ä`ÄË0±9 ³µÌŒğ‡` èeÆxB ƒ1 ÁÌOxb0Bf‚ ™,b0g šã	ÁO\0°ˆ „\b˜ˆ€^b”Ğ06 ØŒñ„`-#Ä& 
›1´Å`ÄØ@:1Æ‚²Œà‰` È&†l‚Áœ`¸!°0˜e`ª€rb\  ƒ7À,A3b@  „Å0Q PYˆ d˜"ÜpöãéˆÄbXŒ Hä,„€ÈbYŒ L$-„€ÌbYŒ Pd-„`–@"´„cÄÀ €i! µ¤cÄÀ €y! ¶ÄcÄÀ €‰!˜%È-¹Å10 àEæB.ÁÅ10  FêBH.ÉÅ10 `FîBf	$Êq€Œ  #¡Œ #¯¡¤c<!XÁ¾`–`"¹˜FĞE  ÃA}„Á,CC³áÅOfã‚¥@\  Ã„@$£„€.€ÁÜ	€DcŒ'¼qÁÀR . ZaB bQB@À`Dø@¬1Æñ¸``) ÕÆ0!ÙÆ(! `0B}˜%°#È£F `–à"ò „ -   æ(  Â à„å3`éÙ}@4ÃNÀD¦À1Ò”N‘e
$’CE‘N‘]
8
}Àé¡Ë`–PC1h‘:H3‰Ö ŒA
Ä€˜¦€31ÏI1h‘:H3IV) 5ƒ©ƒ4“ØlÎ€™~ 4Ó"uÀ¤SdJàXH ™¤À@Q
8
}À%ÑÓaøĞ L:E6)0Àe‘\        a   s   M,      P5PeP„X    3ÃLD äÇ0 ù1ÌD@~3ÂL„äÇ0a ù1ÌD@~3ÃL„äÇ0‘H0D0!´Á 2ÆBD‚Áˆ! ÆxC@c0B	`–  eŒ'Ö` 	a0â	€p€7Ì2C0¡"x0 ƒ• ³Ac<!à#¢` ˆ
 ÈpCÀÁ,‘”²á€n 0˜e(€²1˜Á`Ä mã‚¥@F€A  äñ„à#À  ƒ1Á PŒñ„À#Æ  ƒAA¸  †‚YƒYãèÆxB0ƒgÀ,ÁAg0#Ê$ bq@FÈA  ³Ì,ABl0( ½ÁO„Á9`–@™e<Œ¸_ €Y†î d     &(@LØC¡À8–N‘
ÏÙ¡€"8ÒD1D:Ef(@<Sd¢@“Ù}À4#—á €09‘8\6(°D°hÂˆÃ      a      G,      PEPREQ<5   3 ÃL„èÇ0a ú1ÌDœ ÃLD èÇ0a ú1ÌD¬ ÃLÄJ ú1ÌD€~3 ÃLD èÇ0 ú1F,× F(Ö F$Õ 2.X
Ä 2Á@Ì¨ Óá†€Â`–!(ŠÆxBF@Á ĞLšÆxC
ß`D0 ]ƒ¬1Ş)FÃ 5Æ0¸``) È` mƒ²1 ƒ^0 ä–q€FxÁ 7èÀl@0!Á ƒaˆ`<aÆ;ŒXƒ` hÆK¸ @#Ô  Rƒ1¡Á Ğø@ô#Ü  ºƒ1üÁ;QÁ Œñ„à.ØÁˆ;`–@ ;ã	Á)FäA0 $Úƒ1¨Â`D0!@|0ÆVŒğƒ` H
c<!x…ÁQ`0B€Ba\P°ã	+\°ƒ¥À,Á@¡0,pFŒB0 Ã>„Á,ƒ@T
c0 ˜%0#`A `–À X „   Ö(pÕLDd‰!!†(0bøGàX:E– Â´CD0éÙ¡ÀğL‘)
Ñ¶(@T@TÛ}À4“N‘
 Ï`Zƒ0Æ(@T@d      a   È   I,      PQ…P5P    3°ÃLD ìÇ0a û1ÌDÀ~3'ìÇ01 û!ÌDÀ~3°ÃLD ìÇ0 û1ÌDÀ~3°Ã`ÄrÀ`„bÀ`DRÀ`BÀ`„à )c<!.X
Ä 2q@Ç° h&" jŒ'ÂxBàFĞH0 D#ã‚¥@\  ƒT0 ¤–1±@›¸ @*8nZ!f„ Œ W €Y„À`Œ7¯ğ
ŒÁˆ0€Æ`Œ7²ğŒÁˆ1€È`7±³ÄĞ™ŒÁˆ3€È`FœA0 ³¡ÁŒX“` (N&¥Á0!Á`„@j0HÆpƒœÁ,Ca'ƒä`Œ7áƒÁ0 ¤'“ê`Œ7ä
ƒÁ0 d'c<!…–1* Œñ„€.X
Ä`Ä¨@~2Æ‚S¸``)ƒ¦ ‰ÊO\á‚¥@F¤J  d*c<!h…–1Á* F¼‚- À,Bª2#J! b•1ÜÂ`„«@­2Æ‚\Œx•` èUÆKŒ¨•@ HVÆxBÀ,â !Z&" Z%t FøJ  Ô+c<!@‡Áˆ_	€|eŒ'ê0.Á .Œñ„`.X
Ä Bâ0LD@ã0JèŒ€—@ ˆÆxB@,â !v&" v%t FäK  äc<!è‡–q€=Ğ=Œº@ #D&€Y‚c0b$Ú f		A8      Ö(à(öE C¤S„.ƒå3`é™~ 4Ó"uÀ¤Sd‡JàXH Y¢À@-
8
}À%ÑÓa÷Ğ Œ8\†p Â¤SdŒPC1h‘:H3‰Ö Œ)
p¢À@     a      A,      P 3,àÇ0@ÁoÆ`(ã	A11@BÈ     v@À      a      A,      PE    3,àÇ01 ø!FÅ 0Æ‚2(
ÆKŒ0 cŒ7j Œñ„`Œ‚ Ed   v@ÀØ~€µL      a      A,      P 3,äÇ0 ù1FÅ FÄ P0hã˜c<! #†` 0      v@À~@Ğ      a   H  }     PEQ…Q`Rd>P¥QT¥PÅPĞ…‰SePÅQ5@uP 3€ÃLD àÇ0 ø1ÌD ~3€ÃL„àÇ0Á ~3€ÁLÄ à‡01 ø!ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÂLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ01 ø!ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~3€ÃLD àÇ0 ø1ÌD ~ƒ§ 0a
!1 t
c¼!VD"Œ …` ˆÆxC@¼@ÁnD"f„ ˜%àƒ ~b.ÛÁˆT€TaŒ7*!b…1Ş´DKFÃ +Œ"Ö"¸ @#j!€Y‚laX  ŒÀ…` èÆpÃ Á,±ÕÂ1 @.‚ Ä‚uÁ`/@¼0†‚z8ƒY†Âf	ø€|a3@¸qà‡¢"ÍŠ@$2•Èe"ˆx,ùAúûÁ!ò-""R.‚ÄcÄ€H€¼. ş!ƒâ Ã1  /‚Áˆp€Èa9Œñ†€,@‚‚1Ü@`0Ë€$™C¸ @HÆxC !1@ì0Æ¶`‰–QÁ=h÷°ƒD  ³É,P<Œ"\#¸ @#ì! ¢‡1b@$ lƒô áÃ |ã^Ğc¸À`–aaÊq€?Œñ†À/z‚‚A!1Æ‚Ğø	
‘ÄoH#,(ÄcÄ@ ßXxâ,Bf	˜Y= “#DGp€F°D0 ¤cÄ€H ó#R" b‰1b@$ zƒ* ÁÄ ˜ãl°c¸À`–Áy‚ƒ Òƒ`B\  5f[€€hB\  #„¼GPÁ^¤A.€Á€vB\  Äâ ¡±ãÁxˆƒÌbŒ7æAJ‹1Ş¤‡iP0(.Æˆ #Ò,¬B0KğÌè±Å1  E‚ d0".‚ ·#D¬Hp€F´E0 $cÄ€H€	. Áˆ·€êbŒ	#Á 2ñÁ P^Œñ† ?hƒ‚A{1Fˆ¸‘à 1" Á`D]@1FˆØ‘à ŒØ‹` H4Æˆ‘ ?\  ƒ} •Æ1 @L‚ d0¢/‚ Õ¤c¼!Pó `7Ì2DR@³1è5ÆxCğ"îAÁ ÙãŒÀƒ^c˜€€ncŒ77BšA±1(6ÕÆ Ú4cÄ €9‘å0
b‚Yi–@<Æˆ‘ }\  ƒå Ç1 àO‚ d0B7‚ ó#DˆJp€FğF0 ”cÄ€H€R	. Áß€ØcŒ	*Á 2Á ÿˆ d¸!Ğ0˜e ¬€èc}Œñ†€N`„‚1Ü@`0ËPYáÇoğäF(´c¼!Ø“¡`P|ˆŒñ† Tz„‚Aõ1ˆDÆxC@*?BÁ ü„cÄ@€]y”Ã„`–Àš%ĞB‘1b@$@¹ È`D‹@+2Fˆ8—`0¢? #D¤K0á PŒŠ‘1ŞÄJ›P0†ˆ f°,  •ˆ¸ @(GÆxC+xBÁ ã¯è	ƒ~dŒ7¿Â':“1b  @¾4w² …Ìd³z@b2Fˆø—à Œ8“` èLÉoÎeT(ÃD ³šŒ"L&¸ @#v$ j“1b@$€Ê È`D@p2Fˆh™à Œø‘` hNÆˆ‘ /\  ƒa ÙÉ1 `f‚ d0bL‚ ?´'c¼!Ø]¡`ŸŒñ†À_x…‚An2L@@£2Æ‚‘
ÉÉ 9$'ƒädŒ, °3PƒÄ ³©Ê1(  l‚^™%èf	ô€VeŒ	€6Á 2+Á «Œ"Ô&¸ @#ô$ Š•1b@$€Û È`Ÿ@´2Fˆ€›à ŒØ“` WÆxC€3óBÁ ]#DØMp€€`0bT‚ _#DèMp€F J0 .cÄ€H ¿	. ÁU	€ÈeŒ	:Á 2¡*Á PºJ—1Ş¤MÉP0†ˆ f>0H^¹ËoÜ¦e(/c¼!ˆ›—¡`¯½Œñ†Ànf†‚Aà2¨WıÊ q$.ƒÀeŒ4  ;Ò£FAB0K ³z@ÿ2Fˆàà Œ ™` HdÆˆ‘ ¿\  ƒç •Ì1(  |³!”„2c¼!@²¡`7Ì2ˆÁÔ.cÄ€ €Ş	f	Æ`–@ˆeÆˆ‘ é\  ƒ1 ÅÌ ˜ãAì´c¸À`–¡Î  šãAí¼£¸Ñá† nÂ`–ÁÎ  ãîĞ£¹QÜÀ`È@ #. ƒ î§¹1äT6c¼!(Ò¡`ÚŒñ† }L‡‚Ak3Æ‚õA
ÍÍ1P  „œÅuBf	Î`–@ÈmÆˆ‘ +\  ƒs ÍÍ ¹ãÁü¼c¸À`–!Ö  »ãÁıÄ£ÙÑá†`vÂ`–AÖ  ¾ãÿØ£ÚQ`À`DØ@a#. ƒ r¨Ú1ht:c¼!8!ó¡`êŒñ†@…Ğ‡‚A­3Æ‚R
ÕÎ1P àŒœ~Bf	Ö`–@vÆˆ‘ m\  ÌO#l' ²A¶3Æ’
Æp€Á,C¸A@å%. ñóÚ¡€‚@¾3ÆªŸÁˆ` Ÿ1Ş€]0°ˆ
ÖG+XŸŒ ˜%pƒY= ò#DˆRp€F¨O0 „>cÄ€H R
. ÁˆÓ	€ÖgŒ	pJÁ 2‘:Á ûŒ"T)¸ @#V' ŠŸ1b@$€+ È`Dë@ô3Fˆ€¥à Œp` è~Æˆ‘ ³\  ƒ° éÏ1 À–‚ d0Bv‚ ş#DèRp€FĞN0 BcÄ€H€^
. Áˆİ	€JhP	ñ† ”Âˆ‚1Ü@`0Ë qùŸA+4Æ‚U2#
Æˆ ½TİØ ãÁ+¹Ãˆ ƒñ µÏ ã-ÉÃˆ ƒõ Ù ãA.ÙÃˆ ƒù ‰Ñ şÄ?ƒøgPşÂŸAø3ˆŒÆxC@NDÁ0" ñÏ şBcÄ  rfQb‚Y‚8˜%ĞZ£1b@$ J È`@n4FˆP©à Œ ¡` (Æˆ‘ -\  ƒ" ÑÑ1  ¦‚ d0‚„‚ ;#DĞTp€F˜P0 ¤GcÄ€H ›
. Áˆ
€úhŒ	SÁ 2‘BÁ ("x*¸ @#V( ¥1b@$ X È`D@¦4Fˆ«à Œ ¡` h•­ÒoVêœ(ÃD ³s@½Òo^ª(”kc¼!)x¢`P-ñ† ¦è‰‚A¸4Æœª'
‰ÛovJŸ(Tnc¼!ğ©}¢`Œ àVÊA# ÀUVN0QGÁ P‚£Aå4Æ‚²)
Æˆ wUÅÛ tãAZ¡Ãˆ ƒ~ éÑ wã[±Ãˆ ƒ¢ éÛ yãÁ\ÁÃˆ ƒ¦ ñÓ T”JƒRi)*¥A¯4L@@§4¤ÆxC Z;EÁ0" ­Ò UKcÄ  İ‚§ab‚Y:˜%Ğ:©1b@$ y È`K@*5Fˆ0¯à Œ˜¥` ¨¥Æˆ‘ é\  ƒµ ÁÔ1 €½‚ d0â–‚ ™#DÀWp€FäR0 dScÄ€H€ù
. Áˆ]
€rjŒ	P_Á 2ÑKÁ O"ò+¸ @#~) 
«Aa5Æ‚ğê+
Æp€Á,ƒÜA@ê4(ÕoÎK´(# äWAôVƒÖjŒ7ë¥Zº»aB ‚«1ŞÀ—kQ0è†	¨®ÆxCP_²EÁ }&  ~ÄOƒøi?ƒ ^Œz”‚„`–àf	ô`–@f	ô`–` ¿ìˆ -Ìğ†     6+@W›©ÀQÑoã·Y,Ä¤	“Y«ÀQÑoã½),"M@#²›³ ò ÀÔvoŸFD¿[©À0\¶ Ó9Vl×+€T@ôÛxm[± Ò–ÖaÈÈtD5Û·±
ÃÅ›« 1Ìc–Ğ LêHv)P ÂäDV)  Â„8M‹=„‘
ı¼¥
ñÀdÌ‹ôDÈDˆÃeï-€<@0÷]›§@QÑÏÙ´À2 Ò4!ß¸] Ì}ïf+°H ó,„8\õnµEDµnÀŠ4EDcL‡M›¬ RÑ_ãõmœIE4f¯	ˆqL5mˆqLv+°H ó,„8\5o¸‹0ÏBˆÃU÷Ö, HSD4ÆtØ¼…
Âe§GDã¶*`T@ôs»U,Ò!!×­[²À2 Ò4Û¸-,"M@#³­[¦ "MÑÓaÇÈtD%Û¶©
ı¼n˜Ä L€‰
Ãe÷ LN$—Q
@D3hÂxÍ„L˜8\F+@W›°€ñ ÀØÆ+ˆ4@Äæ+ˆ4@ÌF,`<@0¸i
$À<!—Lm£CDÖ+ˆ4@È-€<@0øm[®€1‘cÅ¦+`LGäX²
ı5n»ÆtD5¬ÀQÑÏÕµa ~ó6,`<@0·= Œ}ÓF-°ˆ4@Ìwn“ÒÄe›Š0ÏBˆÃUª€"Ì³âpåö+HO„L„8\&-°ˆ4@Ä÷       a     a     P…P5P\%V¥Pjå?PåQ%QFVTeUZ…EEP%PµP  3°ÃLD ìÇ01 û!ÌDÀ~3°ÃL„ìÇ0 û1Ff0 ƒEÀ`A01ŒÁ Ğ0ÆjÄ‚Á" "ÆxC€
c@ÁnÈ f!ŒhV f	À€1Ş°+\0°ˆ
.¬àÒá† Â`–a ‚ÁJ `– hñ†€à€‚1Ü@`0ËPQc¼!À…8 `7t³ÆFtx  ³`@Z¸  †‚8 ƒYD	hãÁ/Üc¸!àƒ0˜eH”€¾1ŞŒÃP0. €Áˆ2`–@¡3TcÄ  €“‚Áˆ2€Ê`7¤ ³PŒƒ V‚‚Áˆ4`–€¡6 ÈpC°
a0ËĞ<µÁoâ!(Ã+€Á,ƒóTƒä`Œ7öÀ
ƒÁ0 ƒyp 0K tâ nXf +ŒĞƒQ ºƒ1ŞìÃ-P0. €Áˆ>€ú \ Ã,€Á,
á€ntf() Q ÄpCp`0Ë@M™B¸  †‚\ ƒYª
#R%`– š%°HÄ 2Ü Ì2\X0Ñ
¶  ³©Âo\â(Ã:€Á,C¦Ô
c¼!Wd" `P,Œñ† &à‚1ŞĞ+7P0ÈÆxC ï0bp Àhì2³…Ë ]ãOäc¼Á\À" `Ğ/Œñ†`,ğaÄÀ  Ñ@†€ÔeŒ'Â`»@ë2Æ‚{ wÃB@³Ğ»ŒÁˆx	`–€›%è©ÃoÜâ$#‚a µÃoâ¢%#‚a (Â Añ0Æ‚ºX‰Áˆ` "™Aô0Æ¼x‰Áˆ` Êq€>Œñ†€/hb0"€ôaŒ7~ÁƒÁ_ ñÃo@£'.X
D)¡ƒC  c¼!(±¸``)´„F IŒñ†@5Îâ‚¥@TZALì` ±Äo`ã,(Ãk„Á,ƒ÷cÄ€ €öf	>Š‰1ŞÔ†XF¶1 4c¼!¸±Œpc ¨&ÆxCd1èÆ ĞMŒñ†`7Êb0"àŒğ‰¼ €Y0 Ÿ „     †€ Â´ØCX~@4ã]SØ¦@“§@4#6q™~ “‰Ãe÷GCXZƒ0      a   ¸  k      PeVReUXUeQ…P^¥U€ÅU`%R€åP€øÅP<…VbEUeS8¥SˆP€ıPjåÿP
hA5@%PEP5P5(P5HP€øEQdÅP(P¥PåP€0”á‘€€‹¤í u    3€ÃLÄ à‡0a ø1ÌDX ~3€ÃLÄ à‡0 ø1ÌD ~ƒˆ) !c¼¡NÌ!Œ8‚ e\  ƒl %c0‚M‚ eŒ7ë
Œá† À`–!‚Yµ gŒ7ï0Œ`0bN iŒ7ó`Œ`0ÂN kŒ7÷
Œ`0"O mŒ7û°,¢‚6À
ğ@‡‚ƒY†A
ƒ1Şˆ)P0†’ƒY¢¨ÆxC`æpÁÀR *ø­ v0‚`–  5ãKãŒh•@ èÆxC ç@Á¸@ #`% šƒ1ŞĞ„:P0.€ÁˆY	€î`Œ78,¢‚YÀ
jA‡ƒY†<0òƒ1Şü„;P0†‚°ƒY†ƒ…1ŞŒ;Œ àÁ`)@¤0†³ƒY	èÆxC€ñ0Ş¤EJP . á†€-Ì`–!Q‚ÁVh‰˜%X#X!%`–`™%`ˆ¹ÂoŞâ(# „ÅÂoä"%(Ô/Ã„ À`½@!3ÆxC6AÁ10 `5ö‚hÆxCÀ4AÁ ”& ¸@ #ş% 
‡1ŞˆNP0¨e†	.€Áˆ‘	€ÎaŒ7¨qŒ€ÖaŒ7¬Q#ÇØkûP;Œñ†À5Üâ‚¥@TàXÁJèpC a0ËĞÌA@ô0Æ‚ÚH
ÆpCpa0ËàpÙŒ¸ @ÈfÄ Bü0Æ‚ŞÀ
ıÃoÀC/(# ÀGrÄoÈ/(ÃDp³ÏĞIŒñ† =Jƒ‚1Ü¨Ì2@Q@+1Æö0
¹ÄoŞc4(F ¸@ #Ş&€YfbŒ7ôŒá†€4À`–Ašº‰1ŞàÇlP0H'ÆxC°¯AÁ0" Á0Ñ7 Ìdôc¼! ‘Ş `7£³TĞXŒñ†€D|ƒ‚Af1Æ‚Ù
†A.€ÁˆÓ	`– £µã‹¤c¸!p0˜e°®€ŞbŒ70²’‹1ŞÌÈyP0ŒBp FÔN  ³×,6KÍhtc¼!Àü¸``)À†F _Œñ† GØc0"ğ‘˜%Øf	ä`0‚/zD È/ÆxCğ#üAÁnÂf:0ÈwÄ B¤1Æ‚2ù
Æp¤Á,ƒ÷ƒ¦0KğÍ¼¡ÆoÒÄD(ÃA~€Á,CA@ê#. r1Ş¼‰ŠP0†ˆ fÄ`‚ÁØX˜%ƒY7 ÙãÁœÀc¸!°0˜e(4H~Ä B¸1Æ‚<™
ÆpœÁ,ƒœA0¡õ! ³g0KĞÄc¼!è¡`7ÿ³iÀù¸ @H<ÆxC0*>BÁn ‚3˜ePƒ5#Èã?`–`f	Ø`– f	Ü`–àˆ<ÄpC`*a0Ë qzŒñ† UÈ„‚q F¨P  Äc¼!h0¡`\  ƒ- ÁÇobeM(À`@ô1Æ‚Z©“–QA‹è`Ä åÇot%M#‚]€Y‚8˜%ƒY‚9˜% Ú1Şğ
¯\0°ˆ
f+ÈnÀ%fê ‘1ŞŒ‹ŸP0hŒÄ bÁ ‚`0âŒ ãºô	ƒÒH\   ¸@ #Ú( ‚‘1ŞÄËªP0èÄ bÁ ‚`0b ã¾àËK¨àLp¸!Ø—0˜e°ƒ;hÄ RA¬²"‚`0” ? H¶BÜŠ.€ÁˆQ
`–àèLÆxC€2ã2¤Ì PšŒñ†@eze0"X™ 5ãË˜Ë`DĞ20K€³y0KĞ
Ô&c¼!p™_¡`7ì³{À
ÅÉodf\(ã»D3c0âN‚ ;ãÁÍœƒôdŒñ†`gò…‚1Ş0N=P0èOÆxC 6¾2bp €ß$ÈFüI0 dOb¸!›0˜eàƒ>ˆTÆxCP6%sÁÀR *Ø­€Vv0‚`–ÀHUÆxC°6+sÁÀR *Œ˜%ğz•1ŞÀMËP0¨¤Ä bC ª•1ŞØM¿P0ŒBP½(éÊoög#‚a è¥Ä B¾2Æ‚¿1™Áˆ` º)q€ĞM‰ „ÈeŒ7¥#6Œ nÇ Š©q F€U  $SãŒ «@ h]ÆxCÀ:dCÁ ² ˆ(^ÆxC ;mCÁ0"Á0AS ½Œñ†àvÜ†‚Ao%. ¿Œñ† wà†‚aD‚`0Â§ ãøàƒòJ\  6  “ãúˆÃˆ À`Z@£%. r™1Ş¼êFÃ i‰ „dfŒ7óc:ƒÁ0 ”Zâ !›ãÁıÄÎ`D0 áÌoò'w.X
Dn£ƒC  Ô3c¼!ğß¹``)¬F ĞÏŒá†`„Â`–áV! ²ãA	ÕÃ‚óÁ`Ä ¡ÍoRÈv(ÃÁ	…Á,(„B@o3F 0£`– ¨mÆxCàB¾CÁ¸@ #æ& šq€İŒ ö(n0˜eUÈnÆxCpC÷sÁÀR *€Œ ½ã‘c¸!ğ!0˜eRtÆˆ ¦PèŒñ†@Œäg0"`–àhtÆxC@FàCÁ ÓãÁñÏ`D0 ¡ÎoÒÈ(ä:cÄ  €Uj1Ş¸ÑÿFÃ ĞëŒñ† Bˆ‚1Ü¸Ì2”‚)d;cÄ  €Y¢£€jgŒ7vtBƒÁ0 t;c¼!À£Œòh f	LNlîŒñ†`Ph0"€xgŒ7}TBƒ ùÎoşè…#P Ÿ1Ş„ÒF¢4 ³§@â3Æ‚Q‚!
ÆpCJa0Ë€
©PúŒ À)˜%H:Ÿ1Ş ]0°ˆ
úG+ ¡Œ ˜%PjŸ1Ş¸RF¯4 ô>c¼!€¥5Œbi (~ÆxC Ke4ÌÒ ĞüŒñ†€–Üh0"¨¥˜%X…YV˜%hªŸ1ŞØÒQ0†:
ƒYWˆ…€ògŒ7º4GŒñ†5ã¥`¼!è¥0¢`P‰ Ä‚!À`D˜@#4Ærê#
ÆxC™S0Şœ“Q0ÈÌÄ bÁ‚`0BÍ ã;c¼áÏà)oâi(ôfâ ±`Á01g Ğñ† Ÿb‰‚1ŞjúŒ7û4KÚ3q€X0€àŒø³@ (ŒÆxC R»DÁo˜5’
Æ‚’â%
‘š¸ @,@p F Z  ´Fc¼!`©r¢`Œ7ôšKãÁK•ƒZM\   ¸@ #b- Â£Av4Æ‚›‚'
ÆˆA aEÃN…Á,,¼B@{4Æª§Áˆ Ÿ`– f	búhŒ7>åO,¢‚\Â
vI‡±
ƒYY˜…€ÊMFŒ[  Tnâ !q& ¸@ #Î- J71qn ÌÌ­ÒoØŠ­.X
Dè„¤“7p³´ Á`»ÉÕ Ğ¼‰ „èM\  Toâ 10 à¯Š!Œ¨¥` ¨–ÆpC Wa0ËP¸Ğ-á†€§Â`–Án! \# V0Kp³¸@¾4Æ‚¿ú«–QÁ>épC Za0ËºĞ9 T+˜%Ğ2§1ŞœXQ0†‚²
ƒY†]è…€ÔiŒ7«µV,¢“Â
PJ/ ˆá† ¶Â`–z!1 Àf	za0bådk æÄ 2ÁrÁ PÌ‰ d0¢å‚ ™ È`„Ë@û4†‚Ü
ƒYpğ…€ôiŒ7»µ[,¢‚“Â
pJ‡‚ß
ƒYpø…€BjŒ7âZãÁx×xC@^äE¸ @è¤ÆxC€^§5Ş¤Wj7ê¥^ˆ „ZjŒ7îÕZãÁ{µÖxC _ğE¸ @F °¯æf‹fjŒ7ô5[ãA}Õ×xC`_¶E¸ @(§ÆxC _¹5Şì×n7üÅ_ˆ „~jŒ7 ö[ãAˆıÖxC b"F¸ @F @±æÆ‹ÊjŒ7&V^ãÁ‰ØxC€bèE¸ @h­ÆxCÀbë5Ş´X{7.æbˆ „âjŒ72_ãÁŒÅ×xC@côE¸ @F Ğ±æØ‹îjŒ78v_ãAåØxC c:F¸ @¨¯ÆxCàcı5ŞüØ7`fˆ „FkŒ7d6bãA™ØxC`f&F¸ @F `³æŞk– (µÆxC f)6Ş¬Ùš7lÆfˆ „^kŒ7pöbãAœÅØxC grF¸ @¨¶ÆxC`g56ŞÜY7x†gˆ dÄà €>k`Çh·ÆxCÀg;6ŞôYŸ7~æcˆ „ÂkŒ7¢fãÁ¨ÙxC@j¤F¸ @è¼ÆxC€jg6Ş¤Ú™7ª¦jˆ dÄà €Wk`Í¨½ÆxCàjm6Ş¼Ú«7°gˆ „ækŒ7´6gãA­ÕÙxC`k¶F¸ @(¿ÆxC ky6ŞìZ7¼Ægˆ dÄà €pk€Îè¿ÆxC n6Ş„[¸7â&nˆ „JlŒ7æVjãÁ¹ÚxC€nèF¸ @hÅÆxCÀn«6Ş´Ûª7îæjˆ dÄà €ykàÎf	ÂÔ0Ã¼…Á,ƒ8ÄC@36Æz£µ–QÁ›aq¦Ã¾…Á,C<ŒC@}ˆá†@ßÂ`–!È! 8Ä 2ÜøÌ2”C<ôcc¼! ¹Z£`7â³æÙoHnÜÆ‚’+¹ñ†ÀäLq€Pšñ†@åÒm¼!X¹toXå( ½Ùo`®İ(´F »¥(q€Ğ/Ãƒá@³ˆ „Ä1 Œ Ç  *Ç`7<w³ç ™c0†Ÿ;ƒYt€‡€Ò1Ã»¥Á,C:ÀC@êŒá†ÀİÒ`–Aà! v…c . èÁ10 àí
!nÒ.fÖázµ1Ü¬Ì2°Ã;Äjc¼!h»’£`Ğ«ñ† îN‚aA¼€fmŒ7t§rŒƒ î!»£|Ä 2bp0 éÜ»Ù]@üˆ d¸!Ø;0˜ehw#Ş1¨7˜%pâµ1ŞôÈQ0,Ø9FÁ Ì¼Ã,<ÌÄùc . úÇ@\  ’¸ @F h½b#Æ- ·Aè6Æ‚Ô£¹Áˆ` 2·1Ü¬^Ì2ÈCJ„nc¸!h;0˜e˜‡’ÈİÆxCğzowÁÀR *P9¬€åt¸!˜½0˜e ‡zF È7zÉ`TÀsgAÙàŒ°É €Y’ ~Ãî…Á,?ØC@0ˆ d¸!è;0˜e¸~ÈßÆxCğ{tGÁ ~ÃB ³øÀ¡ÜnHfò*¹1Ş˜ŸßQ0åÆxC~ GÁ°@í@@,7Æ‚ö=
ÆˆÁ ğ‡Áû‘\â 18 ÿøíŞ/ šÃÁü…Á,Ã>èC0q–AÛ	À,Á>Íñ† şô‚aÁì`0b`–€È.q€Ğ]â ¡½Ä 2b` @	Å7ÿ³şĞıe #ú2`–ÀH4q€hâ ¡ĞÄ 2b` €Å7(„Á,HüC@ªˆÁÔ˜% 	BÍ@\  ”š¸ @¨5q€Œ pƒA1ÃAa0Ë#Ğlâ ¡ØÄ B²ˆ dÄÀ €Š!nr0ƒY‘‰`–@-f	Hb– %HïÆxC°ƒÁş]0°ˆ
l+À=n~0ƒY“8‰`Ä` €Ò›%8	ê»1b@  Á,Jèñ†`ƒ.X
D·§ƒC  ³7A§7Æ4Ğ0¸``)ÌVP~z@7n„Á,ƒJØD@¯7Æ8R0 `7.€Á,ÃJØD@ñˆ „ä3 ˆ7„€è3 Èˆ ¡C0q{Á Ğíá†€ƒ0˜e`‰—¨÷ÆxCà‡,¢‚üÃ
öO‡QÂ`–¡%\"1  ıf	\‚ÀoŒ °ŠA0KPT~c¼!0ÅÀƒ–Qüa#èpC ŠAÌ2ĞLÄ~c¼!hÅ ƒ–QAZÁıí` Õßnf1ƒY†™ˆ‰€L4 ÈpC`‹Ì2ÈÄLD£ŒPÑ €Y‚™ ı#”c`†.3³41KP³61KpD£Ánî0 ƒYœÈ‰€øoŒ7½ˆa0øb0 ³91KĞäc¼!øÅàƒ–QÁ:Üˆc³;Á`0F PÇ ˜%à‰Y‚ ÆpCpAÌ2øÄO„‚ÁoÒ1 Ã€‚QA;10Kğ¤¦¸ @†wĞ`–,Â"ŒhÓÀ˜%bÓ@\  ÃA<h0Ë cF¼i ÌŒ¹i . á†€4˜e ‹²#â4 Ç@ f	Ê‚æ4 ÈpC0ŠÌ2˜ÅYƒv a  ³gAtˆ d¸!0ÅÀfĞ"-‚Áˆ;Ö0€Y‚´ <Ä B=Œñ†À[#‚a ˆOq€Pc¼!É ƒÁˆ` úÓ@\  T†ÁoL2àÅ`0"`–@-0   f+°4CXaº	õÀD¤d¹Ğa¸ LNd»B`_0D
H1Ø­À4“N‘ñ
(A„
{ a÷ LN$          /** @file collision.c
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>

#include "collision.h"
#include "scene.h"
#include "actor.h"
#include "movements.h"
#include "grid.h"
#include "main.h"
#include "animations.h"
#include "renderer.h"
#include "extra.h"

/** Check if actor 1 is standing in actor2
	@param actorIdx1 Actor 1 index 
	@param actorIdx2 Actor 2 index */
int32 standingOnActor(int32 actorIdx1, int32 actorIdx2) { // CheckZvOnZv
	int32 x1Left, y1Left, z1Left, x1Right, y1Right, z1Right;
	int32 x2Left, y2Left, z2Left, x2Right, y2Right, z2Right;
	ActorStruct *actor1;
	ActorStruct *actor2;

	actor1 = &sceneActors[actorIdx1];
	actor2 = &sceneActors[actorIdx2];

	// Current actor (actor 1)
	x1Left = processActorX + actor1->boudingBox.X.bottomLeft;
	x1Right = processActorX + actor1->boudingBox.X.topRight;

	y1Left = processActorY + actor1->boudingBox.Y.bottomLeft;
	y1Right = processActorY + actor1->boudingBox.Y.topRight;

	z1Left = processActorZ + actor1->boudingBox.Z.bottomLeft;
	z1Right = processActorZ + actor1->boudingBox.Z.topRight;

	// Actor 2
	x2Left = actor2->X + actor2->boudingBox.X.bottomLeft;
	x2Right = actor2->X + actor2->boudingBox.X.topRight;

	y2Left = actor2->Y + actor2->boudingBox.Y.bottomLeft;
	y2Right = actor2->Y + actor2->boudingBox.Y.topRight;

	z2Left = actor2->Z + actor2->boudingBox.Z.bottomLeft;
	z2Right = actor2->Z + actor2->boudingBox.Z.topRight;

	if (x1Left >= x2Right)
		return 0; // not standing

	if (x1Right <= x2Left)
		return 0;

	if (y1Left > (y2Right + 1))
		return 0;

	if (y1Left <= (y2Right - 0x100))
		return 0;

	if (y1Right <= y2Left)
		return 0;

	if (z1Left >= z2Right)
		return 0;

	if (z1Right <= z2Left)
		return 0;

	return 1; // standing
}

int32 getAverageValue(int32 var0, int32 var1, int32 var2, int32 var3) {
	if (var3 <= 0) {
		return var0;
	}

	if (var3 >= var2) {
		return var1;
	}

    return ((((var1 - var0) * var3) / var2) + var0);
}

/** Reajust actor position in scene according with brick shape bellow actor
	@param brickShape Shape of brick bellow the actor */
void reajustActorPosition(int32 brickShape) {
	int32 brkX, brkY, brkZ;

	if (!brickShape) {
		return;
	}

	brkX = (collisionX << 9) - 0x100;
	brkY = collisionY << 8;
	brkZ = (collisionZ << 9) - 0x100;

	// double-side stairs
	if (brickShape >= kDoubleSideStairsTop1 && brickShape <= kDoubleSideStairsRight2) {
		switch (brickShape) {
		case kDoubleSideStairsTop1: 
			if (processActorZ - collisionZ <= processActorX - collisionX) {
				brickShape = kStairsTopLeft;
			} else {
				brickShape = kStairsTopRight;
			}
			break;
		case kDoubleSideStairsBottom1: 
			if (processActorZ - collisionZ <= processActorX - collisionX) {
				brickShape = kStairsBottomLeft;
			} else {
				brickShape = kStairsBottomRight;
			}
			break;
		case kDoubleSideStairsLeft1: 
			if (512 - processActorX - collisionX <= processActorZ - collisionZ) {
				brickShape = kStairsTopLeft;
			} else {
				brickShape = kStairsBottomLeft;
			}
			break;
		case kDoubleSideStairsRight1: 
			if (512 - processActorX - collisionX <= processActorZ - collisionZ) {
				brickShape = kStairsTopRight;
			} else {
				brickShape = kStairsBottomRight;
			}
			break;
		case kDoubleSideStairsTop2: 
			if (processActorX - collisionX >= processActorZ - collisionZ) {
				brickShape = kStairsTopRight;
			} else {
				brickShape = kStairsTopLeft;
			}
			break;
		case kDoubleSideStairsBottom2: 
			if (processActorZ - collisionZ <= processActorX - collisionX) {
				brickShape = kStairsBottomRight;
			} else {
				brickShape = kStairsBottomLeft;
			}
			break;
		case kDoubleSideStairsLeft2: 
			if (512 - processActorX - collisionX <= processActorZ - collisionZ) {
				brickShape = kStairsBottomLeft;
			} else {
				brickShape = kStairsTopLeft;
			}
			break;
		case kDoubleSideStairsRight2: 
			if (512 - processActorX - collisionX <= processActorZ - collisionZ) {
				brickShape = kStairsBottomRight;
			} else {
				brickShape = kStairsTopRight;
			}
			break;
		default:
			if (cfgfile.Debug == 1) {
				printf("Brick Shape %d unsupported\n", brickShape);
			}
			break;
		}	
	}

	if (brickShape >= kStairsTopLeft && brickShape <= kStairsBottomRight) {
		switch (brickShape) {
		case kStairsTopLeft: 
			processActorY = brkY + getAverageValue(0, 0x100, 0x200, processActorX - brkX);
			break;
		case kStairsTopRight: 
			processActorY = brkY + getAverageValue(0, 0x100, 0x200, processActorZ - brkZ);
			break;
		case kStairsBottomLeft: 
			processActorY = brkY + getAverageValue(0x100, 0, 0x200, processActorZ - brkZ);
			break;
		case kStairsBottomRight: 
			processActorY = brkY + getAverageValue(0x100, 0, 0x200, processActorX - brkX);
			break;
		default:
			break;
		}
	}
}

/** Check collision with actors
	@param actorIx Current process actor index */
int32 checkCollisionWithActors(int32 actorIdx) {
	int32 a, xLeft, xRight, yLeft, yRight, zLeft, zRight;
	ActorStruct *actor, *actorTest;

	actor = &sceneActors[actorIdx];

	xLeft  = processActorX + actor->boudingBox.X.bottomLeft;
	xRight = processActorX + actor->boudingBox.X.topRight;

	yLeft  = processActorY + actor->boudingBox.Y.bottomLeft;
	yRight = processActorY + actor->boudingBox.Y.topRight;

	zLeft  = processActorZ + actor->boudingBox.Z.bottomLeft;
	zRight = processActorZ + actor->boudingBox.Z.topRight;

	actor->collision = -1;

	for (a = 0; a < sceneNumActors; a++) {
		actorTest = &sceneActors[a];

		// aviod current processed actor
		if (a != actorIdx && actorTest->entity != -1 && !actor->staticFlags.bComputeLowCollision && actorTest->standOn != actorIdx) {
			int32 xLeftTest, xRightTest, yLeftTest, yRightTest, zLeftTest, zRightTest;

			xLeftTest  = actorTest->X + actorTest->boudingBox.X.bottomLeft;
			xRightTest = actorTest->X + actorTest->boudingBox.X.topRight;

			yLeftTest  = actorTest->Y + actorTest->boudingBox.Y.bottomLeft;
			yRightTest = actorTest->Y + actorTest->boudingBox.Y.topRight;

			zLeftTest  = actorTest->Z + actorTest->boudingBox.Z.bottomLeft;
			zRightTest = actorTest->Z + actorTest->boudingBox.Z.topRight;

			if (xLeft < xRightTest && xRight > xLeftTest && yLeft < yRightTest && yRight > yLeftTest && zLeft < zRightTest && zRight > zLeftTest) {
				actor->collision = a; // mark as collision with actor a

				if (actorTest->staticFlags.bIsCarrierActor) {
					if (actor->dynamicFlags.bIsFalling) {
						processActorY = yRightTest - actor->boudingBox.Y.bottomLeft + 1;
						actor->standOn = a;
					} else {
						if (standingOnActor(actorIdx, a)) {
							processActorY = yRightTest - actor->boudingBox.Y.bottomLeft + 1;
							actor->standOn = a;
						} else {
							int32 newAngle;

							newAngle = getAngleAndSetTargetActorDistance(processActorX, processActorZ, actorTest->X, actorTest->Z);

							if (actorTest->staticFlags.bCanBePushed && !actor->staticFlags.bCanBePushed) {
								actorTest->lastY = 0;

								if (actorTest->staticFlags.bUseMiniZv) {
									if (newAngle >= 0x80 && newAngle < 0x180 && actor->angle > 0x80 && actor->angle < 0x180) {
										actorTest->lastX = 192;
									}
									if (newAngle >= 0x180 && newAngle < 0x280 && actor->angle > 0x180 && actor->angle < 0x280) {
										actorTest->lastZ = -64;
									}
									if (newAngle >= 0x280 && newAngle < 0x380 && actor->angle > 0x280 && actor->angle < 0x380) {
										actorTest->lastX = -64;
									}
									if ((newAngle >= 0x380 || newAngle < 0x80) && (actor->angle > 0x380 || actor->angle < 0x80)) {
										actorTest->lastX = 192;
									}
								} else {
									actorTest->lastX = processActorX - actor->collisionX;
									actorTest->lastZ = processActorZ - actor->collisionZ;
								}
							}

							if ((actorTest->boudingBox.X.topRight - actorTest->boudingBox.X.bottomLeft == actorTest->boudingBox.Z.topRight - actorTest->boudingBox.Z.bottomLeft) &&
								(actor->boudingBox.X.topRight - actor->boudingBox.X.bottomLeft == actor->boudingBox.Z.topRight - actor->boudingBox.Z.bottomLeft)) {
								if (newAngle < 0x180) {
									processActorX = xLeftTest - actor->boudingBox.X.topRight;
								}
								if (newAngle >= 0x180 && newAngle < 0x280) {
									processActorZ = zRightTest - actor->boudingBox.Z.bottomLeft;
								}
								if (newAngle >= 0x280 && newAngle < 0x380) {
									processActorX = xRightTest - actor->boudingBox.X.bottomLeft;
								}
								if (newAngle >= 0x380 || (newAngle < 0x380 && newAngle < 0x80)) {
									processActorZ = zLeftTest - actor->boudingBox.Z.topRight;
								}
							} else {
								if (!actor->dynamicFlags.bIsFalling) {
									processActorX = previousActorX;
									processActorY = previousActorY;
									processActorZ = previousActorZ;
								}
							}
						}
					}
				} else {
					int32 newAngle;

					if (standingOnActor(actorIdx, a)) {
						hitActor(actorIdx, a, 1, -1);
					}

					newAngle = getAngleAndSetTargetActorDistance(processActorX, processActorZ, actorTest->X, actorTest->Z);

					if (actorTest->staticFlags.bCanBePushed && !actor->staticFlags.bCanBePushed) {
						actorTest->lastY = 0;

						if (actorTest->staticFlags.bUseMiniZv) {
							if (newAngle >= 0x80 && newAngle < 0x180 && actor->angle > 0x80 && actor->angle < 0x180) {
								actorTest->lastX = 192;
							}
							if (newAngle >= 0x180 && newAngle < 0x280 && actor->angle > 0x180 && actor->angle < 0x280) {
								actorTest->lastZ = -64;
							}
							if (newAngle >= 0x280 && newAngle < 0x380 && actor->angle > 0x280 && actor->angle < 0x380) {
								actorTest->lastX = -64;
							}
							if ((newAngle >= 0x380 || newAngle < 0x80) && (actor->angle > 0x380 || actor->angle < 0x80)) {
								actorTest->lastX = 192;
							}
						} else {
							actorTest->lastX = processActorX - actor->collisionX;
							actorTest->lastZ = processActorZ - actor->collisionZ;
						}
					}

					if ((actorTest->boudingBox.X.topRight - actorTest->boudingBox.X.bottomLeft == actorTest->boudingBox.Z.topRight - actorTest->boudingBox.Z.bottomLeft) &&
						(actor->boudingBox.X.topRight - actor->boudingBox.X.bottomLeft == actor->boudingBox.Z.topRight - actor->boudingBox.Z.bottomLeft)) {
						if (newAngle < 0x180) {
							processActorX = xLeftTest - actor->boudingBox.X.topRight;
						}
						if (newAngle >= 0x180 && newAngle < 0x280) {
							processActorZ = zRightTest - actor->boudingBox.Z.bottomLeft;
						}
						if (newAngle >= 0x280 && newAngle < 0x380) {
							processActorX = xRightTest - actor->boudingBox.X.bottomLeft;
						}
						if (newAngle >= 0x380 || (newAngle < 0x380 && newAngle < 0x80)) {
							processActorZ = zLeftTest - actor->boudingBox.Z.topRight;
						}
					} else {
						if (!actor->dynamicFlags.bIsFalling) {
							processActorX = previousActorX;
							processActorY = previousActorY;
							processActorZ = previousActorZ;
						}
					}
				}
			}
		}
	}

	if (actor->dynamicFlags.bIsHitting) {
   		rotateActor(0, 200, actor->angle);

		xLeft  = destX + processActorX + actor->boudingBox.X.bottomLeft;
		xRight = destX + processActorX + actor->boudingBox.X.topRight;

		yLeft  = processActorY + actor->boudingBox.Y.bottomLeft;
		yRight = processActorY + actor->boudingBox.Y.topRight;

		zLeft  = destZ + processActorZ + actor->boudingBox.Z.bottomLeft;
		zRight = destZ + processActorZ + actor->boudingBox.Z.topRight;
	
		for (a = 0; a < sceneNumActors; a++) {
			actorTest = &sceneActors[a];

			// aviod current processed actor
			if (a != actorIdx && actorTest->entity != -1 && !actorTest->staticFlags.bIsHidden && actorTest->standOn != actorIdx) {
				int32 xLeftTest, xRightTest, yLeftTest, yRightTest, zLeftTest, zRightTest;

				xLeftTest  = actorTest->X + actorTest->boudingBox.X.bottomLeft;
				xRightTest = actorTest->X + actorTest->boudingBox.X.topRight;

				yLeftTest  = actorTest->Y + actorTest->boudingBox.Y.bottomLeft;
				yRightTest = actorTest->Y + actorTest->boudingBox.Y.topRight;

				zLeftTest  = actorTest->Z + actorTest->boudingBox.Z.bottomLeft;
				zRightTest = actorTest->Z + actorTest->boudingBox.Z.topRight;

				if (xLeft < xRightTest && xRight > xLeftTest && yLeft < yRightTest && yRight > yLeftTest && zLeft < zRightTest && zRight > zLeftTest) {
					hitActor(actorIdx, a, actor->strengthOfHit, actor->angle + 0x200);
					actor->dynamicFlags.bIsHitting = 0;
				}
			}
		}
	}

	return actor->collision;
}

/** Check Hero collision with bricks
	@param X Hero X coordinate 
	@param Y Hero Y coordinate 
	@param Z Hero Z coordinate
	@param damageMask Cause damage mask */
void checkHeroCollisionWithBricks(int32 X, int32 Y, int32 Z, int32 damageMask) {
	int32 brickShape;

	brickShape = getBrickShape(processActorX, processActorY, processActorZ);

	processActorX += X;
	processActorY += Y;
	processActorZ += Z;

	if (processActorX >= 0 && processActorZ >= 0 && processActorX <= 0x7E00 && processActorZ <= 0x7E00) {
		reajustActorPosition(brickShape);
		brickShape = getBrickShapeFull(processActorX, processActorY, processActorZ, processActorPtr->boudingBox.Y.topRight);

		if (brickShape == kSolid) {
			causeActorDamage |= damageMask;
			brickShape = getBrickShapeFull(processActorX, processActorY, previousActorZ + Z, processActorPtr->boudingBox.Y.topRight);

			if (brickShape == kSolid) {
				brickShape = getBrickShapeFull(X + previousActorX, processActorY, processActorZ, processActorPtr->boudingBox.Y.topRight);
				
				if (brickShape != kSolid) {
					processCollisionX = previousActorX;
				}
			} else {
				processCollisionZ = previousActorZ;
			}
		}
	}

	processActorX = processCollisionX;
	processActorY = processCollisionY;
	processActorZ = processCollisionZ;
}

/** Check other actor collision with bricks
	@param X Actor X coordinate 
	@param Y Actor Y coordinate 
	@param Z Actor Z coordinate
	@param damageMask Cause damage mask */
void checkActorCollisionWithBricks(int32 X, int32 Y, int32 Z, int32 damageMask) {
	int32 brickShape;

	brickShape = getBrickShape(processActorX, processActorY, processActorZ);

	processActorX += X;
	processActorY += Y;
	processActorZ += Z;

	if (processActorX >= 0 && processActorZ >= 0 && processActorX <= 0x7E00 && processActorZ <= 0x7E00) {
		reajustActorPosition(brickShape);
		brickShape = getBrickShape(processActorX, processActorY, processActorZ);

		if (brickShape == kSolid) {
			causeActorDamage |= damageMask;
			brickShape = getBrickShape(processActorX, processActorY, previousActorZ + Z);

			if (brickShape == kSolid) {
				brickShape = getBrickShape(X + previousActorX, processActorY, processActorZ);
				
				if (brickShape != kSolid) {
					processCollisionX = previousActorX;
				}
			} else {
				processCollisionZ = previousActorZ;
			}
		}
	}

	processActorX = processCollisionX;
	processActorY = processCollisionY;
	processActorZ = processCollisionZ;
}

/** Make actor to stop falling */
void stopFalling() { // ReceptionObj()
	int32 fall;

	if (currentlyProcessedActorIdx == 0) {
		fall = heroYBeforeFall - processActorY;

		if (fall >= 0x1000) {
			addExtraSpecial(processActorPtr->X, processActorPtr->Y + 1000, processActorPtr->Z, kHitStars);
			processActorPtr->life--;
			initAnim(kLandingHit, 2, 0, currentlyProcessedActorIdx);	
		} else if (fall >= 0x800) {
			addExtraSpecial(processActorPtr->X, processActorPtr->Y + 1000, processActorPtr->Z, kHitStars);
			processActorPtr->life--;
			initAnim(kLandingHit, 2, 0, currentlyProcessedActorIdx);	
		} else if (fall > 10) {
			initAnim(kLanding, 2, 0, currentlyProcessedActorIdx);	
		} else {
			initAnim(kStanding, 0, 0, currentlyProcessedActorIdx);	
		}

		heroYBeforeFall = 0;
	} else {
		initAnim(kLanding, 2, processActorPtr->animExtra, currentlyProcessedActorIdx);
	}

	processActorPtr->dynamicFlags.bIsFalling = 0;
}

/** Check extra collision with actors
	@param extra to process
	@param actorIdx actor to check collision */
int32 checkExtraCollisionWithActors(ExtraListStruct* extra, int32 actorIdx) {
	int32 a;
	int32 xLeft, xRight, yLeft, yRight, zLeft, zRight;
	int16 * spriteBounding;
	ActorStruct *actorTest;

	spriteBounding = (int16*)(spriteBoundingBoxPtr + extra->info0 * 16 + 4);

	xLeft  = *(spriteBounding++) + extra->X;
	xRight = *(spriteBounding++) + extra->X;

	yLeft  = *(spriteBounding++) + extra->Y;
	yRight = *(spriteBounding++) + extra->Y;

	zLeft  = *(spriteBounding++) + extra->Z;
	zRight = *(spriteBounding++) + extra->Z;

	for (a = 0; a < sceneNumActors; a++) {
		actorTest = &sceneActors[a];
		
		if (a != actorIdx && actorTest->entity != -1) {
			int32 xLeftTest, xRightTest, yLeftTest, yRightTest, zLeftTest, zRightTest;

			xLeftTest  = actorTest->X + actorTest->boudingBox.X.bottomLeft;
			xRightTest = actorTest->X + actorTest->boudingBox.X.topRight;

			yLeftTest  = actorTest->Y + actorTest->boudingBox.Y.bottomLeft;
			yRightTest = actorTest->Y + actorTest->boudingBox.Y.topRight;

			zLeftTest  = actorTest->Z + actorTest->boudingBox.Z.bottomLeft;
			zRightTest = actorTest->Z + actorTest->boudingBox.Z.topRight;

			if (xLeft < xRightTest && xRight > xLeftTest && yLeft < yRightTest && yRight > yLeftTest && zLeft < zRightTest && zRight > zLeftTest) {
				if (extra->strengthOfHit != 0) {
					hitActor(actorIdx, a, extra->strengthOfHit, -1);
				}

				return a;
			}
		}
	}

	return -1;
}

/** Check extra collision with bricks */
int32 checkExtraCollisionWithBricks(int32 X, int32 Y, int32 Z, int32 oldX, int32 oldY, int32 oldZ) {
	int32 averageX, averageY, averageZ;

	if (getBrickShape(oldX, oldY, oldZ)) {
		return 1;
	}

	averageX = Abs(X + oldX)/2;
	averageY = Abs(Y + oldY)/2;
	averageZ = Abs(Z + oldZ)/2;

	if (getBrickShape(averageX, averageY, averageZ)) {
		return 1;
	}

	if (getBrickShape(Abs(oldX + averageX)/2, Abs(oldY + averageY)/2, Abs(oldZ + averageZ)/2)) {
		return 1;
	}

	if (getBrickShape(Abs(X + averageX)/2, Abs(Y + averageY)/2, Abs(Z + averageZ)/2)) {
		return 1;
	}

	return 0;
}

/** Check extra collision with another extra
	@param extra to process
	@param extraIdx extra index to check collision */
int32 checkExtraCollisionWithExtra(ExtraListStruct* extra, int32 extraIdx) {
	int32 i;
	int32 xLeft, xRight, yLeft, yRight, zLeft, zRight;
	int16 * spriteBounding;

	spriteBounding = (int16*)(spriteBoundingBoxPtr + extra->info0 * 16 + 4);

	xLeft  = *(spriteBounding++) + extra->X;
	xRight = *(spriteBounding++) + extra->X;

	yLeft  = *(spriteBounding++) + extra->Y;
	yRight = *(spriteBounding++) + extra->Y;

	zLeft  = *(spriteBounding++) + extra->Z;
	zRight = *(spriteBounding++) + extra->Z;

    for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extraTest = &extraList[i];
		if ( i != extraIdx && extraTest->info0 != -1) {
			int32 xLeftTest, xRightTest, yLeftTest, yRightTest, zLeftTest, zRightTest;
//            int16 * spriteBoundingTest;
//	        spriteBoundingTest = (int16*)(spriteBoundingBoxPtr + extraTest->info0 * 16 + 4);

			xLeftTest  = *(spriteBounding++) + extraTest->X;
	        xRightTest = *(spriteBounding++) + extraTest->X;

	        yLeftTest  = *(spriteBounding++) + extraTest->Y;
	        yRightTest = *(spriteBounding++) + extraTest->Y;

	        zLeftTest  = *(spriteBounding++) + extraTest->Z;
	        zRightTest = *(spriteBounding++) + extraTest->Z;

            if (xLeft < xLeftTest) {
			    if (xLeft < xRightTest && xRight > xLeftTest && yLeft < yRightTest && yRight > yLeftTest && zLeft < zRightTest && zRight > zLeftTest) {
				    return i;
			    }
            }
		}
	}

	return -1;
}
/** @file collision.h
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef COLLISION_H
#define COLLISION_H

#include "sys.h"
#include "extra.h"

/** Actor collition X coordinate */
int32 collisionX; // getPosVar1
/** Actor collition Y coordinate */
int32 collisionY; // getPosVar2
/** Actor collition Z coordinate */
int32 collisionZ; // getPosVar3

/** Actor collition X coordinate */
int32 processCollisionX; // processActorVar11
/** Actor collition Y coordinate */
int32 processCollisionY; // processActorVar12
/** Actor collition Z coordinate */
int32 processCollisionZ; // processActorVar13

/** Cause damage in current processed actor */
int32 causeActorDamage; //fieldCauseDamage

/** Check if actor 1 is standing in actor2
	@param actorIdx1 Actor 1 index 
	@param actorIdx2 Actor 2 index */
int32 standingOnActor(int32 actorIdx1, int32 actorIdx2);

int32 getAverageValue(int32 var0, int32 var1, int32 var2, int32 var3);

/** Reajust actor position in scene according with brick shape bellow actor
	@param brickShape Shape of brick bellow the actor */
void reajustActorPosition(int32 brickShape);

/** Check collision with actors
	@param actorIx Current process actor index */
int32 checkCollisionWithActors(int32 actorIdx);

/** Check Hero collision with bricks
	@param X Hero X coordinate 
	@param Y Hero Y coordinate 
	@param Z Hero Z coordinate
	@param damageMask Cause damage mask */
void checkHeroCollisionWithBricks(int32 X, int32 Y, int32 Z, int32 damageMask);

/** Check other actor collision with bricks
	@param X Actor X coordinate 
	@param Y Actor Y coordinate 
	@param Z Actor Z coordinate
	@param damageMask Cause damage mask */
void checkActorCollisionWithBricks(int32 X, int32 Y, int32 Z, int32 damageMask);

/** Make actor to stop falling */
void stopFalling();

/** Check extra collision with actors
	@param extra to process
	@param actorIdx actor to check collision */
int32 checkExtraCollisionWithActors(ExtraListStruct* extra, int32 actorIdx);

/** Check extra collision with bricks */
int32 checkExtraCollisionWithBricks(int32 X, int32 Y, int32 Z, int32 oldX, int32 oldY, int32 oldZ);

/** Check extra collision with another extra
	@param extra to process
	@param extraIdx extra index to check collision */
int32 checkExtraCollisionWithExtra(ExtraListStruct* extra, int32 extraIdx);

#endif
BCÀŞ!  ?  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  é   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l À6Ä ˆÁ†Ú(şÿÿÿ $€"Ø¡æaÚ ä¡Æ!æ¡ÚÀà¡Â sv˜‡r wx‡60y‡v(‡6€‡wHw ‡r‡6(vH‡v èAê¡€ÁŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ÚÀŞÁÚ€Ê!Ì ÜáÚ ÜÁæ¡ÌÚ ÂĞ0‡p`‡y(€p‡whww˜‡60xhƒvz@ÀÂæ¡ bè!ÆaÚ äáè¡ÆŞAÚ@êÁÌ¡ä¡æ!ô¡ < ˆzp‡ys(‡60xhƒvz@ÀÂæ¡ ¢æ¡Ú`ŞÁè¡ÌŞ!è0‡p`‡y(`ƒaüÿÿÿÿ H I     ‚`B LB˜„˜  ‰   ƒ   2"È	 d…“#¤„“#ã„¡LŒ„äLÔÂ’€Ã¤)¢„Ég'`B„o‰"J˜P¸Lš"J˜ük ¾0$vŠ(aBA` 0G #M%Lşü¦ÒLH0‘¦ˆ&~7çBÃáp8Kš"J˜|M˜œÈt*‚"J˜a0§ISD	“¯5Ó"uÀ°SD	
„“¤)¢„É×„É‰Ø)¢„	Ù`@ „¡@ @ @ BP @ @@$I¶ ˆ
€ \$M%L>ç4b|ÈB !"„@ @ @ I’@Z…
gISD	“ï]S”ˆ4±SD	ŠƒÁ`0$ƒÁ@0)“!M"ˆ“Èò$@ISD	“Ï
DC¤ÒLh0·HSD	“4NƒƒÁ`8…j§ñÆiP0ºHš"J˜üÙivŠ(aB…Hd ’¬D¦D*¡ ¤Jl‚±›€@.rdp€be 4+@ ¨6P„pU HWx¥¸ù
q#,@ °7"–‚@0 d¤LH%ËA –„ ÃA0@    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD 6x§C'P:t¥C'P>rç#'p>rç v(UàI  @ ğ‘8:Ò¡(:ò‘89óò89ó‘89ó‘8:Ò¡(1;s8;aó#89ó‘89³€:Ò¡(:Ò¡(:³81;³81;³8:Ò¡(:Ò¡(:24(9Ó¡(:Ò¡(:Ò¡(:ò‘89ó‘81;ó‘89ó‘8934(Cc24(:Ò¡(:Ò¡(:Ò¡(:Ò¡(:Ò¡(:Ò¡(:Ò¡(/?Ó¡(:Ò¡(:Ò¡(9óD(93U(:Ò¡(WfÑ¡(:ò‘89ó‘89ó‘89ó‘81;Ó¡(:³8[gó…8:Ò¡(:Ò¡(:³81;³81;³89Ó¡(:Ò¡(:Ò¡(:ò‘89ó‘89Ö8:ò‘8eiÖø…      `Èb      0dÉ      ²ì     Yú  €     †,v €     C–? @    €!K(      Àå      `È2
@     0d±      ²ü      YJ €     †, €     C–S `    €!‹*      À…      `ÈÒ@     0dQ      È   2˜ LŒ	&GÆCŒ a€# T Æ 9F ˆ¢›P¯ASt^•È º{^‡Ãßrz™¬ Ë iF ˆ3@  i€P# ¤ Ö ¹F (6  y     C„VHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   Ş  öÑ ÔähFDHRF Î² â4±(‚³,ˆ„8lŠà,"!N3áKSdg…0tHdp‹B`_0D:EÆBDähÂˆÃ•®h‹¦GZ×4‘ALš09Q‡HĞ„¡%@ƒ0-,„=<Oä„$iÂäDé™c@dÓ!‚ÂÀC|Ô²XaÀc“V`/°P„=tÂAŠ&LNÄ9Ë‚HˆÓÀÈtl"(’EDOä„$qÎ² â4±MDOä„$qÎ² â4²IDOä„$qÎ² â4³Y9’@4ÄI1mŠdvÎ9IêH2+DÑXC1Ò›Ju‘£5#—‚«Ç²âë™C1Ò4ÛÊt‘£5#W'²ÜêµYPÒ!±9T3 ±9W:Eö³H ó,ÄêPÍ`[ÉADéTÄ` ÕâPRHDÎF@…8Tde%±,Hc€2XHôDD…8”‘£5ÆB˜_1Ò$#Ì³&ÒtÄ`&%	TÍÄ
òL/°P„±1ED3±ñÄÖÆTÍÄNÄ#›d ‚4È¤5c ‹$¡	“I–ñHO„L‹dDanŒ@EÑLìD<³U)’@4Äì4„d'ÓAD×LÈ„¥+Ú¢©Æ‘÷,€4‘öE C¤Sd>Œ0ÏB¬ÄC “á!Oä$©#Å–‡<‘“¤$›òDN’:Òl†TD 	%Mš09QêHÈ„8<Ò4Òh£	“ÙÁ!F,„y49q âP‘á<Ò!ÁÀàXé]…H®„4N9	!LˆÓXÅs‘#oDáDÄ,‹	1À<‘. F°H“ó|À² aSÌ,
Òš09‘ñHÀ<¡1B4Ñ"adK°8‚²QEADà<Î‚­D3Q‹=„-,‘3¡	“$ ”DhÂäDÀ akØ9!I% M«3â4Zc,„Õ9Oä$©#Å¬DcXp A¬Ã¼@TÓ–õĞÄê8ÌDum5OCw A°Ñ†€	!(œ³,ˆ„8ŒL‡&LN$Ùd@'„ x×œ³,ˆ„8ŒL‡&LN$YP$Ì³&ÒtÄ`k3Xc@cÓ!‚ÂÀC”%PQD4Ó‚}Î²81hÂäDFĞ	!(Ş5E ç,"!N#Ó±Eˆ Hæ²	TÍ”:2!N#6›3`éµ@`
ÎâP’&LNÛ‚óDD…8”¤	“ÉÆà<Q!%iÂäD³İ@ODTˆCI¬@4„8\F¡	TÍ´`iä„$ƒ&LN$—)’@4DHDNlEŠ$‘#›‘"	DC„DäÌö²Î49LISl0KàL“Ã”D1É³Î49LIÓlW‹$ÑF€ H†±HO„LDa	qMP"Òda‡ 0DÄ¦”dNC„DäÄ¶”dNC„DäÈÆ”dNC„DäÌÖDä¤„LˆÓ´ØCØØ! ³åPED3 C ±Ñ&v CD€l2Éä<+bSl3Éä<+b“l4Éä<+bÓl^JCXÀÛ—Ò0DÈğ Ãà]S°! ÀbCŠ$aR"X@óD@H’&LN›@óD@H’&LN$Û@óD@H’&LN4˜Ò0DÌ–1i±Z3°ÄÔ‘ALš09Q‡HĞ„í$1%b“U@ YZ4Ã"ÑÁBXËr‘£5#—‘H9^3!¦µaéµ"gt ¡5ÆB´@p[	u‘ã52a®ËŠ¯gN‰$‘c}ŠM‡“FN2›Æ!ÀàX±mÒ%Ç!ÀàX³$ÏJ4½µí)N4N9IlOC@Š4…4âpY‚#	DCœ£	“I%	TÍ¤	“‰Íì4„q)9š0!NcT$qRÌì4„dGHCX!9±!!a…DäÈÆÀ	!(!9œ³,ˆ„8ŒLÇ!‚"YÒVHDÎl“t ƒcqÎ² â4-öfóTÍÄ
DCˆÃe|ŠM‡“FN"›ZõD@HÒêLÀ„8Í†iÂ˜,Ï”ˆqL†DähÂˆÃu¢«©•°4ƒ/MÄe)ÓADÖ Œ8\Z–^+rvç<‘“¤4³BD‰@Bä<›3MÃ
A4fæÄ² FÈ —YpÂAŠwMÀ9Ë‚HˆÓÀÈtx×&· ÂlTQQmsĞ ÌFÙÖãH ó,„ÆĞ„O„4Sa#ĞAD×LÈ„èjj¥	DMÄÅ9N4 0’i)’@4Ä· †do˜@EÑLš09‘Ö ŒwMN‘) 2iÂäDf"DäxÍ„LX'²Üêµ a   ÷   P,      D(2+‚¢(‹Â(@   3±ÃLÄC¬Å0ñk1ÌD<ÄZ3±ÃLÄC¬Å0ñk1ÌD<ÄZ3±ÃLÄC¬Å0ñk1ÌD<ÄZ3±ÃLÄC¬Å0ñk1ÌD\ÄZ3±Ã`¤À`Ä“ Ac¼4Ø Œ ‚ hŒ7˜†ƒE0 dâ‚2Æ9ğÆ‚9˜ƒñ†€è€qAì@0±@¯!. Ec¼!Øƒ3oø€Æ‚>P
Ä±# Á`D@·!. ic¼! 8oJAÆS0
Ä±# Á`@à!. ÁoZ!ÆWØƒñ†àø€qAì@0!Á zˆBl0Æ[…ñ†àDa¼!À\ @\@;FôA0 â‚PŒñ†àVa¼! ‡UoÂÁ(Ä ƒ£ íÁoÌ(äc¼!H‡ZoÔAÆ‚uX
Ä±# Á`+@¥0ÆxĞ
¡ÂoæáÆz ‡ñ† ÄqAì@01Á Ğ+Œñ†@Æ‚A²0Æ‚~H‡ñ†ÀÖa¼!ø‡ @\@;FüB0 ”c¼! ‰v `/Œñ†à$æa¼!@‰zoRÂ(Ä ƒæ Ão\Â(dc¼!ˆ‰~od¢Æ‚™˜	
Ä±# Á`„<@í0Æœ 	
ÁÃovâ$Æ8‰ñ† 'T‚qAì@0‘Á Iâ‡1Ü g0ËÁ`„J Ì<DƒDb7AÌ2D0Ñg ³¥Ä Ø††Àf
#Œˆ‰µ €Y‚‡ZbPIh"ÃC³FÔÄ[ À,ÁC.1ˆ%Æpƒ¤Á,C¢ƒ8! 0KğĞLZ‰1Ü g0Ë°0Á`ÄNÔ Ì<4ƒbb7AÌ24N0áx ³Ï`„O” Ì<ä ƒp   "   †p\õŠÇd¹V¯ˆqLöp`öŠÇdºGV¯ˆqLæp\öŠÇdÂ LNdpÀ‘Ù+b“¥$€09‘8\µ©$€09‘8\¶ÕW]Åd¶V—D1Ùm€‘Õ%QLÖ`dvI“í—]Åd¼f—D1Yp€“Õ       a   -   F,      D( 3ÑÃLÄC´Å0ñm1ÌD<D[3ÑÃ`¡À`ÄÀ`„€À`Dp c¸!àÒ`–!2Æ` À,AAÄ c7ÁÌ2D@ÉŒ` ˜%(HÄ‚Ğ2LD@Î(! ’†	#ª  f	
ª@á@    –@T@D›j QQm«DD¶±İ       a   ê   s     D(@„$(‚R(2(„’(ˆb(r(Š²(Œb¡ÂPF…8Aà=†2¦ƒÀ	"/  3áÃLÄC¸Å0ñn1ÌD<„[ƒÄ5 DŒá† Â`–A‚Y9 ¿HgA‚Á$ QuƒI0 £‚ë,ğB0±@În°3˜eÒ  h7YÌ2i4†™ˆ æ¢¨‹D.š¸ˆì¢º‹/:ºbqAh5†	AH6Ä¡Ø&!n(‚4˜e0`0‚cƒ˜%@#¸4€Yd– ¨6Ä!Ú&! İ„tc˜„`¸¡Ò`–AY‚Áˆ2ˆƒ˜%`#Ê€`–€™%@qA,‚x‚ĞxˆBâ1LB0ÜPi0Ëà<Á`ÄüÁ Ì@ƒo°0K Í ©‡¸€ 6
AH=†	A¨=Ä!ö&!n(‚4˜e¦`0"La f	¨Áˆ<@…˜% f	Ğ€èC\@šaB²qA¨>†	A†Šàf¬+Œ…W€Yl0Bda f	°Y4 ı„ôc˜„€BD\@‘aB‚á†"HƒYm#VA`–€ŒX…[€Yn– ÈDÄ±_B@&2LB@)". ¡È0!ÁpC¤Á,ƒ÷ƒµ0K ƒµP0K ³h@0". ˆ¥C‚‘aBšqAHF†	A†Š fÄ`‚Áˆ_p‡˜% ƒÁˆ_`‡˜% ƒY4 pÃ;€Á,ƒœA@á0F
 ¸	rf	Î`– f	Ò€Æa7ôp³j •Ãnê!fÖ@:‡1ÌBpÀlğm nĞo@æ0ˆLÄ!u&!18 €,bÂş!0# ÁŒP“@ f	â€ÜašˆBğ0LB0bp  [ä„IœD`F ‚0!' ÌÄÙÃ 9„ğa˜„`Äà  ºp‰°x‰ÀŒ `0BO˜%ˆò‡A|". ‰Ä0!ÁˆÁ |aiq.0À`„¨0K³q0K       Ö@‘›o DŠl¿D)³¥(A„
{       a   ˜  &     D(2+‚)@‡4(@…(«¢(Œ(¨²(ÀÂªÀ€b*­Â)‚(D C	BA”G)GIÔ 3¡ÃLÄC¨Å0ñj1ÌD<„Z3¡ÃLÄC¨Å0ñj1ÌD<„Z3¡ÃLÄE¨Å0ñj1ÌD<„Z3¡ÃLÄC¨Å0ñj1ÌD<„Z3¡ÃLÄC¨Å0ñj1ÌD<„Z3¡ÃLÄC¨Å0ñj1ÌD<„ZƒX ac¼a<V!Œ‚ ñ„¨1Ş¼Œ7° ãA,Äâ‚Ø€`0"‚ ö„º1ŞàB)Œ7¹ã. â‚Ø€`0"‚ ú„Ì`Œ7áà
ã8ÀÂxC0ã@¸€ v Œˆƒ` ¨?Ä¡7ã:ÜÂxC°¹0Ş°ƒ.P . ˆ#ò  *qAÆxC0à0ŞĞ8Œ7õPˆbG ‚ÁˆP€\D\@
…1ŞğC:Œ7ıã?°â‚Ø€`0"‚ TãÁH€Ã`Dp0$1 ³ÅÂ ÃB€³Â<Dc¼LP"Œp…` ÈáÂn‚0˜eâ! XãAKäc¸!‡0˜e â! [ãALÄÄ¥@T`XÁ:èpCPa0ËE@¼0ÆœĞ
¡Ãn‚0˜e0â! pãAOˆƒÈaŒ7`ÑãAX„ÅxC bA¸€ v ŒP‡` hÆxCp,AÁ wãZÜÄxC°k1Ş°…NP . ˆ#æ! ª‡1ŞÄ…LP0ÆxC@a1ŞÔÅXŒ7vaˆbG ‚Á~€şaŒ7{Á‰1ŞøÅZŒ7Ñãh¸â‚Ø€`0¢$‚ ”ãAi¤ƒXbŒ7¨QãAjÔÅxC ªA¸€ v Œp‰` h&ÆxCğsAÁ ›ãlüÅxC01ŞĞ†hP . ˆ#n" "‹A<1†„ fxÈ,Ån3˜e@à! ´c¸AĞ`–!‡€ÔbYŒá!0ƒYb‹Ad1†„ fxÈ-¡Ån3˜e`à! »c¼!`ÔŒ† ¹ã{¸Ç¥@T XjèpC a0ËĞ€B@z1Æ‚úK¨€5°‚×Ğá† ?Â`–Áyâ‹A¢1Æ‚şPñ†À?Øc¼!øÿ @\@;‚X ¸À ƒ; ÉÆ ÖãÁ‰¤Ç`D0À,Ám²1bP €ÁpC°"a0Ë EµÆ Ùã‹ìÇxCğ"ı1ŞÀŒP . ˆA,\`€Á¶	€ÆcPoŒñ† Gôc0"`–ÀnÄ!¸„ÄcŒ7>2"*1Ş„I‰P0F “ä ‚Áñ€ÒcŒ7eR&8–QA`ÿ¡b¸!X“0˜eÖ  ùãA›´É¥@TP"XÁ‰èpC'a0Ë°S@ø1Æ:‘Áˆ N€ôcŒ7vb'8–Q‹àpC'a0Ë@¥A@ù1†‚19ƒY†*h?ÆpCp&h0Ë`e•Èo@eM(ÃAš˜Á,Ã•”"c¼! •7¡`7o‚³X‹Œñ† UÜd0"H“˜%ÈèDÆpC0'g0Ë y¥Ènèf6/ ã«ä	c¸!È3˜eà¼€ndŒ7²Ò'Œá†€OĞ`–¡óÒ‘1ŞØJFu2 ³ÕÈn@åf¾1èFÆpC@*h0Ë cP˜Œñ†€WN…‚1Ü˜ŠÌ2„ÁT&c¼! —U¡`7¬‚³b0¡ÉoÈEU#‚Q€Y‚1 1Ã¬œÁ,CA@e2†‚WAƒY†2@ƒ€ŞdŒ7êR+Œá†ÀVÌ`–áÌ  9ã»ä
c¸!¸4˜e84ÈNÆxC /¸2ÌÊ Ì Á,
‰B{2Æ{‰
†AÈOÆxC /à2@0$. ÊoüW(F! SãÈ„Ë`D0À,Ì¬¡ÊoH&^Æ‚’)™ñ†Àdè…qAÈUÆxC 2÷2Ş¬ÌÊŒ7,Ã2ˆbGª•1ŞÄŒ¿Œ72ã/ãÁÌ„â‚Ğ®Œñ†àfHf¼!À’or&g(Ä ÃN ³l ‘Ëo~†eÆ°›ñ† l^†qAH]ÆxCP623Ş˜ÙŒ7gs6ˆbGŠ—1Ş°MÎŒ7m“3ãÛğâ‚Ğ½Œñ†@n~f¼!˜›Ÿoè†n(Ä ÃN ³m İËnÆfÜàú—A"3Æ‚¾Q›ñ†Àoüf¼!ø›¶¡@\@;‚\`€Áˆ]
`–àHdÆpCà6g0Ë rÉŒá†àmĞ`–!ä  “ô2c¼!P»oVçnÆÖa
Ä±#ÁŒ0§@ f	ä€^f7zs³sPÅÌnüfè Â™A<3Æ‚Û!ñ† wpg¼!ÈÜ¡@\@;‚\`€Áˆz
`– ˆgÆpC:g0Ë€vÏŒá†`uĞ`–áò  °Ãê Á,äA@d3hmÆxC`>³3ŞœÏìŒ7èc;ˆbG‚0!R ÌäÁ,AĞÜŒñ†À}xçÇR *(¬ ut¸!Ÿ0˜eàƒ=H¤Ä`K@"%#X* )1ÁR ÌğÁ,AÌøÁ,ÁÌ¼•Î Ò# ´7ú³¡ 
¥Î Ô# ¬¬øÌˆÑ”¸€ DSâ‚éŒñ†@„Î‡‚A©3Æ‚J
ÆˆÁ 6”D0Q:Á PëŒñ† …RèÇR *¬`|ôB7/³£ÀÙÎob(†.p,¢‚ôÁ
ÖG‡‚
ƒY^ …€xgŒ78D?ƒA ùÎotH‡.p,¢øÁá† ‡Â`–¡t! ŞÃÁ	Á,ƒ)¨B@¾3†‚BƒY†SP…€ÒgŒ7dôBŒá† …Ì`–T! öãÍc¸!˜!4˜eHU~ÆxCÀF24´Ğ Ì¨©ÏnnèfVábŸ1ÜàÌ2°Â+t?c¼!£¢`7=d³­ğ
íÏoì(Œ(Ã¡Á,ƒ+¼B@ş3Æ=Ê¡Áˆ ‡`–àÆpC@Fg0Ë ´şŒá† Ğ`–!h! ã(­c¸!P#3˜eZ(…ÆxC@JoDÁnàffb¡1Ş ’Fg4 ³´@&4†::ƒY[¨…€Ph7s„³¶ÍĞo\)(Ã™Á,.ÜB@74ÆYê#
ÆpC°Gh0Ë€¹ñ†À–øh0"¸£˜%È…Y‚] ÷„~hŒ7ºTG#‚ñ†À—Hi0"€èK\@:£1ŞˆQ0ŒB@j4Æs*¥Áˆ`€Y‚]˜%àb£1Ş S-7é”Nã:áâ‚ñ†Àvi¼!x§woà	(Ä ”Gc¼!¨'qoìIœÆ‚{*'
Ä¡?ãÁ>¡ÓxCÀOè4ŞôS?Q . ˆA†œ fzaB¥1ŞŒ<7$ERãAIÍâ‚+ñ† ¥ìi¼!P)•oVj¥(Ä TKc¼!€©~obªŸÆ™)
Ä¡]ãMÔxCpS#5ŞàNQ . ˆA†œ f|aÒ¥1ÜœÌ2ü84NƒÌiŒ7aåRãX‰ÕxC0V1E¸€ v!¸À ƒÀ,8P9á†@¦Î`–!Æ! sÃÁL¡Á,ƒ8ŒC@ë4hÆxCàV;5Ş¼ÕN7pWˆbG‚0¡j ÌŒÉÓn|êfÈÁ¢§1ÜˆÌ2”ƒ9ÄOƒ@jŒ7{…Vã_ñÕxCĞW}E¸€ v!¸À ƒ¹À,9Ğ?á† ­Î`–!Î! ÃÁ[¡Á,:¨C@#5†·BƒY†tP‡€PjĞKñ†@µîj¼!X­»oXK¯(Ä `0ÂÜ˜%P‡Yw ›ãlÖ¥@TVX[épC`[a0ËĞì¹‰Áx€ÌMFÀ[  dnb0Ş˜%h‡Yw˜%x‡Yx˜%ˆ‡Yy ´¨#Ô*€Y‚€ÆjŒ7¾ÅZ8–QÁ]ax¥Ãx…Á,=”D@j5Æ‚ò‚-
Æˆ ôu^ ¼ú7qAl@@q5ÆöÊ­ñ† ½Úk¼!p/÷¢@\@;FøU0 ÔoƒTN\@_ñ†à¾Èk¼!À/üoòë¼(Ä ƒ¨ Íœ¸€ TZc¼! ±öoBì½Æ1
Ä±# Á`l@<'. ¹ÖoRÌ¾ÆÃ¯ñ†`Åò‹qAì@0[Á PÎ*;qAl@@¹5Æ±ñ† ÆBl¼!°1£@\@;FˆW0 DvƒàN\@yñ†àÇXl¼! 3oÂìÅ(Ä ƒìÀ`„|•Ù ÌÔÉ× ºÃB€³ö@Õ×o½4#Ş+ º¯Aù5†„ fîA$’¯1Ş¸™Q0†‚ƒY|‰€ìkŒ7r&g8–QA‰a,¦Ã…Á,ƒHäC@ı5Æ‚<Û1
¥Øn‚0˜eĞ‘HÄÆxCàgcFÁ ãA¨¹ÙxC j¢6ŞŒÚ¨Q . ˆ#F, b±1Ş Z›Q0èÅÆxC°jx6Ş°«7­¶gˆbG ‚Á€llŒ7²6gÊ±1ŞÔš¨7¶FjãÁ­İâ‚Ø€`0¢Æ‚ 0ã¯õƒÆlŒ7¿Æjã¸¹ÚxCn¯F¸€ v Œğ±` HÍÆxC`nªFÁ 6ãAºÙÚxC n¶6Ş¬ÛºQ . ˆ#Î, ¢³1ŞÀ­Q0èÎÆxC0oà6ŞĞ¸7õ6nˆbG ‚Á8€JmPá!@ƒY†}‰€NmPá!0ƒY~‰€RmPá!@ƒY†~‰€VmPŸá!0ƒY‰€ZmPŸá!@ƒY†‰€^mP¨á!0ƒY‰€rmP®šµ1Ş¸œ¹Q0ÈÖÆxCsüFÁ°@İ@0bp €Ø%H®ñ† æFîÇR *87Œ˜%‰Y‘˜%	2·aÊ`0İ‚˜%¨‡Y‚’ pãÏå#ƒp  8   ¶ ¶4„¥5ÆBÔÆP\%QLf`%QL-!MæP`%QLPd%QLæ `%QL-!M¸a$YISKH“Q$WISKH“u,×ŠÇÔÒtÛwÀ‚­ˆqL-!M¹…,ÙŠÇÔÒ´x€’•D1µ„4é¦€4„¥5ÆBw€r•D1µ„4ÙÖ`\+b“=ØŠÇdÑF¶"Æ1™t@“Ùt@“µ„4Yv€’­ˆqL-!MV \+bSKH“](ØŠÇÔÒd© LN$     a      M,      D(2+@ü    3ÑÃLÄC´Å0ñm1ÌD<D[3ÑÃ`DÁÀ`±À`Ä À`„ Ñ…¸€ Tâ‚]ˆ2b` €C0@Ì ¾Ä‚`04 hhˆbÁ ‚0A 5ˆ4Ä±` ÁŒ@@ H5Änêàf& Õd¸!Àƒ3˜e˜€`C\@á†€Ò`–a`ŠqA†‚3HƒY‚	hÆˆ ²ĞmˆB¸!. å†¸€ ôc¼!8…8oPaÆ‚T 
Ä18 À–ä#â  Šƒ1ÜäÌ2K@t07FÂFèF0 ”â‚zˆBâ!. ùÁ0! Çov¡Æ^8…ñ† PqAF P‡f9‚ÁˆR€Ja7­ ³FĞ*’qAl@@ı!. ù‡¸€ Dc¼!`[oÚÆwÈ
Ä18 `–ä#l! ²…1ÜøBÌ2H@"". È`D0K€Ì($"â‚FøG0 ³Ê,Á2KÀĞŒ0# ĞŒ0!# ˆŒ01# `8 	   –Ä¦È¶ÌÆ  „	HŠÑ(A„
{       a   {   M,      D(Ä  3ÑÃLÄC´Å0ñm1ÌD<D[3ÑÃ`D±À`¡À`ÄÀ`„€ Í…¸€ Dâ‚P]ˆ2b` @C0@Ì ½Ä‚`0â/ hĞ_ˆbÁ ‚01 5h4Ä±` ÁŒ8@ (5Änèàf& Õd¸!¸ƒ3˜e˜€^C\@á†€Ò`–a`‚qA†‚3HƒY‚	hÆˆ ±mˆB·!. á†¸€ # ÀB1ƒk ­Ánä fŠ% 7£a#f# qAh<Ä¡İ„ğ`˜€`ÄÀ  _8Š`0"‚ <Ã(€Á,ƒ‘ôƒÊC\@|ˆBñ!. Èˆ éPÁ`)@¤0†‚UƒY†	è=ÄŒP` f	Y…ŞC\@Áˆõ`–@™%Xf	bq#ü# bq#ş# zq#@$ 	   –Ä¦È¶ÌÆ  „	HŠÍ(A„
{       a   e   M,      D(Š(‹‚~(Œ²©’(ˆ*@R CÔ     3¡‘…¸€ Ã€Á,C°dâ‚Ğ^ˆbC‚Áˆ$ JÆpCğœÁ,ƒ04c¼!X‚Av1Æ7Ø(p  ½ãtŒƒ ö !: ¾ãA|À ƒC0 Äâ‚Œ 
bĞíA0K 7†‚08ƒY¢È4ÆxCàm@Á ÔãA(¸Ã‚7 µÆoJ(# ¸B§@°1ÆT
†s ‚Áˆ! zqAF˜…:€Wf	zƒ1ÜøÌ2G@´!. ÈˆÁQ ¸u0Á,B·!. ÈˆÁQ »P´`Á,2KÌ(ƒ¹Q0KÀĞoŒñ†àö€‚q È7Ä18
@Fá†`–€!óã/°Â¥@T0
:1€á@   v@À²      a     R,      D(2+‚(ƒ¢(‹Â()  3±ÃL-k1ÌD<ÄZ3±ÃLÄC¬Å0ñk1ÌD<ÄZ3±ÃLÄC¬Å0ñk1ÌDÀ±ÃLÄE¬Å0ñk1ÌD<ÄZ3±ÃLÄC¬Å0ñk1ÌD<ÄZƒÑ7 ƒ7 $ƒ¤1ŞÈP . ˆ™ÆŒ`<!Ğ.pì`D Ec<!8ƒÁˆ) Ä!oŒ7~°ˆbE ‚Á0€´1ÀÁ` 	â‚ĞŒñ†àè€qA¬@0Á ĞŒñ„ #Ê  Ä!8ã,ìâ‚X€`0‚ 6ã	(F¸A0 $ˆBy0Æ‚\ 
Ä±" Á`@u0Æ‚UŒ¸ƒ` H„DaŒ7â°
ˆbE ‚ÁP€ü`Œ'´0
Á  . ­ÂoÖ(ÄŠ ƒ¨À`„+¼Ã Ìä
ƒşc7Ì2P@±0ÆVd‚ÁˆU€faP-Œá!ƒY†Á	ÈÆxC€ã@ÁnÈ!f' Yã?ƒjaŒ7ÿ°ãH€ÄxC!A¸€ v ŒØ…` ˆÆxC`î@Á _ãAJÔÃxC *1Ş¬>P . ˆ#È! 2‡1ŞÀÄ=P0(ÆxC0ÿ0ŞĞDHŒ75QˆbG ‚Áˆv€àaŒ7:š‡1ŞôDJŒ7>±ãÁO°â‚Ø€`0Â‚ }ãY¨ƒúaŒ7g1ãZÌÄxCiA¸€ v Œø‡` ˆ$ÆxCà4AÁ “ãA\ôÄxC =1ŞÌXP . ˆ#P" ª‰A-1†„ fŠ& ›c¸AÌ`–ÁhÊ‰A11†„ f& Tc¸AÌ`–iê‰A51†„ f’& Ÿ”c¸AÌ`–AiR‹1Ş¨Æ[P . ÈpCĞa0Ë°0¹Å ·c¼!ˆ» @\@ƒ ÄÃ(¿˜%`h.Æ`Ä] 0KÍ8³ÑÅ°`4@0aÁ Ìƒy 0KQ^€Â   &   – &\%QL-!M¦P\%QL–P×æPd%QLÆP`%QLfd%QL-!MF`%QL-!MàHO„LÄæPÍ€4†í×ŠÇd½¶"Æ1Ùo€‘­ˆqL ÂäD-!MV `+bSKH“(ÙŠÇÔÒdÃÊµ"Æ1µ„4™j “‰Ã     a   y   J,      D("    3ñÃLÄC¼Å0ño1ÌD<Ä[3ñÃLÄC¼Å0ño1ÌD<Ä[3ñÃLÄC¼Å0‘H0D0q@0a<0Q80A4@Æ c1F ˆƒA†‚3ƒY†@# f	r1Ã„ #„¸APEƒM0 $‚†	F˜ƒ ‚Œ#¢` ÈDŒ€AFTÁ Ğ5èt Ja‚á†`Â`–a ‚Áˆ1( ˜%HèÔŒ 
Ah@4ƒÂ`˜€`Ä€0€S*h¢3TÃ„ #„°BPĞˆ ¶°ÁpCÀ
a0ËPÁ`Ø Ì$4ƒÜ`˜€`Ä€0€Y*È¢;$Ã„ #„àBPíÁ ;& 1  ‚
FF 8‡Å†‚^ƒY†	#Já `– Œ(_ €Y‚„Jd     †€ [n TD„lºP`³±Î2Ä–Ä¦È¶ÌÖ@8Ë ›k á,Ã     a     R,      D("(ƒ(B(2    3±ÃL-k1ÌD<ÄZ3±ÃLÄC¬Å0ñk1ÌD<ÄZ3±ÃLÄC¬Å0ñk1ÌDÀ±ÃL-k1ÌD<ÄZ3±ÃLÄC¬Å0ñk1ÌD<ÄZ3±Ã`D´À`¤ ¹Å iŒ7nàˆb&‚ñ#O¶;@ÑOÆ`0b
€qAÈãœâ‚X€`0‚ mŒ'l0Á@‚¸€ tc¼!8 @\@+F A0 4c<!¨ƒÁˆ2€qAÆxCÀ
x@¸€ V Œ€ƒ` ˆÆxBàƒn 	â‚PŒñ† BqA¬@0Á PŒñ„à#î  Ä!Qã/¤â‚X€`0‚ ?ã	,F€B0 $ˆB«0Æ‚s
Ä±" Á`*0á
ë0 ³¹Ânff( XãïáÁ`„*@²0ˆÆpƒ„Á,ÃàÔ
c¼!˜‡y @\@á† Â`–pš…1”Ã`D-@‚¸€ dc¼!à‡t @\@+FèB0 Äc<!p‡Á_€qAèÆxCPò@¸€ V Œ‡` ¨ÆxBpƒç 	â‚:Œñ†À%ôqA¬@0¡Á ;Œñ„ $#à! Ä¡xãÁMŒâ‚X€`0B‚ {ã	AJFäC0 $ˆBú0Æ°X	
Ä±" Á`„>@ 1Æ™Œ‰` H„FbŒ7iAˆbE ‚Á‘€^bJŒá!@ƒY†¢	H&©Än4˜e0˜€hbKŒá!0ƒY†ƒ	È&¹Än4˜e@˜€pbLŒá!0ƒY†„	H'ÉÄn4˜eP˜€xbMŒá!0ƒY†…	¨,Æ`DZ 0KÍ4³Î,ÁCf1,ˆF E0 ³Á`ÄZ¼ ÌD´ ƒp  &   æ\%QL-!MfP\%QL–P×¦Pd%QL†P`%QL&d%QL-!M¦€×âpYm@€o€#=2›C5ÒÖ×-!M`%QL-!Mv`\+b“åØŠÇd»F¶"Æ1Ùo€r­ˆqL-!M `+bSKH“(ÙŠÇÔÒ         /** @file debug.c
	@brief
	This file contains the main game debug window routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "debug.h"

#ifdef GAMEMOD
#include "debug.scene.h"
#include "debug.grid.h"
#include "scene.h"
#include "sdlengine.h"
#include "menu.h"
#include "interface.h"
#include "text.h"
#include "lbaengine.h"
#include "screens.h"
#include "redraw.h"

enum ButtonType {
	NO_ACTION,
	FREE_CAMERA,
	CHANGE_SCENE,
	SHOW_CELLING_GRID,
	SHOW_ZONES,
	SHOW_ZONE_CUBE,
	SHOW_ZONE_CAMERA,
	SHOW_ZONE_SCENARIC,
	SHOW_ZONE_CELLINGGRID,
	SHOW_ZONE_OBJECT,
	SHOW_ZONE_TEXT,
	SHOW_ZONE_LADDER
};

enum WindowType {
	NO_MENU,
	FREE_CAMERA_INFO_MENU,
	CHANGE_SCENE_INFO_MENU,
	ZONES_MENU
};

typedef struct DebugButtonStruct {
	int32 left;
	int32 top;
	int32 right;
	int32 bottom;
	int8  *text;
	int32 textLeft;
	int32 textTop;
	int32 isActive;
	int32 color;
	int32 activeColor;
	int32 submenu;
	int32 type;
} DebugButtonStruct;

typedef struct DebugWindowStruct {
	int32 left;
	int32 top;
	int32 right;
	int32 bottom;
	int32 alpha;
	int32 isActive;
	int32 numLines;
	int8  *text[20];
	int32 numButtons;
	DebugButtonStruct debugButtons[50];
} DebugWindowStruct;

DebugWindowStruct debugWindows[10];
int32 numDebugWindows = 0;


void debugFillButton(int32 X, int32 Y, int32 width, int32 height, int8 color) {
	int32 i, j;
	uint8 *ptr;
	int32 offset;

	ptr = frontVideoBuffer + screenLookupTable[Y] + X;
	offset = 640 - (width);

	for (i = 0; i < height; i++) {
		for (j = 0; j < width; j++) {
			*(ptr++) = color;
		}
		ptr += offset;
	}
}

void debugDrawButton(int32 left, int32 top, int32 right, int32 bottom, int8 *text, int32 textLeft, int32 textRight, int32 isActive, int8 color) {
	debugFillButton(left + 1, top + 1, right - left - 1, bottom - top - 1, color);
	drawBox(left, top, right, bottom);
	ttfDrawText(textLeft, textRight, text, 0);
	copyBlockPhys(left, top, right, bottom);
}

void debugDrawWindowBox(int32 left, int32 top, int32 right, int32 bottom, int32 alpha) {
	drawTransparentBox(left, top, right, bottom, alpha);
	drawBox(left, top, right, bottom);
	//copyBlockPhys(left,top,right,bottom);
}

void debugDrawWindowButtons(int32 w) {
	int32 b;

	for (b = 0; b < debugWindows[w].numButtons; b++) {
		int32 left = debugWindows[w].debugButtons[b].left;
		int32 top = debugWindows[w].debugButtons[b].top;
		int32 right = debugWindows[w].debugButtons[b].right;
		int32 bottom = debugWindows[w].debugButtons[b].bottom;
		int8  *text = debugWindows[w].debugButtons[b].text;
		int32 textLeft = debugWindows[w].debugButtons[b].textLeft;
		int32 textTop = debugWindows[w].debugButtons[b].textTop;
		int32 isActive = debugWindows[w].debugButtons[b].isActive;
		int8  color = debugWindows[w].debugButtons[b].color;
		if (isActive > 0)
			color = debugWindows[w].debugButtons[b].activeColor;

		debugDrawButton(left, top, right, bottom, text, textLeft, textTop, isActive, color);
	}
}

void debugDrawWindow(int32 w) {
	int32 left = debugWindows[w].left;
	int32 top = debugWindows[w].top;
	int32 right = debugWindows[w].right;
	int32 bottom = debugWindows[w].bottom;
	int32 alpha = debugWindows[w].alpha;

	debugDrawWindowBox(left, top, right, bottom, alpha);

	if (debugWindows[w].numLines > 0) {
		int32 l;

		for (l = 0; l < debugWindows[w].numLines; l++) {
			ttfDrawText(left + 10, top + l*20 + 5, debugWindows[w].text[l], 0);
		}
	}

	copyBlockPhys(left, top, right, bottom);

	debugDrawWindowButtons(w);
}

int32 debugTypeUseMenu(int32 type) {
	int32 w, b;

	for (w = 0; w < numDebugWindows; w++) {
		if (debugWindows[w].isActive > 0) {
			for (b = 0; b < debugWindows[w].numButtons; b++) {
				if (debugWindows[w].debugButtons[b].type == type) {
					int submenu = debugWindows[w].debugButtons[b].submenu;
					if (submenu > 0)
						debugWindows[submenu].isActive = !debugWindows[submenu].isActive;
					return submenu;
				}
			}
		}
	}
	return 0;
}

void debugResetButtonsState() {
	int w, b;
	for (w = 0; w < numDebugWindows; w++) {
		if (debugWindows[w].isActive > 0) {
			for (b = 0; b < debugWindows[w].numButtons; b++) {
				if (debugWindows[w].debugButtons[b].type <= -1)
					debugWindows[w].debugButtons[b].isActive = 0;
			}
		}
	}
}

void debugRefreshButtons(int32 type) {
	int32 w, b;

	for (w = 0; w < numDebugWindows; w++) {
		if (debugWindows[w].isActive > 0) {
			for (b = 0; b < debugWindows[w].numButtons; b++) {
				if (debugWindows[w].debugButtons[b].type == type) {
					int32 left = debugWindows[w].debugButtons[b].left;
					int32 top = debugWindows[w].debugButtons[b].top;
					int32 right = debugWindows[w].debugButtons[b].right;
					int32 bottom = debugWindows[w].debugButtons[b].bottom;
					int8  *text = debugWindows[w].debugButtons[b].text;
					int32 textLeft = debugWindows[w].debugButtons[b].textLeft;
					int32 textTop = debugWindows[w].debugButtons[b].textTop;
					int8  color = debugWindows[w].debugButtons[b].color;
					int32 isActive = debugWindows[w].debugButtons[b].isActive = !debugWindows[w].debugButtons[b].isActive;

					if (isActive > 0)
						color = debugWindows[w].debugButtons[b].activeColor;

					debugDrawButton(left, top, right, bottom, text, textLeft, textTop, isActive, color);

					if (debugWindows[w].debugButtons[b].submenu && isActive > 0)
						debugDrawWindow(debugWindows[w].debugButtons[b].submenu);
				}
			}
		}
	}
}

void debugDrawWindows() {
	int32 w;

	for (w = 0; w < numDebugWindows; w++) {
		if (debugWindows[w].isActive > 0) {
			debugDrawWindow(w);
		}
	}
}

void debugResetButton(int32 type) {
	int32 w, b;

	for (w = 0; w < numDebugWindows; w++) {
		if (debugWindows[w].isActive > 0) {
			for (b = 0; b < debugWindows[w].numButtons; b++) {
				if (debugWindows[w].debugButtons[b].type == type) {
					int submenu = debugWindows[w].debugButtons[b].submenu;
					debugWindows[w].debugButtons[b].isActive = 0;
					if (submenu > 0) {
						debugWindows[submenu].debugButtons[b].isActive = !debugWindows[submenu].debugButtons[b].isActive;
					}

					return;
				}
			}
		}
	}
}

void debugRedrawScreen() {
	redrawEngineActions(1);
	copyScreen(frontVideoBuffer, workVideoBuffer);
	debugDrawWindows();
}

int32 debugGetActionsState(int32 type) {
	int32 state = 0;

	switch (type) {
	case FREE_CAMERA:
		state = useFreeCamera;
		break;
	case CHANGE_SCENE:
		state = canChangeScenes;
		break;
	case SHOW_ZONES:
		state = showingZones;
		break;
	case SHOW_ZONE_CUBE:
	case SHOW_ZONE_CAMERA:
	case SHOW_ZONE_SCENARIC:
	case SHOW_ZONE_CELLINGGRID:
	case SHOW_ZONE_OBJECT:
	case SHOW_ZONE_TEXT:
	case SHOW_ZONE_LADDER:
		state = typeZones;
		break;
	default:
		break;
	}
	return state;
}

void debugSetActions(int32 type) {
	switch (type) {
	case FREE_CAMERA:
		useFreeCamera = !useFreeCamera;
		break;

	case CHANGE_SCENE:
		canChangeScenes = !canChangeScenes;
		break;

	case SHOW_ZONES:
		showingZones = !showingZones;
		debugResetButton(-1);
		debugResetButton(-2);
		debugRedrawScreen();
		break;
	case SHOW_ZONE_CUBE:
		if (showingZones) {
			if (typeZones & 0x01)
				typeZones &= ~0x01;
			else
				typeZones |= 0x01;
			debugRedrawScreen();
		}
		break;
	case SHOW_ZONE_CAMERA:
		if (showingZones) {
			if (typeZones & 0x02)
				typeZones &= ~0x02;
			else
				typeZones |= 0x02;
			debugRedrawScreen();
		}
		break;
	case SHOW_ZONE_SCENARIC:
		if (showingZones) {
			if (typeZones & 0x04)
				typeZones &= ~0x04;
			else
				typeZones |= 0x04;
			debugRedrawScreen();
		}
		break;
	case SHOW_ZONE_CELLINGGRID:
		if (showingZones) {
			if (typeZones & 0x08)
				typeZones &= ~0x08;
			else
				typeZones |= 0x08;
			debugRedrawScreen();
			debugRedrawScreen();
		}
		break;
	case SHOW_ZONE_OBJECT:
		if (showingZones) {
			if (typeZones & 0x10)
				typeZones &= ~0x10;
			else
				typeZones |= 0x10;
			debugRedrawScreen();
			debugRedrawScreen();
		}
		break;
	case SHOW_ZONE_TEXT:
		if (showingZones) {
			if (typeZones & 0x20)
				typeZones &= ~0x20;
			else
				typeZones |= 0x20;
			debugRedrawScreen();
		}
		break;
	case SHOW_ZONE_LADDER:
		if (showingZones) {
			if (typeZones & 0x40)
				typeZones &= ~0x40;
			else
				typeZones |= 0x40;
			debugRedrawScreen();
		}
		break;


	case -1:
		debugResetButton(-2);
		debugRedrawScreen();
		break;
	case -2:
		debugResetButton(-1);
		debugRedrawScreen();
		break;
	default:
		break;
	}
}

void debugAddButton(int32 window, int32 left, int32 top, int32 right, int32 bottom, int8 *text, int32 textLeft, int32 textTop, int32 isActive, int32 color, int32 activeColor, int32 submenu, int32 type) {
	int32 button = debugWindows[window].numButtons;
	debugWindows[window].debugButtons[button].left = left;
	debugWindows[window].debugButtons[button].top = top;
	debugWindows[window].debugButtons[button].right = right;
	debugWindows[window].debugButtons[button].bottom = bottom;
	debugWindows[window].debugButtons[button].text = text;
	debugWindows[window].debugButtons[button].textLeft = textLeft;
	debugWindows[window].debugButtons[button].textTop = textTop;
	debugWindows[window].debugButtons[button].isActive = debugGetActionsState(type);
	debugWindows[window].debugButtons[button].color = color;
	debugWindows[window].debugButtons[button].activeColor = activeColor;
	debugWindows[window].debugButtons[button].submenu = submenu;
	debugWindows[window].debugButtons[button].type = type;
	debugWindows[window].numButtons++;
}

void debugAddWindowText(int32 window, int8 *text) {
	int32 line = debugWindows[window].numLines;
	debugWindows[window].text[line] = text;
	debugWindows[window].numLines++;
}

void debugAddWindow(int32 left, int32 top, int32 right, int32 bottom, int32 alpha, int32 isActive) {
	debugWindows[numDebugWindows].left = left;
	debugWindows[numDebugWindows].top = top;
	debugWindows[numDebugWindows].right = right;
	debugWindows[numDebugWindows].bottom = bottom;
	debugWindows[numDebugWindows].alpha = alpha;
	debugWindows[numDebugWindows].numButtons = 0;
	debugWindows[numDebugWindows].isActive = isActive;
	numDebugWindows++;
}

void debugLeftMenu() {
	// left menu window
	debugAddWindow(5, 60, 200, 474, 4, 1);
	debugAddButton(0, 5, 55, 160, 75, (int8*) "Use free camera", 30, 60, 0, 87, 119, NO_MENU, FREE_CAMERA);
	debugAddButton(0, 161, 55, 200, 75, (int8*) "info", 171, 60, 0, 87, 119, FREE_CAMERA_INFO_MENU, -1);
	debugAddButton(0, 5, 76, 160, 96, (int8*) "Change scenes", 30, 81, 0, 87, 119, NO_MENU, CHANGE_SCENE);
	debugAddButton(0, 161, 76, 200, 96, (int8*) "info", 171, 81, 0, 87, 119, CHANGE_SCENE_INFO_MENU, -2);
	debugAddButton(0, 5, 97, 200, 117, (int8*) "Show celling grids", 30, 102, 0, 87, 119, NO_MENU, 3);
	debugAddButton(0, 5, 118, 200, 138, (int8*) "Show zones", 30, 123, 0, 87, 119, ZONES_MENU, SHOW_ZONES);

	// add submenu windows
	//   - free camera window
	debugAddWindow(205, 55, 634, 160, 4, 0);
	debugAddWindowText(FREE_CAMERA_INFO_MENU, (int8*) "When enable, use the following keys to browse through the scenes:");
	debugAddWindowText(FREE_CAMERA_INFO_MENU, (int8*) "           - S to go North");
	debugAddWindowText(FREE_CAMERA_INFO_MENU, (int8*) "           - X to go South");
	debugAddWindowText(FREE_CAMERA_INFO_MENU, (int8*) "           - Z to go West");
	debugAddWindowText(FREE_CAMERA_INFO_MENU, (int8*) "           - C to go East");

	//   - change scene window
	debugAddWindow(205, 55, 634, 137, 4, 0);
	debugAddWindowText(CHANGE_SCENE_INFO_MENU, (int8*) "When enable, use the following keys to change to another scene:");
	debugAddWindowText(CHANGE_SCENE_INFO_MENU, (int8*) "           - R to go Next Scene");
	debugAddWindowText(CHANGE_SCENE_INFO_MENU, (int8*) "           - F to go Previous Scene");

	//   - zones window
	debugAddWindow(205, 55, 634, 97, 4, 0);
	debugAddWindowText(ZONES_MENU, (int8*) "You can enable or disable each zone type:");
	debugAddButton(ZONES_MENU, 205, 118, 350, 138, (int8*) "Cube Zones", 215, 123, 1, 87, 119, 0, SHOW_ZONE_CUBE);
	debugAddButton(ZONES_MENU, 205, 139, 350, 159, (int8*) "Camera Zones", 215, 144, 2, 87, 119, 0, SHOW_ZONE_CAMERA);
	debugAddButton(ZONES_MENU, 205, 160, 350, 180, (int8*) "Scenaric Zones", 215, 165, 3, 87, 119, 0, SHOW_ZONE_SCENARIC);
	debugAddButton(ZONES_MENU, 205, 181, 350, 201, (int8*) "Celling Grid Zones", 215, 186, 4, 87, 119, 0, SHOW_ZONE_CELLINGGRID);
	debugAddButton(ZONES_MENU, 205, 202, 350, 222, (int8*) "Object Zones", 215, 207, 5, 87, 119, 0, SHOW_ZONE_OBJECT);
	debugAddButton(ZONES_MENU, 205, 223, 350, 243, (int8*) "Text Zones", 215, 228, 6, 87, 119, 0, SHOW_ZONE_TEXT);
	debugAddButton(ZONES_MENU, 205, 244, 350, 264, (int8*) "Ladder Zones", 215, 249, 7, 87, 119, 0, SHOW_ZONE_LADDER);
}

int32 debugProcessButton(int32 X, int32 Y) {
	int32 i;
	int32 j;

	for (i = 0; i < numDebugWindows; i++) {
		for (j = 0; j < debugWindows[i].numButtons; j++) {
			if (X > (debugWindows[i].debugButtons[j].left)
			        && X < (debugWindows[i].debugButtons[j].right)
			        && Y > (debugWindows[i].debugButtons[j].top)
			        && Y < (debugWindows[i].debugButtons[j].bottom)) {
				return (debugWindows[i].debugButtons[j].type);
			}
		}
	}

	return 0;
}

void debugPlasmaWindow(int8 *text, int32 color) {
	int32 textSize;
	processPlasmaEffect(5, color);
	if (!(rand() % 5)) {
		plasmaEffectPtr[rand() % 320 * 10 + 6400] = 255;
	}
	textSize = getTextSize(text);
	drawText((SCREEN_WIDTH / 2) - (textSize / 2), 10, text);
	drawBox(5, 5, 634, 50);
	copyBlockPhys(5, 5, 634, 50);
}

void debugProcessWindow() {
	if (rightMouse) {
		int32 quit = 0;
		int8* text = (int8*) "Game Debug Window";
		int32 color = 64;
		int32 colorIdx = 4;
		int32 count = 0;
		MouseStatusStruct mouseData;
		rightMouse = 0;
		leftMouse = 0;

		copyScreen(frontVideoBuffer, workVideoBuffer);

		debugResetButtonsState();
		if (numDebugWindows == 0)
			debugLeftMenu();
		debugDrawWindows();

		do {
			readKeys();
			getMousePositions(&mouseData);

			if (mouseData.left) {
				int type = 0;
				if ((type = debugProcessButton(mouseData.X, mouseData.Y)) != NO_ACTION) { // process menu item
					if (debugTypeUseMenu(type)) {
						copyScreen(workVideoBuffer, frontVideoBuffer);
						copyBlockPhys(205, 55, 634, 474);
					}

					debugRefreshButtons(type);
					debugSetActions(type);
				}
				mouseData.left = 0;
			}

			// draw window plasma effect
			if (count == 256) {
				colorIdx++;
				count = 0;
			}
			color = colorIdx * 16;
			if (color >= 240) {
				color = 64;
				colorIdx = 4;
			}
			debugPlasmaWindow(text, color);

			// quit
			if (mouseData.right)
				quit = 1;

			fpsCycles(25); // rest

			count++;
		} while (!quit);
		reqBgRedraw = 1;
	}
}

void processDebug(int16 pKey) {
	debugProcessWindow();

	changeGrid(pKey);
	changeGridCamera(pKey);
	if (needChangeScene == 0);
	applyCellingGrid(pKey);
}

#endif

/** @file debug.grid.c
	@brief
	This file contains grid debug routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "debug.grid.h"
#include "grid.h"
#include "lbaengine.h"
#include "scene.h"
#include "main.h"
#include "redraw.h"

int32 useFreeCamera = 0;
#ifdef _DEBUG
int32 canChangeScenes = 1;
#else
int32 canChangeScenes = 0;
#endif

/** Change scenario camera positions */
void changeGridCamera(int16 pKey) {
	if (useFreeCamera) {
		// Press up - more X positions
		if (pKey == 0x2E) {
			newCameraZ--;
			reqBgRedraw = 1;
		}

		// Press down - less X positions
		if (pKey == 0x2C) {
			newCameraZ++;
			reqBgRedraw = 1;
		}

		// Press left - less Z positions
		if (pKey == 0x1F) {
			newCameraX--;
			reqBgRedraw = 1;
		}

		// Press right - more Z positions
		if (pKey == 0x2D) {
			newCameraX++;
			reqBgRedraw = 1;
		}
	}
}

/** Change grid index */
void changeGrid(int16 pKey) {
	if (canChangeScenes) {
		// Press up - more X positions
		if (pKey == 0x13) {
			currentSceneIdx++;
			if (currentSceneIdx > NUM_SCENES)
				currentSceneIdx = 0;
			needChangeScene = currentSceneIdx;
			reqBgRedraw = 1;
		}

		// Press down - less X positions
		if (pKey == 0x21) {
			currentSceneIdx--;
			if (currentSceneIdx < 0)
				currentSceneIdx = NUM_SCENES;
			needChangeScene = currentSceneIdx;
			reqBgRedraw = 1;
		}

		if (cfgfile.Debug && (pKey == 'f' || pKey == 'r'))
			printf("\nGrid index changed: %d\n", needChangeScene);
	}
}

/** Apply and change disappear celling grid */
void applyCellingGrid(int16 pKey) {
	// Increase celling grid index
	if (pKey == 0x22) {
		cellingGridIdx++;
		if (cellingGridIdx > 133)
			cellingGridIdx = 133;
	}
	// Decrease celling grid index
	if (pKey == 0x30) {
		cellingGridIdx--;
		if (cellingGridIdx < 0)
			cellingGridIdx = 0;
	}

	// Enable/disable celling grid
	if (pKey == 0x14 && useCellingGrid == -1) {
		useCellingGrid = 1;
		//createGridMap();
		initCellingGrid(cellingGridIdx);
		if (cfgfile.Debug && pKey == 0x14)
			printf("\nEnable Celling Grid index: %d\n", cellingGridIdx);
		needChangeScene = -2; // tricky to make the fade
	} else if (pKey == 0x14 && useCellingGrid == 1) {
		useCellingGrid = -1;
		createGridMap();
		reqBgRedraw = 1;
		if (cfgfile.Debug && pKey == 0x14)
			printf("\nDisable Celling Grid index: %d\n", cellingGridIdx);
		needChangeScene = -2; // tricky to make the fade
	}
}

/** @file debug.grid.h
	@brief
	This file contains grid debug routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef GRIDDEBUG_H
#define GRIDDEBUG_H

#include "sys.h"

extern int32 useFreeCamera;
extern int32 canChangeScenes;

/** Change scenario camera positions */
void changeGridCamera(int16 pKey);
/** Change grid index */
void changeGrid(int16 pKey);
/** Apply and change disappear celling grid */
void applyCellingGrid(int16 pKey);

#endif
BCÀŞ!  s  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  ™   ˆ  °³!üÿÿÿÿ H;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å lˆáÿÿÿÿ‚Êaæ¡àAÊaÒaÊ¡ÌÚ!È0‡p`‡y(€p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th€ä¡ÊÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú¡ÜáÜ¡Ø¡ÂÁ ÂŞ¡ÒÁÌaÚÀà¡Ú!è sv˜‡r wx‡6p‡pp‡yhs€‡6h‡p t Ì!ØaÊ æÂaÖ¡àAŞÊaèáä¡Ä¡ÌÁÊAÚ`ÒAÊÀ€¨w˜‡p0‡rhs€‡6h‡p t Ì!ØaÊ êaÊ¡æáÌÚÀØáÂ sv˜‡r   I     „@˜  ‰   r   2"È	 d…“#¤„“#ã„¡LŒ„äL„Â` "Á’
„ \$M%L>ç4b|ÈB ¯P   €                    2ƒ@‰!Ğ"CÔ =9àA‘D Ğ$	TIè ]Î’¦ˆ&_&'2Š`§ˆ&D eR€p˜4E”0ùìLˆğ-€!±SD	
6—ISD	“ßaÀ Â· †ÄN%L(Øœ#M%Lşü¦ÒLH‘¦ˆ&~7çBƒÇã9Mš"J˜|­A˜aˆ¨&€"J˜ğ œ$M%L¾&LNÄN%LÈ8    <                    €             À'J²‰(D¤‹¤)¢„Ég¢!Ri&4‚[¤)¢„É§A„@ œB5ˆÓø@ã4(8]$M%Lşì4;E”0¡Âd I–"U"˜ˆ•Pr&M%L>ZÑ`%"MìQÂ„@ © £Ø@f¢Uğ [  ÂÕ`Fº€9‚`
 3ú   °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD òf `òç@Pòg pò' v(JÀI  @ p (ú€îP˜ ’  € Ø¡8?$  À@>àäÎ@>àäNÈ?à”€NJHàäÎ@>àäÎÇ>`èÊ> èÊ> èJÈ?à„üNÈ?à„üNÈ?àèÊ> èÊ> èJ‹H äÎ> èÊ> èÊ> èÊ@>àäÎ> èJÈ?à„üNÈ?àÄŒNIàäÎ@>àäÎ@>àäÎ> äÎ@>à„üNÈ?àäÎ@>àäÎ@>à´ˆJ‹H ´ˆÊ> èÊ> èÊ> èÊ> èÊ> èÊ> èÊ> èÊ> äÎQIà,™Î> èÊ> èÊ> äÎÕI äÎJ èÊ> |¥FÈ?àäÎ@>àäÎ@>àèÊ@>àäÎ@>àäN™J C–:       €!K      Àå€     `ÈR      0dÉ      ²ì     d    &   2˜ LŒ	&GÆCŒ `€# ”PLq”§É ´›\ÆƒÆè°û\&ë@%²‚ú)Šî°˜]ËlvÚ}åi2(í&—ñ:P‰¬ †‚‚˜‡Åì2hXf³Óî3è(O“Ai7¹Œ×Jd=F (2@“ ªŒ Ğe€2# $ Ò ©F ˆ5@® Š   y     C>HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   i  –Ñ ÔähFDHR¦ã,ópTÍD˜!¾4EvVC‡DfBDähÂˆÃ•®h‹¦GÚBáKSTCáKSd[ÍTDN3½È@8UD ’Å-NED€•ˆ4™˜#	DCœÓF€ HFRDähÂˆÃ¥àê±¬øz†´H ó,ÄêPÍ`%ÓADÖ Œ8\Èr«×zDIO„LÄæPÍ€4Ææ\éšÍ@D%QL¦Q=Q!%…DälÄTˆCE¦àPÁË‚4!ƒmDODTˆCI!9Zc,„©%ÑDÔ:Í<–)/2ÎFY’#Ì³&ÒtÄ`æ%	TÍÄ
òL/°P„<ĞpĞ+!ÙÄ#=2,’-,„e-’@4„&LN$³8Î“F„$I`¦HÑ³Ó’…L9^3!–®h‹¦GZÚÍ@D+b“1À<±Læ£dÃ°BDBaÈBFs‘³P!Ğ#=2ì•N‘,mÆJ`™Õs‘#oDáDÄ,‹¹9Å ÅJ`mÎeKŒ0ÏB¤€ƒ}1°(HchÂäD±‹#(UDdE’0ÏBhL€@´CÙ#@c«ã0/Õ´•=Â4±:óQ]O³8Î£	“±ñ˜ÁÓÄÀ@c¬@4„)EÀ<a"MG, ¶6ƒÑ@Eä4Ó‹„³QEADÆe	TÍ´`Ÿ³,Eš09‘ÙD’DS:B=-,„¡lED3¥„LˆÓˆÍæX:E-X›$PQtRZ¬ÄÖæ\ö=Q!%±ÑâpY“"	DC„DäÄæ¤HÑ!9²=)’@4DHDÎlc‹$ÑF€ HĞPñEÁ¦²Î49LI“l+KàL“Ã”D1Íf÷ 2qÄ² FÈ`)KàL“Ã”D1Å&±HO„LDa‡ 0DÄöp CD€l‡ 0DÌF•dNC„DäÈ6•dNC„DäÄvDä¤„LˆÓ´ØCXU’9‘3›%PQD40Z+a,Éä<+bSl-Éä<+b“lJCXÀ[ƒÒ0DÈ& 4„Å³¹$“ó¬ˆqL³õT"ÁB°BDÍJD3‘1)’@4„IIˆ`]’@EÑLš09‘ØÌNCQP"Æ1Ù–Ã"A!8\–c=Q!%•ó¤!IÄ@˜,9Zƒ0âp™‡t‘ã52aZ–^+röADäxÍ„L˜‚«Ç²âë™V"	DC„DäÅ!ÀàX±UÒ%›Å!ÀàX³­1ÑD´9Óä0&£DˆqL¦CI„ÕAÀó,G,Ò`„†åHÑ'ÅhÂäD’Í)Â4FÈ``$qRÌì4„dPHCX!9±E!a…DäÈ&…4„‘3ÛÅ$ÀàXœ³,ˆ„8M‹=„ÉAÂ4FÈÀVğTÍÄ
DCˆÃe;Ñâ8ØTD39&Nc1ÉB“éPa0Ç -Â6¤ Ës %b“‰D9Zƒ0âpèjj¥½-¡	“ÙÈt‘£5#—Ö†¥×Šœİ,‹ã<¦SéY‚#Ë‚4!ƒ8\Æ	‘ólÎ49+DÑ›4D€%6 Àm4Òæ\fäH ó,„ÆĞ„ÑO„4SaĞAD×LÈ„èjj¥İ5BD FÈ`™)’@4Ä· †dpQ@ÁB°O„L„ØÄe/D!0„H9^3!Ö‰,·z­  a   4   K,      ((®Â*ŸÒ"A	   3°Â`D ÍÄn¸0˜e”€q@†f„! ›4 ŒÀ‰` #n"€Y‚q@†fˆ" L Œè‰` #xÂ€Y‚‚q@†	fŒ# Ÿ\ Œ ‹` #Âb€Y‚ƒ$q@†f$ ±t Œ(‹` #Ì€Y‚d–@Áp    ¦@<$     a   E   O,   
   (r(“ªb)æ€" A	P`(9 | `‚C
à€  3°Â`DĞ ÙÄnÀ f' A\ á†ÀƒY¡è&†#r" Ê‰1ÜLf0Ë0Á`ÄN Á Ì´c0b'‚Œğ	G f	
ZÄ n*0˜e0’€~bX``0",‚ °ÃÁ Á,ÃƒcÁÀ,Bc1#Æ"€Á³°`– ¡j7r³JP%. ÈpCÀÁ,³„‰ 2Üx`0ËÀ4­Å1( Àº`– ™%p0   ¦@<$     a   e   V,      (”¨‚"*E«b!A)
”@P`(9 | d‚CÌà€Cà€´İİ   3ÀÂ`D	 â€7Ì2D@5!*X`0â& › d¸!˜Ì`–A‚Á€`–`˜% ( d¸!¨À`–¡@ê	Qƒ? ı„¸  Ã Á,ƒqƒb!0KpÌ ‰ 2ÜˆÌ2$N@d!. ÈpCğÁ,ƒâƒgÑ	 ¡…¸  # ôA@Şnú f–& N\ á† À`–i‚q@F
 82f	šÁ»xƒ˜%¨HÄ næ f* º d¸!¨0˜e€¨`0/Ú@ F HƒÁˆ¿p 6ÃÁ*„Á,C4¤â€7{ ³Ò_ˆ 2bP @-ÄA0K0FFÀ,5KPa8    ¦@<$         /** @file debug.h
	@brief
	This file contains the main game debug window routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef DEBUG_H
#define DEBUG_H

#include "sys.h"

typedef struct MouseStatusStruct {
	int32 left;
	int32 right;
	int32 X;
	int32 Y;
} MouseStatusStruct;


void processDebug(int16 pKey);

#endif
BCÀŞ!  x   ‚        #‘AÈI29’„%‹b€EB’B$28I
2D$H
!#ÄR€!r$ÈHb¨ ¨@Æğ   ‰   	   2"H d…“ ¤„“ ã„¡L‚Œ„$L    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€y   C X ;„ƒ;œØC9ÈÃ<¤Ã;¸ÌĞŒPØì¡Ü È¡Ü¦     y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p        /** @file debug.scene.c
	@brief
	This file contains scenario debug routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "debug.scene.h"
#include "scene.h"
#include "grid.h"
#include "lbaengine.h"
#include "redraw.h"
#include "interface.h"
#include "renderer.h"

int32 showingZones = 0;
int32 typeZones = 127; // all zones on as default

void drawBoundingBoxProjectPoints(ScenePoint* pPoint3d, ScenePoint* pPoint3dProjected) {
	projectPositionOnScreen(pPoint3d->X, pPoint3d->Y, pPoint3d->Z);

	pPoint3dProjected->X = projPosX;
	pPoint3dProjected->Y = projPosY;
	pPoint3dProjected->Z = projPosZ;

	if (renderLeft > projPosX)
		renderLeft = projPosX;

	if (renderRight < projPosX)
		renderRight = projPosX;

	if (renderTop > projPosY)
		renderTop = projPosY;

	if (renderBottom < projPosY)
		renderBottom = projPosY;
}

int32 checkZoneType(int32 type) {
	switch (type) {
	case 0:
		if (typeZones & 0x01)
			return 1;
		break;
	case 1:
		if (typeZones & 0x02)
			return 1;
		break;
	case 2:
		if (typeZones & 0x04)
			return 1;
		break;
	case 3:
		if (typeZones & 0x08)
			return 1;
		break;
	case 4:
		if (typeZones & 0x10)
			return 1;
		break;
	case 5:
		if (typeZones & 0x20)
			return 1;
		break;
	case 6:
		if (typeZones & 0x40)
			return 1;
		break;
	default:
		break;
	}

	return 0;
}

void displayZones(int16 pKey) {
	if (showingZones == 1) {
		int z;
		ZoneStruct *zonePtr = sceneZones;
		for (z = 0; z < sceneNumZones; z++) {
			zonePtr = &sceneZones[z];

			if (checkZoneType(zonePtr->type)) {
				ScenePoint frontBottomLeftPoint;
				ScenePoint frontBottomRightPoint;

				ScenePoint frontTopLeftPoint;
				ScenePoint frontTopRightPoint;

				ScenePoint backBottomLeftPoint;
				ScenePoint backBottomRightPoint;

				ScenePoint backTopLeftPoint;
				ScenePoint backTopRightPoint;

				ScenePoint frontBottomLeftPoint2D;
				ScenePoint frontBottomRightPoint2D;

				ScenePoint frontTopLeftPoint2D;
				ScenePoint frontTopRightPoint2D;

				ScenePoint backBottomLeftPoint2D;
				ScenePoint backBottomRightPoint2D;

				ScenePoint backTopLeftPoint2D;
				ScenePoint backTopRightPoint2D;

				uint8 color;

				// compute the points in 3D

				frontBottomLeftPoint.X = zonePtr->bottomLeft.X - cameraX;
				frontBottomLeftPoint.Y = zonePtr->bottomLeft.Y - cameraY;
				frontBottomLeftPoint.Z = zonePtr->topRight.Z - cameraZ;

				frontBottomRightPoint.X = zonePtr->topRight.X - cameraX;
				frontBottomRightPoint.Y = zonePtr->bottomLeft.Y - cameraY;
				frontBottomRightPoint.Z = zonePtr->topRight.Z - cameraZ;

				frontTopLeftPoint.X = zonePtr->bottomLeft.X - cameraX;
				frontTopLeftPoint.Y = zonePtr->topRight.Y - cameraY;
				frontTopLeftPoint.Z = zonePtr->topRight.Z - cameraZ;

				frontTopRightPoint.X = zonePtr->topRight.X - cameraX;
				frontTopRightPoint.Y = zonePtr->topRight.Y - cameraY;
				frontTopRightPoint.Z = zonePtr->topRight.Z - cameraZ;

				backBottomLeftPoint.X = zonePtr->bottomLeft.X - cameraX;
				backBottomLeftPoint.Y = zonePtr->bottomLeft.Y - cameraY;
				backBottomLeftPoint.Z = zonePtr->bottomLeft.Z - cameraZ;

				backBottomRightPoint.X = zonePtr->topRight.X - cameraX;
				backBottomRightPoint.Y = zonePtr->bottomLeft.Y - cameraY;
				backBottomRightPoint.Z = zonePtr->bottomLeft.Z - cameraZ;

				backTopLeftPoint.X = zonePtr->bottomLeft.X - cameraX;
				backTopLeftPoint.Y = zonePtr->topRight.Y - cameraY;
				backTopLeftPoint.Z = zonePtr->bottomLeft.Z - cameraZ;

				backTopRightPoint.X = zonePtr->topRight.X - cameraX;
				backTopRightPoint.Y = zonePtr->topRight.Y - cameraY;
				backTopRightPoint.Z = zonePtr->bottomLeft.Z - cameraZ;

				// project all points

				drawBoundingBoxProjectPoints(&frontBottomLeftPoint,    &frontBottomLeftPoint2D);
				drawBoundingBoxProjectPoints(&frontBottomRightPoint,   &frontBottomRightPoint2D);
				drawBoundingBoxProjectPoints(&frontTopLeftPoint,       &frontTopLeftPoint2D);
				drawBoundingBoxProjectPoints(&frontTopRightPoint,      &frontTopRightPoint2D);
				drawBoundingBoxProjectPoints(&backBottomLeftPoint,     &backBottomLeftPoint2D);
				drawBoundingBoxProjectPoints(&backBottomRightPoint,    &backBottomRightPoint2D);
				drawBoundingBoxProjectPoints(&backTopLeftPoint,        &backTopLeftPoint2D);
				drawBoundingBoxProjectPoints(&backTopRightPoint,       &backTopRightPoint2D);

				// draw all lines

				color = 15 * 3 + zonePtr->type * 16;

				// draw front part
				drawLine(frontBottomLeftPoint2D.X, frontBottomLeftPoint2D.Y, frontTopLeftPoint2D.X, frontTopLeftPoint2D.Y, color);
				drawLine(frontTopLeftPoint2D.X, frontTopLeftPoint2D.Y, frontTopRightPoint2D.X, frontTopRightPoint2D.Y, color);
				drawLine(frontTopRightPoint2D.X, frontTopRightPoint2D.Y, frontBottomRightPoint2D.X, frontBottomRightPoint2D.Y, color);
				drawLine(frontBottomRightPoint2D.X, frontBottomRightPoint2D.Y, frontBottomLeftPoint2D.X, frontBottomLeftPoint2D.Y, color);

				// draw top part
				drawLine(frontTopLeftPoint2D.X, frontTopLeftPoint2D.Y, backTopLeftPoint2D.X, backTopLeftPoint2D.Y, color);
				drawLine(backTopLeftPoint2D.X, backTopLeftPoint2D.Y, backTopRightPoint2D.X, backTopRightPoint2D.Y, color);
				drawLine(backTopRightPoint2D.X, backTopRightPoint2D.Y, frontTopRightPoint2D.X, frontTopRightPoint2D.Y, color);
				drawLine(frontTopRightPoint2D.X, frontTopRightPoint2D.Y, frontTopLeftPoint2D.X, frontTopLeftPoint2D.Y, color);

				// draw back part
				drawLine(backBottomLeftPoint2D.X, backBottomLeftPoint2D.Y, backTopLeftPoint2D.X, backTopLeftPoint2D.Y, color);
				drawLine(backTopLeftPoint2D.X, backTopLeftPoint2D.Y, backTopRightPoint2D.X, backTopRightPoint2D.Y, color);
				drawLine(backTopRightPoint2D.X, backTopRightPoint2D.Y, backBottomRightPoint2D.X, backBottomRightPoint2D.Y, color);
				drawLine(backBottomRightPoint2D.X, backBottomRightPoint2D.Y, backBottomLeftPoint2D.X, backBottomLeftPoint2D.Y, color);

				// draw bottom part
				drawLine(frontBottomLeftPoint2D.X, frontBottomLeftPoint2D.Y, backBottomLeftPoint2D.X, backBottomLeftPoint2D.Y, color);
				drawLine(backBottomLeftPoint2D.X, backBottomLeftPoint2D.Y, backBottomRightPoint2D.X, backBottomRightPoint2D.Y, color);
				drawLine(backBottomRightPoint2D.X, backBottomRightPoint2D.Y, frontBottomRightPoint2D.X, frontBottomRightPoint2D.Y, color);
				drawLine(frontBottomRightPoint2D.X, frontBottomRightPoint2D.Y, frontBottomLeftPoint2D.X, frontBottomLeftPoint2D.Y, color);
			}
		}
	}
}
/** @file debug.scene.h
	@brief
	This file contains scenario debug routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef SCENE_DEBUG_H
#define SCENE_DEBUG_H

#include "sys.h"

extern int32 showingZones;
extern int32 typeZones;

void displayZones(int16 pKey);

#endif
BCÀŞ!  Õ  ‚        #‘AÈI29’„%‹b€EB’BÄ28I
2D$H
!#ÄR€!r$Èˆb¨ ¨@Æğ   Q  ™   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l † À  I     ‚`B L†    ‰   c   2"ˆ	 d…#¤„#ã„¡LŒŒ„ÄLøÁ0G ‘p‘4E”0ù¬@4Dê Í„An‘¦ˆ&hœ‚ §Pâ4>Ğ8
Š‹¤)¢„ÉŸ†`§ˆ&T„`Iv2G€’È1‰ CK¥€r˜4E”0ùìLˆğ-€!±SD	
¦Ë¤)¢„Éï°`á[ Cb§ˆ&LçHSD	“?¿©ƒ4áiŠ(aòçws.4X–u–4E”0ùš09‘éT;E”0!Bà4iŠ(aòµaZ„!¢˜ vŠ(aBÂœ$M%L¾&LNÄN%LÈ¨
   X€                `           ¸°,É4ÚH£.‘úJ¡0¡ 	;Lš"J˜|´"¢ÀJDšØ)¢„	‚ ‚ ¤‚I' :@DØ¶%·    H.+]    { €Ú9‚`
€â °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD \fà%``å &P`eÀ%p\gÀ%p\gB&P\gÀ%p\gÀ%p6jçÃ&p\gÀ%p\ç"&0`å &P`å &P`%„&pBh'„&pBh'„&p`å &P`å &P`¥ä&P\ç &P`å &P`å &P`eÀ%p\gÀ%pBh'„&p\gÀ%p\gÀ%pJn¥ä&PJnå &P`å &P`å &P`å &P`å &P`å &P`å &P`å &P\'''pztç &P`å &P`å &P\'h'P`å &PŠxcÀ%p\gÀ%pBhç &P`eÀ%p\ç &P`%„&pBh'„&p’zg	'p\gÀ%p\gÀ%p\ç &P\ç &P`eÀ%p\gÀ%p\'Ê'PBhgÀ%p\gÀ%p\gÀ%p\gÀ%p\gÀ%p`å &P`eÀ%p\gÀ%p\gÀ%p\gj&p`eÀ%p®~ej&ğ!Ë      À%€     `È2      0d©      ²Ü     d    2˜ LŒ	&GÆCF Ê?€„ RF  a€– bF È h€° ÚF ¨ o€Â G è u    y     C<HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   ²  V÷LÄ5ÁH38ÖŠÇd@MfD„$!adÎâ8GEÑL$\!™u‘£5#Wº¢-šjiwĞD\Œ4ƒcmÎ49Œ}MEä4Ó‹„³QEAD"ÙÛâTD´ X‰H“99’@4ÄI1mŠd{Î9IêH2+DÑHu‘£5#—‚«Ç²âë`@1Ò›Í"Ì³«C5ƒ(ÑDTÅd!ÓADÖ Œ8\Èr«×zöBIO„LÄæPÍ€4Ææ\éY`@1Ò$›EõDD…8”‘³P!Ù•CIG,Ò`„v=Q!%…Däh±vDD3Që<ÖõXN¤¼È@8UDd70ÏB˜HÓ€“$PQD4+DÈ3½ÀB&æ,ó¤!IÄ@˜=<Ò!Á"ÑÁBØÑ"	DChÂäD’%(’@4Äì4„dKD4­ˆqLÖ1DäxÍ„LXº¢-šji5Œ0ÏB¬ÄC “	 Oä$©#Å6€<‘“¤$òDN’:ÒlhJæ8+DÑØœ3×#ÍàX%QLf7MÄ5ÁH38ÖŠÇÄaÍADÎF@…8Td.ôDÈD°08V:E¦¶D´+1D€ey"¹Òht8iä$„0!NcDÏAD¼…°,¦Ğ!(³Ó-öÆæ4ƒ+1D€µ9—ÉEqM0ÒÕ:T„!pCX›C5Ò›s¥‘“Â”:H3I–ÃH ó,Dº 1X3‹‚4†&LNd3’0ÏBhL€@´C˜Õ, lTQ‘8³`+ÑDÔbazÎ9IêH1+DÑXbÀõDNBSêHÈ„8Ú°BD	!M³A=Â4±:óQM[Ô#@c«ã0/Õµ™5‹ã<š09;­<AÜ4Á
DCN$Ì³&ÒtÄ`k3˜TDN3½È@8UDdJ–@EÑLö9ËâXÄ 	“X$	A4¥ã(ÔÓÁBÉ&PQD4SêHÈ„8ØlÎ€¥SÔ0ÒáXHcÌNCH¶&	Tƒ+1D€µ9—µ@ODTˆCI¬@4„8\LØCÌNCH¶£HÑ!9±ñ(’@4DHDl=Š$‘3ÛÓ"	DC´ (’•,3MSÅ›É8Óä0%QL²,3MSÅ4Û`€#À@h±-Üæ°HO„LDa}ŠM‡“FNÛÂ! ±1À [Ã! ³	%™Ó!9²%™Ó!9±A9©#!â4-öC	TÍVDÄ
DCJ29ÏŠÇ[J29ÏŠÇ$›J29ÏŠÇ4Û”Ò0DÄV¥4„Å³%™Ó!9³é(’@4„IIˆ`K’@EÑLš09‘ØÌNCX\3×#ÍàX­ó•Ò0DÈ&“Ä”ˆqL†ÀDD3ÑæL“ÃX’Ã"A!8\6f=Q!%•ó¤!IÄ@˜,9Zƒ0âp™†t‘ã52aZ–^+rv<+ÑDôÖ¶ADäxÍ„L˜‚«Ç²âëR"	DC„DäØŸâDÓá¤‘“ÌqH08Vl‡t ƒcÉ&qH08ÖlgÕ€H@°¬D³ÑLDdxÔD\Œ4ƒcmÎ49T„ù)N4N9‰l‹Ì€HÏ`³Ó’q)b“éPaF$qRŒ&LN$™B#	DCœ3;!™ÒVHDNl?HCX!9²!a…DäÌ61I08ç,"!NÓba[ÉB“éPaŒÈV‰4„±<ED3±ÑâpYY´8Î#6ÑLN„‰ÁXŒ,Ï”ˆqL¦u,Ğ"aÑADÖ Œ8\'ºšZi…KC1hñÑD\Ö¶T,„&LNdÓADÖ Œ8\Z–^+r¶,ó˜NE¤Sd|Î9IêH3+DÑ$DÎ³9Óä0¬DcX@,Ò`„âpYš4D€%6 Àm4Òæ\FãH ó,„ÆĞ„e@9^3!v¢«©•F'MÄ5ÁH38VIT„DMÄÅ9N4 0’I)’@4Ä· †dnQ@ÁB°O„L„ØÄeYD!0„qH9^3!Ö‰,·z­  a   I   I,      ”@    3y „Å0‘@Xƒ‚1 ƒA1 $Œñ† Ë( BÆoº„q ¤Œñ† 
Ä€Œ €I\zÆxCpg0@r!HãXƒÁ  D‚ª1Ş´6@v1H/Ä€7Ì2B@}!. d0‚/‚˜%h/†¸ á†!@ƒY†h4Ä€F„F0 ³Æ Ò 2Ü0f0ËP¡†¸ ÁÓ`–À Ò´â@†† f$ × 2±Á Ì       ö€<©ƒ4Ó=h@ô¤ÒL÷FNB1       a   G   Y,      ”@B”B1DP   3 ÃLD €Å04@Á&«%° ÂâE,²€Êb"¶8:ÜˆAÌ2C0a@ 0K€Í\ô£H‡‚2ƒY†Â#’	 f	°Y‚‹äbT épC€a0Ë€$Á`cÀ,6KpQ]Œ
"nÖ f&Œx2 ˜%Àf	.Â‹QÁ¤Ã„Á,ƒóƒ ³Ø,ÁE{1*¨t¸!ˆƒ0˜eˆ¤`0¢ú `– ›%¸È/F—7t³TF`b  ³Ø,Á5KpF`u  ³a ƒp     ö@LØC      a   }  I,      ”@Hi?”‘$@K -   3 ÂLD €Å0Ñ X3m €…0Ñ X3m €…0Ñ X3m €…0Ñ X3m €…0Ñ X3m €…0Ñ X3m €…0Ñ X3m €…0Ñ X3m €…0Ñ X3 Á`¥	 åÅn40˜e`0‚º`0¢rƒ˜%¨$c¸AĞ`–a8ÂÆxƒ]ÈA0‘@Ùoè ( 2b@ €Ã„Á,Qôñ†@ô`¼!Øƒ= @\ Æ0!ÁŒ7˜A(„Â`D  ¡ÁoFaÆRˆ
Ä€j‚\ ÀxÃ¨ÂF‚ PŒñ†€ò`¼!h…< @\ ÁÆ0!ÁŒ7àÁ,üÁ`D  éÁojAÆ[°
Ä€Ğn‚\ Àx(ğ/F‚ Ğ(Œñ†À|a¼!øV @\ Ç0!ÁŒ7¤B9ÈÂ`D  ±ÂoÎÆt 
Ä€Ğz‚\ Àxƒ,¸ƒ.F‚ P-Œñ† àa¼!ˆ‡x @\ ÙÇ0!ÁŒ7èÂ=ÜÃ`D  ùÂoòÁÆ}8
Ä€‚\ ÀxÃ8€D;F‚ Ğ9Œñ†@$Şa¼!‰w @\ ™È0!ÁŒ7°CJÔÃ`D  ÁÃoVÆ–`	
Ä€PŒ‚\ Àx=È„LF‚ P>Œñ†€&Bb¼!¨	‘ @\ åÈ0!ÁŒ7ôÃN Ä`D  ‰ÄozB%ÆŸP	
Ä€P˜‚\ ÀxƒILF‚ ĞJŒñ†À,Ìb¼!8‹³ @\ ±É0!ÁŒ7¸D[´Å`D  ÑÄoŞâ-Æ¸è	
Ä€‚\ ÀxÃMØÅXF‚ POŒñ† /ğb¼!È‹² @\ ñÉ0!ÁŒ7€Å_¬Å`D  ™ÅoBÃ-ÆÑ
Ä€Ğ©‚\ ÀxZ jF‚ Ğ[Œñ†@5Tc¼!X¼ @\ ½Ê0!ÁŒ7ÄEløÅ`D  áÅofc6ÆÚ 
Ä€Ğ­‚\ Àxƒ^è†iF‚ PhŒñ†€7xc¼!èŞ @\ ‰Ë0!ÁŒ7ˆÆxŒÇ`D  ©ÆoÊC6Æó˜
Ä€º‚\ ÀxÃj°GnF‚ ĞlŒñ†À=Üc¼!xİ @\ ÉË0!ÁŒ7ĞF}„Ç`D  ñÆoîƒ<ÆüÀ
Ä€P¿‚\ Àxoø‡F‚ PyŒñ† DÚc¼!÷ @\ •Ì0!ÁŒ7”Ç‰ĞÇ`D  ¹ÇoR$EÆ±
Ä€PË‚\ Àxƒ{ÀF‚ Œ `#öá# ØH}´ÇˆA 6Bì1bP €ÌÇzŒ `#ò¡# ØH|¤ÇˆA 6è1bP €¼ÇyĞ}Œñ†@Füƒq €ˆD\ À`D{0ŞP8‚#ˆ oÀA
Ä€Œ7ä‡øâ@Æø#L\„q ”á F 8&1†`¼!DÌÄL( 2Ş@"ib#ˆ o06a
Ä€Œ7¤È›ğâ@èDÂ@Œ  P'LbÁxƒ‹Ğ	P . d¼!Fî„L( 2Ş`#z¢'ˆ oÈ‘>Q
Ä€P„€1@ `T˜Ä‚ñQ¡@\ ÈxC˜”ŠœP . d¼¡LPU( 2Ş€&«‚'ˆ ¡1	 1b€ @¬0‰1ãk+°B¸ ñ7™P¡@\ ÈxC›ØŠ­P . d¼NrÅT( Bq. bÄ €_acÆêÄW|…q ãx.®B¸ ñ=!r¡@\ ÈxCŸœ­P . „ş$\ Äˆ íÂ$ÆŒ7ˆ
»°â@ÆJå]x…q ã¬"/òB¸ ñ†W©q¡@\ µJ¸ ˆ ö…IŒ!o }Ñ
Ä€Œ7ÜJ¿¨â@Ævd@†q ã¾22ğB¸ Ú•p# ¤“C0Ş.(ƒ2ˆ o —•Á
Ä€Œ7”‹Ë¸â@ÆĞ%fü…q ”.á F ¸&1†`¼¡]lÆf( 2Ş /9c2ˆ oá
Ä€Œ7ÔËÏ°â@è^Â@Œ  P6LbÁxƒ¾ÙP . d¼¡_Î†f( 2Ş 2j£6ˆ o(™¶Ñ
Ä€PÉ„€1@ `n˜Ä‚ñ•‘¹¡@\ ÈxCËÔØP . d¼!fğo( 2Ş@3{ƒ6ˆ ¡™	 1b€ @è0‰1ã=: C¸ ñ°¸¡@\ ÈxÃÏ˜éP . d¼AlRÇn( Ba. bÄ €×acÆÎÆu\‡q ãj;~C¸ ñ¶¡Ú¡@\ ÈxÃÛÜéP . „Ş&\ Äˆ ½Ã$ÆŒ7Ğïğâ@ÆîæwX‡q ã~#>âC¸ ñ†Ğ)Ù¡@\ õM¸ ˆ Ö‡IŒ!o0õQ
Ä€Œ7¤Nûèâ@ÆZ~à‡q ã°3?àC¸ Zp# ä“C0KPÌô;ÃóÁ`Dø0K Ì O   †PÎâDv0€ ´Î³"Æ1¥ÒLvg«R9ÍÔ:ÏŠÇ”:H3Ym€ ‚²9Óä0+bSê Ídw–P‘ÓL›3M³"Æ1¥ÒL&0‘ÓL­ó”D1¥ÒLvg°V9Í´9Óä0%QL©ƒ4“İÙk@ ‚Ò:ÏŠÇ”:H3Yk  ‚²9Óä0+bSê Íd¶R Jë<%QL©ƒ4“İ™j@TDN3µÎSÅ”:H3ÙiÀ‘9‘N‘¡PEä4ÓæL“Ã”D1¥ÒLFP€ lÎ49LISê Ídwö@<$™i@kÀ ‚²9Óä0%QL©ƒ4“Å\Eä4ÓæL“Ã¬ˆqL©ƒ4“İÙl UDN3µÎ³"Æ1¥ÒLvg®P Jë<%QL©ƒ4            /** @file extra.c
	@brief
	This file contains extra (bonus, projectils, keys, etc.) routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>

#include "extra.h"
#include "lbaengine.h"
#include "collision.h"
#include "resources.h"
#include "gamestate.h"
#include "scene.h"
#include "movements.h"
#include "renderer.h"
#include "grid.h"
#include "sound.h"
#include "redraw.h"
#include "interface.h"

/** Hit Stars shape info */
int16 hitStarsShapeTable[] = {
	10,
	0,
	-20,
	4,
	-6,
	19,
	-6,
	7,
	2,
	12,
	16,
	0,
	7,
	-12,
	16,
	-7,
	2,
	-19,
	-6,
	-4,
	-6
};

/** Explode Cloud shape info */
int16 explodeCloudShapeTable [] = {
	18,
	0,
	-20,
	6,
	-16,
	8,
	-10,
	14,
	-12,
	20,
	-4,
	18,
	4,
	12,
	4,
	16,
	8,
	8,
	16,
	2,
	12,
	-4,
	18,
	-10,
	16,
	-12,
	8,
	-16,
	10,
	-20,
	4,
	-12,
	-8,
	-6,
	-6,
	-10,
	-12
};

int32 addExtra(int32 actorIdx, int32 X, int32 Y, int32 Z, int32 info0, int32 targetActor, int32 maxSpeed, int32 strengthOfHit) {
	int32 i;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 == -1) {
			extra->info0 = info0;
			extra->type = 0x80;
			extra->info1 = 0;
			extra->X = X;
			extra->Y = Y;
			extra->Z = Z;
			extra->actorIdx = actorIdx;
			extra->lifeTime = targetActor;
			extra->destZ = maxSpeed;
			extra->strengthOfHit = strengthOfHit;

			setActorAngle(0, maxSpeed, 50, &extra->trackActorMove);
			extra->angle = getAngleAndSetTargetActorDistance(X, Z, sceneActors[targetActor].X, sceneActors[targetActor].Z);
			return i;
		}
	}
	return -1;
}

/** Add extra explosion
	@param X Explostion X coordinate 
	@param Y Explostion Y coordinate
	@param Z Explostion Z coordinate */
int32 addExtraExplode(int32 X, int32 Y, int32 Z) {
	int32 i;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 == -1) {
			extra->info0 = 0x61;
			extra->type = 0x1001;
			extra->info1 = 0;
			extra->X = X;
			extra->Y = Y;
			extra->Z = Z;
			extra->actorIdx = 0x28;
			extra->lifeTime = lbaTime;
			extra->strengthOfHit = 0;
			return i;
		}
	}
	return -1;
}

/** Reset all used extras */
void resetExtras() {
	int32 i;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		extra->info0 = -1;
		extra->info1 = 1;
	}
}

void throwExtra(ExtraListStruct *extra, int32 var1, int32 var2, int32 var3, int32 var4) { // InitFly
	extra->type |= 2;
	
	extra->lastX = extra->X;
	extra->lastY = extra->Y;
	extra->lastZ = extra->Z;

	rotateActor(var3, 0, var1);

	extra->destY = -destZ;

	rotateActor(0, destX, var2);

	extra->destX = destX;
	extra->destZ = destZ;

	extra->angle = var4;
	extra->lifeTime = lbaTime;
}

void addExtraSpecial(int32 X, int32 Y, int32 Z, int32 type) { // InitSpecial
	int32 i;
	int16 flag = 0x8000 + type;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 == -1) {
			extra->info0 = flag;
			extra->info1 = 0;

			if (type == kHitStars) {
				extra->type = 9;

				extra->X = X;
				extra->Y = Y;
				extra->Z = Z;

				// same as InitFly
				throwExtra(extra, Rnd(0x100) + 0x80, Rnd(0x400), 50, 20);

				extra->strengthOfHit = 0;
				extra->lifeTime = lbaTime;
				extra->actorIdx = 100;

				return;
			} else if (type == kExplodeCloud) {
				extra->type = 1;

				extra->X = X;
				extra->Y = Y;
				extra->Z = Z;

				extra->strengthOfHit = 0;
				extra->lifeTime = lbaTime;
				extra->actorIdx = 5;

				return;
			}
		}
	}
}

int32 addExtraBonus(int32 X, int32 Y, int32 Z, int32 param, int32 angle, int32 type, int32 bonusAmount) { // ExtraBonus
	int32 i;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 == -1) {
			extra->info0 = type;
			extra->type = 0x4071;

			/*if(type == SPRITEHQR_KEY) {
				extra->type = 0x4030;
			}*/

			extra->X = X;
			extra->Y = Y;
			extra->Z = Z;

			// same as InitFly
			throwExtra(extra, param, angle, 40, 15);

			extra->strengthOfHit = 0;
			extra->lifeTime = lbaTime;
			extra->actorIdx = 1000;
			extra->info1 = bonusAmount;

			return i;
		}
	}

	return -1;
}

int32 addExtraThrow(int32 actorIdx, int32 X, int32 Y, int32 Z, int32 sprite, int32 var2, int32 var3, int32 var4, int32 var5, int32 strengthOfHit) { // ThrowExtra
	int32 i;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 == -1) {
			extra->info0 = sprite;
			extra->type = 0x210C;
			extra->X = X;
			extra->Y = Y;
			extra->Z = Z;

			// same as InitFly
			throwExtra(extra, var2, var3, var4, var5);

			extra->strengthOfHit = strengthOfHit;
			extra->lifeTime = lbaTime;
			extra->actorIdx = actorIdx;
			extra->info1 = 0;

			return i;
		}
	}

	return -1;
}

int32 addExtraAiming(int32 actorIdx, int32 X, int32 Y, int32 Z, int32 spriteIdx, int32 targetActorIdx, int32 maxSpeed, int32 strengthOfHit) { // ExtraSearch
	int32 i;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 == -1) {
			extra->info0 = spriteIdx;
			extra->type = 0x80;
			extra->info1 = 0;
			extra->X = X;
			extra->Y = Y;
			extra->Z = Z;
			extra->actorIdx = actorIdx;
			extra->lifeTime = targetActorIdx;
			extra->destZ = maxSpeed;
			extra->strengthOfHit = strengthOfHit;
			setActorAngle(0, maxSpeed, 50, &extra->trackActorMove);
			extra->angle = getAngleAndSetTargetActorDistance(X, Z, sceneActors[targetActorIdx].X, sceneActors[targetActorIdx].Z);	

			return i;
		}
	}

	return -1;
}

// cseg01:00018168
int32 findExtraKey() {
	int32 i;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 == SPRITEHQR_KEY) {
			return i;
		}
	}

	return -1;
}

// cseg01:00018250
int32 addExtraAimingAtKey(int32 actorIdx, int32 X, int32 Y, int32 Z, int32 spriteIdx, int32 extraIdx) { // addMagicBallAimingAtKey
	int32 i;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 == -1) {
			extra->info0 = spriteIdx;
			extra->type = 0x200;
			extra->info1 = 0;
			extra->X = X;
			extra->Y = Y;
			extra->Z = Z;
			extra->actorIdx = extraIdx;
			extra->destZ = 0x0FA0;
			extra->strengthOfHit = 0;
			setActorAngle(0, 0x0FA0, 50, &extra->trackActorMove);
			extra->angle = getAngleAndSetTargetActorDistance(X, Z, extraList[extraIdx].X, extraList[extraIdx].Z);	

			return i;
		}
	}

	return -1;
}

void addExtraThrowMagicball(int32 X, int32 Y, int32 Z, int32 param1, int32 angle, int32 param2, int32 param3) { // ThrowMagicBall
	int32 ballSprite = -1;
	int32 ballStrength = 0;
	int32 extraIdx = -1;

	switch (magicLevelIdx) {
	case 0:
	case 1:
		ballSprite = 1;
		ballStrength = 4;
		break;
	case 2:
		ballSprite = 42;
		ballStrength = 6;
		break;
	case 3:
		ballSprite = 43;
		ballStrength = 8;
		break;
	case 4:
		ballSprite = 13;
		ballStrength = 10;
		break;
	}

	magicBallNumBounce = ((inventoryMagicPoints - 1) / 20) + 1;
	if (inventoryMagicPoints == 0) {
		magicBallNumBounce = 0;
	}

	extraIdx = findExtraKey();
	if (extraIdx != -1) { // there is a key to aim
		magicBallNumBounce = 5;
	}

	switch (magicBallNumBounce) {
	case 0:
		magicBallIdx = addExtraThrow(0, X, Y, Z, ballSprite, param1, angle, param2, param3, ballStrength);
		break;
	case 1:
		magicBallAuxBounce = 4;
		magicBallIdx = addExtraThrow(0, X, Y, Z, ballSprite, param1, angle, param2, param3, ballStrength);
		break;
	case 2:
	case 3:
	case 4:
		magicBallNumBounce = 1;
		magicBallAuxBounce = 4;
		magicBallIdx = addExtraThrow(0, X, Y, Z, ballSprite, param1, angle, param2, param3, ballStrength);
		break;
	case 5:
		magicBallIdx = addExtraAimingAtKey(0, X, Y, Z, ballSprite, extraIdx);
      break;
	}

	if (inventoryMagicPoints > 0) {
		inventoryMagicPoints--;
	}
}

void drawSpecialShape(int16 *shapeTable, int32 X, int32 Y, int32 color, int32 angle, int32 size) {
	int16 currentShapeTable;
	int16 var_8;
	int16 temp1;
	int32 computedX;
	int32 computedY;
	int32 oldComputedX;
	int32 oldComputedY;
	int32 numEntries;
	int32 currentX;
	int32 currentY;

	currentShapeTable = *(shapeTable++);

	var_8 = ((*(shapeTable++)) * size) >> 4;
	temp1 = ((*(shapeTable++)) * size) >> 4;

	renderLeft   = 0x7D00;
	renderRight  = -0x7D00;
	renderTop    = 0x7D00;
	renderBottom = -0x7D00;

	rotateActor(var_8, temp1, angle);

	computedX = destX + X;
	computedY = destZ + Y;

	if (computedX < renderLeft)
		renderLeft = computedX;

	if (computedX > renderRight)
		renderRight = computedX;

	if (computedY < renderTop)
		renderTop = computedY;

	if (computedY > renderBottom)
		renderBottom = computedY;

	numEntries = 1;

	currentX = computedX;
	currentY = computedY;

	while (numEntries < currentShapeTable) {
		var_8 = ((*(shapeTable++)) * size) >> 4;
		temp1 = ((*(shapeTable++)) * size) >> 4;

		oldComputedX = currentX;
		oldComputedY = currentY;

		projPosX = currentX;
		projPosY = currentY;

		rotateActor(var_8, temp1, angle);

		currentX = destX + X;
		currentY = destZ + Y;

		if (currentX < renderLeft)
		  renderLeft = currentX;

		if (currentX > renderRight)
		  renderRight = currentX;

		if (currentY < renderTop)
		  renderTop = currentY;

		if (currentY > renderBottom)
		  renderBottom = currentY;

		projPosX = currentX;
		projPosY = currentY;

		drawLine(oldComputedX, oldComputedY, currentX, currentY, color);

		numEntries++;

		currentX = projPosX;
		currentY = projPosY;

	}

	projPosX = currentX;
	projPosY = currentY;
	drawLine(currentX, currentY, computedX, computedY, color);
}

void drawExtraSpecial(int32 extraIdx, int32 X, int32 Y) {
	int32 specialType;
	ExtraListStruct *extra = &extraList[extraIdx];

	specialType = extra->info0 & 0x7FFF;

	switch(specialType) {
	case kHitStars:
		drawSpecialShape(hitStarsShapeTable, X, Y, 15, (lbaTime << 5) & 0x300, 4);
		break;
	case kExplodeCloud: {
		int32 cloudTime = 1 + lbaTime - extra->lifeTime;

		if (cloudTime > 32) {
			cloudTime = 32;
		}

		drawSpecialShape(explodeCloudShapeTable, X, Y, 15, 0, cloudTime);
	}
		break;
	}
}

void processMagicballBounce(ExtraListStruct *extra, int32 X, int32 Y, int32 Z) {
	if (getBrickShape(X, extra->Y, Z)) {
		extra->destY = -extra->destY;
	}
	if (getBrickShape(extra->X, Y, Z)) {
		extra->destX = -extra->destX;
	}
	if (getBrickShape(X, Y, extra->Z)) {
		extra->destZ = -extra->destZ;
	}

	extra->X = X;
	extra->lastX = X;
	extra->Y = Y;
	extra->lastY = Y;
	extra->Z = Z;
	extra->lastZ = Z;

	extra->lifeTime = lbaTime;
}

/** Process extras */
void processExtras() {
	int32 i;

	int32 currentExtraX = 0;
	int32 currentExtraY = 0;
	int32 currentExtraZ = 0;
	int32 currentExtraSpeedX = 0;
	int32 currentExtraSpeedY = 0;

	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 != -1) {
			// process extra life time
			if (extra->type & 0x1) {
				if (extra->actorIdx + extra->lifeTime <= lbaTime) {
					extra->info0 = -1;
					continue;
				}
			}
			// reset extra
			if (extra->type & 0x800) {
				extra->info0 = -1;
				continue;
			}
			// 
			if (extra->type & 0x1000) {
				extra->info0 = getAverageValue(97, 100, 30, lbaTime - extra->lifeTime);
				continue;
			}
			// process extra moving
			if (extra->type & 0x2) {
				currentExtraX = extra->X;
				currentExtraY = extra->Y;
				currentExtraZ = extra->Z;

				currentExtraSpeedX = extra->destX * (lbaTime - extra->lifeTime);
				extra->X = currentExtraSpeedX + extra->lastX;

				currentExtraSpeedY = extra->destY * (lbaTime - extra->lifeTime);
				currentExtraSpeedY += extra->lastY; 
				extra->Y = currentExtraSpeedY - Abs(((extra->angle * (lbaTime - extra->lifeTime))* (lbaTime - extra->lifeTime)) >> 4);

				extra->Z = extra->destZ * (lbaTime - extra->lifeTime) + extra->lastZ;

				// check if extra is out of scene
				if (extra->Y < 0 || extra->X < 0 || extra->X > 0x7E00 || extra->Z < 0 || extra->Z > 0x7E00) {
					// if extra is Magic Ball
					if (i == magicBallIdx) {
						int32 spriteIdx = SPRITEHQR_MAGICBALL_YELLOW_TRANS;

						if (extra->info0 == SPRITEHQR_MAGICBALL_GREEN) {
							spriteIdx = SPRITEHQR_MAGICBALL_GREEN_TRANS;
						}
						if (extra->info0 == SPRITEHQR_MAGICBALL_RED) {
							spriteIdx = SPRITEHQR_MAGICBALL_RED_TRANS;
						}

						magicBallIdx = addExtra(-1, extra->X, extra->Y, extra->Z, spriteIdx, 0, 10000, 0);
					}

					// if can take extra on ground
					if (extra->type & 0x20) { 
						extra->type &= 0xFFED;
					} else {
						extra->info0 = -1;
					}

					continue;
				}
			}
			// 
			if (extra->type & 0x4000) {
				if (lbaTime - extra->lifeTime > 40) {
					extra->type &= 0xBFFF;
				}
				continue;
			}
			// process actor target hit 
			if (extra->type & 0x80) {
				int32 actorIdx, actorIdxAttacked, tmpAngle, angle;

				actorIdxAttacked = extra->lifeTime;
				actorIdx = extra->actorIdx;

				currentExtraX = sceneActors[actorIdxAttacked].X;
				currentExtraY = sceneActors[actorIdxAttacked].Y + 1000;
				currentExtraZ = sceneActors[actorIdxAttacked].Z;

				tmpAngle = getAngleAndSetTargetActorDistance(extra->X, extra->Z, currentExtraX, currentExtraZ);
				angle = (tmpAngle - extra->angle) & 0x3FF;

				if (angle > 400 && angle < 600) {
					if (extra->strengthOfHit) {
						hitActor(actorIdx, actorIdxAttacked, extra->strengthOfHit, -1);
					}

					if (i == magicBallIdx) {
						magicBallIdx = -1;
					}

					extra->info0 = -1;
					continue;
				} else {
					int32 angle, pos;

					angle = getAngleAndSetTargetActorDistance(extra->Y, 0, currentExtraY, targetActorDistance);

					pos = getRealAngle(&extra->trackActorMove);

					if (!pos) {
						pos = 1;
					}

					rotateActor(pos, 0, angle);
					extra->Y -= destZ;

					rotateActor(0, destX, tmpAngle);
					extra->X += destX;
					extra->Z += destZ;

					setActorAngle(0, extra->destZ, 50, &extra->trackActorMove);

					if (actorIdxAttacked == checkExtraCollisionWithActors(extra, actorIdx)) {
						if (i == magicBallIdx) {
							magicBallIdx = -1;
						}

						extra->info0 = -1;
						continue;
					}
				}
			}
			// process magic ball extra aiming for key
			if (extra->type & 0x200) {
				int32 actorIdx, tmpAngle, angle;
//				int32 actorIdxAttacked = extra->lifeTime;
                ExtraListStruct *extraKey = &extraList[extra->actorIdx];
				actorIdx = extra->actorIdx;

                tmpAngle = getAngleAndSetTargetActorDistance(extra->X, extra->Z, extraKey->X, extraKey->Z);
				angle = (tmpAngle - extra->angle) & 0x3FF;

				if (angle > 400 && angle < 600) {
                    playSample(97, 0x1000, 1, sceneHero->X, sceneHero->Y, sceneHero->Z, 0);
                    
                    if (extraKey->info1 > 1) {
                        projectPositionOnScreen(extraKey->X - cameraX, extraKey->Y - cameraY, extraKey->Z - cameraZ);
                        addOverlay(koNumber, extraKey->info1, projPosX, projPosY, koNormal, 0, 2);
                    }
                    
                    addOverlay(koSprite, SPRITEHQR_KEY, 10, 30, koNormal, 0, 2);

                    inventoryNumKeys += extraKey->info1;
                    extraKey->info0 = -1;
                    
					extra->info0 = -1;
                    magicBallIdx = addExtra(-1, extra->X, extra->Y, extra->Z, SPRITEHQR_KEY, 0, 8000, 0);
					continue;
				} else {
					int32 angle, pos;

					angle = getAngleAndSetTargetActorDistance(extra->Y, 0, extraKey->Y, targetActorDistance);
					pos = getRealAngle(&extra->trackActorMove);

					if (!pos) {
						pos = 1;
					}

					rotateActor(pos, 0, angle);
					extra->Y -= destZ;

					rotateActor(0, destX, tmpAngle);
					extra->X += destX;
					extra->Z += destZ;

					setActorAngle(0, extra->destZ, 50, &extra->trackActorMove);

					if (actorIdx == checkExtraCollisionWithExtra(extra, magicBallIdx)) {
						playSample(97, 0x1000, 1, sceneHero->X, sceneHero->Y, sceneHero->Z, 0);
                    
						if (extraKey->info1 > 1) {
							projectPositionOnScreen(extraKey->X - cameraX, extraKey->Y - cameraY, extraKey->Z - cameraZ);
							addOverlay(koNumber, extraKey->info1, projPosX, projPosY, koNormal, 0, 2);
						}
	                    
						addOverlay(koSprite, SPRITEHQR_KEY, 10, 30, koNormal, 0, 2);

						inventoryNumKeys += extraKey->info1;
						extraKey->info0 = -1;
	                    
						extra->info0 = -1;
						magicBallIdx = addExtra(-1, extra->X, extra->Y, extra->Z, SPRITEHQR_KEY, 0, 8000, 0);
						continue;
					}
				}
				if (extraKey->info0 == -1) {
					int32 spriteIdx = SPRITEHQR_MAGICBALL_YELLOW_TRANS;

					if (extra->info0 == SPRITEHQR_MAGICBALL_GREEN) {
						spriteIdx = SPRITEHQR_MAGICBALL_GREEN_TRANS;
					}
					if (extra->info0 == SPRITEHQR_MAGICBALL_RED) {
						spriteIdx = SPRITEHQR_MAGICBALL_RED_TRANS;
					}

					extra->info0 = -1;
					magicBallIdx = addExtra(-1, extra->X, extra->Y, extra->Z, spriteIdx, 0, 8000, 0);
					continue;
				}
			}
			// process extra collision with actors
			if (extra->type & 0x4) {
				if (checkExtraCollisionWithActors(extra, extra->actorIdx) != -1) {
					// if extra is Magic Ball
					if (i == magicBallIdx) {
						int32 spriteIdx = SPRITEHQR_MAGICBALL_YELLOW_TRANS;

						if (extra->info0 == SPRITEHQR_MAGICBALL_GREEN) {
							spriteIdx = SPRITEHQR_MAGICBALL_GREEN_TRANS;
						}
						if (extra->info0 == SPRITEHQR_MAGICBALL_RED) {
							spriteIdx = SPRITEHQR_MAGICBALL_RED_TRANS;
						}

						magicBallIdx = addExtra(-1, extra->X, extra->Y, extra->Z, spriteIdx, 0, 10000, 0);
					}
					
					extra->info0 = -1;
					continue;
				}
			}
			// process extra collision with scene ground
			if (extra->type & 0x8) {
				int32 process = 0;

				if (checkExtraCollisionWithBricks(currentExtraX, currentExtraY, currentExtraZ, extra->X, extra->Y, extra->Z)) {
					// if not touch the ground
					if (!(extra->type & 0x2000)) {
						process = 1;
					}
				} else {
					// if touch the ground
					if (extra->type & 0x2000) {
						extra->type &= 0xDFFF; // set flag out of ground
					}
				}

				if (process) {
					// show explode cloud
					if (extra->type & 0x100) {
						addExtraSpecial(currentExtraX, currentExtraY, currentExtraZ, kExplodeCloud);
					}
					// if extra is magic ball
					if (i == magicBallIdx) {
						// FIXME: add constant for sample index
						playSample(86, Rnd(300) + 3946, 1, extra->X, extra->Y, extra->Z, -1);

						// cant bounce with not magic points
						if (magicBallNumBounce <= 0) {
							int32 spriteIdx = SPRITEHQR_MAGICBALL_YELLOW_TRANS;

							if (extra->info0 == SPRITEHQR_MAGICBALL_GREEN) {
								spriteIdx = SPRITEHQR_MAGICBALL_GREEN_TRANS;
							}
							if (extra->info0 == SPRITEHQR_MAGICBALL_RED) {
								spriteIdx = SPRITEHQR_MAGICBALL_RED_TRANS;
							}

							magicBallIdx = addExtra(-1, extra->X, extra->Y, extra->Z, spriteIdx, 0, 10000, 0);

							extra->info0 = -1;
							continue;
						}

						// if has magic points
						if (magicBallNumBounce == 1) {
							if (!magicBallAuxBounce--) {
								int32 spriteIdx = SPRITEHQR_MAGICBALL_YELLOW_TRANS;

								if (extra->info0 == SPRITEHQR_MAGICBALL_GREEN) {
									spriteIdx = SPRITEHQR_MAGICBALL_GREEN_TRANS;
								}
								if (extra->info0 == SPRITEHQR_MAGICBALL_RED) {
									spriteIdx = SPRITEHQR_MAGICBALL_RED_TRANS;
								}

								magicBallIdx = addExtra(-1, extra->X, extra->Y, extra->Z, spriteIdx, 0, 10000, 0);

								extra->info0 = -1;
								continue;
							} else {
								processMagicballBounce(extra, currentExtraX, currentExtraY, currentExtraZ);
							}
						}
					} else {
						extra->info0 = -1;
						continue;
					}
				}
			}
			// extra stop moving while collision with bricks
			if (extra->type & 0x10) {
				int32 process = 0;

				if (checkExtraCollisionWithBricks(currentExtraX, currentExtraY, currentExtraZ, extra->X, extra->Y, extra->Z)) {
					// if not touch the ground
					if (!(extra->type & 0x2000)) {
						process = 1;
					}
				} else {
					// if touch the ground
					if (extra->type & 0x2000) {
						extra->type &= 0xDFFF; // set flag out of ground
					}
				}

				if (process) {
					int16 *spriteBounds;

					spriteBounds = (int16 *)(spriteBoundingBoxPtr + extra->info0 * 16 + 8);
					extra->Y = (collisionY << 8) + 0x100 - *(spriteBounds);
					extra->type &= 0xFFED;
					continue;
				}
			}
			// get extras on ground
			if ((extra->type & 0x20) && !(extra->type & 0x2)) {
				// if hero touch extra
				if (checkExtraCollisionWithActors(extra, -1) == 0) {
					// FIXME: add constant for sample index
					playSample(97, 0x1000, 1, extra->X, extra->Y, extra->Z, -1);

					if (extra->info1 > 1 && !(loopPressedKey & 2)) {
						projectPositionOnScreen(extra->X - cameraX, extra->Y - cameraY, extra->Z - cameraZ);
						addOverlay(koNumber, extra->info1, projPosX, projPosY, 158, koNormal, 2);
					}

					addOverlay(koSprite, extra->info0, 10, 30, 0, koNormal, 2);

					if (extra->info0 == SPRITEHQR_KASHES) {
						inventoryNumKashes += extra->info1;
						if (inventoryNumKashes > 999) {
							inventoryNumKashes = 999;
						}
					}

					if (extra->info0 == SPRITEHQR_LIFEPOINTS) {
						sceneHero->life += extra->info1;
						if (sceneHero->life > 50) {
							sceneHero->life = 50;
						}
					}

					if (extra->info0 == SPRITEHQR_MAGICPOINTS && magicLevelIdx) {
						inventoryMagicPoints += extra->info1 * 2;
						if (inventoryMagicPoints > magicLevelIdx * 20) {
							inventoryMagicPoints = magicLevelIdx * 20;
						}
					}

					if (extra->info0 == SPRITEHQR_KEY) {
						inventoryNumKeys += extra->info1;
					}

					if (extra->info0 == SPRITEHQR_CLOVERLEAF) {
						inventoryNumLeafs += extra->info1;
						if (inventoryNumLeafs > inventoryNumLeafsBox) {
							inventoryNumLeafs = inventoryNumLeafsBox;
						}
					}

					extra->info0 = -1;
				}
			}
		}
	}
}

/** @file extra.h
	@brief
	This file contains extra (bonus, projectils, keys, etc.) routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "sys.h"
#include "actor.h"

#ifndef EXTRA_H
#define EXTRA_H

#define EXTRA_MAX_ENTRIES		50

typedef struct ExtraListStruct
{
	int16 info0; // field_0
	int16 X;
	int16 Y;
	int16 Z;

	int16 lastX; // field_8
	int16 lastY; // field_A
	int16 lastZ; // field_C

	ActorMoveStruct trackActorMove;

	int16 destX; // field_E
	int16 destY; // field_10
	int16 destZ; // field_12
	int16 type;  // field_14
	int16 angle; // field_16
	int32 lifeTime;
	int16 actorIdx; // field_ 1C
	int16 strengthOfHit; // field_1E
	int16 info1; // field_20
} ExtraListStruct;

ExtraListStruct extraList[EXTRA_MAX_ENTRIES];

enum ExtraSpecialType {
	kHitStars = 0,
	kExplodeCloud = 1
};

int32 addExtra(int32 actorIdx, int32 X, int32 Y, int32 Z, int32 info0, int32 targetActor, int32 maxSpeed, int32 strengthOfHit);

/** Add extra explosion
	@param X Explostion X coordinate 
	@param Y Explostion Y coordinate
	@param Z Explostion Z coordinate */
int32 addExtraExplode(int32 X, int32 Y, int32 Z);

/** Reset all used extras */
void resetExtras();

void addExtraSpecial(int32 X, int32 Y, int32 Z, int32 type);
int32 addExtraBonus(int32 X, int32 Y, int32 Z, int32 param, int32 angle, int32 type, int32 bonusAmount);
int32 addExtraThrow(int32 actorIdx, int32 X, int32 Y, int32 Z, int32 sprite, int32 var2, int32 var3, int32 var4, int32 var5, int32 strengthOfHit);
int32 addExtraAiming(int32 actorIdx, int32 X, int32 Y, int32 Z, int32 spriteIdx, int32 targetActorIdx, int32 maxSpeed, int32 strengthOfHit);
void addExtraThrowMagicball(int32 X, int32 Y, int32 Z, int32 param1, int32 angle, int32 param2, int32 param3);

void drawExtraSpecial(int32 extraIdx, int32 X, int32 Y);

/** Process extras */
void processExtras();


#endif

BCÀŞ!  	  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  ï   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØ@€m À6Ä `b£øÿÿÿÿ`‡r˜‡yhx‡r‡t˜‡rhs€‡vr Ì!ØaÊ ÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú y¨‡r wx‡60y‡v(‡6€‡wHw ‡r‡6(vH‡vhwxwhv(‡p0€p‡whƒtps˜‡60xhƒvz@ÀÂæ¡ ÂŞ¡Ü!ÜaÚÀà¡Ú!è sv˜‡r ˆy ‡p‡uhx‡w ‡rzxyhq¨s0‡r‡6˜‡tĞ‡r ğ  êÁæ!Ì¡ÚÀà¡Ú!è sv˜‡r ˆz˜‡rhƒyxs ‡60vx‡p ÀÂæ¡€µaüÿÿÿÿ H E°C9ÌÃ<´<ÈC9ŒC:ÌC9´9ÀC;„9 æì0å îğm`òíPm ïî@å mPìí Ğƒ<ÔC9 ƒ;¼C˜ƒ<„C;”CÀÃ;¤ƒ;ĞC9ÈC”;¤C;´;¼ƒ;´;”C8˜@¸Ã;´A:¸ƒ9ÌC˜<´A;„= `áÀóP áïĞîî0m`ğĞíô€€9„;ÌC9 Ä<ĞC8ŒÃ:´<ÈÃ;ĞC9Œ=¼ƒ<´8Ôƒ9˜C9ÈCÌC:èC9 x õàóæPm`ğĞíô€€9„;ÌC9 D=ÌC9´Á<¼ƒ9ĞC˜;¼C8Ğ`áÀóPÀâ  l ¶H Û@(€m0–ÿÿÿÿ 	  I  	   ‚`!D1!(&ÆDˆI”bÂ Ä„`™pq ‰ ‰   œ   2"È	 d…“#¤„“#ã„¡LŒ„äLÜÃ” 
d	€s`p–4E”0ùš09‘éT;E”0!  Î’¦ˆ&ß»¦(ib§ˆ&     0        Ræ@ˆ9$‡ISD	“ÏNÀ„ß;E”0¡`q™4E”0ùÖ "|`HìQÂ„‚)Î‘¦ˆ&~Si&$  ÇHSD	“?¿›s¡áñxœ&M%L¾Ö L‹0DÔÀN%LHpN’¦ˆ&_&'b§ˆ&dŒF¡P(G¡P(
…B¡P(
…B¡P(
‚£P(
…B¡P(
…Bbˆ$™„&T  IèBDp&‘
ÄI yú¡@ 2$ €‚FÉ¡ RZ(è”
J¥BV) Vr8è•Š]$M%L>+‘:H3¡  Ü"M%L>Ğ8"   àªAœÆ§Aí"iŠ(aòg§!Ø)¢„	³ H2İ9`F¹„RĞ,  _Î8˜ó&Hˆ‡ISD	“VD´ X‰H;E”0¡     @*éX’B¡P(
…%G J±  "b–¢P(
ä,D¡P(´K’Ò¡Kj¡P(PµËB¡@×R,…B²%(Ğ¶ …B¡P(
Ô-K¡P(
…B¡P o9
…B¡P(P¸ ËB¡P(
4.ÇÒR(
*cY(
:—bI-
”.B¡@ë"DÔ.CZ wA–      (>@Ô)€9‚     °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD 
èH‚Û ™8)xg…mà¬°œ¶Ó‚6PZĞJÚ@iA(-he…mà¬°œ¶³Â6pZĞJÚ@Ya81|g…mà¬°œ¶Ó‚6PfìÎ
ÛÀYa8-h¥m ´ ”¿³<pVØÎ
ÛÀYa8j£m ´ ”´Ò‚6PZĞÊŒİÀ™±83vgÆnàÌØœ´Ò‚6PZĞJÚ@iA(?Âe…mà´ ”´Ò‚6PZĞJÚ@iA(+l§m ´ ”»3c7pfìÎñÀ)‚8+lg…mà¬°œ¶Ó‚6PVØÎ
ÛÀYa8+lg…mà¬°œ¶“d<0ZĞJÚ@iA(MÈ#Jy`T1Œ,ç³Â6pº Ê
ÛÀ	“8eÔg…mà¬°œ¶3c7pVØÎ
ÛÀYa8+lçGx ü”áÒ‚6PZĞJÚ@iA(-h¥m ´ ”´Ò‚6PZĞJÚ@iA(-h¥m ´ ”¶Ó‚6PZĞJÚ@iA(-he…màÄY”¶S‡=PZĞJÚ@ÉÓ-h¥m ´ ”´Ò‚6PbøNÚ@iA(-he…mà´ ”´Ò‚6PZĞÊ
ÛÀYa8+lg…màìéœ´²Â6pş¸ÊŞÀYa8+lg…màÌØœ´Ò‚6P½Î!øÀY8‹â§m ´ ”¶³Â6pVØÎ
ÛÀ‰$(3vg…mà¬°œ¶³Â6pVØÎ
ÛÀYa8+l²¨      YZ     †,¯ À     C–X       €!Ë,      ÀÅ      `È‚@     0dÑ      ²ğ     Y| €     †,à  @     CU       €!/      ÀE      `ÈB      0d1      ²      Yp €     †,ê  @     C–X `    €!Ë,      Àå€     `ÈÂ@     0dÑ      ²¸     Yà€    †,ä À     C–X `    €!‹< P    À€     `È"@      8   2˜ LŒ	&GÆCŒ b€
# 4«$€ıÿÀ€ÿ?@ìÿúÿŠÿÿ@"BH`øÿ$ûÿˆşÿ ÿ?PØÿúÿüÿıÿıÿûÿúÿ2Œ b€cU
Àş@èÿLúÿ‡À@ÀAÿ åÿíÿúÿüÿúÿä É YF è2@š âŒ g€@# 4 Ò F (5@« j Ğk€b# t Ü íF È7@À  q€#     y     C„yHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   «  –¤Î² â4±e(‚³,ˆ„8lJŠà,"!N3t€ZÑ`&CDähÂˆÃ•®h‹¦Gšl 4×#ÍàX›3McÅĞ–wMÀ>„€ ‹I)”„4a@S9Íô"álTQQ€Hõ ME4“a'Å€€dª‹SÑ`%"Mæà<‘“¤$³BDÁT9Zƒ0âpi ¸z,+¾™-À<±:T3˜g€CIG,Ò`„æóXN¤¼È@8UDdg0ÏB˜HÓ€™$PQD4+DÈ3½ÀB¦á,ó¤!IÄ@˜,’@4„&LN$YÃÍ@D+b“µL9^3!–®h‹¦GZ#Ì³+ñÀdÒTD39f"¤ÒL’Ñ À0x×ÖA!ME4“a'Å”PH›s™–ƒ4ÑLN„µ@°ÆP!’+!F‡“FNBâ4F÷DäÈQ8ñËb¸KDHÄä]SH–Å‡ƒ„ÖHYiÀĞf¬Ä–¥1À<‘. Föà Ãà]Shƒ4†ñĞ6&I ó,„ÆÑD‹0„Y8³`+ÑDÔbaK°8‚²QEADfÔ,óhÂäDìD<¶%!ME4“a,’-,„9(Ï`,À<ax–@EÑLö9ËâXÄ 	“™h€#Ì³Rº ÒF³	TÍ”:2!N#6›3`éµ@`‰ÎâP’&LN›b€óDD…8”¤	“Éæ=Q!%±ÑâpÙb€óDD…8”¤	“Íf 	Tƒ+1D€µ9—­)’@4DHDNllŠ$‘#[›"	DC„DäÌö·HÑmŠd5KàL“Ã”D1Åf³Î49LI“l7KàL“Ã”D1Í6å ME4“aß’U8Ò„ÖÑÁm‹ôDÈD´@°¦À0€°,âpÅ! ±YÀ0›\’9‘#[Å! ²Í%™Ó!9³Å%™Ó!9±101­°h±VĞHÄ¤	“i±vTˆÁ
A4+!ÍDD¶ğ Ãà]S°! ÀbjŠ$aR"X$PQD4“&LN$6³Ó¦ 4„Å±m(aq CD€lœJCXÀ0ÛÍ@D›3McÆÖ9!I&` B ,ËæP@ØÌr‘£5#—e$ÏJ4½µ­P9^3!¦àê±¬øz6‘HÑ!9rH08Vl!‡t ƒcÉ&rH08Öl³ÔD\Œ4ƒcmÎ49T„Ù9’@4ÄI1š09‘d„ÊAD&LˆÓØÈ$ÀàXœ³,ˆ„8M‹=„ñ$QL¦CI„ CX%ÒV-óˆME4“aâD0– LGäXŞ5E€u=ED3±ÑâpÁ±@‹0„LÀ0x×Â ¡M$™Kt‘£5#×‰®¦VÚeÀÒPZ¼D4—¡,¡	“ÙSb ñ-€!Ùc€óDN’:ÒÌ
A4†	‘ólÎ49+DÑØg€#Ë‚4!ƒ8\À	!(Ş5E ç,"!N#Óá]S™#Ì³ @#ö MÄ5ÁH38VIT„…@À<!±HF´@°v!ME4“a'Å&™`€"	DC|`H–T,ûDÈDˆÍ@\Æ"DäxÍ„LX'²ÜêµXÄõ,Î@p‹Cì<Da%@MfD„$!aP‹0w ÏDDFä,ópTÍD˜­ÂĞ!‘aMÀÜá !±Ä4!!™Ä4‘ALš09Q‡HĞ„!<Oä„$iÂäDéYrÀc“V`/°P„Y-ÀÜá !Ùp 4D€Å>„€ { aKÑ9!Iœ³,ˆ„8MlLÑ9!Iœ³,ˆ„8lMÑ9!Iœ³,ˆ„8Ílˆ°Ë¢Q×æP@˜Ÿ#	DCœÓF€ HfP„4Å6Dä˜NEVP„4ÍÆ DD3QI“H2±Iì<Da”ôDÈDlÕHclÎ•N‘ÅL9Zƒ0âpu"Ë­^ëe@1Ò$›IõDD…8”‘³P!ÙIôDD…8”‘£5ÆB˜CÍ@D­óXo@ƒwM°9%YlÀ4×#ÍàX+bT„}<Ò!Á"ÑÁB˜p€ƒwMĞ‘c™€°,Ö§HÑ³Ó’A Oä$©#Å<‘“¤$d òDN’:ÒlHJæ8+DÑ˜k€3×#ÍàX%QLFÒDälÄTˆCEöõHO„L{ ƒc¥Sd£”0ÏBHé`HchÂäD’8Å ÅJ`mÎeUTDº  Ch #Ì³Ra­ÑD\Œ4ƒcµÎÃa{Ì,
Òš09‘58Oä$©#Å¬DcºKäLÀDhÂäDöp=‘“Â”:2!Nƒ6¬DcÒTD39vRLI …dN P¡	“u „<Â4±:óQM[`À#@c«ã0/Õµq=AÜ4Á
DCXs@'„ x×œ³,ˆ„8ŒL‡&LN$r@óD@H’wM Z$Ì³&ÒtÄ`k3ØTDN3½È@8UDdÇAL[„
{ aA‘$DÑ”£POaÒp‚â]SpÎ² â402[„ŠdˆP±ˆÃe‘ŠM‡“FN›d€âDÓá¤‘“È&×%"M6 8Ñt8iä$³ÕA9©#!â4-öF	TÍVDÄ
DCN29ÏŠÇ[N29ÏŠÇ$›N29ÏŠÇ4p S Íà]SfWJC1Üá !Ya@óD@H’&LN›m@Ä¤5ÆBhÍÀSD1iÂäD"M@#vĞ<‘#’¤	“ÍÆĞLÄ5ÁH38Vë<&–Ä”ˆqLvç0„ ¤HcPH#—)@ ÙõDD…8”T:Î“F„$I`¦"DäxÍ„L˜Ö†¥×Šœ4Oä„$iÂäD²õ(b“éPa|$qRÌì4„dnHCX!9±½!a…DäÈ‡4„‘3Û†„4ÑLN„CÒAH¦ Ës %b“Q1‡³8ğ|`HæĞ Ãà]S´GäXö2DähÂˆÃ¥µaéµ"gBËâ8éTD:E– 1€°,'ÅlÕ„‘HCXbÑF@#mÎe)ĞAD×LÈ„èjj¥aDMÄÅ9N4 0’Á<qM0Òµ"Æ1ÙQÈa·0Ş5E€w=‹3¶€È¤	“a   ’   H,      (@"£B	Ô@QF‘•EAGi”G9  3UÁÃLDUğÇ0Qü1ÌDT3UÁÃLDUğÇ0Qü1ÌDT3UÁÃLDUğÇ0AƒŠÀ`D0€Á Fß FŞ Fİ FÜ FÛ F0 ³	c¸!¨Ğ`–A0"ÆxCˆB0Q@ÅoH(d¸!øÀ`–a zÆ  fŒ7«°
ƒÁ  äŒñ† Â`0"H hŒ7¯ ƒ, iã 5Æ‚Y`ƒÁˆ` êÆ  lŒ7·ƒÁ  ã 7Æ‚]`ƒÁˆ` :ƒq ÆxCğo0@f0hÆxC q0@h0.  ÁoÌ¡#‚A hÆ  5ã:àÁ`D0 ÁÁ¸  ôc¼!p‡=18à%âaH…€ò`ºƒ1Ş@*òŒ7ó 
Úƒ1Ş€*öŒ7÷Ğ
Œƒ pBIŠà PŒñ†€da0"€@aF¨B  ³Ç,AA¡0,ÀFŒB0 ³Á`+à ÌÄ
 ƒp      v°L@d“&LNd’b“qM`ø\ìCƒÍ±Ñ²Õ³ÙHS8´É €09‘8\–ĞHSD4Æt EˆL       a   X   H,      (á€*(*”@YYH”Aq”Fy    3UÃLDUàÇ0Qø1ÌDT~3UÃL=ø1FÖ FÕ FÔ Fs0 ³	c¸!xĞ`–A0"ÆxCŠØA0Q@Åoğ (d¸!¸À`–a RÆxCĞ}0x@Ìoş Œ> gŒ7¡ F¤  D @ÒoJA#‚A è €¬1Ş¤BFƒ 6.  ic¼!h2Œ nŒ7¯Pƒ …É¤oŒ7²pƒÁ0 c¼! 4ŒnA ˆÆ`D 0KpÌTÃ: Á`Ä0KF¬ À,ÁAk 2   v(P×&Ä6ÈFÌf(      a   !   E,      ¨ B	Y  3UAÃL=ô1Fd0 ³	c¸!(Ğ`–A "Æxƒ~œA0Q@ÅoÒ #‚F èãÁ(ƒ# ³)ÃƒL0 ³†   †P×v      a   U   A,      T("(‹B(…2(†’(ˆ¢(ŒÒ 3ôPÜÇ0Q÷1ÌDTÅ}3UqÃLDUÜÇ0QX0AT01P0!L0H@Åoè ¢@\P
¨½  ƒE  ´Œñ†@0
9c¼!èl0"€ 1ŞüG iŒ7¢ÀFƒ P5ÆRè(„ñ†à¾Áˆ` ºicÄÀ €rT! ¶
A.  }c¼!p…2Œ cÄÀ  vˆ! 0 €Ê`Œ7´ ƒÁ  T&ã PŒñ† Ú`0"€Î`\  jƒ1ŞğFƒ ›L‚ƒ1Şü‚FÃ `8   	   &P×6@T@T} Q‘mõDD·Ùá        a      L,   
   (‰B(R B	YYA”GiGÔ@ A
 D¡   3U¡ÃLDUèÇ0Qú1ÌDT…~3U¡ÃL„Uè‡0A…~ƒ‡7 ƒF7 ƒ7 ƒÄ6 D{\ €Áˆ"€ÁÃ`–  c7Ì2K@Èo ‘P#` ãÁ(Œâ‚‚7Ì2I@ gŒ7©
ƒÁ  ñ†`¸ÁˆÀ€ª1Ü´Ì2E@Ôo^#‚7 âÆ  lŒ7³àƒÁ  ô @Üoná#‚A HÆ  0ãÁ.ÈÁ`D0 ‰Á1 À*p³À@0b0 @>Tğ6b€ €?CÀo@h0Æ‚qÈƒÁˆÀ€êdÒŒñ†Àö`0"€Ú`Œ7èÀƒÁ)À,ÁBr0†‚R ƒYã(ÆxCÀ¥0¨‚ PŒ @u0ÆxX…Áˆ` âƒq (ÆxC@¬0@0.  õÁoğá#‚A èÆxC °0ôƒ «L…1Şôƒ,FÃ )Œñ†àfa0"à˜%Xf	Y‚d–@!Tğ#T!€Y‚ Ã 	   V@LØCØ£@A\S˜|@Û|@ }@0›£ Q,€a    a   s   H,      (ñ@‚~ B	Ô@yYYATiG   3U±ÃLDUìÇ0Qû1ÌDTÅ~3U±ÃLDUìÇ0Qû1ÌDTÅ~3U±ÃL=û1F$Ş F İ FÜ FÛ FÚ FÙ FØ F{0 ³	c¸!˜Ğ`–A0"ÆxCŒøA0Q@Åo@(d¸!àÀ`–a jÆ  fŒ7§p
ƒÁ  äŒñ† ¾ÁˆÀ€°q HãA+œÁ`D0 mã 5Æ‚X0ƒÁˆ` òÆ  mŒ7µƒÁ  ÄƒAb0F ¨‡AØ èã.ÈÁ`DĞ@l2IÆxCĞo0@d0Æ‚_€ƒÁˆ`€Ğ`\  Bƒ1ŞŒÃFƒ ĞŒÁ: `–à˜%(ˆ†  ‚Á7`– Œ°P €Y‚ƒì d      VP<@0v@LØCØ£@A\S˜}@4ÆB˜|@Û|@ }@0~À8%iŒC5“9
     a   ƒ   H,      (LÂ *”@YYA”GiG   3UÑÃLDUôÇ0Qı1ÌDTE3UÑÃLDUôÇ0Qı1ÌDTE3UÑÃLDUôÇ0Qı1ÌDTE3ôPôÇ0ÁˆÁ F,a0 ƒ
À`DòÀ`âÀ`ÄÑÀ`„ÁÀ`D±À`¡À`ÄÀ`„ğ0K0†f# bŒ7Ôˆ(ƒE0 TŒñ†€HqAA†f" h\  bÆxC°
«0@ÎoZA#‚3 ÒÆ  iŒ7±ƒÁ  Ô @Öoj!#‚A Æ  mŒ7¹ÀƒÁ  ÄƒAc0hÁ1@ `
bƒq hÆxC t0@t2ÉÆxCPv0@s0.  ©ÁoÒ!#‚A ˆÆxC°z0¸ƒ ĞŒÁˆ= `–à˜%(†¦ ‚Á9`– ŒèS €Y‚ƒú d     ¶ĞHSD4Æt EˆL6)P×&) f`HO„L„Í±Ñ²Õ³İÙ†@T@t[~ Qnò LN$—éå      a   “   H,      (@"£B	Ô@QF‘•EAGi”G9  3UÁÃLDUğÇ0Qü1ÌDT3UÁÃLDUğÇ0Qü1ÌDT3UÁÃLDUğÇ0AƒŠÀ`D0€Á Fß FŞ Fİ FÜ FÛ F0 ³	c¸!¨Ğ`–A0"ÆxCˆB0Q@ÅoH(d¸!øÀ`–a zÆ  fŒ7«°
ƒÁ  äŒñ† Â`0"H hŒ7¯ ƒ, iã 5Æ‚Y`ƒÁˆ` êÆ  lŒ7·ƒÁ  ã 7Æ‚]`ƒÁˆ` :ƒq ÆxCğo0@f0hÆxC q0@h0.  ÁoÌ¡#‚A hÆ  5ã:àÁ`D0 ÁÁ¸  ôc¼!p‡=18à%âaH…€ò`ºƒ1Ş@*òŒ7ó 
Úƒ1Ş€*öŒ7÷Ğ
Œƒ pBIŠà PŒñ†€da0"€@aF¨B  ³Ç,AA¡0,ÀFŒB0 ³Á`+à ÌÄ
 ƒp      &) 6)P×vàL@d“&LN$—á p±A6ÄFÈVÌfHO„L„8\&€ ÂäDâpY~@#MÑÓ!2     a   &   H,      T("+† 3U!ÃLDUÈÇ0A…|ƒÀ,A@Ân4˜eŒ€ˆ1Ş gFÁ P1Æ‚4H
Än0˜eˆ€–1Ñ 0KpÌÄ$F8Á Ìƒ ³= ƒp      †P×v      a   €   H,      (`ŸD(2*”@”A‘•EAqEy”Ca 3U±ÃLDUìÇ0Qû1ÌDTÅ~3U±ÃLDUìÇ0Qû1ÌDTÅ~3ôPìÇ0x0qt0ap0Ql0Ah01d0!ìÁ Ì$Œá†`BƒYÁˆã1âÁ`D c¼! P @\Pá†€ƒY†¨ €˜1ŞœÂ)Fƒ 3Æ‚Tø#3 ‚ÆxC°
`0¸‚ 6.  Qc¼!x…4Œ m\  ÂÆxC0g0@Ş¸  Äñ†àŞ`0"€À`\  ƒ1Şì‚Fƒ Œñ† Ş`0"Ø 2ãÁ/ÀÁ`D @f0Æ‚pˆƒƒÃ D‚ş rƒAm0ˆÆx”C0Ş˜(P .(ÅÁoèuÆ‚u
Ä18  %˜Å.  ÙÁoâ#‚A (Æ`D( 0KpÌ¤ÃW Á`0KFŒ‚+ À,ÁA£ 2      æ( ö(P×6ÄFÈVÌfHO„L„8\&€ ÂäDâpÙ} B\SˆÃ    a       Q,      („R( B	Ô@!AU1”UA”FQJ)    3UÑÃLDUôÇ0Qı1ÌDTE3UÑÃLDUôÇ0Qı1ÌDTE3UÑÃLDUôÇ0¡ˆÁ F$a0 ƒÀ`ÄñÀ`„áÀ`DÑÀ`ÁÀ`Ä`À`„ğ0X@-".(È0MµôG "BˆÿAFÙ F× Ìƒ5 ƒÄ4 ³Å`D!À`À,A1Q@0A<0KP‹ˆ
bÁ‚
"² Á Œ˜‘@ ˆFÄnRfŒ#Œ°V€Y‚cÄ` €_Œh‚ f7c³HFäÀ,AB9".(È0O8µ¡ôÇ"Lˆ0ÿÁ¤HCÚ m6È´Úmƒ¶AÚ1h àp!A£ !¸  ƒeÀ,3A&v  TƒÊ`P
ƒAf0È™Á 3TcÄ  }‡9Œ‚„à FÀI  ³Î`Dœü F¼I( ÁÁ 8ƒØ`PŠƒAq0(ÁÁ1h  $Ü!A£ !¸  ƒ{À,C{0híÁ ;dcÄ €”¨‡‚„à FˆJ  ³‘Š¸  ÃA>˜Á,Ãt*¢Z€ÁˆT	`– Âp     V`<@0µİŒmøÆD s[¤€ ËÂ>2fP ±&Ä6ÈFÌ&)ÀÀ²°SD4ÆtØ¤ B\SˆÃ     a   ÷   T,      T(B(@ú
¤ 3}PàÇ0Qø1ÌDT~3UÃLDUàÇ0Qø1ÌDX~3VÂL„Uà‡0Qø1ÌDT~3UÃLDUàÇ0Qø1ÌDT~3UÃ`¤À`Ä“À`„ƒÀ`DsÀ`cÀ`ÄR Ac<!¨#¤` HƒM  4ñ„ Œ¨‚ A\P’†	*àò FP Ğ6Æ0Œè‚ A\PÒ†	* ƒ¼  ƒ[  ƒ3R0!#d0 ƒ1R0#d0 Ä‰
B¸  4cÄÀ  u „€|dFˆA0 $&ƒÔ`˜€`0‚‚ 2ô#c¸AĞ`–!Bƒ1!&Á Ì”ƒÄd7Ì2D@l0#Ê$€Y‚Ø`P™Œá!@ƒY†ÂèÆ`š0K`B“1Ü f0Ëp ÍÁŒX“` f	Áˆ8… :ƒq ÕÁŒˆƒ` f	šƒA{ .(ÈpÃ Á,ƒ2D
c<!H…ÁS€qAAh†	*h…¼  ƒ¥ ±ÂOba0Â‚ A\PZ…aB ‚
j!/ À`+@¦0#T! 2…1¡
Á *Œ 0A* P*Œ 0Q* Ğ,ˆ
B´ .(éÂ10  ,! ZôÃ„ ƒ´ åÊ p& Œ°…` èÙÊn4˜eX˜€taFäJ0 ³íÂ \ÃB`³/ŒÁ^	`–À!_Ä+c¸AĞ`–á
‡1ñ+Á Ì@$ƒ~e7Ì2DR@å0#Ä%€Y‰Îa\ €Áˆq	€Ğa\ €Ár	€Üa;j‡Aí0HÆˆ vQƒP<Fƒó ±‹¸  ƒô µ‹¸  ƒõÀ,ABö0. À`„¼@÷0. À`Ä¼@ú0H…Ä ”cÄ €Ò(ˆA0$   6(PT@ôó¦(€TÍ[}@!8‹}@ Û¢ "PQD4“löĞa„ÅD0Om‰JC1^3E!Ù|@[¡@"8ÌCMÄ›¡@"8ÌCMÄ Û} !!aˆŒ³œÃ<ÔD²	
DED3±ğ-,„
0Î2póP1Ä& Hğ-,     a   H   F,   	   T(ò( òÿ(…d(„Ò ËP† µQÔÆPµQÔ  3UQÃLDUÔÇ0Qõ1ÌDTE}3ôPÔÇ0Qõ1FÓ FÒ FÑ 1ÆH$‚Á" "ÆxC0s@¸  L:¡@Êæ(‚¢6‚ú¨ÔZ‘YÁu\:b À+TÁ×,AA.2Í@@Ño@!£`„`0‚
€¨1ÜˆÌ2D0aÁ Ì¤ÒacÄ  ]øáP!˜%(0   &(°H! ÀÒbaƒqM`„‰°8ÔĞ"aóAlòqM —Ñ2      a   n   G,      T("(‰‚(ƒ¢(„R(†Ò    3ôPØÇ0Qö1ÌDT…}3UaÃ`!À`ÄÀ`„ À`Dğ ƒŠ1ŞÄÁC¸  dŒ FÁ‚á†ÀÂ`–!bÆxC€â‚‚Ø!¸  $ñ†À¶Áˆ`€Y¨1Ş€ÂG¸  d²Æˆ ³0ÁpC`
a0Ë0qc¼!@2 @\P[…  €Ä`Œ7® ƒÁ  ³Á 1dc¼!…6 @\P ÆÁ(‚á†ÀÂ`–¡0bƒ1Şà‚P .(ˆíB‚ @r0Æ_ÀƒÁˆ`€Yƒæ`\  ²ƒ1ŞˆC(Fƒ ĞŒ @z0ÆsøƒÁˆ` Òƒq ÈÆxC ¨0@~0.  ‰ÂoÜÁ#‚A (Æ  Sã<´Â`D0 •Â¸  ¤
c¼!°‡VŒ T™Ô
c¼!È‡WŒ†Àp    &P×6ÄFÈVÌ     a   ™  7      ¨"(¢("+†â(ç*”@”EH”FaEqVQ•v@Yw@9 P	D!Cr `@‘`_Ù”BâPiÿ”ÿClBy”ÿ¿AJ‚r@ñ”D
Tùÿ @A? BauO±”ó 3U±ÃLDUìÇ0Qû1ÌDTÅ~3U±ÃLDUìÇ0AÅ~3U±ÃLDUìÇ0Qû1ÌDTÅ~3U±ÃLDUìÇ0Qû1ÌDTÅ~3U±ÃLDUìÇ0AÅ~3U±ÃLDUìÇ0Qû1ÌDTÅ~3U±ÃLDUìÇ0Qû1ÌDTÅ~3}PìÇ0¡ÑÃ Fdô0 ƒ=À`ÄE0aÑÃ Flô0 ³mc¸!À4˜el" nŒ7¨Ê=ƒY0 ”ñ† òqAA†‚XƒY†&òÆxCà¶@¸  ì‚7"³ÄŒñ†€$jqAAÆxC€¼@Á0" ñÊn‚4˜e(Œ€Ü`Œ7.áƒ<À,AMÌc¼!€	t @\P
PA‡šƒY$	ÈÆxC`61èƒ ÌÔáÁop(¤‚rĞá†€'Â`–AYr—I0Æ‚Ÿ˜
†AF p‹u°…Z.  •ÂoÊ¢,#‚A f	j‚NaŒ7gñˆ
RÁHèpC°a0ËÀpµÂoÚâ$(d0Â‚ XãA\¨â‚‚FäB0 Tc¼!¨– @\PÁ^€raŒ7yˆ
B-3ÉÆxCà2AÁ0"#Ê! *‡Aä0ÆÒX	
Ä±" Á  uãjÅ`D0 ±ÃoXÃ(„ÀfR<Œñ† 6Ê‚‚aD3FÜC0 dc¼!°› @\PÚ‡a ‚Áˆ~€úaP?Œñ† 7à‚qAA(n&‰ÄoÄÃ.(F!0#İÍ$”ãzğÃˆ f"¨`.rÄ€8 ül
Bp (&ÆxCª1@31Æ‚ù(
Ä¡Ó™„c¼!ÀÖ `„ÀŒ@Ôc¼!èÑ @\P+\  ‹1ŞŒˆnFƒ PYŒñ† D|ƒqAA†AƒY†¨	H-ÆxC "äA¸  ÃA‹ Á,Cäôc¼!x‘ô @\Pá† 6Ì`–!z¢‹1ŞĞÈzP .(ÈpCp#h0ËAåÅor>(d¸!Ø3˜eˆ¶€HcPúˆ
2Ü0`0Ë ]Á`DhÄÇ hŒñ†@LÄ„qAA†ú ƒY†‰
#Lƒ>`–€¢ÓãÁ™œ	â‚‚7÷³•F¬Æ}À,E¬1Æ61
Ä!Øãœ¤â‚‚mŒñ†€NV„qAAè6ÆˆÁ ¹Ò"Š!xÒxr #J(€Y‚‹vcŒ7{2#ˆ
RèpCğ'a0Ë€e…ÇoB%G(¤‚Ñ 0Q0K ÑyŒñ†àTNe0"X˜%Ğf	jb–€£ôãAª„	â‚‚TĞ:Ü´JÌ2t`ĞM‚1ŞÀ
™P0ŒB0ÜŒˆÌ2x_@õ1Æ‚Zi
Ä©àDô F Ì|³5Aû1Æ‚]™
Ä©€Et¸!ø•0˜e8(DÆxC.uBÁŒ‘` ˆDÆxC@.uB¸  ƒ& •ÈoĞ#t	Æ‚tÙ
Æ`DŒ@)2Æüˆ]‚ñ† ]J…‚a€`0¢F‚ ã£/ÁxC /¥BÁŒÀ‘` ¨FÆxCP/¯B¸  ”#c¼!ÈX¡@\P“Aa2F è™c‚Á	€xdP˜Œñ† dh…qAA¬BPA¨è`„˜@b2†Q1ƒY1@ƒ€Èd7£‚³c€­ÉoV†T(ÃÁË„Á,”A@m2¨MÅÉobFU(dÄà  Ÿ1Š ]f	Ê€öd8‰
2Ü0`0Ë`gFŒÓ¾À,ÁPŒñ† grf0"è˜%¨	Ú“1Şì½P .(Ê q# üÍ 6B0Á'Á ¨Œñ†@lÚeÄ€  ¶	#ü$ ò“1Ü”MÌ2¨Aƒ 20K *ƒDeŒ 0:Ú„OƒTeŒ7j32ˆ
bA‚ 0Q@ş4¨UÆˆ ¬7B@ 5hVÆxC07-C¸   ¸  ƒE  „RƒteŒ7z3ˆ
bA‚ 0Q@à2ÆĞ‘
ËoFÇeF ÓÄ& qd.ƒÊeŒ ğ:B0Ü@`0Ë°n¼ª)qAA†† fØ ‚Áœ‚˜%hr—1Ş¸ëFr# ³51Kğ³p@ğ2ÆØA
Ä©à_t¸! 0˜eˆRÈ^ÆxC`;gC¸  ãl•;Á`¼@û2Æ‚İa
ÄŒ¸—` è_ÆxCğ;yC¸  42c¼!½¡@\Pâ—1ŞœOèP .(ÌoÖGt(dÄà €j’"Œ8™` èdÅÌoâ‡t(ÄŠ ÄF´L0 Ô2c¸!3˜e;èeÆpC07h0Ë0v_ñ†`Z‡‚A5Æÿ±
‰ÖoBˆv(#
 ¨ë´NïD0B”3c¼! !İ¡@\Pá† |Ì`–ê  ŸãA
â‚‚Pk‚ÙŒñ†à…Ğ‡qAAH¶†	AHmÆxCPCìC¸  t[Ã„ # €Qs7c¼!à!ù¡@Ğx	/1b  @…Ğ b$F"4KP#
”‘õı‰‘‘İŒñ† Œî‡qAAH¼Ä±` Á Œ0¯@ ÈoÆxCFi4´ ĞêŒñ†`Öh0"x! ÖãAâ‚‚PìŒñ† TˆqAA¨vÆxCPG,D¸  # äR%Eà?x¤?xt #J,€Y‚š İãÁÑâ‚‚íŒñ†àpˆqAA¨ÄÆˆÁ âdŒ’FäN0 T>c¼!(%1  à•‚Áˆİ	€vg7¨³xpÁ`DïŒÑ ÌàõÎ ß# ˜“°JíØ öãA+™â‚‚XP„à F P˜ZŸ1b` À;Ñ’Ğ˜²Ÿ1ŞØQ .(ˆ. À`D ­Ù şãA/Ñâ‚‚XP€à F Ğñ†`œêˆA&4ÆsŠ£ƒÃ N*†R
„¥Ğ :dÄ  €w‚á†" ƒY†<àƒ€ŞlŒ7îJ’³1ŞÄS*Q0¨ÎÆxC@O§DÁ1P  Ÿş”`é {"ãÁ=µâ‚‚7´d³z°ÅĞoøÉ–(„@m˜„€nhŒ7"µKˆ
B¥6LB@=4Æ”ú%
Ä!U&!10 `¦š# 2ãÁK•‚lM­‰pŠ!¨©šª§Y‚=1P §j
æIjª¦ê‰ÒhŒ74¥Nˆ
Bµ&.(ˆ. À`D®@q4Æâ©Áˆ ¤€ühŒ7>åSƒH	 ÒoÀJŸ(„HiŒ7dÕOˆ
B¨4Æ´ú'
Ä1X €µ@*)‚xZ«vZ« 0o ÌÔÄ,AĞ(ñ†À­ÜŠqAA†“ƒY?…`0¢”Dj h–ÆxC0WsE¸  ÃAIÁ,Ã€B0¡J%5 ³ @¸4Æ¼Â+
ÄnP
fBA‚ÁˆWB©˜%ê¥1ŞôU_Fa% ôKc¼!ø«œ¢@\P§1ŞŒOQ .(ÓoNË§(„ziŒ, À^`¥B°Z-µZ `0ç˜%¨‰YR wãk™â‚‚T€S:ÜÈVÌ2”‚+DOƒêiŒ7µeVˆ
2bP  xÁpCàVa0Ë`
­PH2;qAA†† fN‚Áxr« ãÁoıâ‚‚7q³¨
Á`D=ÅÕ Ì¤‘ÔoÈ‹¼(d¸! +0˜eP…U#ô‰®`–`(¥ÆxC^£E¸  ÔRc¼!h/Ó¢@\PŠ©1ŞÄjQ .(™Ô1X ÀÆTK1„ ¾ôª¾. À`„è0KÀ
„Sc¼!À/üŒxK f	jb–ÀH§ÆxC _²E¸  ”–7ş³¯ĞÁ`Lı× PY*«Ae5h¬ÆxC0b½E¸  tVc¼!81ğ¢@\PZ«1Ş¬˜xQ .(ÈˆA 1ö8MRÃÁ‹…Á,,ÌB@q5Æ‚K/
Ä© ·t¸!¨±0˜e…X#Î
¾`–@f	lîjŒ77ö^ˆ
RoépC°ca0Ë@µP_ñ† Çê‹qAA*À-½  ƒE  ³µ0K`4Wc¸!³0˜e¸v¨´ÆxCPfıE¸  ü–7i³¸ÁÖ Ø[cÄà €S„àÄf	rhkPş‰
2Ü0`0Ë êŒ  jô–YĞ[  ÚãA½â‚‚Pnñ† ÏdŒqAA¨·ÆxCĞg4F¸  #
 œZz5:–Aâ‚‚7¢–³» Á`ÄlÍØ yñ†€ÔHqAA†ƒY^è…`0·ll f	zÒkŒ7©–jˆ
2ÜäÌ2øÂ/ƒ½•c0Kğä^c¼!p54£@\P’¯1ŞÈÚšQ .(Ù×ol­Í(„ÒkŒ, °oo¦B k?¦k `0âƒ@ ¨¿ÆxCĞk½6„š ÌÔ©a .(ÈpC g`0ËéĞ¢‚RƒÁˆ6nÊ-fÎA‚Áˆù¢³ ãA¹•â‚‚7w³ã@Á`~İÙ Ì©ØoÔMİ(d¸!Ğ30˜e(s#úKÏ`–ÀèÅÆxCğn©F¸  4cc¼!˜7V£@\Pº±1ŞÜ›«Q .(¥Ø1X €ç`M1„`ß@mß. À`* ñ†Àßüm0"7˜%¨	³Af6ÈÌ™Ù18 @æˆAf	Ğa– f	ÖÈlŒ7$Grƒº	À,AMÌ°Ã,A;™ñ†Àä|qAA*ø5nT.fÜ‚Áˆ[¹ 8gƒâlĞ›ñ†àåÒqAAhÎÆxC0sìF¸  tgc¼!¸9w£@\Pƒ zîqš¤†‚ƒY†w‡€úlŒ7=Woˆ
R¹épCva0ËğFÀ¿À,A<ÌÔÚoÆnß(¤uÓá†àìÂ`–aè! TãAÚ…â‚‚T@nz #Š@ f	èa– ˆÏÆpCğva0Ë`÷P;ƒdmŒ7r'wˆ
bÁÊ‰`<ÁÆ‚»À²ƒ¦ Õc0*¹³@Ş@@©6(Äˆ  €ÄmŒ7¢·sƒÁ  Dnc¼! =£@\P
HN/ À`DÀ,AMÌà©ÛoTOì(¤‚•Óá†ÀõÂ`–!f" xãì¡â‚‚TÀv:ÜĞ^Ì2Ì„>docÄ   ßÖn¸!¸=0˜eØ™(ßÆxC{sG¸  Ôoc¼!è=»£@\P
¹1Ş„ŞQ .(Èˆ ë×vnçwIä•ÜoÊoï(d¸!=3˜eàˆ,ƒQÁèépC°~a0ËàıPËñ† ıNqAA(.ƒaBš¹1ŞÌëQ .(Ùe0LB@97Æ‚üƒ=
Ä¡½†	AF  Á 9»1Ş€``{:Í@ĞibÄ@A€Êoğ3ÁÀüf	üÊnŒ7%”`@1P€ƒ‚ó3¿R0H?B»1Ş `€‚â‚‚7â³ÿ µİoZ0?
Ä!ÕÄ±` Á ŒpÍ  rÍ@\Pá†ÀïÌ`–$B"ŒˆÍ@ş`– $f	D‚ğnŒ78à`@¸  ÃøÁ,ÃH˜D@}7Æ‚æqAAH<ƒ1Ş„a ~FÁ yc¼!(ÃÀü(Ãú™Á,I”D@êŒñ† õŒÚo f	Jb–À$hõÆxC°†Áˆ
2Ü¸Ì2œÄJÔŸ¸  ÃAa0Ë€+Ğìñ†`ƒ(Ä‚D@$ˆ
bÁ ‚ 0¢A  „¢¸  ´¢¸  ÔŸ†ˆÀfRB%zÑ@\PòO `0BFƒ@ f	Tb–`%ÈüÆxC`Š)ˆ
2Ü¼` ³,Ñ­ßoV1Ã€qAAˆEqAA,@p #`4`– %hşÆxC0‹Á,ˆ
2Ü„a ³.áßop1pÃ€qAAˆFqAA,@p #p4€p4„r4d¸aÌ`–á%`" Ä`„ ÌÀÄ,AL	c¼!0ÇÀƒÁˆ@˜%‰Y‚™˜% ‰Y‚š †¢€`0ƒ` f	E   +ĞTÍä]SÈ+ĞTÍä]SÌF,p<‘#’dÈŒôDÈDlÕ’$Oä„$Õµå
@c,„É
HED3y×ìCCl³’@EÑLŞ5E ûÄ ¯@“‰Ãe›®€4ÆBÔæ+` ±¸@c,Dn¶ LN$—İ
@€09‘8\Ú4‚BF+P×,@<¤›«@€X¯@21ÖqÛ¯ B\Sf»ÃãH&, HO„L„8\»(Ò!!oÅŠôDÈDˆÃÕ® 21Öaµ‰ôDÈDˆÃeÆ‹ôDÈDˆÃUÓö*ĞTÍä]SÄ           /*
 * Copyright (c) 2009 Keith Bauer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "fcaseopen.h"

#include <stdlib.h>
#include <string.h>
#include <errno.h>

#ifdef WIN32
#include <direct.h>
#else
#include <unistd.h>
#include <dirent.h>
#endif

#ifndef WIN32

// r must have strlen(path) + 2 bytes
static int casepath(char const *path, char *r)
{
    size_t l = strlen(path);
    char *p = alloca(l + 1);
    strcpy(p, path);
    size_t rl = 0;
    
    DIR *d;
    if (p[0] == '/')
    {
        d = opendir("/");
        p = p + 1;
    }
    else
    {
        d = opendir(".");
        r[0] = '.';
        r[1] = 0;
        rl = 1;
    }
    
    int last = 0;
    char *c = strsep(&p, "/");
    while (c)
    {
        if (!d)
        {
            return 0;
        }
        
        if (last)
        {
            closedir(d);
            return 0;
        }
        
        r[rl] = '/';
        rl += 1;
        r[rl] = 0;
        
        struct dirent *e = readdir(d);
        while (e)
        {
            if (strcasecmp(c, e->d_name) == 0)
            {
                strcpy(r + rl, e->d_name);
                rl += strlen(e->d_name);

                closedir(d);
                d = opendir(r);
                
                break;
            }
            
            e = readdir(d);
        }
        
        if (!e)
        {
            strcpy(r + rl, c);
            rl += strlen(c);
            last = 1;
        }
        
        c = strsep(&p, "/");
    }
    
    if (d) closedir(d);
    return 1;
}
#endif

FILE *fcaseopen(char const *path, char const *mode)
{
    FILE *f = fopen(path, mode);
#ifndef WIN32
    if (!f)
    {
        char *r = alloca(strlen(path) + 2);
        if (casepath(path, r))
        {
            f = fopen(r, mode);
        }
    }
#endif
    return f;
}

void casechdir(char const *path)
{
#ifndef WIN32
    char *r = alloca(strlen(path) + 2);
    if (casepath(path, r))
    {
        chdir(r);
    }
    else
    {
        errno = ENOENT;
    }
#else
    _chdir(path);
#endif
}
/*
 * Copyright (c) 2009 Keith Bauer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifndef fcaseopen_h
#define fcaseopen_h

#include <stdio.h>

#if defined(__cplusplus)
extern "C" {
#endif

extern FILE *fcaseopen(char const *path, char const *mode);

extern void casechdir(char const *path);

#if defined(__cplusplus)
}
#endif

#endif
BCÀŞ!  Ø  ‚        #‘AÈI29’„%‹b€EB’BÄ28I
2D$H
!#ÄR€!r$Èˆb¨ ¨@Æğ   Q  ç   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l¨áÿÿÿÿ@(‚Êaæ¡àAÊaÒaÊ¡ÌÚ!È0‡p`‡y(€p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th€ä¡ÊÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú¡ÜáÜ¡Ø¡ÂÁ ÂŞ¡ÒÁÌaÚÀà¡Ú!è sv˜‡r wx‡6p‡pp‡yhs€‡6h‡p t Ì!ØaÊ æÂaÖ¡àAŞÊaèáä¡Ä¡ÌÁÊAÚ`ÒAÊÀ€¨w˜‡p0‡rhs€‡6h‡p t Ì!ØaÊ êaÊ¡æáÌÚÀØáÂ sv˜‡r 6Äÿÿÿÿ€P   I     ‚`B L†	 ‰   )   2"ˆ	 d…#¤„#ã„¡LŒŒ„ÄL¬Á’ ÷HSD	“ÿ‹èÿ‰¥7F Ğ@@ˆ¢ c Š€””)
ZF ŠĞäRˆ¢2EAÓIÒQÂäÿÿ€DÒ 3F PU« ‹Š2YAZ‹¸9(€k¤)¢„Éˆh&T ˆ|!´H b ˜ ‹Bú    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:DH #DB€Š@I  @ ìP„ J  `Èr      Àå @    €!‹€     C †     †,      Y      ²H@     0d¡€     `È‚     Àe@    €!K€     C–1 @    €!€     Y    2˜LŒ	&GÆC
4xmà   y     C2HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q      ¶`HS$%Ò	f‰ H„pHd „/M‘  0vPÇ€D¦p8ÑHdI! á<Dcˆ°81 ‘9(Ò	€DÌcEá<Dc†4EÑX@áKSTôÿD5Î¿80!NcGD Ã€D   a   -   E,      „Œ ”@1   3B3B3e€PÃLD†PÃ`¡À`Ä ƒˆ1bP €&ƒE0 TŒá† 	ƒY"(# tAÌDˆ ƒJ0 ÔZÆˆA a Ã³Â3(# œFHÁ Ì³I#ƒp       ¦D&A0Î@XFPXñ Ó       a   °   U,   
   Œ WyR^…P# TŒ e’!ÙP†  ’‘5@á    3‚3‚3‚3‚3‚3‚3h€`ÃL„`ÃLD†`ÃLD Ø0‘`0\@É1  À‚Áˆ$ JFÌD ƒK0 ´zÆˆA g ƒ6 äŒñ„ £ \€ÈpCğÁ,C # °6!@ÔOÀ`0Â
`–`1  à¼Áˆ* ÊÆxB ƒ mc<!(ƒÁˆ``0B3ƒ˜%#°2€ƒ æ`ƒÁ,€Y‚°1Ü˜AÌ2Q@ÜnÊ f#Œ 5 €YŠº1Ü¬AÌ2 I@`0F Ğƒ`0Ü  f	(ƒAg0Æa0"¨ƒ  3ÌF A0 „ƒØ`Œ'Â`DÀ@j0F …`0"‚˜%P(ÆpC@a0Ë°8±Á 6ãøÁxCĞ}0bP @*ÁpCğ`0ËÀ4áÁ ;ã	B@t0ÆR0…ñ† JaÄ   [ Âƒ1Ş ‚*Œ7©
# üB@ 0*`0B‚ P# ìB@§0F ø…`0¢‚˜%p¨Æˆ ¾FB0 ³
‘Ân^!f ' V´
c<AHÆˆA é Ä
cÄ€  x(FFÌB0 ƒ±ğ0K  À´°ƒ±À,A³0†^ƒYi
¨Æˆ ïÌLƒ½@ 0K@Q/€Â 	   6<&DvVfB,€4J@˜H°Xñ Óa$B´        a      D,      „”@Œ   3"3"ƒ‚1 $Œ ¨ f"
$#Š` ÈdŒƒ 0!n”0˜e„€’1b@ @Ì#dƒÁ3 ³†      fDA<Àt            /** @file filereader.c
	@brief
	This file contains file read routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "filereader.h"
#include "fcaseopen.h"
#include <ctype.h>

/** Feed buffer from file
	@param fr FileReader pointer */
void frfeed(FileReader* fr) {
	fread(fr->buffer, BUFFER_SIZE, 1, fr->fd);
	fr->bufferPos = 0;
}

/** Read file
	@param fr FileReader pointer
	@param destPtr content destination pointer
	@param size size of read characters */
void frread(FileReader* fr, void* destPtr, uint32 size) {
	if (BUFFER_SIZE - fr->bufferPos >= size) {
		memcpy(destPtr, &fr->buffer[fr->bufferPos], size);
		fr->bufferPos += size;
	} else {
		// feed what we can
		int8* tempPtr = (int8*)destPtr;
		memcpy(tempPtr, &fr->buffer[fr->bufferPos], BUFFER_SIZE - fr->bufferPos);
		tempPtr += BUFFER_SIZE - fr->bufferPos;
		size -= BUFFER_SIZE - fr->bufferPos;

		// feed the rest
		do {
			fr->currSector++;
			frfeed(fr);
			if (size >= BUFFER_SIZE) {
				memcpy(tempPtr, fr->buffer, BUFFER_SIZE);
				tempPtr += BUFFER_SIZE;
				size -= BUFFER_SIZE;
			} else {
				memcpy(tempPtr, fr->buffer, size);
				fr->bufferPos += size;
				size = 0;
			}
		} while (size > 0);
	}
}

/** Seek file
	@param fr FileReader pointer
	@param seekPosition position to seek */
void frseek(FileReader* fr, uint32 seekPosition) {
	uint32 sectorToSeek;

	sectorToSeek = seekPosition / 2048;

	fseek(fr->fd, sectorToSeek * 2048, SEEK_SET);

	fr->currSector = sectorToSeek;
	frfeed(fr);
	fr->bufferPos = (seekPosition - (sectorToSeek * 2048));
}

/** Open file
	@param fr FileReader pointer
	@param filename file path
	@return true if file open and false if error occurred */
int32 fropen2(FileReader* fr, char* filename, const char* mode) {
	fr->fd = fcaseopen(filename, mode);

	if (fr->fd) {
		fr->currSector = 0;
		frfeed(fr);
		return 1;
	}

	return 0;
}

/** Write file
	@param fr FileReader pointer
	@param destPtr content destination pointer
	@param size size of read characters */
void frwrite(FileReader* fr, void* destPtr, uint32 size, uint32 count) {
	fwrite(destPtr, size, count, fr->fd);
}

/** Close file
	@param fr FileReader pointer */
void frclose(FileReader* fr) {
	fclose(fr->fd);
}
/** @file filereader.h
	@brief
	This file contains file read routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef FILEREADER_H
#define FILEREADER_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "sys.h"

/** Number of sector in the buffer */
#define SECTORS_IN_BUFFER (3)
/** Buffer size */
#define BUFFER_SIZE (2048*SECTORS_IN_BUFFER)

/** File reader structure */
typedef struct FileReader {
	/** File descriptor */
	FILE* fd;
	/** Content buffer */
	uint8 buffer[BUFFER_SIZE];
	/** Current position in the buffer */
	uint32 bufferPos;
	/** Current sector in the buffer */
	uint32 currSector;
} FileReader;

/** Feed buffer from file
	@param fr FileReader pointer */
void frfeed(FileReader* fr);

/** Read file
	@param fr FileReader pointer
	@param destPtr content destination pointer
	@param size size of read characters */
void frread(FileReader* fr, void* destPtr, uint32 size);

/** Seek file
	@param fr FileReader pointer
	@param seekPosition position to seek */
void frseek(FileReader* fr, uint32 seekPosition);

/** Open file
	@param fr FileReader pointer
	@param filename file path
	@return true if file open and false if error occurred */
int32 fropen2(FileReader* fr, char* filename, const char* mode);

/** Write file
	@param fr FileReader pointer
	@param destPtr content destination pointer
	@param size size of read characters */
void frwrite(FileReader* fr, void* destPtr, uint32 size, uint32 count);

/** Close file
	@param fr FileReader pointer */
void frclose(FileReader* fr);

#endif
BCÀŞ!  †  ‚        #‘AÈI29’„%‹b€EB’BÄ28I
2D$H
!#ÄR€!r$Èˆb¨ ¨@Æğ   Q     f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l † X6„ ,@µ(şÿÿÿ $  I     ‚`B L¢   ‰   %   2"ˆ	 d…#¤„#ã„¡LŒŒ„ÄL”ÁÀ=ÒQÂäÿ"úbé Ì 	3Ì€ÁEÒQÂäÈB¬0"¢(È(pBC)
¥(Z
JAÍAP@QŠâ!¨ÀQTˆB(
¢
QŠBVE!¬À¡iE(âè ‚*H™ °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€C– €     †,     Y      ²D@     0d™      `ÈR     Àå      €!K€     C– €     †,     Y      ²t@     ‡     C/X ;„ƒ;œØC9ÈÃ<¤Ã;¸ÌĞŒPØì¡Ü È¡Ü¦     y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q      F`‘DŠ%…!aEÀ`GY2&`QD ƒ$… H„ó-…°8a
G	‹#`QAƒEä<DcÛ@¶,ã3#<˜ÿĞï?4ÂûÈm[AQH¡  a      A,      TŒ ”@‚   3_áƒ1 Œñ†À(Æ‚ã bŒ7IBÁ18 à"% dŒ728€á@     Æ         a   q   J,      TŒ ”@ XĞ3   3_3cP@ÃL„Ğ014FÍ FÌ FË 1Æ‚%¡`”c¸AÆ`–!J-c¼! 
9c¼!¨¨ñ†Àè# "×DĞ iŒ7FÁ¨€€Áˆ!€Y‚„¬1Q@Õ lŒ7`àQ0ˆãÁˆÁxC@}c¼!02 `T1b€ @,E€d@c0Æ5@
F¥ADc<!#Ì  Jƒ1ŞÀP0ê‚ 51ÑÁ Ìôc¼!°9 `Tp01@s0F H…€ä`7x0³DĞºƒ1ŞøA\ ìˆ ¬@}ğ{@w0Æ?ŒÈƒ` HF ƒ|À,A{0èÆxC`
¥p²
cÄ €Z(„ HBa)Œñ†`R‚QƒC0 ƒ¦à
0K`Ìd
c¸!x1˜e`– Áp     Öp„4¥SdB™!!aÇD0O:E        a   (   A,      TŒ ”@‚”A  3_ñ3bP<ÃL„Ï01(0!$@Â¨à˜Áˆ! *ÆxC°,2FŒŒ €ÁCÉ fŒ7Ò3@Î1  @r9£Jj‚¦1ŞdÕ`D0 †   Æ ‘U0!LNÔ:,A(ÖÀH¡¤„LˆÓ      a   *   D,      T”Á@	0   3bPDÃLÄWDÃLÄÑ01E4FË FÊ FÉ 0H# HB@Æo–e0"€1Ş4c¸!hÂ`–!bÆxCIƒ4 äŒ Æ Œ€$ ˜%# 	 f	‚@á@   Ö€ÈB4 C˜Á8aB      a      A,      T”À    3_3cP@ÃL„Ğ0!4FÊ FÉ FÈ FÇ Ğ0h4:ÆxC$Œƒ &£     Öp„4¥SdBÙC!8T3™!!     a      A,      TŒ ”    3_áƒ1 Œñ†€ (#  †    Æ             /** @file movies.c
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "flamovies.h"
#include "screens.h"
#include "sdlengine.h"
#include "main.h"
#include "sound.h"
#include "music.h"
#include "filereader.h"
#include "lbaengine.h"
#include "keyboard.h"

/** Config movie types */
#define CONF_MOVIE_NONE    0
#define CONF_MOVIE_FLA     1
#define CONF_MOVIE_FLAWIDE 2
#define CONF_MOVIE_FLAPCX  3

/** FLA movie extension */
#define FLA_EXT ".fla"

/** FLA Frame Opcode types */
enum FlaFrameOpcode {
	kLoadPalette	= 0,
	kFade			= 1,
	kPlaySample		= 2,
	kStopSample		= 4,
	kDeltaFrame		= 5,
	kKeyFrame		= 7
};

/** Auxiliar FLA fade out variable */
int32 _fadeOut;
/** Auxiliar FLA fade out variable to count frames between the fade */
int32 fadeOutFrames;

/** FLA movie sample auxiliar table */
int32 flaSampleTable[100];
/** Number of samples in FLA movie */
int32 samplesInFla;
/** Auxiliar work video buffer */
uint8* workVideoBufferCopy;
/** FLA movie header data */
FLAHeaderStruct flaHeaderData;
/** FLA movie header data */
FLAFrameDataStruct frameData;

FileReader frFla;

/** FLA movie draw key frame
	@param ptr FLA frame buffer pointer
	@param width FLA movie width
	@param height FLA movie height */
void drawKeyFrame(uint8 * ptr, int32 width, int32 height) {
	int32 a, b;
	uint8 * destPtr = (uint8 *)flaBuffer;
	uint8 * startOfLine = destPtr;
	int8 flag1;
	int8 flag2;

	do {
		flag1 = *(ptr++);

		for (a = 0; a < flag1; a++) {
			flag2 = *(ptr++);

			if (flag2 < 0) {
				flag2 = - flag2;
				for (b = 0; b < flag2; b++) {
					*(destPtr++) = *(ptr++);
				}
			} else {
				char colorFill;

				colorFill = *(ptr++);

				for (b = 0; b < flag2; b++) {
					*(destPtr++) = colorFill;
				}
			}
		}

		startOfLine = destPtr = startOfLine + width;
	} while (--height);
}

/** FLA movie draw delta frame
	@param ptr FLA frame buffer pointer
	@param width FLA movie width */
void drawDeltaFrame(uint8 * ptr, int32 width) {
	int32 a, b;
	uint16 skip;
	uint8 * destPtr;
	uint8 * startOfLine;
	int32 height;

	int8 flag1;
	int8 flag2;

	skip = *((uint16*)ptr);
	ptr += 2;
	skip *= width;
	startOfLine = destPtr = (uint8 *)flaBuffer + skip;
	height = *((int16*)ptr);
	ptr += 2;

	do {
		flag1 = *(ptr++);

		for (a = 0; a < flag1; a++) {
			destPtr += (unsigned char) * (ptr++);
			flag2 = *(ptr++);

			if (flag2 > 0) {
				for (b = 0; b < flag2; b++) {
					*(destPtr++) = *(ptr++);
				}
			} else {
				char colorFill;
				flag2 = - flag2;

				colorFill = *(ptr++);

				for (b = 0; b < flag2; b++) {
					*(destPtr++) = colorFill;
				}
			}
		}

		startOfLine = destPtr = startOfLine + width;
	} while (--height);
}

/** Scale FLA movie 2 times

	According with the settins we can put the original aspect radio stretch
	to fullscreen or preserve it and use top and button black bars */
void scaleFla2x() {
	int32 i, j;
	uint8* source = (uint8*)flaBuffer;
	uint8* dest = (uint8*)workVideoBuffer;

	if (cfgfile.Movie == CONF_MOVIE_FLAWIDE) {
		for (i = 0; i < SCREEN_WIDTH / SCALE*40; i++) {
			*(dest++) = 0x00;
		}
	}

	for (i = 0; i < FLASCREEN_HEIGHT; i++) {
		for (j = 0; j < FLASCREEN_WIDTH; j++) {
			*(dest++) = *(source);
			*(dest++) = *(source++);
		}
		if (cfgfile.Movie == CONF_MOVIE_FLAWIDE) { // include wide bars
			memcpy(dest, dest - SCREEN_WIDTH / SCALE, FLASCREEN_WIDTH*2);
			dest += FLASCREEN_WIDTH * 2;
		} else { // stretch the movie like original game.
			if (i % (2)) {
				memcpy(dest, dest - SCREEN_WIDTH / SCALE, FLASCREEN_WIDTH*2);
				dest += FLASCREEN_WIDTH * 2;
			}
			if (i % 10) {
				memcpy(dest, dest - SCREEN_WIDTH / SCALE, FLASCREEN_WIDTH*2);
				dest += FLASCREEN_WIDTH * 2;
			}
		}
	}

	if (cfgfile.Movie == CONF_MOVIE_FLAWIDE) {
		for (i = 0; i < SCREEN_WIDTH / SCALE*40; i++) {
			*(dest++) = 0x00;
		}
	}
}

/** FLA movie process frame */
void processFrame() {
	FLASampleStruct sample;
	uint32 opcodeBlockSize;
	uint8 opcode;
	int32 aux = 0;
	uint8 * ptr;

	frread(&frFla, &frameData.videoSize, 1);
	frread(&frFla, &frameData.dummy, 1);
	frread(&frFla, &frameData.frameVar0, 4);

	frread(&frFla, workVideoBufferCopy, frameData.frameVar0);

	if ((int32)frameData.videoSize <= 0)
		return;

	ptr = workVideoBufferCopy;

	do {
		opcode = *((uint8*)ptr);
		ptr += 2;
		opcodeBlockSize = *((uint16*)ptr);
		ptr += 2;

		switch (opcode - 1) {
		case kLoadPalette: {
			int16 numOfColor = *((int16*)ptr);
			int16 startColor = *((int16*)(ptr + 2));
			memcpy((palette + (startColor*3)), (ptr + 4), numOfColor*3);
			break;
		}
		case kFade: {
			// FLA movies don't use cross fade
			// fade out tricky
			if (_fadeOut != 1) {
				convertPalToRGBA(palette, paletteRGBACustom);
				fadeToBlack(paletteRGBACustom);
				_fadeOut = 1;
			}
			break;
		}
		case kPlaySample: {
			memcpy(&sample, ptr, sizeof(FLASampleStruct));
			playFlaSample(sample.sampleNum, sample.freq, sample.repeat, sample.x, sample.y);
			break;
		}
		case kStopSample: {
			stopSample(sample.sampleNum);
			break;
		}
		case kDeltaFrame: {
			drawDeltaFrame(ptr, FLASCREEN_WIDTH);
			if (_fadeOut == 1)
				fadeOutFrames++;
			break;
		}
		case kKeyFrame: {
			drawKeyFrame(ptr, FLASCREEN_WIDTH, FLASCREEN_HEIGHT);
			break;
		}
		default: {
			return;
		}
		}

		aux++;
		ptr += opcodeBlockSize;

	} while (aux < (int32)frameData.videoSize);
	//free(workVideoBufferCopy);
}

/** Play FLA PCX Screens
	@param flaName FLA movie name */
void fla_pcxList(int8 *flaName) {
	// TODO if is using FLA PCX than show the images instead
}

/** Play FLA movies
	@param flaName FLA movie name */
void playFlaMovie(int8 *flaName) {
	int32 i;
	int32 quit = 0;
	int32 currentFrame;
	int16 tmpValue;
	int8 fileNamePath[256];

	stopSamples();

	// Play FLA PCX instead of movies
	if (cfgfile.Movie == CONF_MOVIE_FLAPCX) {
		fla_pcxList(flaName);
		return;
	}

	stopMusic();

	// take extension if movie name has it
	for (i = 0; i < (int32)strlen(flaName); i++) {
		if(flaName[i] == '.') {
			flaName[i] = 0;
		}
	}

	sprintf(fileNamePath, FLA_DIR);
	strcat(fileNamePath, flaName);
	strcat(fileNamePath, FLA_EXT);

	_fadeOut = -1;
	fadeOutFrames = 0;

	if (!fropen2(&frFla, fileNamePath, "rb"))
		return;

	workVideoBufferCopy = workVideoBuffer;

	frread(&frFla, &flaHeaderData.version, 6);
	frread(&frFla, &flaHeaderData.numOfFrames, 4);
	frread(&frFla, &flaHeaderData.speed, 1);
	frread(&frFla, &flaHeaderData.var1, 1);
	frread(&frFla, &flaHeaderData.xsize, 2);
	frread(&frFla, &flaHeaderData.ysize, 2);

	frread(&frFla, &samplesInFla, 2);
	frread(&frFla, &tmpValue, 2);

	for (i = 0; i < samplesInFla; i++) {
		int16 var0;
		int16 var1;
		frread(&frFla, &var0, 2);
		frread(&frFla, &var1, 2);
		flaSampleTable[i] = var0;
	}

	if (!strcmp(flaHeaderData.version, "V1.3")) {
		currentFrame = 0;

		if (!quit) {
			do {
				if (currentFrame == flaHeaderData.numOfFrames)
					quit = 1;
				else {
					processFrame();
					scaleFla2x();
					copyScreen(workVideoBuffer, frontVideoBuffer);

					// Only blit to screen if isn't a fade
					if (_fadeOut == -1) {
						convertPalToRGBA(palette, paletteRGBACustom);
						if (!currentFrame) // fade in the first frame
							fadeIn(paletteRGBACustom);
						else
							setPalette(paletteRGBACustom);
					}

					// TRICKY: fade in tricky
					if (fadeOutFrames >= 2) {
						flip();
						convertPalToRGBA(palette, paletteRGBACustom);
						fadeToPal(paletteRGBACustom);
						_fadeOut = -1;
						fadeOutFrames = 0;
					}

					currentFrame++;

					fpsCycles(flaHeaderData.speed + 1);

					readKeys();

					if (skipIntro)
						break;
				}
			} while (!quit);
		}
	}
	
	if (cfgfile.CrossFade) {
		crossFade(frontVideoBuffer, paletteRGBACustom);
	} else {
		fadeToBlack(paletteRGBACustom);
	}

	stopSamples();
}

/*
void fla_pcxList(char *flaName)
{
	// check if FLAPCX file exist
//	if(!checkIfFileExist("FLA_PCX.HQR") || !checkIfFileExist("FLA_GIF.HQR")){
//		printf("FLA_PCX file doesn't exist!");
		//return;
	//}

	// TODO: done this with the HQR 23th entry (movies informations)
	if(!strcmp(flaName,"INTROD"))
	{
		prepareFlaPCX(1);
		WaitTime(5000);
		prepareFlaPCX(2);
		WaitTime(5000);
		prepareFlaPCX(3);
		WaitTime(5000);
		prepareFlaPCX(4);
		WaitTime(5000);
		prepareFlaPCX(5);
		WaitTime(5000);

	}
	else if(!strcmp(flaName,"BAFFE") || !strcmp(flaName,"BAFFE2") || !strcmp(flaName,"BAFFE3") || !strcmp(flaName,"BAFFE4"))
	{
		prepareFlaPCX(6);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"bateau") || !strcmp(flaName,"bateau2"))
	{
		prepareFlaPCX(7);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"flute2"))
	{
		prepareFlaPCX(8);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"navette"))
	{
		prepareFlaPCX(15);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"templebu"))
	{
		prepareFlaPCX(12);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"glass2"))
	{
		prepareFlaPCX(8);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"surf"))
	{
		prepareFlaPCX(9);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"verser") || !strcmp(flaName,"verser2"))
	{
		prepareFlaPCX(10);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"capture"))
	{
		prepareFlaPCX(14);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"neige2"))
	{
		prepareFlaPCX(11);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"sendel"))
	{
		prepareFlaPCX(14);
		WaitTime(5000);
	}
	else if(!strcmp(flaName,"sendel2"))
	{
		prepareFlaPCX(17);
		WaitTime(5000);
	}
}

void prepareFlaPCX(int index)
{
	int i;
	SDL_Surface *image;

	// TODO: Done this without SDL_Image Library
	if(checkIfFileExist("FLA_PCX.HQR"))
		image = IMG_LoadPCX_RW(SDL_RWFromMem(HQR_Get(HQR_FlaPCX,index), Size_HQR("FLA_PCX.HQR", index))); // rwop
	else if(checkIfFileExist("FLA_GIF.HQR"))
		image = IMG_LoadGIF_RW(SDL_RWFromMem(HQR_Get(HQR_FlaGIF,index), Size_HQR("fla_gif.hqr", index))); // rwop

	if(!image) {
		printf("Can't load FLA PCX: %s\n", IMG_GetError());
	}

	osystem_FlaPCXCrossFade(image);
}*/
/** @file movies.h
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef FLAMOVIES_H
#define FLAMOVIES_H

#include "main.h"

/** FLA movie directory */
#define FLA_DIR "fla/"

/** FLA movie header structure */
typedef struct FLAHeaderStruct {
	/** FLA version */
	int8 version[6];
	/** Number of frames */
	int32 numOfFrames;
	/** Frames per second */
	int8 speed;
	/** Unknown var1 */
	int8 var1;
	/** Frame width */
	int16 xsize;
	/** Frame height */
	int16 ysize;
} FLAHeaderStruct;

/** FLA movie frame structure */
typedef struct FLAFrameDataStruct {
	/** Current frame size */
	int8 videoSize;
	/** Dummy variable */
	int8 dummy;
	/** Unknown frameVar0 */
	int32 frameVar0;
} FLAFrameDataStruct;

/** FLA movie sample structure */
typedef struct FLASampleStruct {
	/** Number os samples */
	int16 sampleNum;
	/** Sample frequency */
	int16 freq;
	/** Numbers of time to repeat */
	int16 repeat;
	/** Dummy variable */
	int8 dummy;
	/** Unknown x */
	uint8 x;
	/** Unknown y */
	uint8 y;
} FLASampleStruct;

/** FLA movie file buffer */
unsigned char flaBuffer[FLASCREEN_WIDTH*FLASCREEN_HEIGHT];

/** Play FLA movies
	@param flaName FLA movie name */
void playFlaMovie(int8 *flaName);

#endif
BCÀŞ!  Å  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q     f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØ@°l0X€jAüÿÿÿÿ Hb£øÿÿÿÿ`‡r˜‡yhx‡r‡t˜‡rhs€‡vr Ì!ØaÊ ÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú y¨‡r wx‡60y‡v(‡6€‡wHw ‡r‡6(vH‡vhwxwhv(‡p0€p‡whƒtps˜‡60xhƒvz@ÀÂæ¡ ÂŞ¡Ü!ÜaÚÀà¡Ú!è sv˜‡r ˆy ‡p‡uhx‡w ‡rzxyhq¨s0‡r‡6˜‡tĞ‡r ğ  êÁæ!Ì¡ÚÀà¡Ú!è sv˜‡r ˆz˜‡rhƒyxs ‡60vx‡p ÀÂæ¡   I     ‚`Â Ä„    ‰   b   2"È	 d…“#¤„“#ã„¡LŒ„äLØÂ’€ô 
€© ˜# ƒ \$M%L>ç4b|ÈB ¯P0†ƒ`0ƒÁ`0ƒÁ`0!î‘¦ˆ&ÿÑÿKoŒ  EÂ .’¦ˆ&ÿCb%€ˆ±`Ô¸Lš"J˜ü¯Ô¾`ˆ˜ vŠ(aB ` G (B†D % d¡C æ ³¤)¢„ÉÿJ-$€ˆØ)¢„	  ÑĞ&ÉÔ!MÎ”ó%ˆH‰0 S"•R%ôƒXgISD	“¯	“™NE°SD	"4\# …€Š•60Ğ¬0ªÍÅ€Ãp…€9Ò•6¯°ùŠ3‹ 3°0"Á0 cƒ!Ë0HYƒc0 fƒ9¦ Î’¦ˆ&ÿ+5`…`§ˆ&dh4  @Ò    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD 
ò#p& €yÀ	™œxÀ)¡Œ“wÀY©Œ“wÀw(W`I  @ ìP®à’  € Ø¡`A<$  @>àœ¼NÏ>à;”+À‡$    H€œw@I€œ•zÀøq”w@ùq”w@I€œ•zÀâœ£~ÀYòœ%À9yœ§À™	œ“wÀ9yœ“wÀ9hŒw@ùq”w@ùq”w@I€œxÀI€œxÀI€œw@ùq”w@ùq”w@¹
	”“wÀùq”w@ùq”w@ùq”w@9yœ“wÀùq”w@I€œ-‘Àù	œ“wÀ9yœ“wÀ9yœ“wÀùq”“wÀùq”w@ùq”w@9yœ“wÀ‡,r  @     C:       €!‹      À%€     `Èb      0dÙ      ²ô     Yş €    †,¡ À     C–Q `    €!Ë      Àå      `ÈR
@     0d)      ²œ     YR€    †,« À     C–V `    €!Ë+ 0    À¥€     `Èò@     0dù      ²”     Yş €    †,£ À     C–R `    €!K 0    @   2˜ LŒ	&GÆCŒ f€# 4 Ã
Q@ zŒ Pd€(# dQÂÌ¿–ğ‹Xâ­ı›# ´ Î F H4@¤ 2 j€T# Ä ×   y     CXHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   3  öàÀÌ³-,„™)1¥ÀBLa'@MfD„$!aLÊ’D$ÙD!™áKSdFÎâ8GEÑL$YVó, ö- 0ÏBØQ,ÈciIñH&,„d4ÔADÖ Œ8\éŠ¶hªq¤…Ò	Àd M
,Ä4¶PøÒÕÆPøÒÙQøÒİ4‘ÓL/2ÎFˆdWà4M)°´Î
nšI$’‚<b3EM)’ ,Ä· öe2ÕADÖ Œ8\®ËŠ¯gÊ,+!1ØÌt‘£5#W'²Üêµ¡%0­“‹¡TODTˆCI!9q âP‘¥DODTˆCI!9Zc,„<–)/2ÎF‘³8Î“F„$I`òHO„L‹dDadŠà<+DÑØËt‘ã52aéŠ¶hªq¤}0ED3™”„¦¤dÃ°BDQ,°ÓD¬à¦™À!F,„™49q âP‘YEÀ`”0ÏBHé`HchÂäD’m0À<!µ@°õDä¤!IÄ@˜mRÎVG,ğE CBô 1MÄ
nGI“ÃX™Q !6¦¥H“ó° ó,„U1Oä„$}ÀF•-KÅøÁæ?4Âûğ>rÛ†Ô,óhÂäDìD<‘ÓL/2ÎFY3D€EØaB‘$DÑ”£POa	MJM_0„d\Ì³ Ø· ¦S!„u8À<!¥€!a6›@EÑL©#!â4b³9–NQöäDä¤!IÄ@˜İ,3MSÅÛÖR,ÀÿW‰H“Ò	Ìc9KàL“Ã”D1Í†³Î49LI“lŒ0ÏBHbó-€,Ò!ÑÁBØ!=ÒL… JM¦“LÎ³"Æ1Å¶“LÎ³"Æ1É6PÑ· Æ“LÎ³"Æ1Í–TˆÁ
A4+!ÍDDV0YN¤¼È@8UDÄ9fXKDël (æ4(fEÖâPRé8O’D$YÍr‘£5#—±H9^3!¦µaéµ"gKŠ¤ ÏC$Yu‘ã52a®ËŠ¯g"‡t ƒcÅ6rH08–l$‡t ƒcÍæ•H“ó˜”„¤DˆqL¦CI„5)ED3‘f%“t ƒcqÎ² â4-öö“,D1™%v-óˆME4“aâD0öeHS´©!$IÖµH“ó° ó,„d>Ç -ÂDähÂˆÃu¢«©•FÀ03DähÂˆÃ¥µaéµ"gCËâ8éTD:E¦	‘ólÎ49+DÑ@R,ÀF™Áñ 1M„i<€4)°ÓD¬à¦Ù
t‘ã52a'ºšZiM± !DÔ`0ÏBH,’-,„U$°p”49Œ­%BäHÒ„],‹#()°ÓD˜ØQDÎC4¶õ …L Àæ"DäxÍ„LX'²ÜêµaL”DhËDD0)°ÓD  a   ‚   S,      d¨ ÁP† î`¸  3„qÃLÄdœÄ01'1ÌDLÆI3“qÃLaœÄ0A'1ÌDÆI3ƒqÁLÄ`œD0¡@0‘<080Q,@ÅŒ(‚˜%hã	3Ñ@BŒ8‚ ŒXÒ` f	Z!áƒ7Ì2P@ÒOªÁ* Â`D 5áƒ7r€³D.0ˆÕA‚ 0A0İÁ Ì„ªÂn4˜e0€À`Œ'c0!Á Èã	F€A0 ƒÂ ³…Á° @01Á Ì³ÁOÔ`0"‚ !F„A ƒfP
0K ƒpA†† f–& 2¤c<!ƒÁ6`0B`–€¡6Ğ#Ş €Ye–À™%x†v ‚Á9`–@ 7Tc<A#æ €Á9`– ";ğ#ğ €á† Â`–!    FPXÈ0Æ Ö&ÎâD²,60<SdÇ@HS:EV`b“=,ÒDZ”HCd@Q,€Q[d@Q,€a       a      S,      d¨(e€á†; 3„aÃLÄd˜Ä01&1ÌDL†I3ŸaÂLa˜Ä0A&1ÌDL†I3ƒaÁLÄ`˜D01&F,Ñ F(Ğ Ğ2.ø,b0B	€œ1DƒP0 ôjÄ†°`ÁŒˆ H\`ˆñ,Œ˜‚Œ‚ l\ğY
ÄŒ¨‚ nŒ'ß`„À,A@ŞOÄ`0‚ !FdA F||0 ³}ƒ´pA†† f( 2ã	AFœA0 $„Ad0Æa0Â‚ 5ã	ÁF´A0 $„Áˆ2€Ê \`á†`Ì`–H‚Á7`…˜%(È¥A¸À ÃC€³PŒñ„ #î  ÍÁOø`0¢‚Œ† ˜%8è†~ ‚Áˆ<`– ˜%phÂ±\Bp #î  …1Â`„(@BŒÈƒ  #@Á`–@!P´áƒ7Ì2,M@}hÆxBÀ
ƒ¥À`„0À,C§0,pF¤B0 ³Ê,3Kğ*`ƒ¬À,@¨0ÈÆx‚F°B0 ƒ«À,ADª0,°F°B0 Ã;„Á,C    FPXÈ0¶ Æ6ÎâD²,60<Sd„¤ 9!Méd€qˆqLö°HMhQ"a‘E± Fm’E± †     a   ˆ   \,      t C	 BT BB”IA`AQĞd(#w0R‚C`¸ƒá 3“AÃLÄdÄ0A$1ÌDIƒB1 $c0B€1Ü<`0ËÁ`Ä0K Ğ1†‚f†" cŒ'Õ`À`„à0K@Ğ2,¸@0Ñ0K ÌƒÀ,ÁAÍn&4˜e@ª`0Âƒ˜%HÈÃ…³
Ğ3(ñ„àŒ‚Œ†  iŒ'a0Q@B jŒ'd0q0!0K°P6,0FlÁ Ì$äá†ÀÀ`–¡qÚqc<!@ƒ xaÖ€Ú€¼1°Á`0K0ÑŒ
ÚÀ†SƒY†
h‘ÁOà`Ä  r‚9 ƒ: 3ã	F A0 ³­Á¨àl¸!p…0˜eˆ¤€Ö`Œñ„ F `‡!Ø>èrƒ1ğÁ`0K ÍL³ÍÁ°à@0QÁ Ìtc¸!ø0˜e°¶`0âpa f	.ºƒ1ÜüÌ2`Z@v0Æ‚RŒÀƒ` #_€Y‚Œö`Xp
 Œèƒ` f	®Y‚Ã      &@„4Yd€!9T$ö $      a   §   R,      t CAE9`A	A!”BĞÀv0”†;(1”Q!†;î0”!†;î@“¡ˆ0ÜÁH	e@„á†;    3³` „01(1ÌDJ3“ÃLa Ä0ñ(!ÌD|JƒÀˆ ¤pˆ4b`  )Ü# @
7Ñ@Tƒ”1b` €)ä„.0ÈpC i0ËÁ,AD:1#’` f	Ja0¢	€–1hƒM0 ÔŒ>K¸ÀƒT0 ñ„ #¦` ¨
Â2Á08î@ D‘ˆJ$+¡˜DCÖ¸à³ˆÁ, ÊÆxB€|–1±@›¸À ¨ÆÎ  0ã	Áˆbˆ`Ä €t0ˆ ô`–à!»Ã„Á,ƒq#  ÃÀÁˆ ç ƒxq0KpÌ<Çƒ¥4# ´ƒğAøÁxƒÌÂ,P .0ÈxCØP .0Èxä‚P .0ÈxÃğ(P.0Äxƒü‚(P.0Äˆ ÷Ğ(Ì<ã} â@¸À # äC0KğŒƒ D"hj1Ü´Ì2,L@­1,xF¼F0 ³Ì,ÁC¡0F @‰@ja–à™%ˆh†² ‚ÁˆR€NaP)Œñ„@Œ8…` f	 B…A­.0ÈpÃ Á,Ã      Fğ8àÄ¶8‚Â"a“†0ÏBf€ÒPZpÎâDv0<Sd•†óÎ@Xf€"M@4qÎâDf0 Ô     a      A,      d( 3„AÃ`D0 †     6pp       a   ÿ   f  *   t«2J)Cq•I!”AA	ĞÀvâ0”qA†;î`ûù°ıxepáÆJØN6†20ÆpÃ†2®ÅpÃ†2.ÅpÃ†2$ÃpÃ†2¸Æp£%†B¸ÆpÃw ÉP×î`¸ÄPF"î`¤ÄPF"î`”}†2¸ÆpC%†2¸ÆpÃ$Èf[ì²-zÙÏl‹j4Ê¨Ãw  3„áÃLÄd¸Ä01.1ÌDL†K3ŸáÂLD-.ÌD|†K3ŸáÂ`¢0aüÁ Œ ĞP4†‚1 ƒY†@H# ÔB0KP# <ƒŠ(À,Á@Ê fŒ 0ÁpÃ Á,ä‚ÆxB P.0ÈpC`0ËPQƒ¬1ƒA,À,1KpĞ5,€FdÁ ÌãU,ÄÂˆA à¤ÁxÃ5³@İ1( @„`¼A³[1( €‚7Œø=€Áˆ¾À…oàpF (Òä`¸!Ğ…0˜eP’`– 5Æ`Di0b`  =œŒÂˆ ôpv 
# ĞÃiÄŒ @§q|0b`  =œôÁˆ ôpyĞ# ĞÃiìA\vÄÀ €z@À#Ê `–`¡2äc¸AĞ`–q‚ƒÁ ¬ˆÂÁ`G Ğ‡ÖFÊ@\`bƒ1Ş@åFÃ Ì4äÃ‚S Á`0K°Œ 0|`
ÃA:„Á,C<Á`¨Ã PŒá†`Â`– `– "9
c¸AÀ`–Aš‚Á;x…˜%èF @‰ƒ T‚xcPkŒƒ öA7ÆpC@`0Ë@aÁˆA *‘
}@y0†zƒY«
F ğ‡?˜%¸F è‡?˜%¸f	0Ò1ÜÜÂÌ2dZ0b0 À(Œ à­
# ôC(FøF.À`oÜÃ ÌhÔÃ\ Á`Ä@®.0ˆ» ‚ B"1 à7ÄpCàa0Ë°qÁ,Á7KĞÍxT
c¸!ø‡0¨@x–!ú‚Y0˜%’…1ÜˆDÌ2ˆÁcÄ  €“\a–€F Ğ	W˜% ƒƒ da– 0    ¦ÀÈBœ C¤ÀtØi QÈdƒG± 'Àf ¶@T@Dk QQm¨Œ@EÑL_0„¥ ó¼ÀB           /** @file gamestate.c
	@brief
	This file contains game state routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "gamestate.h"
#include "scene.h"
#include "redraw.h"
#include "text.h"
#include "menu.h"
#include "renderer.h"
#include "grid.h"
#include "lbaengine.h"
#include "interface.h"
#include "animations.h"
#include "keyboard.h"
#include "resources.h"
#include "extra.h"
#include "sound.h"
#include "screens.h"
#include "music.h"
#include "filereader.h"
#include "menuoptions.h"
#include "collision.h"

#define SAVE_DIR "save/"

int32 magicLevelStrengthOfHit[] = {
	kNoBallStrenght,
	kYellowBallStrenght,
	kGreenBallStrenght,
	kRedBallStrenght,
	kFireBallStrength,
	0
};

/** Initialize engine 3D projections */
void initEngineProjections() { // reinitAll1
	setOrthoProjection(311, 240, 512);
	setBaseTranslation(0, 0, 0);
	setBaseRotation(0, 0, 0);
	setLightVector(alphaLight, betaLight, 0);
}

/** Initialize variables */
void initSceneVars() {
	int32 i;

	resetExtras();
	
	for (i = 0; i < OVERLAY_MAX_ENTRIES; i++) {
		overlayList[i].info0 = -1;
	}

	for (i = 0; i < NUM_SCENES_FLAGS; i++) {
		sceneFlags[i] = 0;
	}

	for (i = 0; i < NUM_GAME_FLAGS; i++) {
		gameFlags[i] = 0;
	}

	for (i = 0; i < NUM_INVENTORY_ITEMS; i++) {
		inventoryFlags[i] = 0;
	}

	sampleAmbiance[0] = -1;
	sampleAmbiance[1] = -1;
	sampleAmbiance[2] = -1;
	sampleAmbiance[3] = -1;

	sampleRepeat[0] = 0;
	sampleRepeat[1] = 0;
	sampleRepeat[2] = 0;
	sampleRepeat[3] = 0;

	sampleRound[0] = 0;
	sampleRound[1] = 0;
	sampleRound[2] = 0;
	sampleRound[3] = 0;

	for (i = 0; i < 150; i++) {
		holomapFlags[i] = 0;
	}

	sceneNumActors = 0;
	sceneNumZones  = 0;
	sceneNumTracks = 0;

	currentPositionInBodyPtrTab = 0;
}

void initHeroVars() { // reinitAll3
	resetActor(0); // reset Hero

	magicBallIdx = -1;

	inventoryNumLeafsBox = 2;
	inventoryNumLeafs    = 2;
	inventoryNumKashes   = 0;
	inventoryNumKeys     = 0;
	inventoryMagicPoints = 0;

	usingSabre = 0;

	sceneHero->body = 0;
	sceneHero->life = 50;
	sceneHero->talkColor = 4;
}

/** Initialize all engine variables */
void initEngineVars(int32 save) { // reinitAll
	resetClip();

	alphaLight = 896;
	betaLight = 950;
	initEngineProjections();
	initSceneVars();
	initHeroVars();
	
	newHeroX = 0x2000;
	newHeroY = 0x1800;
	newHeroZ = 0x2000;

	currentSceneIdx = -1;
	needChangeScene = 0;
	quitGame = -1;
	mecaPinguinIdx = -1;
	canShowCredits = 0;
		
	inventoryNumLeafs = 0;
	inventoryNumLeafsBox = 2;
	inventoryMagicPoints = 0;
	inventoryNumKashes = 0;
	inventoryNumKeys = 0;
	inventoryNumGas = 0;
	
	cropBottomScreen = 0;

	magicLevelIdx = 0;
	usingSabre = 0;

	gameChapter = 0;

	currentTextBank = 0;
	currentlyFollowedActor = 0;
	heroBehaviour = 0;
	previousHeroAngle = 0;
	previousHeroBehaviour = 0;

	if (save == -1) {
		loadGame();
		if (newHeroX == -1) {
			heroPositionType = kNoPosition;	
		}
	}
}

void loadGame() {
	FileReader fr;
	uint8 data;
	int8* namePtr;

	if (!fropen2(&fr, SAVE_DIR "S9999.LBA", "rb")) {
		printf("Can't load S9999.LBA saved game!\n");
		return;
	}

	namePtr = savePlayerName;

	frread(&fr, &data, 1); // save game id

	do {
		frread(&fr, &data, 1); // get save player name characters
		*(namePtr++) = data;
	} while (data);

	frread(&fr, &data, 1); // number of game flags, always 0xFF
	frread(&fr, gameFlags, data);
	frread(&fr, &needChangeScene, 1); // scene index
	frread(&fr, &gameChapter, 1);

	frread(&fr, &heroBehaviour, 1);
	previousHeroBehaviour = heroBehaviour;
	frread(&fr, &sceneHero->life, 1);
	frread(&fr, &inventoryNumKashes, 2);
	frread(&fr, &magicLevelIdx, 1);
	frread(&fr, &inventoryMagicPoints, 1);
	frread(&fr, &inventoryNumLeafsBox, 1);
	frread(&fr, &newHeroX, 2);
	frread(&fr, &newHeroY, 2);
	frread(&fr, &newHeroZ, 2);
	frread(&fr, &sceneHero->angle, 2);
	previousHeroAngle = sceneHero->angle;
	frread(&fr, &sceneHero->body, 1);

	frread(&fr, &data, 1); // number of holomap locations, always 0x96
	frread(&fr, holomapFlags, data);

	frread(&fr, &inventoryNumGas, 1);

	frread(&fr, &data, 1); // number of used inventory items, always 0x1C
	frread(&fr, inventoryFlags, data);

	frread(&fr, &inventoryNumLeafs, 1);
	frread(&fr, &usingSabre, 1);

	frclose(&fr);

	currentSceneIdx = -1;
	heroPositionType = kReborn;
}

void saveGame() {
	FileReader fr;
	int8 data;

	if (!fropen2(&fr, SAVE_DIR "S9999.LBA", "wb+")) {
		printf("Can't save S9999.LBA saved game!\n");
		return;
	}

	data = 0x03;
	frwrite(&fr, &data, 1, 1);

	data = 0x00;
	frwrite(&fr, "TwinEngineSave", 15, 1);

	data = 0xFF; // number of game flags
	frwrite(&fr, &data, 1, 1);
	frwrite(&fr, gameFlags, 255, 1);

	frwrite(&fr, &currentSceneIdx, 1, 1);
	frwrite(&fr, &gameChapter, 1, 1);
	frwrite(&fr, &heroBehaviour, 1, 1);
	frwrite(&fr, &sceneHero->life, 1, 1);
	frwrite(&fr, &inventoryNumKashes, 2, 1);
	frwrite(&fr, &magicLevelIdx, 1, 1);
	frwrite(&fr, &inventoryMagicPoints, 1, 1);
	frwrite(&fr, &inventoryNumLeafsBox, 1, 1);
	frwrite(&fr, &newHeroX, 2, 1);
	frwrite(&fr, &newHeroY, 2, 1);
	frwrite(&fr, &newHeroZ, 2, 1);
	frwrite(&fr, &sceneHero->angle, 2, 1);
	frwrite(&fr, &sceneHero->body, 1, 1);

	data = 0x96; // number of holomap locations
	frwrite(&fr, &data, 1, 1);
	frwrite(&fr, holomapFlags, 150, 1);

	frwrite(&fr, &inventoryNumGas, 1, 1);

	data = 0x1C; // number of inventory items
	frwrite(&fr, &data, 1, 1);
	frwrite(&fr, inventoryFlags, 28, 1);

	frwrite(&fr, &inventoryNumLeafs, 1, 1);
	frwrite(&fr, &usingSabre, 1, 1);

	frclose(&fr);
}

void processFoundItem(int32 item) {
	int32 itemCameraX, itemCameraY, itemCameraZ; // objectXYZ
	int32 itemX, itemY, itemZ; // object2XYZ
	int32 boxTopLeftX, boxTopLeftY, boxBottomRightX, boxBottomRightY;
	int32 textState, quitItem, currentAnimState;
	uint8 *currentAnim;
	AnimTimerDataStruct tmpAnimTimer;

	newCameraX = (sceneHero->X + 0x100) >> 9;
	newCameraY = (sceneHero->Y + 0x100) >> 8;
	newCameraZ = (sceneHero->Z + 0x100) >> 9;

	// Hide hero in scene
	sceneHero->staticFlags.bIsHidden = 1;
	redrawEngineActions(1);
	sceneHero->staticFlags.bIsHidden = 0;

	copyScreen(frontVideoBuffer, workVideoBuffer);

	itemCameraX = newCameraX << 9;
	itemCameraY = newCameraY << 8;
	itemCameraZ = newCameraZ << 9;

	renderIsoModel(sceneHero->X - itemCameraX, sceneHero->Y - itemCameraY, sceneHero->Z - itemCameraZ, 0, 0x80, 0, bodyTable[sceneHero->entity]);
	setClip(renderLeft, renderTop, renderRight, renderBottom);

	itemX = (sceneHero->X + 0x100) >> 9;
	itemY = sceneHero->Y >> 8;
	if (sceneHero->brickShape & 0x7F) {
		itemY++;
	}
	itemZ = (sceneHero->Z + 0x100) >> 9;

	drawOverModelActor(itemX, itemY, itemZ);
	flip();

	projectPositionOnScreen(sceneHero->X - itemCameraX, sceneHero->Y - itemCameraY, sceneHero->Z - itemCameraZ);
	projPosY -= 150;

	boxTopLeftX = projPosX - 65;
	boxTopLeftY = projPosY - 65;

	boxBottomRightX = projPosX + 65;
	boxBottomRightY = projPosY + 65;

	playSample(41, 0x1000, 1, 0x80, 0x80, 0x80, -1);

	// process vox play
	{
		int32 tmpLanguageCDId;
		stopMusic();
		tmpLanguageCDId = cfgfile.LanguageCDId;
		//cfgfile.LanguageCDId = 0; // comented so we can init vox bank
		initTextBank(2);
		cfgfile.LanguageCDId = tmpLanguageCDId;
	}

	resetClip();
	initText(item);
	initDialogueBox();

	textState = 1;
	quitItem = 0;

	if (cfgfile.LanguageCDId) {
		initVoxToPlay(item);
	}

	currentAnim = animTable[getBodyAnimIndex(kFoundItem, 0)];

	tmpAnimTimer = sceneHero->animTimerData;
	
	animBuffer2 += stockAnimation(animBuffer2, bodyTable[sceneHero->entity], &sceneHero->animTimerData);
	if (animBuffer1 + 4488 < animBuffer2) {
		animBuffer2 = animBuffer1;
	}

	currentAnimState = 0;

	prepareIsoModel(inventoryTable[item]);
	numOfRedrawBox = 0;

	while (!quitItem) {
		resetClip();
		currNumOfRedrawBox = 0;
		blitBackgroundAreas();
		drawTransparentBox(boxTopLeftX, boxTopLeftY, boxBottomRightX, boxBottomRightY, 4);

		setClip(boxTopLeftX, boxTopLeftY, boxBottomRightX, boxBottomRightY);

		itemAngle[item] += 8;

		renderInventoryItem(projPosX, projPosY, inventoryTable[item], itemAngle[item], 10000);

		drawBox(boxTopLeftX, boxTopLeftY, boxBottomRightX, boxBottomRightY);
		addRedrawArea(boxTopLeftX, boxTopLeftY, boxBottomRightX, boxBottomRightY);
		resetClip();
		initEngineProjections();

		if (setModelAnimation(currentAnimState, currentAnim, bodyTable[sceneHero->entity], &sceneHero->animTimerData)) {
			currentAnimState++; // keyframe
			if (currentAnimState >= getNumKeyframes(currentAnim)) {
				currentAnimState = getStartKeyframe(currentAnim);
			}
		}

		renderIsoModel(sceneHero->X - itemCameraX, sceneHero->Y - itemCameraY, sceneHero->Z - itemCameraZ, 0, 0x80, 0, bodyTable[sceneHero->entity]);
		setClip(renderLeft, renderTop, renderRight, renderBottom);
		drawOverModelActor(itemX, itemY, itemZ);
		addRedrawArea(renderLeft, renderTop, renderRight, renderBottom);

		if (textState) {
			resetClip();
			textState = printText10();
		}

		if (textState == 0 || textState == 2) {
			sdldelay(15);
		}

		flipRedrawAreas();
		
		readKeys();
		if (skippedKey) {
			if (!textState) {
				quitItem = 1;
			}

			if (textState == 2) {
				textState = 1;
			}
		}

		lbaTime++;
	}
	
	while (playVoxSimple(currDialTextEntry)) {
		readKeys();
		if (skipIntro == 1) {
			break;
		}
		delaySkip(1);
	}

	initEngineProjections();
	initTextBank(currentTextBank + 3);

	/*do {
		readKeys();
		delaySkip(1);
	} while (!skipIntro);*/
	
	if (cfgfile.LanguageCDId && isSamplePlaying(currDialTextEntry)) {
		stopVox(currDialTextEntry);
	}

	sceneHero->animTimerData = tmpAnimTimer;
}

void processGameChoices(int32 choiceIdx) {
	int32 i;
	copyScreen(frontVideoBuffer, workVideoBuffer);

	gameChoicesSettings[0] = 0;	// Current loaded button (button number)
	gameChoicesSettings[1] = numChoices; // Num of buttons
	gameChoicesSettings[2] = 0; // Buttons box height
	gameChoicesSettings[3] = currentTextBank + 3;

	if (numChoices > 0) {
		for(i = 0; i < numChoices; i++) {
			gameChoicesSettings[i * 2 + 4] = 0;
			gameChoicesSettings[i * 2 + 5] = gameChoices[i];
		}
	}

	drawAskQuestion(choiceIdx);

	processMenu(gameChoicesSettings);
	choiceAnswer = gameChoices[gameChoicesSettings[0]];

	// get right VOX entry index
	if (cfgfile.LanguageCDId) {
		initVoxToPlay(choiceAnswer);
		while(playVoxSimple(currDialTextEntry));
		stopVox(currDialTextEntry);

		hasHiddenVox = 0;
		voxHiddenIndex = 0;
	}
}

void processGameoverAnimation() { // makeGameOver
	int32 tmpLbaTime, startLbaTime;
	uint8 *gameOverPtr;

	tmpLbaTime = lbaTime;

	// workaround to fix hero redraw after drowning
	sceneHero->staticFlags.bIsHidden = 1;
	redrawEngineActions(1);
	sceneHero->staticFlags.bIsHidden = 0;

	// TODO: drawInGameTransBox
	setPalette(paletteRGBA);
	copyScreen(frontVideoBuffer, workVideoBuffer);
	gameOverPtr = malloc(hqrEntrySize(HQR_RESS_FILE, RESSHQR_GAMEOVERMDL));
	hqrGetEntry(gameOverPtr, HQR_RESS_FILE, RESSHQR_GAMEOVERMDL);

	if (gameOverPtr) {
		int32 avg, cdot;

		prepareIsoModel(gameOverPtr);
		stopSamples();
		stopMidiMusic(); // stop fade music
		setCameraPosition(320, 240, 128, 200, 200);
		startLbaTime = lbaTime;
		setClip(120, 120, 519, 359);
		
		while(skipIntro != 1 && (lbaTime - startLbaTime) <= 0x1F4) {
			readKeys();
			
			avg = getAverageValue(40000, 3200, 500, lbaTime - startLbaTime);
			cdot = crossDot(1, 1024, 100, (lbaTime - startLbaTime) % 0x64);
			blitBox(120, 120, 519, 359, (int8*) workVideoBuffer, 120, 120, (int8*) frontVideoBuffer);
			setCameraAngle(0, 0, 0, 0, -cdot, 0, avg);
			renderIsoModel(0, 0, 0, 0, 0, 0, gameOverPtr);
			copyBlockPhys(120, 120, 519, 359);

			lbaTime++;
			sdldelay(15);
		}

		playSample(37, Rnd(2000) + 3096, 1, 0x80, 0x80, 0x80, -1);
		blitBox(120, 120, 519, 359, (int8*) workVideoBuffer, 120, 120, (int8*) frontVideoBuffer);
		setCameraAngle(0, 0, 0, 0, 0, 0, 3200);
		renderIsoModel(0, 0, 0, 0, 0, 0, gameOverPtr);
		copyBlockPhys(120, 120, 519, 359);

		delaySkip(2000);

		resetClip();
		free(gameOverPtr);
		copyScreen(workVideoBuffer, frontVideoBuffer);
		flip();
		initEngineProjections();

		lbaTime = tmpLbaTime;
	}
}
/** @file gamestate.h
	@brief
	This file contains game state routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef GAMESTATE_H
#define GAMESTATE_H

#include "sys.h"

#define NUM_GAME_FLAGS			255
#define NUM_INVENTORY_ITEMS		28

#define GAMEFLAG_HAS_HOLOMAP			0
#define GAMEFLAG_HAS_MAGICBALL			1
#define GAMEFLAG_HAS_SABRE				2
#define GAMEFLAG_TUNIC					4
#define GAMEFLAG_BOOKOFBU				6
#define GAMEFLAG_PROTOPACK				12
#define GAMEFLAG_MECA_PINGUIN			14
#define GAMEFLAG_HAS_CLOVER_LEAF		27
#define GAMEFLAG_INVENTORY_DISABLED		70

/** Magicball strength*/
enum MagicballStrengthType {
	kNoBallStrenght			= 2,
	kYellowBallStrenght		= 3,
	kGreenBallStrenght		= 4,
	kRedBallStrenght		= 6,
	kFireBallStrength		= 8
};

/** LBA engine game flags to save quest states */
uint8 gameFlags[256];

/** LBA engine chapter */
int16 gameChapter;

/** Magic ball type index */
int16 magicBallIdx;
/** Magic ball num bounce */
int16 magicBallNumBounce;
/** Magic ball auxiliar bounce number */
int16 magicBallAuxBounce; // magicBallParam
/** Magic level index */
int16 magicLevelIdx;

/** Store the number of inventory keys */
int16 inventoryNumKeys;
/** Store the number of inventory kashes */
int16 inventoryNumKashes;
/** Store the number of inventory clover leafs boxes */
int16 inventoryNumLeafsBox;
/** Store the number of inventory clover leafs */
int16 inventoryNumLeafs;
/** Store the number of inventory magic points */
int16 inventoryMagicPoints;
/** Store the number of gas */
int16 inventoryNumGas;

/** Its using FunFrock Sabre */
int16 usingSabre;

/** Inventory used flags */
uint8 inventoryFlags[NUM_INVENTORY_ITEMS];

/** Inventory used flags */
uint8 holomapFlags[150]; // GV14

int8 savePlayerName[30]; // playerName

int32 gameChoices[10]; // inGameMenuData
int32 numChoices;      // numOfOptionsInChoice
int16 gameChoicesSettings[18]; // choiceTab -  same structure as menu settings
int32 choiceAnswer; // inGameMenuAnswer

extern int32 magicLevelStrengthOfHit[];

/** Initialize all engine variables */
void initEngineVars(int32 save);

/** Initialize engine 3D projections */
void initEngineProjections();

void processFoundItem(int32 item);

void loadGame();
void saveGame();

void processGameChoices(int32 choiceIdx);

void processGameoverAnimation();

#endif
BCÀŞ!    ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q     f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l † À6D ,ŒB  Ú@ÿÿÿÿ?  I     ‚`B LaÂ@Æ„` ‰   Ñ   2"
 d…$¤„$ã„¡LŒ„M¨Å¤ Àt˜4E”0ùhED€•ˆ4±SD	:R¡€æ„B „@ …ä@ †$  ‡´@ "H„Ã¤)¢„Ég'`B„o‰"J˜P@q™4E”0ùÖ "|`HìQÂ„
B8Gš"J˜üùM¤™@@pŒ4E”0ùó»9000Î’¦ˆ&_&'2Š`§ˆ&D œ&M%L¾Ö L‹0DÔÀN%LH¸ 8Iš"J˜|M˜œˆ"J˜TX     \ \                      \ \                dhluä}ä …¤¤•$ĞE"\J* \$M%L>ç4b|ÈB …                         €Z›à‚^’ã‚bò?€€fR‚€jR€nr9 €v’Œƒz.’¦ˆ&Ÿˆ†H¤™Ğ@@@p‹4E”0ù@ã4ˆ    8…j§ñÆiP t‘4E”0ù³ÓìQÂ„ŠŸ‚ ‚$¢¡Dø¡¢# #Ò ‰  ¥„~  ¦Ä&  §ä  ¨³¤)¢„É÷®)JDšØ)¢„	E )3ET9pAV9 @X	@Z	h€@\# %ğ¢¯Bx  PX¼h¬^TV/ :»Gš"J˜ü_DÿO,½1€Òá"iŠ(aò?d!Vˆjk  ÄV€¶‹r«ÀÁÂ«í€äŠàÕFt¥ğj»   »2x]\^A       .H¯^    ÄW    ò+ˆ        €Ë   @„sA1¼..  é6
pq‘HŠEğº Æbx    c1¼  .  ²  ‰$Y€¢¬ Y`‚0‹p@še ¸  ÎB \\ g)     ´$^      $Z "˜ ª °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD 
¼
ÌUÁ9°*8\¥¬`dˆŒ²‚bVPBÌ
JˆYA)A+VçÀªàXœ«‚s¢UPN´
Ê‰VA9Ñ*('ZåD« œh”¸‚s¢UPN´
Ê‰VA9°*8VçÀªàœh”«‚s¢UPN´
Ê‰VA9Ñ*(VçD« œh”­‚r¢UPN´
ºCƒ W’  € Ø¡ˆA°+I  @ ìPÈ à•$    hâ+Ø‚_I  `‡BA¯$  °Cƒ@W’  € àÀªàXœ«‚3ÅVp¦Ø
Î àÀªàXœ«‚s`UpN´
Ê‰VAé „	œ)¶‚3ÅVpÊˆÎUÁ9°*8iÆåD« Xœ«‚s¢UPÚÊUÁ‰S.8VçÀªàXœ:æ‚1 8Ñ*('Zå
¸àä9œ«‚s`Up¬
ÎVÁ8Ñ*(SlgŠ­àL±œ)¶‚3ÅVpN´
Ê‰VA9Ñ*('ZåD« „˜”­‚r¢UPN´
Ê‰VA9Ñ*('ZåÀªàL±œ)¶‚s`Up¬
Î‰VA9Ñ*('ZåD« œh”­‚r¢UPN´
Ê‰VA9Ñ*('Z¥ºàœh”­‚r¢UP¥J#uA9Ñ*('ZåD« œh”«‚s`Up¬
Î[Á™b+8VçÀªàXœ«‚s`Up¬
ÎUÁ9°*8VçÀªàXœ«‚s`Up¬
ÎUÁÉ+bcŠ­àL±œ«‚s`Up¬
ÎUÁ9°*8VçÀªàL±œ«‚s`Up¬
ÎUÁ‰´.(VçÀªàdˆŒ«‚s`Up¬
N†XÁ˜t+8VçD« œh”­‚r¢UP¬
ÎUÁ9°*8VçÀªàXœJµ‚s¢UP¬
N&vA©T+8VçÀªàXœ)¶‚s¢UPN´
Ê‰VA9Ñ*(Sl§S»àLºœ«‚s`Up¬
ÎUÁ9°*8'ZåÀªàL±œ«‚s`Up¬
ÎUÁ9°*8VçÀªàXœPî‚s¢UPN´
Ê‰VA9Ñ*('ZåD« L±œ)¶‚3ÅVpN´
Ê‰VA9Ñ*(VçÀªà”zœUğ‚ó*^pfÉÎ­yÁ¹5/8»è£¹`œh”­‚r¢UPN´
Ê[Á©c.V'C¬`¼`Œ«‚s`Up¬
ÎUÁ9°*8VçÀªàX|È      0d      ²ˆ     YÄ     †,â €     Cp       €!9      À      `Èb@     0dA      ²     YÀ €     †,ï €     C–x @    €!Ë<      À¥€     `È      0d¹      ²       YĞ     †,ù €     C–} @    €!K?      ÀE€     `ÈB@     0dù      ²„     YÈ     †,è €     Ct @    €!9      Àe$€     `ÈR@     0dA	      ²¬     YZ     †,ä €     C–— @    €!KL      À¥€     `ÈÒ@     0d™	      ²Ô     Yj     †,7€     Ct @    €!9      À…€     `È2@     0dA      ²Œ     YĞ     †,è  @     Ct @    €!KN      À      `ÈÒ@     0dÙ	      ²ô     Y~     †,ä €     Cr @    €!ËK      À%,€     `È@     0d      ²„     Yú     †,e€     C–– @    €,  >   2˜$LŒ	&GÆC „ " ƒ 
ËÂ@ J … j ‡ Š ‰ º  ê uæa{ù5Íår9S\§µÆk¤!X "(d…( ƒaØ}¢ƒØï04Íår9SÍÃö2t·Ë!…†Á0ì>ÑAó°½šær¹œ‹)‚æa{™:‡Ûå‚JF èD‡»xE*# ô2@1# 43@5# t3@9# ´3@=# 44@E# t4@K# Ô4@O# 5@T# d5@X# ¤5@\#    y     C³HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q     f0Q¡-5ÀD¤ÀBLaıŠà,"!N[®À3D€¥IŠJÒ„8ù(‚³,ˆ„8l)„/M‘ı(‚³,ˆ„8Íl£Ò Óë\­“. fœD± ‰Q9Zƒ0âp¥+Ú¢©Æ‘Ö“ Â´@°f	Tu°´Ä5yÍa€0NE˜DC™v 4×#ÍàX›3Mc
%!ÁAD˜¡€$ÓHD´ â4†+ =‘#’Á"’ù
0yÍa,’öñ ME4“a'Å€€d’Î€ KK\Óæ\­óØÀâTD´ X‰H“%LEä4Ó‹„³QEAD"ÙQ")È#6Sä˜c@4 ÀÒ×ÄNÎÃ9‹Ùl€óDN’:’Ì
A4VDähÂˆÃ¥àê±¬øz–* `µĞHÍ´9—%,À<±:T3f PEm™D@¶8”DpÄ² FÈ`4åDÊ‹„³QEADöæH ó,„‰4± ˜ñIED3±B„<Ó,aÅG° Óæ\Æà,ó¤!IÄ@˜é-’@4„&LN$ÎÍ@D+b“uM9^3!–®h‹¦G#Ì³+ñÀd#@EÑL-qMĞ(¶Ğ°p± &,IÄÄ©#!â4æ´<ÀBL±‚›fÒTD39f"¤ÒL’UD,-qM›s¥@0µYD,-qM›s¥@0¶ñBaÈB± "D$uÎdÒTD39vRLI …´9—AH,-qMUDÄ"a@ÒTD39ÖÁBØ`ÀĞf¬Ä–ÅTˆäJHc Ñá¤‘“Â„8å=9òFND|À²˜¢À1y×’-1Âá ¡5’EDÖ*IÄd:±hÂ â4ÖäTÎ"Ã@4b3—Å1À<‘. FÆà<ÒL-qMüDµ!Ğæ&I ó,„ÆÑD‹0„y8O„4SK\ÿÑmÎ!ÍÔ×Ä¿@dh€óDH3µÄ5ñ/åà<ÒL-qMüDº8O„4SK\ÿo½Îã,ØJ4µØCX©@¶,ã3#<˜ÿĞï?4ÂûÈmqÀ, lTQ‘A4‹ã<š09;­HHSÍäD‹dDaÊ³ 0ÏBX¯€Á ËâFb	TÍ´`Ÿ³,Eš09‘‘,a C¼@„[iÀÒ0ÄD¹‰
<HƒL,A›sÙ{€#Ì³Rº Òæ°	TÍ”:2!N#6›3`éµ@`§Ï¢ä˜Î@,ö 	TÍ´`iä„$ƒ&LN$—	IE'Å ÅJ`mÎejĞâP+!—‰L­·?GEÑL%1MD$›­ÀƒH,À<‘. †4†Í)’@4DHDNltŠ$‘#["	DC„DäÌ¶*p`mÎedKàL“Ã”D1ÅV¶Î49LI“l„Ò “×HC¤‘“Â„8dÒTD39ö-€!Ùß"	DC´ (’™-3MSÅ4e@4 ÀÒ×´9×æL“Ã˜Ô"=2-,„ñ8Ò„ÖÑÁmˆ°Ë"—Ù%™Ó!9±İ
Òä<¯sÙ]’9‘#^’9‘3Ûj€$PQD4Óë\Ğ(²p CD@lÂ‡ 0DÈ6p CDÀlèƒB`æ(D„DLÜ‚<£4„Å±Å(aq CD€l2JCXÀ0›œ"	DC˜”„¶'	TÍ¤	“‰Íì4„½HE&ÑP-qMUDdÑÕ€H@°¬D³ÑLDdŸSëÅíÏQQD4SILÅ–ÃDD3ÑæL“Ãp@ò¬D3Ñ[ÛØr‘£5#—uTOä„$­ÎLˆÓl˜Ö ŒmQ9^3!¦àê±¬øzÆ( D„DLš09‘Y$’@4DHDQÒ›±€#0Dh±VuH08–lV‡t ƒcÍ¶@MÄ5ÁH38ÖæL“Ã°@EØSªë¿z,ûbéÙ‚#	DCœ£	“Iv,ĞÎƒm‹#(éIv TÍD˜M
E$,DXk@$PQdÕ×$6qÙÕ$ÀàXœ³,ˆ„8M‹=„$QL¦CI„i<ED3±Ñâpk€$Õ!Àâ±QA°ö-óˆME4“aâD0,°H“ó° ó,„dEÇ -ÂæDähÂˆÃu¢«©•æ°4ƒ/MÄeLÌH!2Dó:—,¡	“YAb ñ-€!«@ÃJ`i$DÎ³9Óä0¬Dc´Î9IêH3+DÑ© dÓæ˜Ö ŒØÄeÒ€ KK\;ÑÄ9‹™~€ò, FD'ÀfàÄ² FÈ —ı,@ƒ0UDT›Ï4³QEAD¶8À<¡14a‘Æ!ÍT˜f€óDH3µÄ5ñéÕ¶à<ÒL-qM|:E¶%ÈD0Zc,„]HqM0ÒUÅÄa®@E‘I4TK\Ó4Š¹@À<!±HF´@°6!ME4“a'Å&"	DC|`H)p‘óm¿ËE 1yÍaÆ%DäxÍ„LX'²Üêµ)@,ìÄFLA4&² CpğLDd¯ALìDI`E0„%EDp<ÀBLaX@MfD„$!aÎÎâ8GEÑL$Ùt@!Òd Á"KLÒ’DÁ>2b3—‘,
}Àé~ÀÃ H“1MÄ
nšÕ,‹#()°ÓDØx &PQD4“&LN¤5ã]S¤Sd‘Ï€ KK\Óæ\%QLv°0 Ò¤ÀBLa*…/MQm+…/M‘m-…/MÑmJ‹0w8ˆ@HöRøÒå&+ğò¬Ä–€d‰Ò +ñ‘d‹Ò SHDÎD’Ñ
4Ï`¯s±ó,„¹¾4E¸<1iñEX¨ ‚4ÈÔ×d€Ñ9!Iœ³,ˆ„8MlÑ9!Iœ³,ˆ„8l$qRL‚"Y£€ƒ4Èä5Ò/I–P„4ÅV+Ä`¬‚<¦P„4Éf£DD3QI“]
L1D€å5Òš0!N#%=2›C5Ò›s¥SdaÓADÖ Œ8\Èr«×zvĞ ÃP"±E ÄvR=Q!%…DälÄTˆCEf=Q!%…Däh±v“DD3Që<¶P„4Í%1€°,umÕ„0ED3±ñÄÀTÍÄNÄ#[vÀ4×#ÍàX+bT„M=Ò!Á"ÑÁB¦€"8Æ
A4&ÀTÍÄNÄ3›Ÿ"	DCÌNCHÆĞ°´Ä5qÎâDVğ,€4‘öE C¤Sd‚Ñ9!Iœ³,ˆ„8Íl ˆP±°SD4Æt EˆL–ÀTÍdR"ØòDN’:Rl:È9IêH²Õ Oä$©#Í& dÃ°BDQ
 P À6 °´Ä5mÎµ"Æ1™u€3×#ÍàX%QLF <À²1ƒ•49q âP‘I
EÀ`ğ”0ÏBHé`HchÂäD’9Å ÅJ`mÎekôDÈD°08V:EÆâH@E¤€Ñ	0„µ0À<!µ@°VMÄ5ÁH38Vë<,P¦ğDä¤!IÄ@˜m 4ìáX\DÈ$Y3‹‚4†&LNd²Î9IêH1+DÑ˜|@ô 1MÄ
nGI“ÃXD„4ÑLN„S@!Y§ÀõDNBSêHÈ„8Ú°BDy`Oä„$•€4­ÎLˆÓh±6( 	 %š09Q0€A`À#@c«ã0/Õ´<Â4±:óQ]ÛÆÓÄÀ@c¬@4„Å
 Ò°Ä`fğ<ÒL-qM5ıQm›ÒZ‘éÄ¢	“™¦À!· 
H1¡Ñt8iä$„0!Nc‡DL «3â4¶+€=‘#’áTD¤5LˆÓ\$Ì³&ÒtÄ`k3ØTDN3½È@8UDd™ND4‰’c:±˜®ÀòD@H’I4”=@,-qMìD<,’¦IBDMé8
õ´@°f) =‘#’ô9T3ˆÁXz€s‘“F„$I`–À°´Ä5±HFXHÃ "”DE,âpÙe€óDH3µÄ5½@Tßf 8Ñt8iä$±İ(N4N9‰l¸ŠM‡“FN2j@ñL¼„›©€#M hÂ â4†Dä¤„LˆÓ´ØC{@B\S”ˆ4Y%PQD40Z+aÜĞ ‹dDagÉä<+bSlhÉä<+b“liÉä<+bÓlIJC1Üá !u@3×#ÍàX­ó˜@P"Æ1Y‡Ã"A!8\V“Î€µ@°æ*ğÄtRI`E0„dDŠ¤ ÏC$™–t‘ã52aZ–^+rÖ`=Q!%•ó¤!IÄ@˜U
EdEÈDØ§@"MÎcR"r€!Æ1™%,ĞH“ó˜È€˜”„ÆĞHÑ'ÅÌNCH†pN3¥SdHCX!9±a a…DäÈ–4„‘3¬ÀòDH3µÄ5Õ´
0HƒL-qMĞ(f 	Tu°´Ä5±HFªÀ,È´‚bDÕZD ’Í
 $I¦5Ä5u°´Ä5yÍa¦ÀÎâ0Àó-€!™„„4ÑLN„CÒAH  Ës %b“©
LÑD$6ÑLN„‰ÁØ×t‘£5#—Ö†¥×Šœ-,‹ã<¦Sé”Ä "lÀ²œ³9T#¶0ÍDDé`DtñQmüÑLD”. FD'À/Ù–°=ÒL-qM|UDô‘m‚Ò–Ø€ C´ĞH›sÙaÀ#PQÔ!ÀÒ×”N‘eA9^3!v¢«©•†(àHÄT"Æ1½„09‘Í$°p”49ŒıDMÄÅ9N4 0’=
 ‹ ÀÆ+ HÄ”1M„a<qM0Òµ"Æ1QÈaæÊ’D$   a      A,      Pî>P€   # ÈÃ # ÄC´AŒ  mĞm@ö2È^Æˆ ñ o€ a   ƒ   U,      PEPEQ å?P8Å*@5@CĞ¨
 *CĞ¨
@/CĞ¨
P/CĞ¨
`/C¨
 *C¨
@/C¨
P/C¨
`/CP¨
 *CP¨
@/CP¨
P/CP¨
`/fK¦(  3@/ÃˆÁ  Â`D
0KP0†‚
f" aŒ7¬)ãA)lƒ% ³Ã‚ƒH0 ³Á`‚
0KP2†‚f$ eŒ7ÄÌ*ƒÁ*À,ÁAÌ°`@0á0KPF8®0 ³	9c¸! 4˜eP˜€ 1Ş`3±F± ³IÃ‚4 Á`À,A2AÑÂ Ì4Dá† Ğ`–Á²ÆxÃÎÜB0ÜB Ì<„Ş ƒZ0 ³Í`Ä  F˜À`D  FÀ`Äà‚ Fˆ.À`Dà‚ F€.À`Ä‡0áá‚ Ft¸  ƒ.À`„¦0K‘6†5@ƒY‰
ˆã=ÓÁ`DĞ0K0‘7,¨F€A0 ³Ñ`ÄÏ€Ã Fø8À`DÏ€Ã Fğ8 †      ¦8         a      A,      PeSd%SDP5   #D¼ÃF°K  ƒë"À`„º0‘.o  ƒèò0q.o  ƒæò@å2Æ9@#‚9 :—1ŞĞA2$@é2Æ;H#‚d   a   I   E,      P%P€Åî@P€`5PfKæ(   3`/Ã`D°ÀˆÁ  Â`„¿ 0Ñ/Ç Œ °# ØÃˆÁ  ô0.† FœK! ƒæbÀ`D¹(0A.u0 ƒã¢À`„¸0.u0 ƒî20ñ.ƒ F¬ËÀ`D»Ì F°ËÀ`¸Ì FüÊÀ`„¯Ì F¨ËÀ`D¯Ì FğJÀ`Ä®Ì FèÊÀ`D®Ì FàÊ c¸!XÀ`–! ‚ƒ äÔE\  Ã³ÂFğ
À,Á0K@`8    F/@H@E      a   Œ   G,      PEP eS5@e@C`€ª ª2”!j ¨
 *Cd°€ª ª2”al ¨
 *CL¨
 *¶¶"¶%¶¶!¶¶¶¶¶C’¨
 *¶C¨
 *¶¶    3í ĞË0qôÌD¤@/Ãˆ "1\ÖpC
a0Ë Áˆ #qÍƒÄ5 # Œ„Q„Á,Á0b` ÀHEP¨ã	ÁFÁ FC Ì„„á†ÀÂ`–a(‚ PbQÌ€”p@Œ  MŒ  ‡# ¨D³¡Áˆ *Ñhh@÷"#ì% :™1ŞĞÂ\p±# ¸D°Áˆ .uk0b` €KDŒ àÑÆ# ¸D¤±Áˆ .ek0b` €KDØŒ àÑµ¤2c¼!¸…5¸àbG ˆ	*pj™1Şè‚P0. €Áˆ	€bfŒ7¾ \ìˆ 8±v0b`  Nlš. ˆ t¢ƒ`ÄÀ  èÂ F Ğ‰ÃâÂ 1b`  O|bŒ À_èÁˆ <ñŒ °ß`ÍÔÁ F˜À,á@      9p4 C¤SdBä 1      a   ƒ   D,   !   PEPå?P6RÅ*P8„P5PÕ…CC`€ª ª2”m ¨
 *Cdà€ª ª2”o ¨
 *CL¨
 *¶¶"¶%¶¶!¶¶¶¶¶C’¨
 *¶C¨
 *¶¶    3í ĞË0qôŒ p‚U7®³BŒ €Ö,Á0At0bp @I„˜Á`ñ
0bp @I˜Á`ÁÀˆÁ %Qf`# ”DQŒ Pef0bp @I“˜ÁˆÁ %QHf`D2c¼!ˆ…1¸àbG @	$Hƒ418  %
Ò`Äà  ”@¦4Hƒƒ P‘Ò F @	$Jƒ418  %Ò`Äà  ”@4Hƒƒ PqĞ èdÆxC@epÁÅ °K°l@*3Æ‚[8ƒ.vÄà  —p‚7xƒÁˆ†`Äà  —pš7xƒƒ \Â™ĞàF p	Gzƒ7ŒhÆ  F p	§yƒ718 À%œèŞ`Äà  —p 7xƒƒ \ÂyŞàF €	g–`Àp      V9 ‘Y0     a   è  a     PEPQHP…Q€%Pj…PÅPşÅ*PRT…RFÊPdXDPƒˆ@†# fK6+`KÆ)`Kö)`K&*`K†*`K&+`Kæ(@CnÀ€ª !C¥¶—°    3P/ÃLÄ ÔË01 õ2ÌD@½3P/ÃLÄ ÔË01 õ2ÌD@½3P/ÃLÄ ÔË01 õ2ÌD@½3P/ÃLÄ ÔË0‘@½3)ÔË01 õ2FDv0 D3c¼!9 `X0 ¨àr0â_‚ œã9ÔÃ< A{ƒ# ùÌoÖ!(ô*…Œ8™` hlÆxC ğpÁÄR *€­ v0‚`Ä€  ´PJ›1ŞØƒ=\0±ˆ
ì@#†@ (fÅÌ1( À-„€lfT 7áÁ ĞÍŒ
bá#Ş  Â™Q-Ü`@v3Æ‚‘ 
ÕÁ0!íÍoPâ(”Ã„ :c¼!h‰] `P‚PéŒñ†@&Ì‚1Ş64P0F 8h1lbl" µ´6ƒÖfĞÚŒƒ Vƒ„€^gŒ7<ÑÜÈCF´B0 D;c¼!x `TP9Á îŒñ† ,Ú‚Q;èpC€a0ËÕÂ°à@0qÁ Ìô;c¼!`} `Xà ¨@$r0b‚ ^ÔƒzaŒ  ƒŒ Àt>c¼! ‹’ `9‚ûŒñ† /P‚‚Aê0LB@ñ3Æ¿`	
¹Ã0!Áˆ ï±Í¸ @,X‰\@ ƒ· Ù¸ @,¨‰FĞC0 ¤;â ± 'B0aÁ ïˆ Ä‚ Á`>@à#. |ƒúÀˆ ÿ7``a# ¬™ÄŒ¨‡` F ğ´ zƒ(ÀˆÁ  )A&1F ø`Ä` €–Œà‡µ€Áˆ}° ”ÃÁm„Á,Ã@”cÄ€  	f	ˆƒ @„'tc¼}v# `F€D0 Cc¼!ğ´¸¸Ø.vÄ  ‚¹X ödCc¼!» `Œ7èOyÚ¡1Ş Ç\Œ Ğ"ÈıŒñ„@ŒÀŸ` è~ÆxBà¤?c¸AÈ`–¡0ÚŸ1Ñ?Á Ìƒ5@b1ÆøG>
Æˆ 7Fô}À,ÁA91†‚úƒ
è‚g,1 `-#şç>`Ä` €¶ °ƒÂbPXŒ x„„ 4¨,•Å ²TcÄà €7!! ¸ã'"â ± 6@pF ‰ „nH\  ¤c¼†T$ `P_Œñj‘€q€Œ   '
R°Az1H/éÅ ½# Ì	1ùÅ ¿äƒübŒ `'Ä # °ÆˆÁ  ¾B|1ˆ/¹Òovä=(ãrÔ#ƒfiŒ7`²# øI‚ÁpC &a0Ë0Æ° ?@0‘Á PjJ1b@ À¨ÃCp³ÊkŒ J%Œx` f	–Y†~iŒ7lÒòaB"§1ŞÄ	ˆP0H<†	A(ÆxC`'$BÁ ó&! wãÁ¼c¼A–ú$ `Œ(  /Ğbü	‹üI@´4ˆ–ÑÒ Z# Ğ1ÅÇ øcÄÀ  {„€viĞ.Ú¥A»4F HbŠ1Ü°JÌ24N0b0 @ˆŒ ğƒôÀ,Cô1†‚WƒYè	È>ÆpCP&`0Ë EÁˆ ë#³ÑˆÁ  '2b0  ‹.‰á† VÂ`–AºÒ1ÜÔJÌ2PS0±k2 ³ñÇnÖf*+Œğ6€Yk–à¢^š¸	#~)‚Y‚c– #_# ÄK0ÜğJÌ2h]0b0 À8‰ d¸! 0˜eØ¸`– 1   ^êd– 1 Àlè¤†j‚ X& ÃÁ¸„Á,ƒ¡Ó1   _‚á†À\Â`–áƒ€ÖiŒ °/Á,Oñ† ]èä‚‹½¹Ø bFüÄNÎÃ /   :°ÎÕ:OI“l¤ÉD\;a2Ll2ŒlŸ2Ìl¦@EÑLZƒ0ìL„,ED3iÂXêÀ31O	4×‰ƒÑÈD0¦9° Áp CD@l›20DÈÆ9° Áp CDÀl¥D!“8Œ‰<smÎ49ÌŠÇÛèÀ8×æL“Ã¬ˆqL²¡0óhÂ´CD:°ÎÕ:OIS     a   ^   L,      PEP…P
40”á| ¨
p/41”a¨ ¨
 *Cv€
€ª õ2”a¨ ¨
`/Cv€
€ª ÷3P/ÃLÄ ÔË0!4@®2ÈUÆˆA ë ƒÈ éÉ¸€ #’@ #< —aÁ‚`0B	€şd7`³F( 0 ³)ƒDe7Ì2E@Í° ÆPÅ‚Áˆ €¢1Ş€*¨P0.  ª†` <Œ7ÀŠ+ƒA! ³eÃ‚2 Á`ÄÀ,0K`7F ‡`Ä€  qq€Œ7ÔJ-ŒÁ[	€Î`7¸³Ç®Œ B"˜%@èWÆˆ ò7½³‰Ì $.cÄ€  y#zå`0‚W~a f	   F/‡ƒ„8\8       a   µ   H,      Pğ%På\P€¥R…~P€2…P XPàOP€åQ°0¥TDPƒˆ@†# fK,`K,`K6+`Kæ(`KÆ)@Czà
€ª ª3P/ÃLÄ ÔË0‘@½3P/ÃLÄ ÔË@°2#Œ` dÆxCĞ
­pÁÄR *˜´‚i#ˆ@ F (‰3 “ãÁ,ÌÂK¨ ÓÁˆ!€ ÊA"wä.cÄ  €•¢•1bP €9k0b@  :ƒT0 DÂ•1b` @:ÁĞ5†‚ZƒY†à(# ”D0b0 €Œ # ¨C°ÈĞ¹ÌÁ.€ƒ f"òàì`–@ s ÈpC a0Ë0­Ë$0&!nğ f	ˆ
“°Af
#1  ^&•Á0!ÁˆÁ õp|ĞÁ`„@ô2)†	A*ø18  Pa@!ŒPƒ` He±Ì1X `XT!V`…€Ø`Ø=! 7#
 ôC>äC>äƒÅÁ1P `-ôAôAôA‚ƒ ü!bá\@fZ Œ™`F °	R˜%F ø‡
TÁ,(Œ( À¥Ô‚,È‚,ÙÌ œ# œ.à‚-Ô‚€¸Œ( `"!"!"!°@z0F  ‹‘‰‘‰‘‰`Äà €“Ğ]À…[1   '`aÄ` €P ># ˜D@;3¨gÆˆA y!# ŒÂˆÁ  ­A¡0#Z&‚Y‚Ã    F9@ƒ3Yä #M@4•Ğ"a’‹0ZQ:E690 •aÊÄ<e ´C          /** @file grid.c
	@brief
	This file contains grid manipulation routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "grid.h"
#include "resources.h"
#include "lbaengine.h"
#include "scene.h"
#include "sdlengine.h"
#include "interface.h"
#include "screens.h"
#include "actor.h"
#include "renderer.h"
#include "redraw.h"
#include "collision.h"

/** Grip X size */
#define GRID_SIZE_X 64
/** Grip Y size */
#define GRID_SIZE_Y 25
/** Grip Z size */
#define GRID_SIZE_Z GRID_SIZE_X

/** Total number of bricks allowed in the game */
#define NUM_BRICKS 9000

/** Total number of bricks allowed in the game */
#define CELLING_GRIDS_START_INDEX	120

/** Table with all loaded bricks */
uint8* brickTable[NUM_BRICKS];
/** Table with all loaded bricks masks */
uint8* brickMaskTable[NUM_BRICKS];
/** Table with all loaded bricks sizes */
uint32   brickSizeTable[NUM_BRICKS];
/** Table with all loaded bricks usage */
uint8  brickUsageTable[NUM_BRICKS];

/** Current grid pointer */
uint8 *currentGrid;
/** Current block library pointer */
uint8 *currentBll;
/** Number of block libraries */
int32 numberOfBll;

/** Block fragment entry */
struct BlockEntry {
	/** Block library index */
	uint8 blockIdx;
	/** Brick index inside the block library */
	uint8 brickBlockIdx;
};
/** Grid block entry types */
typedef struct BlockEntry blockMap[64][64][25];

/** Brick entry data */
typedef struct BrickEntry {
	/** Brick X position in screen */
	int16 x; //z
	/** Brick Y position in screen */
	int16 y;
	/** Brick Z position in screen */
	int16 z; // x
	/** Brick pixel X position */
	int16 posX;
	/** Brick pixel Y position */
	int16 posY;
	/** Brick index */
	int16 index;
	/** Brick shape type */
	uint8 shape;
	/** Brick sound type */
	uint8 sound;
} BrickEntry;

/** Brick data buffer */
BrickEntry bricksDataBuffer[28][150];
/** Brick info buffer */
int16 brickInfoBuffer[28];

/** Current brick pixel X position */
int32 brickPixelPosX;
/** Current brick pixel Y position */
int32 brickPixelPosY;

/** Copy grid mask to allow actors to display over the bricks
	@param index current brick index
	@param x grid X coordinate
	@param y grid Y coordinate
	@param buffer work video buffer */
void copyGridMask(int32 index, int32 x, int32 y, uint8 *buffer) {
	uint8 *ptr;
	int32 top;
	int32 bottom;
	int32 left;
	int32 right;
	uint8 *outPtr;
	uint8 *inPtr;
	int32 offset;
	int32 vc3;

	int32 temp;
	int32 j;

	int32 absX;
	int32 absY;

	int32 vSize;

	ptr = brickMaskTable[index];

	left = x + *(ptr + 2);
	top = y + *(ptr + 3);
	right = *ptr + left - 1;
	bottom = *(ptr + 1) + top - 1;

	if (left > textWindowRight || right < textWindowLeft || bottom < textWindowTop || top > textWindowBottom)
		return;

	ptr += 4;

	absX = left;
	absY = top;

	vSize = (bottom - top) + 1;

	if (vSize <= 0)
		return;

	offset = -((right - left) - SCREEN_WIDTH) - 1;

	right++;
	bottom++;

	// if line on top aren't in the blitting area...
	if (absY < textWindowTop) {
		int numOfLineToRemove;

		numOfLineToRemove = textWindowTop - absY;

		vSize -= numOfLineToRemove;
		if (vSize <= 0)
			return;

		absY += numOfLineToRemove;

		do {
			int lineDataSize;

			lineDataSize = *(ptr++);
			ptr += lineDataSize;
		} while (--numOfLineToRemove);
	}

	// reduce the vSize to remove lines on bottom
	if (absY + vSize - 1 > textWindowBottom) {
		vSize = textWindowBottom - absY + 1;
		if (vSize <= 0)
			return;
	}

	outPtr = frontVideoBuffer + screenLookupTable[absY] + left;
	inPtr = buffer + screenLookupTable[absY] + left;

	do {
		vc3 = *(ptr++);

		do {
			temp = *(ptr++); // skip size
			outPtr += temp;
			inPtr += temp;

			absX += temp;

			vc3--;
			if (!vc3)
				break;

			temp = *(ptr++); // copy size

			for (j = 0; j < temp; j++) {
				if (absX >= textWindowLeft && absX <= textWindowRight)
					*outPtr = *inPtr;

				absX++;
				outPtr++;
				inPtr++;
			}
		} while (--vc3);

		absX = left;

		outPtr += offset;
		inPtr += offset;
	} while (--vSize);
}

/** Draw 3D actor over bricks
	@param X actor X coordinate
	@param Y actor Y coordinate
	@param Z actor Z coordinate */
void drawOverModelActor(int32 X, int32 Y, int32 Z) {
	int32 CopyBlockPhysLeft;
	int32 CopyBlockPhysRight;
	int32 i;
	int32 j;
	BrickEntry *currBrickEntry;

	CopyBlockPhysLeft = ((textWindowLeft + 24) / 24) - 1;
	CopyBlockPhysRight = ((textWindowRight + 24) / 24);

	for (j = CopyBlockPhysLeft; j <= CopyBlockPhysRight; j++) {
		for (i = 0; i < brickInfoBuffer[j]; i++) {
			currBrickEntry = &bricksDataBuffer[j][i];

			if (currBrickEntry->posY + 38 > textWindowTop && currBrickEntry->posY <= textWindowBottom && currBrickEntry->y >= Y) {
				if (currBrickEntry->x + currBrickEntry->z > Z + X) {
					copyGridMask(currBrickEntry->index, (j * 24) - 24, currBrickEntry->posY, workVideoBuffer);
				}
			}
		}
	}
}

/** Draw sprite actor over bricks
	@param X actor X coordinate
	@param Y actor Y coordinate
	@param Z actor Z coordinate */
void drawOverSpriteActor(int32 X, int32 Y, int32 Z) {
	int32 CopyBlockPhysLeft;
	int32 CopyBlockPhysRight;
	int32 i;
	int32 j;
	BrickEntry *currBrickEntry;

	CopyBlockPhysLeft = ((textWindowLeft + 24) / 24) - 1;
	CopyBlockPhysRight = (textWindowRight + 24) / 24;

	for (j = CopyBlockPhysLeft; j <= CopyBlockPhysRight; j++) {
		for (i = 0; i < brickInfoBuffer[j]; i++) {
			currBrickEntry = &bricksDataBuffer[j][i];

			if (currBrickEntry->posY + 38 > textWindowTop && currBrickEntry->posY <= textWindowBottom && currBrickEntry->y >= Y) {
				if ((currBrickEntry->x == X) && (currBrickEntry->z == Z)) {
					copyGridMask(currBrickEntry->index, (j * 24) - 24, currBrickEntry->posY, workVideoBuffer);
				}

				if ((currBrickEntry->x > X) || (currBrickEntry->z > Z)) {
					copyGridMask(currBrickEntry->index, (j * 24) - 24, currBrickEntry->posY, workVideoBuffer);
				}
			}
		}
	}
}

/** Process brick masks to allow actors to display over the bricks
	@param buffer brick pointer buffer
	@param ptr brick mask pointer buffer */
int processGridMask(uint8 *buffer, uint8 *ptr) {
	uint32 *ptrSave = (uint32 *)ptr;
	uint8 *ptr2;
	uint8 *esi;
	uint8 *edi;
	uint8 iteration, numOfBlock, ah, bl, al, bh;
	int32 ebx;

	ebx = *((uint32 *)buffer); // brick flag
	buffer += 4;
	*((uint32 *)ptr) = ebx;
	ptr += 4;

	bh = (ebx & 0x0000FF00) >> 8;

	esi = (uint8 *) buffer;
	edi = (uint8 *) ptr;

	iteration = 0;

	do {
		numOfBlock = 0;
		ah = 0;
		ptr2 = edi;

		edi++;

		bl = *(esi++);

		if (*(esi) & 0xC0) { // the first time isn't skip. the skip size is 0 in that case
			*edi++ = 0;
			numOfBlock++;
		}

		do {
			al = *esi++;
			iteration = al;
			iteration &= 0x3F;
			iteration++;

			if (al & 0x80) {
				ah += iteration;
				esi++;
			} else if (al & 0x40) {
				ah += iteration;
				esi += iteration;
			} else { // skip
				if (ah) {
					*edi++ = ah; // write down the number of pixel passed so far
					numOfBlock++;
					ah = 0;
				}
				*(edi++) = iteration; //write skip
				numOfBlock++;
			}
		} while (--bl > 0);

		if (ah) {
			*edi++ = ah;
			numOfBlock++;

			ah = 0;
		}

		*ptr2 = numOfBlock;
	} while (--bh > 0);

	return ((int)((uint8 *) edi - (uint8 *) ptrSave));
}

/** Create grid masks to allow display actors over the bricks */
void createGridMask() {
	int32 b;

	for (b = 0; b < NUM_BRICKS; b++) {
		if (brickUsageTable[b]) {
			if (brickMaskTable[b])
				free(brickMaskTable[b]);
			brickMaskTable[b] = (uint8*)malloc(brickSizeTable[b]);
			processGridMask(brickTable[b], brickMaskTable[b]);
		}
	}
}

/** Get sprite width and height sizes
	@param offset sprite pointer offset
	@param width sprite width size
	@param height sprite height size
	@param spritePtr sprite buffer pointer */
void getSpriteSize(int32 offset, int32 *width, int32 *height, uint8 *spritePtr) {
	spritePtr += *((int32 *)(spritePtr + offset * 4));

	*width = *spritePtr;
	*height = *(spritePtr + 1);
}

/** Load grid bricks according with block librarie usage
	@param gridSize size of the current grid
	@return true if everything went ok*/
int32 loadGridBricks(int32 gridSize) {
	uint32 firstBrick = 60000;
	uint32 lastBrick = 0;
	uint8* ptrToBllBits;
	uint32 i;
	uint32 j;
	uint32 currentBllEntryIdx = 0;

	memset(brickTable, 0, sizeof(brickTable));
	memset(brickSizeTable, 0, sizeof(brickSizeTable));
	memset(brickUsageTable, 0, sizeof(brickUsageTable));

	// get block librarie usage bits
	ptrToBllBits = currentGrid + (gridSize - 32);

	// for all bits under the 32bytes (256bits)
	for (i = 1; i < 256; i++) {
		uint8 currentBitByte = *(ptrToBllBits + (i / 8));
		uint8 currentBitMask = 1 << (7 - (i & 7));

		if (currentBitByte & currentBitMask) {
			uint32 currentBllOffset = *((uint32 *)(currentBll + currentBllEntryIdx));
			uint8* currentBllPtr = currentBll + currentBllOffset;

			uint32 bllSizeX = currentBllPtr[0];
			uint32 bllSizeY = currentBllPtr[1];
			uint32 bllSizeZ = currentBllPtr[2];

			uint32 bllSize = bllSizeX * bllSizeY * bllSizeZ;

			uint8* bllDataPtr = currentBllPtr + 5;

			for (j = 0; j < bllSize; j++) {
				uint32 brickIdx = *((int16*)(bllDataPtr));

				if (brickIdx) {
					brickIdx--;

					if (brickIdx <= firstBrick)
						firstBrick = brickIdx;

					if (brickIdx > lastBrick)
						lastBrick = brickIdx;

					brickUsageTable[brickIdx] = 1;
				}
				bllDataPtr += 4;
			}
		}
		currentBllEntryIdx += 4;
	}

	for (i = firstBrick; i <= lastBrick; i++) {
		if (brickUsageTable[i]) {
			brickSizeTable[i] = hqrGetallocEntry(&brickTable[i], HQR_LBA_BRK_FILE, i);
		}
	}

	return 1;
}

/** Create grid Y column in block buffer
	@param gridEntry current grid index
	@param dest destination block buffer */
void createGridColumn(uint8 *gridEntry, uint8 *dest) {
	int32 blockCount;
	int32 brickCount;
	int32 flag;
	int32 gridIdx;
	int32 i;
	uint16 *gridBuffer;
	uint16 *blockByffer;

	brickCount = *(gridEntry++);

	do {
		flag = *(gridEntry++);

		blockCount = (flag & 0x3F) + 1;

		gridBuffer = (uint16 *) gridEntry;
		blockByffer = (uint16 *) dest;

		if (!(flag & 0xC0)) {
			for (i = 0; i < blockCount; i++)
				*(blockByffer++) = 0;
		} else if (flag & 0x40) {
			for (i = 0; i < blockCount; i++)
				*(blockByffer++) = *(gridBuffer++);
		} else {
			gridIdx = *(gridBuffer++);
			for (i = 0; i < blockCount; i++)
				*(blockByffer++) = gridIdx;
		}

		gridEntry = (uint8 *) gridBuffer;
		dest = (uint8 *) blockByffer;

	} while (--brickCount);
}

/** Create grid Y column in block buffer
	@param gridEntry current grid index
	@param dest destination block buffer */
void createCellingGridColumn(uint8 *gridEntry, uint8 *dest) {
	int32 blockCount;
	int32 brickCount;
	int32 flag;
	int32 gridIdx;
	int32 i;
	uint16 *gridBuffer;
	uint16 *blockByffer;

	brickCount = *(gridEntry++);

	do {
		flag = *(gridEntry++);

		blockCount = (flag & 0x3F) + 1;

		gridBuffer = (uint16*) gridEntry;
		blockByffer = (uint16 *) dest;

		if (!(flag & 0xC0)) {
			for (i = 0; i < blockCount; i++)
				blockByffer++;
		} else if (flag & 0x40) {
			for (i = 0; i < blockCount; i++)
				*(blockByffer++) = *(gridBuffer++);
		} else {
			gridIdx = *(gridBuffer++);
			for (i = 0; i < blockCount; i++)
				*(blockByffer++) = gridIdx;
		}

		gridEntry = (uint8 *) gridBuffer;
		dest = (uint8 *) blockByffer;

	} while (--brickCount);
}

/** Create grid map from current grid to block library buffer */
void createGridMap() {
	int32 currOffset = 0;
	int32 blockOffset;
	int32 gridIdx;
	int32 x, z;

	for (z = 0; z < GRID_SIZE_Z; z++) {
		blockOffset = currOffset;
		gridIdx = z << 6;

		for (x = 0; x < GRID_SIZE_X; x++) {
			int32 gridOffset = *((uint16 *)(currentGrid + 2 * (x + gridIdx)));
			createGridColumn(currentGrid + gridOffset, blockBuffer + blockOffset);
			blockOffset += 50;
		}
		currOffset += 3200;
	}
}

/** Create celling grid map from celling grid to block library buffer
	@param gridPtr celling grid buffer pointer */
void createCellingGridMap(uint8* gridPtr) {
	int32 currGridOffset = 0;
	int32 currOffset = 0;
	int32 blockOffset;
	int32 z, x;
	uint8* tempGridPtr;

	for (z = 0; z < GRID_SIZE_Z; z++) {
		blockOffset = currOffset;
		tempGridPtr = gridPtr + currGridOffset;

		for (x = 0; x < GRID_SIZE_X; x++) {
			int gridOffset = *((uint16 *)tempGridPtr);
			tempGridPtr += 2;
			createCellingGridColumn(gridPtr + gridOffset, blockBuffer + blockOffset);
			blockOffset += 50;
		}
		currGridOffset += 128;
		currOffset += 3200;
	}
}

/** Initialize grid (background scenearios)
	@param index grid index number */
int32 initGrid(int32 index) {

	// load grids from file
	int32 gridSize = hqrGetallocEntry(&currentGrid, HQR_LBA_GRI_FILE, index);

	// load layouts from file
	hqrGetallocEntry(&currentBll, HQR_LBA_BLL_FILE, index);

	loadGridBricks(gridSize);

	createGridMask();

	numberOfBll = (*((uint32 *)currentBll) >> 2);

	createGridMap();

	return 1;
}

/** Initialize celling grid (background scenearios)
	@param index grid index number */
int32 initCellingGrid(int32 index) {
	uint8* gridPtr;

	// load grids from file
	hqrGetallocEntry(&gridPtr, HQR_LBA_GRI_FILE, index + CELLING_GRIDS_START_INDEX);

	createCellingGridMap(gridPtr);

	if (gridPtr)
		free(gridPtr);

	reqBgRedraw = 1;

	return 0;
}

/** Draw brick sprite in the screen
	@param index brick index to draw
	@param posX brick X position to draw
	@param posY brick Y position to draw */
void drawBrick(int32 index, int32 posX, int32 posY) {
	drawBrickSprite(index, posX, posY, brickTable[index], 0);
}

/** Draw sprite in the screen
	@param index sprite index to draw
	@param posX sprite X position to draw
	@param posY sprite Y position to draw
	@param ptr sprite buffer pointer to draw */
void drawSprite(int32 index, int32 posX, int32 posY, uint8 *ptr) {
	drawBrickSprite(index, posX, posY, ptr, 1);
}

// WARNING: Rewrite this function to have better performance
/** Draw sprite or bricks in the screen according with the type
	@param index sprite index to draw
	@param posX sprite X position to draw
	@param posY sprite Y position to draw
	@param ptr sprite buffer pointer to draw
	@param isSprite allows to identify if the sprite to display is brick or a single sprite */
void drawBrickSprite(int32 index, int32 posX, int32 posY, uint8 *ptr, int32 isSprite) {
	//unsigned char *ptr;
	int32 top;
	int32 bottom;
	int32 left;
	int32 right;
	uint8 *outPtr;
	int32 offset;
	int32 c1;
	int32 c2;
	int32 vc3;

	int32 temp;
	int32 iteration;
	int32 i;

	int32 x;
	int32 y;

	if (isSprite == 1)
		ptr = ptr + *((uint32 *)(ptr + index * 4));

	left = posX + *(ptr + 2);
	top = posY + *(ptr + 3);
	right = *ptr + left - 1;
	bottom = *(ptr + 1) + top - 1;

	ptr += 4;

	x = left;
	y = top;

	//if (left >= textWindowLeft-2 && top >= textWindowTop-2 && right <= textWindowRight-2 && bottom <= textWindowBottom-2) // crop
	{
		right++;
		bottom++;

		outPtr = frontVideoBuffer + screenLookupTable[top] + left;

		offset = -((right - left) - SCREEN_WIDTH);

		for (c1 = 0; c1 < bottom - top; c1++) {
			vc3 = *(ptr++);
			for (c2 = 0; c2 < vc3; c2++) {
				temp = *(ptr++);
				iteration = temp & 0x3F;
				if (temp & 0xC0) {
					iteration++;
					if (!(temp & 0x40)) {
						temp = *(ptr++);
						for (i = 0; i < iteration; i++) {
							if (x >= textWindowLeft && x<textWindowRight && y >= textWindowTop && y < textWindowBottom)
								frontVideoBuffer[y*SCREEN_WIDTH+x] = temp;

							x++;
							outPtr++;
						}
					} else {
						for (i = 0; i < iteration; i++) {
							if (x >= textWindowLeft && x<textWindowRight && y >= textWindowTop && y < textWindowBottom)
								frontVideoBuffer[y*SCREEN_WIDTH+x] = *ptr;

							x++;
							ptr++;
							outPtr++;
						}
					}
				} else {
					outPtr += iteration + 1;
					x += iteration + 1;
				}
			}
			outPtr += offset;
			x = left;
			y++;
		}
	}
}

/** Get block library
	@param index block library index
	@return pointer to the current block index */
uint8* getBlockLibrary(int32 index) {
	int32 offset = *((uint32 *)(currentBll + 4 * index));
	return (uint8 *)(currentBll + offset);
}

/** Get brick position in the screen
	@param x column x position in the current camera
	@param y column y position in the current camera
	@param z column z position in the current camera */
void getBrickPos(int32 x, int32 y, int32 z) {
	brickPixelPosX = (x - z) * 24 + 288; // x pos
	brickPixelPosY = ((x + z) * 12) - (y * 15) + 215;  // y pos
}

/** Draw a specific brick in the grid column according with the block index
	@param blockIdx block library index
	@param brickBlockIdx brick index inside the block
	@param x column x position
	@param y column y position
	@param z column z position */
void drawColumnGrid(int32 blockIdx, int32 brickBlockIdx, int32 x, int32 y, int32 z) {
	uint8 *blockPtr;
	uint16 brickIdx;
	uint8 brickShape;
	uint8 brickSound;
	int32 brickBuffIdx;
	BrickEntry *currBrickEntry;

	blockPtr = getBlockLibrary(blockIdx) + 3 + brickBlockIdx * 4;

	brickShape = *((uint8 *)(blockPtr));
	brickSound = *((uint8 *)(blockPtr + 1));
	brickIdx = *((uint16 *)(blockPtr + 2));

	if (!brickIdx)
		return;

	getBrickPos(x - newCameraX, y - newCameraY, z - newCameraZ);

	if (brickPixelPosX < -24)
		return;
	if (brickPixelPosX >= SCREEN_WIDTH)
		return;
	if (brickPixelPosY < -38)
		return;
	if (brickPixelPosY >= SCREEN_HEIGHT)
		return;

	// draw the background brick
	drawBrick(brickIdx - 1, brickPixelPosX, brickPixelPosY);

	brickBuffIdx = (brickPixelPosX + 24) / 24;

	if (brickInfoBuffer[brickBuffIdx] >= 150) {
		printf("\nGRID WARNING: brick buffer exceeded! \n");
		return;
	}

	currBrickEntry = &bricksDataBuffer[brickBuffIdx][brickInfoBuffer[brickBuffIdx]];

	currBrickEntry->x = x;
	currBrickEntry->y = y;
	currBrickEntry->z = z;
	currBrickEntry->posX = brickPixelPosX;
	currBrickEntry->posY = brickPixelPosY;
	currBrickEntry->index = brickIdx - 1;
	currBrickEntry->shape = brickShape;
	currBrickEntry->sound = brickSound;

	brickInfoBuffer[brickBuffIdx]++;
}

/** Redraw grid background */
void redrawGrid() {
	int32 i, x, y, z;
	uint8 blockIdx;
	blockMap* map = (blockMap*)blockBuffer;

	cameraX = newCameraX << 9;
	cameraY = newCameraY << 8;
	cameraZ = newCameraZ << 9;

	projectPositionOnScreen(-cameraX, -cameraY, -cameraZ);

	projPosXScreen = projPosX;
	projPosYScreen = projPosY;

	for (i = 0; i < 28; i++) {
		brickInfoBuffer[i] = 0;
	}

	if (changeRoomVar10 == 0)
		return;

	for (z = 0; z < GRID_SIZE_Z; z++) {
		for (x = 0; x < GRID_SIZE_X; x++) {
			for (y = 0; y < GRID_SIZE_Y; y++) {
				blockIdx = (*map)[z][x][y].blockIdx;
				if (blockIdx) {
					drawColumnGrid(blockIdx - 1, (*map)[z][x][y].brickBlockIdx, x, y, z);
				}
			}
		}
	}
}

int32 getBrickShape(int32 x, int32 y, int32 z) { // WorldColBrick
	uint8 blockIdx;
	uint8 *blockBufferPtr;
	
	blockBufferPtr = blockBuffer;

	collisionX = (x + 0x100) >> 9;
	collisionY = y >> 8;
	collisionZ = (z + 0x100) >> 9;

	if (collisionX < 0 || collisionX >= 64)
		return 0;

	if (collisionY <= -1)
		return 1;

	if (collisionY < 0 || collisionY > 24 || collisionZ < 0 || collisionZ >= 64)
		return 0;

	blockBufferPtr += collisionX * 50;
	blockBufferPtr += collisionY * 2;
	blockBufferPtr += (collisionZ << 7) * 25;

	blockIdx = *blockBufferPtr; 

	if (blockIdx) {
		uint8 *blockPtr;
		uint8 tmpBrickIdx;
		
		blockPtr = currentBll;

		blockPtr += *(uint32 *)(blockPtr + blockIdx * 4 - 4);
		blockPtr += 3;
		
		tmpBrickIdx = *(blockBufferPtr + 1);
		blockPtr = blockPtr + tmpBrickIdx * 4;

		return *blockPtr;
	} else {
		return *(blockBufferPtr + 1);
	}
}

int32 getBrickShapeFull(int32 x, int32 y, int32 z, int32 y2) {
	int32 newY, currY, i;
	uint8 blockIdx, brickShape;
	uint8 *blockBufferPtr;
	
	blockBufferPtr = blockBuffer;

	collisionX = (x + 0x100) >> 9;
	collisionY = y >> 8;
	collisionZ = (z + 0x100) >> 9;

	if (collisionX < 0 || collisionX >= 64)
		return 0;

	if (collisionY <= -1)
		return 1;

	if (collisionY < 0 || collisionY > 24 || collisionZ < 0 || collisionZ >= 64)
		return 0;

	blockBufferPtr += collisionX * 50;
	blockBufferPtr += collisionY * 2;
	blockBufferPtr += (collisionZ << 7) * 25;

	blockIdx = *blockBufferPtr; 

	if (blockIdx) {
		uint8 *blockPtr;
		uint8 tmpBrickIdx;

		blockPtr = currentBll;

		blockPtr += *(uint32 *)(blockPtr + blockIdx * 4 - 4);
		blockPtr += 3;
		
		tmpBrickIdx = *(blockBufferPtr + 1);
		blockPtr = blockPtr + tmpBrickIdx * 4;

		brickShape = *blockPtr;

		newY = (y2 + 255) >> 8;
		currY = collisionY;

		for (i = 0; i < newY; i++) {
			if (currY > 24) {
				return brickShape;
			}

			blockBufferPtr += 2;
			currY++;

			if (*(int16 *)(blockBufferPtr) != 0) {
				return 1;
			}
		}

		return brickShape;
	} else {
		brickShape = *(blockBufferPtr + 1);

		newY = (y2 + 255) >> 8;
		currY = collisionY;

		for (i = 0; i < newY; i++) {
			if (currY > 24) {
				return brickShape;
			}

			blockBufferPtr += 2;
			currY++;

			if (*(int16 *)(blockBufferPtr) != 0) {
				return 1;
			}
		}
	}

	return 0;
}

int32 getBrickSoundType(int32 x, int32 y, int32 z) { // getPos2
	uint8 blockIdx;
	uint8 *blockBufferPtr;
	
	blockBufferPtr = blockBuffer;

	collisionX = (x + 0x100) >> 9;
	collisionY = y >> 8;
	collisionZ = (z + 0x100) >> 9;

	if (collisionX < 0 || collisionX >= 64)
		return 0;

	if (collisionY <= -1)
		return 1;

	if (collisionY < 0 || collisionY > 24 || collisionZ < 0 || collisionZ >= 64)
		return 0;

	blockBufferPtr += collisionX * 50;
	blockBufferPtr += collisionY * 2;
	blockBufferPtr += (collisionZ << 7) * 25;

	blockIdx = *blockBufferPtr; 

	if (blockIdx) {
		uint8 *blockPtr;
		uint8 tmpBrickIdx;
		
		blockPtr = currentBll;

		blockPtr += *(uint32 *)(blockPtr + blockIdx * 4 - 4);
		blockPtr += 3;
		
		tmpBrickIdx = *(blockBufferPtr + 1);
		blockPtr = blockPtr + tmpBrickIdx * 4;
		blockPtr++;

		return *((int16 *)blockPtr);
	}

	return 0xF0;
}
/** @file grid.h
	@brief
	This file contains grid manipulation routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef GRID_H
#define GRID_H

#include "sys.h"

enum ShapeType {
	kNone = 0,
	kSolid = 1,
	kStairsTopLeft = 2,
	kStairsTopRight = 3,
	kStairsBottomLeft = 4,
	kStairsBottomRight = 5,
	kDoubleSideStairsTop1 = 6,
	kDoubleSideStairsBottom1 = 7,
	kDoubleSideStairsLeft1 = 8,
	kDoubleSideStairsRight1 = 9,
	kDoubleSideStairsTop2 = 10,
	kDoubleSideStairsBottom2 = 11,
	kDoubleSideStairsLeft2 = 12,
	kDoubleSideStairsRight2 = 13,
	kFlatBottom1 = 14,
	kFlatBottom2 = 15
};

/** New grid camera X coordinates */
int32 newCameraX;
/** New grid camera Y coordinates */
int32 newCameraY;
/** New grid camera Z coordinates */
int32 newCameraZ;

/** Current grid camera X coordinates */
int32 cameraX;
/** Current grid camera Y coordinates */
int32 cameraY;
/** Current grid camera Z coordinates */
int32 cameraZ;

/** Celling grid brick block buffer */
uint8 *blockBuffer;


/** Flag to know if the engine is using celling grids */
int16 useCellingGrid; // useAnotherGrm
/** Current celling grid index */
int16 cellingGridIdx; // currentGrid2


/** Draw 3D actor over bricks
	@param X actor X coordinate
	@param Y actor Y coordinate
	@param Z actor Z coordinate */
void drawOverModelActor(int32 X, int32 Y, int32 Z);

/** Draw sprite actor over bricks
	@param X actor X coordinate
	@param Y actor Y coordinate
	@param Z actor Z coordinate */
void drawOverSpriteActor(int32 X, int32 Y, int32 Z);

/** Get sprite width and height sizes
	@param offset sprite pointer offset
	@param width sprite width size
	@param height sprite height size
	@param spritePtr sprite buffer pointer */
void getSpriteSize(int32 offset, int32 *width, int32 *height, uint8 *spritePtr);

/** Draw brick sprite in the screen
	@param index brick index to draw
	@param posX brick X position to draw
	@param posY brick Y position to draw */
void drawBrick(int32 index, int32 posX, int32 posY);

/** Draw sprite in the screen
	@param index sprite index to draw
	@param posX sprite X position to draw
	@param posY sprite Y position to draw
	@param ptr sprite buffer pointer to draw */
void drawSprite(int32 index, int32 posX, int32 posY, uint8 *spritePtr);

/** Draw sprite or bricks in the screen according with the type
	@param index sprite index to draw
	@param posX sprite X position to draw
	@param posY sprite Y position to draw
	@param ptr sprite buffer pointer to draw
	@param isSprite allows to identify if the sprite to display is brick or a single sprite */
void drawBrickSprite(int32 index, int32 posX, int32 posY, uint8 *spritePtr, int32 isSprite);

/** Get block library
	@param index block library index
	@return pointer to the current block index */
uint8* getBlockLibrary(int32 index);

/** Create grid map from current grid to block library buffer */
void createGridMap();

/** Initialize grid (background scenearios)
	@param index grid index number */
int32 initGrid(int32 index);

/** Initialize celling grid (background scenearios)
	@param index grid index number */
int32 initCellingGrid(int32 index);

/** Redraw grid background */
void redrawGrid();

int32 getBrickShape(int32 x, int32 y, int32 z);

int32 getBrickShapeFull(int32 x, int32 y, int32 z, int32 y2);

int32 getBrickSoundType(int32 x, int32 y, int32 z);

#endif
BCÀŞ!  Â  ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q  ›   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l † X6Äÿÿÿÿ€I     ‚`B L   ‰   ©   2"
 d…$¤„$ã„¡LŒ„MˆÄB ‰j@s`@Ğt0G %G)\$M%Lş!‚â5S„!$!!!!!  -’£Õ€ Õˆ€$(!Q ¨" è"9 (#- h#= ¨#è#%($9h$9¨$‘è$‘(%	hå,iŠ(aò5ar"Ó©vŠ(aBDBBµ¤ ÀaÒQÂä³0!Â· †ÄN%L(x¹Lš"J˜ük ¾0$vŠ(aBÁË9ÒQÂäÏoê Í„„„„c¤)¢„ÉŸßÍ¹Ğ ##sš4E”0ùZƒ0-ÂQL ;E”0!!€à$iŠ(aò5ar"vŠ(aBv C@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@0ÓB“d5dC5„s‘4E”0ù¬@4Dê Í„†„„„[¤)¢„É§ADBBBÂ)Tƒ84Nƒ‚‹¤)¢„ÉŸ†`§ˆ&Tèè$ğ$$Yù$r€% 	%  %  E$PÒaÒQÂä£- V"ÒÄN%LèHHHHHHHH…%b:Kš"J˜|ïš" D¤‰"J˜P”Ğ’@2Nô4PŠ(‚ ’*DQ•  €¬JEXEˆ
 ­"W)¢

È«6G#* €€@ŒÆ
A`@@eeˆ
 ³bDPZ1¢h­
ÔVz+ÅLÕQ\$M%Lş¶8‚â5S„!  3òH/öˆúhô( °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD ôÎŞÀYÀ8xgoà4øœ¾s<P>„JƒßÀ!'Æç@oà4øœ¿Ó  hğ8 € ÀŞÀI±(xgoà,àœ¼³€7ğŠ”G   ,àœ¼³€7pRìJŠİ@I±()v%Ån ,àœ¼³€7pRìJŠİ@‰a)v%Ån ¤Ø”»’b7PRìJŠİ@I±()v%Ån ¤Ø”»Rã<0r FôÀ¢8x§Èz ,àœ$ìÓ¤=p¢¸N•÷ÀYÀ8xgoàĞŒ»’b7PRìJŠİ@I±(~§Áoà4øœ¿Óà7pRìJŠİ@I±()v%Ån d”¼“b7PRìJŠİ@I±()v%Ån ,àœ¼“b7PRìJƒßÀé8xgoà,àœ¼³€7pRìÊŞÀYÀ8xgoà4øœ¿³€7pğÎŞÀYÀ8Yà%| d”»’b7PRìJŠİ@I±()v%Ån ¤Ø”»’b7PRìJŠİ@I±()v%Ån ,àœ7ò3g>pRìJŠİ@I±()v%Ån ,àœ?ô²€7pÕJŠİ@9d~goà,àœ¼³€7pİÆ#üÀx„)v%Ån ¤Ø”»Òà7páÆŞÀI±()veoà,àœ¼³€7pğÎŞÀ‰D8)veoàTÊ”Hä³€7pğÎŞÀYÀ8)veoà,àœ¼³€7p6éJ¨ıÀYÀ8xgoà,à|È2      0d©      ²Ô      Yn €     †,¹  @     C–] @    €!K/      Àå      `È      0d!      ²˜     YĞ €     †,è  @     C–\       €!Ë.      À%      `È      0d©      ²¨      Yf €     †,½  @     C–Z       €!;      ÀÅ€     `È’      0d      ²À      Yä €     †,ğ  @     Y   +   2˜ LŒ	&GÆC „ "  : € R ‡ ‚ ‰ ¢ 
=ÅQš$‚®A©3é<ê@byz¼‰ëfsY*ãÇå2¹Lt1@# ´1@# ô1@!# 42@%# t2@)# ´2@-# d3@8# ä3@@# $4@D# d4@I# Ä4@O#     y     C„yHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   ²  6¢Î² â4±‘(‚³,ˆ„8lÈ—ÀDpÄ² FÈÀ9Å4¦AøÒY‰"8Ë‚HˆÓÌ&EDähÂˆÃ•®h‹¦GÚu@dÓ!‚ÂÀC|Ô²4×#ÍàX›3Mc4
%!ÁADØªë_nÚ¿­äÿ‰¥g_S9Íô"álTQQ€H6ó ME4“a'Å€€d¶‹SÑ`%"MV@-KÅøÁHÄä?4ÂûÈmÛs€2D€Å>2â<‘“¤$³BDAU9Zƒ0âpi ¸z,+¾Í-À<±:T3Ø‚Dˆ °HF´@°&…êú—›öoeùbé™‰CIG,Ò`„–ğXN¤¼È@8UDdt0ÏB˜HÓ€Yb€$PQD4+DÈ3½ÀBæ,ó¤!IÄ@˜,’@4„&LN$YÓt‘ã52aéŠ¶hªq¤¹,ÑD´"Æ1™#Ì³+ñÀd
O!‚âJ€A´@°v°<ÀBL±‚›f2ÒTD39f"¤ÒL’ÁPHSÍäDØI1%Òæ\Æã ME4“a-,„)PBD ÁË‚4!ƒ	<öP!’+!F‡“FNBâ4F±D´+1D€eÏAD¼…°,¶Ã‡ƒ„ÖHv@dÓ!‚Â:T3´ØC˜#Ì³é`Ä`ÄÎâ !Ã!‚"Ä, lTQ‘ÁIÀ<¡1B4Ñ"a©Îã,ØJ4µØCØq $D0`„œ³PLc‹@EÑL`„VÖ,óhÂäDìD<Ö#!ME4“a,’-,„	°,`‡–@EÑLö9ËâXÄ 	“tÀcÓ¶8‚R"AD˜QmED3¥„LˆÓˆÍæX:E-˜l€$PQtRZ¬ÄÖæ\¦=Q!%±Ñâp"	DC„DäÄ–§HÑ!9²é)’@4DHDÎl‹$ÑF€ HÆğ 2qÄ² FÈ`UKàL“Ã”D1Åæ0`¡±O„L„&LNd5ÒTD39ö-€!™Õ8Óä0%QL²]-3MSÅ4›Ï"=2-,„¡8Ò„ÖÑÁm‡ 0DÄÆq CD€l‡ 0DÌ¦Â0€°,âp™_’9‘Û_’9‘#`@’9‘3›q t@HLÀ²8‚×LfJCXÀ†Ò0DÈ–¡4„Å³Q(1D€FÈ`fÕ€H@°¬D³ÑLDdwŠ$aR"b€$PQD4“&LN$6³ÓÀDD3ÑæL“Ãk@ò¬D3Ñ[ÛÔr‘£5#—-Q9^3!¦àê±¬øzVHÑ!9tH08VlA‡t ƒcÉ&tH08Öl•ÔD\Œ4ƒcmÎ49T„8’@4ÄI1š09‘dO!‚"6…³QEAD64I08ç,"!NÓba]ÉB“éPai@EÑL¬@4„8\F-óˆME4“aâD0Ö`m"(Æu,Ğ"aNÑADÖ Œ8\'ºšZiªKC1hñÑD\F°T,„&LNd(‰0Ä· †d Î9IêH3+DÑØ‰#Ë‚4!ƒ8\†	‘ólÎ49+DÑ˜eÀñ 1M„y<€4)°ÓD¬à¦Yœ#Ì³ @#6`<ÒL…MHqM0ÒUÅÄa›ËâJ
,Ä46±4ZlËb.ÒTD39vRI`’A(’@4Ä· †dµQ@ÁB°O„L„ØÄeLÒAD×LÈ„u"Ë­^ëYÊb ÁÀ3‘EDVÔ ÔähFDHR6æ,ópTÍD˜EÂĞ!‘éLÀÜá !±Ä4!!YgÀÂ H“1M„á,ÀÜá !YtÀbÓ!‚’:’áDOä„$qÎ² â4±åDOä„$qÎ² â4²éDOä„$qÎ² â4³±H` Â,‹F]›C5a$qRL‚"Yi@1Ò›f€ò ËJHÄDF0MÄ5ÁH38ÖŠÇÄaQÓADÖ Œ8\Èr«×zÆFIO„LÄæPÍ€4Ææ\éÙi@1Ò4[k€Í@D%QLfP„4ÉfT=Q!%…DälÄTˆCE6ĞÄÄ>2,’v=Q!%…Däh±öDD3Që<…êú—›öƒ«øbéÙÏ#=2,’-,„1(’@4Äì4„dÒÎç,Ó€2˜òDN’:Rl È9IêH²… Oä$©#Í&àLÄ5ÁH38VI“)™ã0¬Dc¿Ï9!I`„& )FÔDälÄTˆCE¶öHO„L{ ƒc¥Sd³NC1h±CX›s™ƒ"PQD4Ó¶,vãH@E¤€Ñ	0„IDqM0ÒÕ:T„)0°(HchÂäDöá<‘“¤³BDaD°ÓD¬à¦q”49ŒU\Oä$„0¥„LˆÓ +DÑXL„4ÑLN„S@!Ùn $ ”DhÂäDÀ a¼Œà<!ƒ	HŠ‰<Â4±:óQMÛcÀ#@c«ã0/Õµ9<CX[„
ûDÈDÚÓÄÀ@c¬@4„!@A„ŠÔ°QEADÖ `¡™Î@,š09‘U8A„JŠ\Ä’:RlN!‚’"±¤$[]$Ì³&ÒtÄ`k3XTDN3½È@8UDdËÒ !ƒY41m"(ì<„D’DS:B=-,„1(A„Ja-ˆP±ˆÃe N!‚b’ÒÁB˜h€âDÓá¤‘“Ä6 8Ñt8iä$²‘(N4N9Él·	qMP"Òd‚ĞADNêHÈ„8M‹=„µQED3 C ±Ñ†•LÎ³"Æ1Å–•LÎ³"Æ1É¦•LÎ³"Æ1Í–£4Ã"’4qM0ÒÕ:½%1%b“8! )ÒÒˆÃebÖâPRé8O’D$™’t‘ã52aZ–^+ràL!ƒ	HŠy)b“éPa‹$qRÌì4„d{HCX!9±ñ!a…DäÈÖ‡4„‘3Û‹„4ÑLN„CÒAHfÃÎâ0Àó-€!™›,Ï”ˆqLö4DähÂˆÃ¥µaéµ"g`Ëâ8éTD:E¶"1€°,'ÅlÕ„ÅHCXbÑF@#mÎeIĞAD×LÈ„èjj¥e$°p”49Œ%4BD FÈ`­DMÄÅ9N4 0’<qM0Òµ"Æ1gÀDI„¶LDÔ ‘1M„m!…L À    a   0  b     DP5PeP¨ 3ñÃLDAüÇ0Qÿ1ÌDÄ3ñÃLDAüÇ0Qÿ1ÌDÄ3ñÃL„AüÇ0aÿ1ÌDÄ3ñÃLDAüÇ0Qÿ1ÌDÄ3ñÃLDAüÇ0Qÿ1ÌDÄƒ”7 ƒS7 ƒ7 ƒÑ6 Dñùƒ€‚11@Ö jŒ'á‚°" Á`„ mƒ´1ˆá‚°" Á`„ }ƒ‚pAĞ7L@`„`0"‚ 2ã	P. BƒaB ê ƒj ¥Á :ÃB`³DĞº“1Ü h0Ë@ÁÁ <ÃB€³ÄÚ“1Ü f0Ë@Á,AŒñ„à#ô  ºƒ1Á ŒÁ8€ô`‚X
 Œ˜ƒ` hÆpCği0Ë`Á,A…aBT!FA,ˆ…F„B0 D
Ã‚Y Á`„)@¨0,¨F¨B0 
ƒfe7Ì2 N@µ2ˆ†	A#H! "…A¦0,B0
Á *Œá†€$Ò`–!Q‚Y‚0 TÄ
Ãƒ®À,ÁBº0Æ‚rŒà…` HÄ`Ä+@¯0èÆxB F„C0 ³ÍÂ°`@0QÁ 71³KÌ8„ƒpa˜€À‚xµËn3˜ex¤€ŞeĞ/‚Xp Œ‡` (ÆpCĞi0Ë EÁ,AÌHD/ƒÊaŒ7ÔXŒñ" yã	B0!Á >b‡1ŞÀ/gP0Æˆ€òaŒ'Á`>0K0‘?Œñ„ %#@" Â1¡Á ÌP$c<!h‰Á’€„pAFôC0 ÔƒDbŒ'Â`I@ 1ˆ$ÆxB F˜D0 4ƒDbX €`0‚$‚ “ä#R" J‰1Ü€FÌ2XU0KğÑLŒñ„À'#j" Â1áÁ F´DiÀ,ÁE-1è%Æpƒ Á,ÖôƒÄf7ÁÌ2d[@21ÈlÆpƒ¤Á,ƒ¶¤ƒ‚@=1#! f	6Â‰a[€`0B'‚ °ã	\FˆE0 c<!‹Áˆ±`–€£ŸĞ#Â"€Y‚k–À£±Ô#Ê"€á†`7Â`–úZ‹1AÁ ZZ‹1ƒm ­Å ¶ã	0ñÁ Ì€¡Å°à/@0¡Á 7å³S $   )`8E!“M
‰1
QL)0TÂmÒ¤Sd†CMé¥ Rl•H²Y
‹d„)
“óØ¢€8Óä0–(0<Sd’ÄD0íH3—ñ—õ˜ùUDd˜Ì‚4DL ‹d„5
b“]
DÅ E‰4Dë¬ãT       a   y   O,      DPSÅT¥  3áÃLDAøÇ0Qş1ÌD„3áÃLDAøÇ0Qş1ÌDØáÃ`À`ÄÀ`„ñ ©È°ÀAY…`0"	€^dX  ‚‰#–` ˆƒJ0 ³)ƒš1Ü i0Ë 8Á`„Ã0K03Èã2âân(4˜e ˜€¨AÔo¸RÆ‚R#¬` ÈãÁ)ˆâ±€@@c2†„Àf
% nŒ7®ˆ„Ğd7AÌ2J@c0ÆZˆ
ÄBm0†„àf% 4ã.èâ¡6ã/Üâ±" İÁ =& n 3˜e@’€ì`Œ7çğˆ„ö`Xp
"° B@}0ÆwH
ÄB£2F ˆ‰Ä‚Y‚d–@™%Xˆ†° ‚ÁS`–`˜%h¨†² ‚ÁˆS`– Àp     v(qÎƒm‹#(éI%QL¶ÄÆÈÖÌ†( qÎƒm‹#(éI+b“%
ˆ)
‰-
8E[„Š×L     a   “   S,      DPSEP
Å 3áÃLDAøÇ0Qş1ÌD„3áÃLDAøÇ0Qş1ÌDØáÃ`À`ÄÀ`„ñ ©È°ÀAY…`0"	€^dX  ‚‰#–` ˆƒJ0 ³)ƒš1Ü i0Ë HÁ`„Ã0K03Èã2âân(4˜e  €¨AÔo¸RÆ‚R#¬` ÈãÁ)ˆâ±@@@c2†„Àf
' nŒ7®ˆ„Ğd7AÌ2N@c0ÆZˆ
ÄBm0†„àf' 4ã.èâ!:ÃB ³ˆĞŒñ† ô€qŒá! ƒY†D	¨ÆxC`@¸€@H†¦ N!Äc¼!hT @\@ $*cÄà  ˜H!˜%P(ÆxC ò@¸€@ˆÆpƒ˜Á,³t
c¼!ÀY @\@ c¸AÌ`–ij…1ŞøÃ-P . ’…a/ˆÀ‚_ÑÂoJ(éÊ18  -Cf	šYg–à¡]œ#z!€Y‚a– "^¤#|!€Y‚ Ã     v(qÎƒm‹#(éI%QL¶ÄÆÈÖÌ†( qÎƒm‹#(éI+b“%
ˆ)
‰-
8E[„Š×L     a   Í   S,      P5@%PÈP8P~(P€ 3ñÃL„AüÇ0Ä3ñÃL„AüÇ0aÿ1ÌDÄ3ñÁLD@üG0ÿÌDÄ3ñÁLDAüÇ0Ñd0Á`@Ì¸ `#š` è,c0Â€¤1hƒT0 „¢Æ;@ÖO¾Á, jF` €A^  ƒR ÔÁ- êÆ`„À`DÖ
0KF`­ ƒW+ ic0¢€¶1¤Á`D yc<!XƒÁ0€„0Á@a0(Dl ÃA-„Á,ƒ0Tc<!˜ƒÁˆ3`0BĞ…  2ÜFœA ³Ã,Aj0Æ‚;Œ`ƒ` Hƒg AŒ`ƒ  ˆÂQÁè 0A „
B#ä  rƒpATÀ:ÜœCÌ2F@v. ²ƒpAX0€à ŒĞƒ  ÈÆxB°
ƒ À,Cz. ˆ
NA‡‚yƒY†	HÂA¢. \  ƒ¦ ¡B¸€ ˆÆxB F¸B0 ³©BnB"f% Vc<!ğ…ÁY`0B€`!T 0!A FÄÂIÀ,B³¨ÆxB0ƒ·À`„0 ÕB¨à`0â‚ ˜%Xf	˜Y‚†j!T€0qA \@ÃAK˜Á,á¤a¸!ˆ‰0˜ex €x!8Œñ„À#Ä!€Áa ‡P<À`„807 ³‰C sƒ ³C¨ `0B‚ ¸€ †0ƒY†@
H¹Ã¸ `o È²„ 2     ¶(0b‰Ç3E,P¦(@<SdÛ£€ &) ‡E
ÀbB°X£@‚LDLˆÓ˜£€ÒPZl‹#(Æ(0büÃ3E¶`TQ‘M
Dp       a   1   I,      DPÍ  3±Ã`D00KP0†‚f$ aŒ7Ü‡„á†@Â`–a0:ÆxC‰¨A@ÁnÒ fˆ" eŒ7¤ˆŒ T!˜%(Èã!cÄ€  VHã0RÁ`D0 Qc¼ÁDî  `Ğ5ÆjD
ÆˆA ¸@³Æ,ÁAÛ°ÀÁ`DÀ,A€á@    Ö        a   *   A,      DP…    3ñÃL>ÿ1ÌDàñÃL„AüÇ0A(01$0! 0@Á bXpˆ`<a.(X
c<!#’` („‚œ1@ÍO&
ÂAÒŒ„Àp  	   ÆPXÈ0¶`8E!“õÇdş‰ôDÈD¤S       a   å   W,      P$6@5P
%P,KPœzPĞŒT€Q0”)Än»a;±`;À    3"ÃLDA€È0Q 2ÌDˆ3"ÃLDA€È0Q 2ÌDˆ3"ÁLDA€È0a 2ÌDˆ3"ÃLDA€È0Q 2ÌDˆ3"Ã`D40i0ñŒÂ F,£0 # ä‚T
\# äÂT
\# äU
™#ƒ¤a‚ñ„!Œ‚ŒˆÄ` f	ŠÆpCÀ‘Á,ƒ D¢FŞŒ'a0¢
€°QÁh¡AÅÁ]  ƒY ¤…‚¶pAÔèpC€a0Ë08™É 1ã	BpAÁR0#Æ  Z“Ad0Æ„`0¢‚ 2ã	8P. ˆÁ4€Ò`Œ'¡@A¸€ #Ö  jƒ1ğá‚Œpƒ` ÁÁ(!ŠƒQB ƒr ÙÁO^a0b‚Œèz€Y‚ú`PŒá! ƒY†¢	ÈÆK¸€@#ò  Êƒ1ÜğCÌ2K@{0*ØŒèƒ` ¨µÂn‚2˜e8€@aFÀB0 ³…Â XÃB ³‰)ŒÁˆY`–@¡Rã¹‚Á`D€0K°*Œñ„€#T!€Y†haTp0aÁ Ì³ÕÂ¨ `0â‚˜%x(Fë ƒ»À,A@¾0#x!€Y‚ˆxaĞ/Œá!(ƒYÉ
èÆxÃ¹ØD@Ant"f&* qãé¢Ë s# ÈÅ „c¼á]~"Œ†˜% f	*R‡Q?À`;0Ke?„  -   ¶€2°HF˜¥ $PQD4Ó¶,hQHÄdÌ3E­³-Ë†L’E
ˆI
‰q
(Á²tÀ¤Sd˜H°,,’±e
 Á²°HFÈV)àTÍ´!“	HŠi
 Á²°HFÌÖ)€"(âp™£€R ‘4m"(6) 	TÍ´-‹×L&—m
Á²°HF¥€#PQD4Ó†L6v)ĞTÍ´-K:Eö(,€4m"(     a   ‹   V,      DPåW€P 3ÑÃL„AôÇ0Qı1ÌDD3ÑÃLDAôÇ0Qı1ÌD ÑÃL*ı1F$Ğ F Ï P2Æ‚g0b	€„pAF(Á ÌÔŒñ„`Œx‚ !\@ƒM0 ÔŒ
,µ Á`„ QãŠŒx‚ j\@±ƒP0 D
8nB!f!Œ¨Da f	ªic¸AĞ`–0²ÆxB@ƒX0 ƒ*À,AAÚ°À@0Á0K0ÌLä
Ê@‡‚UƒY¤	#>V€Y‚„¾Ad0†„ f& 0ã	FŒA0 $ƒ1ÄÁ`D0!0K°Ğæ ƒiÀ,A2K Œñ„ #Ô  Ä1áÁ F´.À,Cm0HÆpƒ Á,Ãã‚ 8ã	FÈA0 ƒÂ  ³ÑÁ° @0aÁ Ì8³Ò,ÁDu0.ØÁ?€ì`\°ƒÀ,E}0,FüA0 ÃA:„Á,CP   Æ@„4Y¢€bDÈ°QEADF( ‹#(œC5“
(A„
çPÍdû‰!ƒ×Lfˆb†D± †
F„âp™¢À, lXQ     a   Š   V,      DPåW€P 3ÑÃL„AôÇ0Qı1ÌDD3ÑÃLDAôÇ0Qı1ÌD ÑÃL*ı1F$Ğ F Ï P2Æ‚g0b	€„pAF(Á ÌÔŒñ„`Œx‚ !\@ƒM0 ÔŒ
,µ Á`„ QãŠŒx‚ j\@±ƒP0 D
8nB!f!Œ¨Da f	ªic¸AĞ`–0²ÆxB@ƒX0 ³iÃ3 Á`À,Á0K0‘7*(nV!f&ŒøXa f	ú‘Án4˜eP˜€Â`Œ'n01Á  hÆxBƒeÀ`„0À,ÁBg0,˜F¤A0 ³É,Dh0Æ‚:ŒPƒ` HÄ`„0Ñº0 ³µÁ 9ÃB€³OPŒ€à`Œ'~0!Á Fƒ Ì@DÃP Á`„0KàÌH³ÕÁ¸ `#ü  ²ƒqAÀFüA0 ³õÁ°@@0ñÁ 7é³A`8     Æ@„4Y¢€bDÈ°QEADF( ‹#(œC5“
(A„
çPÍdû‰!ƒ×Lfˆb†D± †
F„âp™¢À, lXQ     a   J   I,      DPPEPd(   3±ÃLDAìÇ0Qû1ÌDÄ~3±ÃLDAìÇ0a°Á Fl0 ³	c¸!`Ğ`–A@BÆ` £ç#’` #8€Y‚1ÜDh0Ë@…È eP3L@`T ‚ñ„"¸€b)Ä`D ©È iŒ'©È lŒ'ÁˆA ¶@´>FtÁ Ì´Ê ƒ]0 ³Á°@@0!Á ÌäÒ ƒ`À,A€á@    &(°‹#(hQHÄdŠ@EZ1¡@pY¡@Ù ÀaDÈ —
(F„hQHÄ      a   Y   I,      DPPEV€(  3ÁÃLDAğÇ0Qü1ÌD3ÁÃLDAğÇ0aü1ÌDƒÈ3 ƒÇÀ`„ñ0A¼Á ÌDŒá†ÀAƒY	ƒH0 ´ZÆx‚F Á F$u0 ³%c¸! Ğ`–0RÆK¸€ #š` Èã	A6@Ö hŒ'­È kŒ'ÁˆA ¶@”À ƒ[0 ³eÃ‚2 Á`ÄÀ,Á@ß°`@0Á È ƒbÀ,ÁA`0,XFˆA0 ³†      V(°‹#(hQHÄd„Š@EZ1¢À2ÌFÈN‘
—
8E`„hQHÄd†Afû‡!C:E–( 2 E!     a   "   A,      DPE    3ÁÃLDAğÇ0!@ï1h# ğA}Á` ÅÇ cŒ ğ÷!tŒ F!1  H?ÆKÁ¨ÀÁÁˆü`Ä` €QH(    ö€2°HFØ~@4q       a      C,      DP@	%    3ÁÃL„AğÇ0!@ğ1h 10 Àˆ! bŒ Àc¸!Hƒ0˜e„€1b@  *³Â`D},n     ¶P Í@\(p2¤S    a      A,      DP 3áÃLDAøÇ0Qş1FÇ FÆ FÅ Ğ0h42Æxƒ~¬A@Á1@ @Œ‚Ú Ã       ¶P Í@\Æ@<[ ñ8’    a   %  c     DP¨PEPåW€    3"ÃLDA€È0Q 2ÌDˆ3"ÃLDA€È0Q 2ÌDˆ3"ÃL„A€È0Q 2ÌDˆ3"ÃLDA€È0Q 2ÌDˆ3"ÃLDA€È0Q 2FL`0 ƒÒ7 ƒ‘7 ƒP7 ƒ7 ôŒá†€ƒY†@H4º†Æ†à‚‚¥`Œ'Á`„À,@Ü mŒ'd@A¸€ ¬@0Á@a0(ÆxB„ÂŠ ƒd ™Á  \@TÃ„ ØA#Î  bƒ1àá‚ 7& ° B0Á ĞŒñ„ #ê  Šƒ1Á ŒÁ4€ä`X0
 Œ ƒ` È†¥ ‚Á<€BeŒñQi‡€‚1@Äc<A#ø  êƒA0LB`Á+„Àì!Á`(0ñ÷0 ³ıÁ Rt
Ã„ ÃD€³„Ä
c<!À…ÁW€„pAF˜B0 ƒ§ 0KPĞ):…1Ü h0Ë`€A@³0Æ‚_Œ¨…` HÄ`+@¬0*ğŒh…` ÈF¿ ÃÁJ„Á,ÃÑÃt Á`„,@³0*n`"f$$ pã	A;FŒC0 $„b0B‚ŒÀ…š€Y‚„pa.Œá!@ƒY%
HÉËn‚3˜eX€za½Œá!@ƒYæ	èİËn‚3˜eh€ÄaP¾Œá!@ƒYç	(Æ @ç0,	X0" u&  ã	0 0KğĞ;Rƒñ åÃOVb0b‚˜%€ˆ†-‚Á{`– ™%à#ìa.`–`"{„c¸AĞ`–ÚÂ‡A03†„àfª, }D3c¸AĞ`–ÁÊê‡A53†„àf®, t3c¸AĞ`–Ë’‰AA ’ü„,PJĞÏŒñ„@Œ ˜%È¨%†g‚Áˆ—€zbŒ'i1ñÁ PNŒñ„`-#v"€YhbXĞ Œ°‰` f	¦Yn–À£›¼è'ÆxB F„E0 ´Ã‚¹ íÄ°@ Á`DO0KàÍ|$Ã‚» Á`Y0KPYB‹1ƒj ±ÅŒ‹` H,†}‚Á²`– h-†‚Áˆ¶`–`Àp     &)`8E!“a
ˆñ#ÅÖ@<$Û£ ±Åd•C%Ü)`8Ô”N‘]
$ÈDDÀ„8ı ˆÄ>2Ö(0LÎc”‚`›£€8Óä0æ0<SdûÒÄe–ÄD0M
Bm™ÁešfE„Ç    a      A,      DP 3ñÃLDAüÇ0Qÿ1ÌDÄƒD2 ƒ2 ƒÂ1 ƒ1 D"ƒˆ1b€ €ƒ$    æ0<SdûÒÄeüÄãH±õ#É       a      A,      DP…    3ÁÃLDAğÇ0!@ò1hV"O‚
–‚1q@ø1ã	BA8      ö`8E!“íH3     a   "   A,      DPSÀ…Qå:    3áÃLDAøÇ0Qş1FÌ FË FÊ Ğ0H&!°`#î# BÃ„ 8" eXğˆÀ† @ Œğ` 0    ¶\Æ`Öd        a   °   N,   
   ”PDPePEP0S€
ÕTÀÅ*P
ÅP0”aiÄn»   3"ÃLDA„È0Q!2ÌDDˆ3"ÃL„A„È0A!"ÌDDˆ3"ÁLDA„È0aDˆƒË7 ƒŠ7 ƒI7 ƒ7 ƒÇ6 ´Œ V!O4j†›Æ†`0‚	€˜AAŒ`‚  gŒ'b@AŒp‚  hŒ'bpÅR #¨@ ˆÃ,„Á,ƒ³iƒjd˜„€¸A72LB@Ş &!10 `" ÃÁ Á,Ã@³…Énààf
#˜%hHLÆpCh0Ëp Á,ACd2†98ƒY†D	f	:qAXĞ! 5¤&cÄÀ  z„€ØdXĞ ¨Àh0‚‚ 6ã~¢ânüàf&1  Àö`– !9ã¤â!;ã§BÁxCPÃ`@ 0.H Òƒ1ŞäC>Fƒ Ğ(Œ€ü`Œ7ıpƒÁ  d
ã‚ QãAHàÂ`D0 ¡Ê¸ ÈÆxCP¾0@«2.H R…1Ş¤D8Fƒ ,ˆÂsÁ	@°0Æ‚—ø…Áˆ` ª…@³0Æ™‡Áˆ` º…@¶0Æ‚š‡Áˆ` Ê…1Ş°.7P * Œ˜%h0    ¶€‹#(âp¥ , ¤Sd•H!‚"—]
(A„
ëPÍ`˜L!‚²QE!—õ—ù˜ı™ñ4A„Ê¶8‚"—Y
(A„
{ a™@EÑ!‚â5S„       a   |   U,      DP%Q€Q8%3±ÃLDAìÇ0Qû1ÌDÄ~3±ÁL„?û1Ğ}Œúv0b€äcTàÜ`|@ó1*pn0">‚ úH7!Á }«ƒ TÃî ÙÇ°<B0b`  (C@ø!#ğ# º1q F\}0 ³]c¸!ĞĞ`–A ÊÆx€B0ˆ‚ Ì´Ä ƒ]0 ³ñ‡¸€@†‚R ƒY†Âf	¨ÁˆÎ`–à n7e€³F„*À,ABa0†‚3@ƒYE
#Ä@`–`!1Ã Á,DƒÌ`P"ƒ1ŞÀ‚0ŞÄ1ŞÈ‚1ŞÌÂ,P#Ö  Zƒ0ÜàBÌ24N@m. ò $ƒè`Ğ’ƒ1Şø‚0Şü1Ş€ƒ1Ş„C(P. êƒA}0¨Æˆ ğàƒÌ8³ıÁ° @0
Á Ì,³‰Â°@@0A
Á Ì$³‰Â°€@0A
Á Ì      V(€‹#(âp™ @pY @€Ø @€¡@™¡ÀÀ      a   ˆ   N,      DPHPPQSdEP%S	e    3áÃLDAøÇ0Qş1ÌD„3áÁL„AøÇ0aş1ÌD„ƒG6 ƒ6 ƒÅ5 D"c0‚€aÁ‚
®Œ¨` HX9aÁ Ğ2,à@P—ƒø éÇnFf„  şÃÁw³ÂFT¦  ³õÇn¼4˜e Š`0â* ˜%hè?ÆpC
h0Ë…ÈnÂÀf’# ÃA+ Á,C‚D"c¸!Hƒ3˜eH”`0âƒ ˜%hE†f âÆxB FxÁ ĞŠÒ@c<!#Ä  r‘Qœl *ƒ1ƒg Á  F¨A ¤a¸!‡0˜eX˜€ÜdF¬A0 ´ƒÜ \@øÆˆ`<!Àƒ
–‚As0Æa0¢‚ :ã	AFÜA0 „c<!`
Â`D@z0HÂaA+ˆ`<#ş  úƒAA¸€ #P! €Y‚†FaŒ'·@A¸€ #X! €Y‚†Xd     )€‹#(âp™¤ , ¤Sd“ËÄ<[„Š8\¶\Æ`Öd)à‹#(UD”N        a   æ   _,      DPQ0EP€%Q€…Pş5PdåP2•P 3ñÃLDAüÇ0Qÿ1ÌDÄ3ñÃLDAüÇ0Qÿ1ÌDÄ3ñÁLD@üG0aÿ1ÌDÄ3ñÁ`0±|0¡x0‘t@+2#ˆ` ¨h ¨@ËÁş€Qä`D@Ğ°àA_FüG0 "c¸!P4˜e‚€Fd7bp³ÂFh­  ³‘ÈnÂ fˆ"ŒàÖ  f	<2‘1ÜÀÌ2$F@(2†60ƒY†ä(EÆpC@h0Ë ­ÈnØàf%Œ ƒ[ €Y^dX " nŒ'Â`„ ÉÈ° D@`0Æa0B‚ ÄÁY" 2ã	0qÁ Ğ
Â`Ä@k†‚tƒY†…
¨NÆ`Ä@k0èÂaA(ˆ`<Æ‚>¸ `)4c<!#ê  ªƒ1ˆÂ`Ä@x0ÆY  FäA ¤ƒô \@À‚Æˆ`0â‚ ?„ÁˆQ€PaX@ ¨€r0B‚ <ƒªÀ`D*ŒÄ Ì0”
ƒXa7Ì24S@­0†‚p0ƒYç	ˆÂ1q ÌxÔ
c<! ‡ÁˆW€faX Œ¨…` (ÆK¸€@†™ƒY(
#Àá `–À›%(†ğ ‚Áˆ]`–€¡\Ä`9 0Kà‘.Œñ„€(ƒ¾ Ã°à@PÁ=ä`D9@´2#Ê!€Árğ‰˜%¨ˆÃn4˜e°¸€Ğa7ü`³Ğ9„b0B ˜%ğÆxBğƒê ¹Ã°€$@0Á ;Œ(–q7m³™FìƒJ À,7K°=VƒöÀ,A5KĞFô\ À,Gı 2   f)€‹#(âpY¦ , ¤SdšËÄ<[„Š8\6)@4„%¥@!PQ$Û~@p@€Y@™€€ÙV) v) "(ì<„a
8ÁâÊF¥S       a   ‰   N,      DPHPPQSdEP%S	ePà 3áÃLDAøÇ0Qş1ÌD„3áÁL„AøÇ0aş1ÌD„ƒ‡6 ƒF6 ƒ6 T"c0‚€a‚
°Œ°` H\9qÁ Ğ2,è@PA—ƒù íÇnHf„  şÃœÁ,ƒ0ƒÕ) À,ACş1†‚/fˆ"Œ¸Ì  f	‘1Ü¨Ì2$F@"2†10ƒY†ähDÆpCà
h0Ë •ÈnÔàf%Œøb f	J‘aÁˆ€¸1ƒ^0 Ä"Ã5ÁO„Á1€^dTĞgAˆ€Ê`Œ'Â`Ä@g0(ƒj ©AnÆ!f& 7ƒk ­Á 7„ ‚ñ"Oòà‚‚¥`ĞŒñ„@Œ¨ƒ` ¨ÆxBàƒw áÁOZ‚0‘A ÒƒpAXà
"O ‚Áˆ?€ş`Œ'µ0
Á P(Œ(–qF¬B  ³Í`Ä*° Ì4´
 ƒp     )€‹#(âpÙ¤ , ¤Sd”ËÄ<[„Š8\¶\Æ`Öd&)à‹#(UD”N            /** @file holomap.c
	@brief
	This file contains holomap routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "holomap.h"
#include "gamestate.h"

/** Set Holomap location position
	@location Scene where position must be set */
void setHolomapPosition(int32 location) {
	holomapFlags[location] = 0x81;
}

/** Clear Holomap location position
	@location Scene where position must be cleared */
void clearHolomapPosition(int32 location) {
	holomapFlags[location] &= 0x7E; 
	holomapFlags[location] |= 0x40;
}
/** @file holomap.h
	@brief
	This file contains holomap routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef HOLOMAP_H
#define HOLOMAP_H

#include "sys.h"

/** Set Holomap location position
	@location Scene where position must be set */
void setHolomapPosition(int32 location);

/** Clear Holomap location position
	@location Scene where position must be cleared */
void clearHolomapPosition(int32 location);


#endif
BCÀŞ!  o  ‚        #‘AÈI29’„%‹b€EB’B¤28I
2D$H
!#ÄR€!r$ÈHb¨ ¨@Æğ   Q  L   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊ I     ‚  ‰      2"H	 d…“"¤„“"ã„¡LŠŒ„¤LXsHZ 
	( hÌ@T’ĞI@i Ra£•…Ş@â"9@     °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:¤H #DD 
F"Ãh`(¥¡40”†ÒÀPJCi`(¥¡40”ˆ†QÙ06NçÂ	y(²L      0d™            2˜LŒ	&GÆCZ# TF hŒ Ğ 4@a€Ø ½     y     C*X ;„ƒ;œØC9ÈÃ<¤Ã;¸ÌĞŒPØì¡Ü È¡Ü¦     y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   J   öàH@E¤€Ñ	0„	,ÀÜ<Ù Ã "lÀ²ˆÃeˆ°Ë¢Q×æP@X@b ñ-€!Ä "lÀ²œ³9T#¦!ME4“a'Å”PH&1 Cp‡ƒ„ÄÓ„4†d”°@:‹Ã OêHÈ„8-PHSÍäD˜	ˆ:H3I¡4Ã"’QH1…Îâ0À“:2!Nc	ÒTD39vRLI …´9—5(”„4a‹0w8ˆ@HÆğ ME4“a'Å€€dÒTD39vRI`’98HSÍäDØ· †dŒp8ˆ@hd‘!HHSÍäDØI1$ „d Ìá,<ß’4` BITÄ" a      A,      ê?€V	  3ÎÃ`D@ c¼aš`0"( Ã      æ, LˆÓ        a      A,      ´J ø
0     3ÎòƒA1 Œñ2p
Â+*8ô ƒE tŒñ5 
Â+*`ö ƒE     æ, LˆÓ            /** @file hqrdepack.c
	@brief
	This file contains High Quality Resource (HQR) decompress routines.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "hqrdepack.h"
#include "filereader.h"

FileReader fr;

/** Decompress entry based in Yaz0r and Zink decompression code
	@param dst destination pointer where will be the decompressed entry
	@param src compressed data pointer
	@decompsize real file size after decompression
	@mode compression mode used */
void hqrDecompressEntry(uint8 * dst, uint8 * src, int32 decompsize, int32 mode) {
	uint8 b;
	int32 lenght, d, i;
	uint16 offset;
	uint8 *ptr;

	do {
		b = *(src++);
		for (d = 0; d < 8; d++) {
			if (!(b & (1 << d))) {
				offset = *(uint16*)(src);
				src += 2;
				lenght = (offset & 0x0F) + (mode + 1);
				ptr = dst - (offset >> 4) - 1;
				for (i = 0; i < lenght; i++)
					*(dst++) = *(ptr++);
			} else {
				lenght = 1;
				*(dst++) = *(src++);
			}
			decompsize -= lenght;
			if (decompsize <= 0)
				return;
		}
	} while (decompsize);
}

/** Decompress entry based in the original expand lzss lba code
	@param dst destination pointer where will be the decompressed entry
	@param src compressed data pointer
	@decompsize real file size after decompression
	@mode compression mode used */
void hqrDecompressLZEntry(uint8 * dst, uint8 * src, int32 decompsize, int32 mode) {
	uint16 offset;
	int32 lenght;
	uint8 *ptr;

	while (decompsize > 0) {
		uint8 bits;
		uint8 type = *(src++);
		for (bits = 1; bits != 0; bits <<= 1) {
			if (!(type&bits)) {
				offset = *(uint16*)(src);
				src += 2;
				lenght = (offset & 0x0F) + (mode + 1);
				ptr = dst - (offset >> 4) - 1;
				if (offset == 0) {
					memset(dst, *ptr, lenght);
				} else {
					if ((ptr + lenght) >= dst) {
						int32 n;
						uint8 *tmp = dst;
						for (n = 0; n < lenght; n++)
							*tmp++ = *ptr++;
					} else {
						memcpy(dst, ptr, lenght);
					}
				}
				dst += lenght;
			} else {
				lenght = 1;
				*(dst++) = *(src++);
			}
			decompsize -= lenght;
			if (decompsize <= 0)
				return;
		}
	}
}

/** Get a HQR entry pointer
	@param ptr pointer to save the entry
	@param filename HQR file name
	@param index entry index to extract
	@return entry real size*/
int32 hqrGetEntry(uint8 * ptr, int8 *filename, int32 index) {
	uint32 headerSize;
	uint32 offsetToData;
	uint32 realSize;
	uint32 compSize;
	uint16 mode;

	if (!filename)
		return 0;

	if (!fropen2(&fr, (char*)filename, "rb"))
		printf("HQR: %s can't be found !\n", filename);

	frread(&fr, &headerSize, 4);

	if ((uint32)index >= headerSize / 4) {
		printf("\nHQR WARNING: Invalid entry index!!\n");
		frclose(&fr);
		return 0;
	}

	frseek(&fr, index*4);
	frread(&fr, &offsetToData, 4);

	frseek(&fr, offsetToData);
	frread(&fr, &realSize, 4);
	frread(&fr, &compSize, 4);
	frread(&fr, &mode, 2);

	if (!ptr)
		ptr = (uint8*)malloc(realSize);

	if (!ptr) {
		printf("\nHQR WARNING: Unable to allocate memory!!\n");
		frclose(&fr);
		return 0;
	}

	// uncompressed
	if (mode == 0) {
		frread(&fr, ptr, realSize);
	}
	// compressed: modes (1 & 2)
	else if (mode == 1 || mode == 2) {
		uint8* compDataPtr = 0;
		compDataPtr = (uint8*)malloc(compSize);
		frread(&fr, compDataPtr, compSize);
		hqrDecompressEntry(ptr, compDataPtr, realSize, mode);
		free(compDataPtr);
	}

	frclose(&fr);

	return realSize;
}

/** Get a HQR entry pointer
	@param filename HQR file name
	@param index entry index to extract
	@return entry real size */
int hqrEntrySize(int8 *filename, int32 index) {
	uint32 headerSize;
	uint32 offsetToData;
	uint32 realSize;

	if (!filename)
		return 0;

	if (!fropen2(&fr, (char*)filename, "rb")) {
		printf("HQR: %s can't be found !\n", filename);
		exit(1);
	}

	frread(&fr, &headerSize, 4);

	if ((uint32)index >= headerSize / 4) {
		printf("\nHQR WARNING: Invalid entry index!!\n");
		frclose(&fr);
		return 0;
	}

	frseek(&fr, index*4);
	frread(&fr, &offsetToData, 4);

	frseek(&fr, offsetToData);
	frread(&fr, &realSize, 4);

	frclose(&fr);

	return realSize;
}

/** Get a HQR total number of entries
	@param filename HQR file name
	@return total number of entries */
int hqrNumEntries(int8 *filename) {
	uint32 headerSize;

	if (!filename)
		return 0;

	if (!fropen2(&fr, (char*)filename, "rb")) {
		printf("HQR: %s can't be found !\n", filename);
		exit(1);
	}

	frread(&fr, &headerSize, 4);

	return headerSize / 4;
}

/** Get a HQR entry pointer with memory allocation
	@param ptr pointer to save the entry
	@param filename HQR file name
	@param index entry index to extract
	@return entry real size */
int32 hqrGetallocEntry(uint8 ** ptr, int8 *filename, int32 index) {
	int32 size;
	size = hqrEntrySize(filename, index);

	*ptr = (uint8*)malloc(size * sizeof(uint8));
	if (!*ptr) {
		printf("HQR WARNING: unable to allocate entry memory!!\n");
		return 0;
	}
	hqrGetEntry(*ptr, filename, index);

	return size;
}

/** Get a HQR entry pointer
	@param ptr pointer to save the entry
	@param filename HQR file name
	@param index entry index to extract
	@return entry real size*/
int32 hqrGetVoxEntry(uint8 * ptr, int8 *filename, int32 index, int32 hiddenIndex) {
	uint32 headerSize;
	uint32 offsetToData;
	uint32 realSize;
	uint32 compSize;
	uint16 mode;

	if (!filename)
		return 0;

	if (!fropen2(&fr, (char*)filename, "rb"))
		printf("HQR: %s can't be found !\n", filename);

	frread(&fr, &headerSize, 4);

	if ((uint32)index >= headerSize / 4) {
		printf("\nHQR WARNING: Invalid entry index!!\n");
		frclose(&fr);
		return 0;
	}

	frseek(&fr, index*4);
	frread(&fr, &offsetToData, 4);

	frseek(&fr, offsetToData);
	frread(&fr, &realSize, 4);
	frread(&fr, &compSize, 4);
	frread(&fr, &mode, 2);

	// exist hidden entries
	if (hiddenIndex > 0) {
		int32 i = 0;
		for (i = 0; i < hiddenIndex; i++) {
			frseek(&fr, offsetToData + compSize + 10); // hidden entry
			offsetToData = offsetToData + compSize + 10; // current hidden offset
			
			frread(&fr, &realSize, 4);
			frread(&fr, &compSize, 4);
			frread(&fr, &mode, 2);
		}
	}

	if (!ptr)
		ptr = (uint8*)malloc(realSize);

	if (!ptr) {
		printf("\nHQR WARNING: Unable to allocate memory!!\n");
		frclose(&fr);
		return 0;
	}

	// uncompressed
	if (mode == 0) {
		frread(&fr, ptr, realSize);
	}
	// compressed: modes (1 & 2)
	else if (mode == 1 || mode == 2) {
		uint8* compDataPtr = 0;
		compDataPtr = (uint8*)malloc(compSize);
		frread(&fr, compDataPtr, compSize);
		hqrDecompressEntry(ptr, compDataPtr, realSize, mode);
		free(compDataPtr);
	}

	frclose(&fr);

	return realSize;
}

/** Get a HQR entry pointer
	@param filename HQR file name
	@param index entry index to extract
	@return entry real size */
int hqrVoxEntrySize(int8 *filename, int32 index, int32 hiddenIndex) {
	uint32 headerSize;
	uint32 offsetToData;
	uint32 realSize;
	uint32 compSize;

	if (!filename)
		return 0;

	if (!fropen2(&fr, (char*)filename, "rb")) {
		printf("HQR: %s can't be found !\n", filename);
		exit(1);
	}

	frread(&fr, &headerSize, 4);

	if ((uint32)index >= headerSize / 4) {
		printf("\nHQR WARNING: Invalid entry index!!\n");
		frclose(&fr);
		return 0;
	}

	frseek(&fr, index*4);
	frread(&fr, &offsetToData, 4);

	frseek(&fr, offsetToData);
	frread(&fr, &realSize, 4);
	frread(&fr, &compSize, 4);

	// exist hidden entries
	if (hiddenIndex > 0) {
		int32 i = 0;
		for (i = 0; i < hiddenIndex; i++) {
			frseek(&fr, offsetToData + compSize + 10); // hidden entry
			offsetToData = offsetToData + compSize + 10; // current hidden offset
			
			frread(&fr, &realSize, 4);
			frread(&fr, &compSize, 4);
		}
	}

	frclose(&fr);

	return realSize;
}

/** Get a HQR entry pointer with memory allocation
	@param ptr pointer to save the entry
	@param filename HQR file name
	@param index entry index to extract
	@return entry real size */
int32 hqrGetallocVoxEntry(uint8 ** ptr, int8 *filename, int32 index, int32 hiddenIndex) {
	int32 size;
	size = hqrVoxEntrySize(filename, index, hiddenIndex);

	*ptr = (uint8*)malloc(size * sizeof(uint8));
	if (!*ptr) {
		printf("HQR WARNING: unable to allocate entry memory!!\n");
		return 0;
	}
	hqrGetVoxEntry(*ptr, filename, index, hiddenIndex);

	return size;
}
/** @file hqrdepack.h
	@brief
	This file contains High Quality Resource (HQR) decompress routines.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef HQRDEPACK_H
#define HQRDEPACK_H

#include "sys.h"

/** Get a HQR entry pointer
	@param ptr pointer to save the entry
	@param filename HQR file name
	@param index entry index to extract
	@return entry real size */
int32 hqrGetEntry(uint8 * ptr, int8 *filename, int32 index);

/** Get a HQR entry pointer
	@param filename HQR file name
	@param index entry index to extract
	@return entry real size */
int32 hqrEntrySize(int8 *filename, int32 index);

/** Get a HQR total number of entries
	@param filename HQR file name
	@return total number of entries */
int32 hqrNumEntries(int8 *filename);

/** Get a HQR entry pointer with memory allocation
	@param ptr pointer to save the entry
	@param filename HQR file name
	@param index entry index to extract
	@return entry real size */
int32 hqrGetallocEntry(uint8 ** ptr, int8 *filename, int32 index);

int32 hqrGetVoxEntry(uint8 * ptr, int8 *filename, int32 index, int32 hiddenIndex);
int32 hqrGetallocVoxEntry(uint8 ** ptr, int8 *filename, int32 index, int32 hiddenIndex);

#endif
BCÀŞ!  5  ‚        #‘AÈI29’„%‹b€EB’BÄ28I
2D$H
!#ÄR€!r$Èˆb¨ ¨@Æğ   Q  ë   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØ@°l †ÿÿÿÿ iƒAÀTb£øÿÿÿÿ`‡r˜‡yhx‡r‡t˜‡rhs€‡vr Ì!ØaÊ ÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú y¨‡r wx‡60y‡v(‡6€‡wHw ‡r‡6(vH‡vhwxwhv(‡p0€p‡whƒtps˜‡60xhƒvz@ÀÂæ¡ ÂŞ¡Ü!ÜaÚÀà¡Ú!è sv˜‡r ˆy ‡p‡uhx‡w ‡rzxyhq¨s0‡r‡6˜‡tĞ‡r ğ  êÁæ!Ì¡ÚÀà¡Ú!è sv˜‡r ˆz˜‡rhƒyxs ‡60vx‡p ÀÂæ¡€³aüÿÿÿÿ D;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l ÿÿÿÿ€ I     ‚`‚ &Å„À˜  ‰   5   2"ˆ	 d…#¤„#ã„¡LŒŒ„ÄLüÁ=ÒQÂäÿ"úbé Ì 	#Ì€ÁEÒQÂäÈB¬0"‚ ¨ÈÔ(É–\¨I JIAĞ4G#’‚¨È*F$IQVB’Ò
A’D\‰¼BD†DX„È ±‘AY‰ ³‘Dh‰ µAl‰\’
AÀAq)I"šAHAu)X"ºˆ˜#€hŸ     °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:¤H #DD ¾CA‚-	  €ŠpI  @ ìP˜ K  `‡â^   ;(ø’  € ²P      0d¡      `Èr     À%`    €!Ë @     C–     †,     YÂ      †,c      C–2 €    €!Ë @    À%€      `È²      0di  
    ²¼      Yä  €     †,t  @     C;       €!      @*   2˜LŒ	&GÆC*F èX!
(Ñ•ê@¥9hvŸè qd~×İdPHA‹’•‚®A©3é<ê@I·=ÌN“Ae7]¥İä2>RP£j @F¥ kPêL::PÕ³Ë úf³ßã0½j—Ûoy>RĞ£o€ŒJA× Ô™tu º;,f—Aô7(Ìf¿ÇazTvÓåyP»Ü~Ëó¡  y     C„<HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   >   ö`‘DŠEED@øÒ™ÃQDÂâH„5EÀ`ÌE^3E‹d„Pu„à0ODHR9{ÍaFPøÒİVPøÒá6PøÒÙfáPÓë\^3E˜EdÔ²TŒÏŒDLşC#¼Ü¶	¾4EµaLÄ,‹#¼Îå5S„Yt@HLÀ²8‚×Lf	Ù²TŒÏŒğ`şC#¼ÿĞï#·mÒE!8Ì’ä5S„ƒñDH3vñPô:—×LÆ"aÍE'ÅxÍ!„d,‹#ØA\ÈdG9ÑØ¦°P“×La   z   Q,      D”À@AAyB    3p@ŒÁ0Ä3z@ŒÁ0¡Ä31ÁL„c0ÌDè1ÃL„c0ÌDğ1ÂLc0F(Õ F$Ô F Ó FÒ Ì”Œñ„@ŒX‚ !F$A FÓ ÌtŒá†`BƒY†Á	h	AË¨,¸n´0˜eHˆ€¨q¿ˆÁ( ºÆxBĞFdÁ $. ¢‚OI”l@0±@`0(QAd©Aã	E0œÁ`„À`´Á ÌƒÆ`7Ì2H@a0Æ9Œƒ` HÔc<!¨ƒÁˆ7`0B`–à 4Ü#Ô €Y‚b–@Œ`< ‚ƒ1äÁ`„@B :ã	FØA0 ƒÂ ³
ÅÁ :!Œ¸ƒ` èÆpC 
i0Ë°0Á,4KĞPFƒwÀ,0KğĞŒá†€Â`–!€      æ¢„à0„d„Áƒ‰Œ363<Sd2†S1È E‚Åˆ}ƒ4Ù‹±qL     a      W,      $” %0PåQ5@Õ    3p@Á03z@Á0¡3|@0¡3p@Á0!dÌDH3z@Á0ƒË5 ƒŠ5 ƒI5 ƒ5 ³%c¸!Ì`–A°bÆxBPF8Á #  #, f	JÂD7XÌ2U@K¸€rÂDÔèpCà…Á,T„ø¥@F` Ğ6Æ1Œè‚ M\@Dd äÒ 6 Œø‚ 2â"*Pƒ,7b<¡Æ6Œ(ƒ` èÄD7s ³ÆJƒAA¸€ˆ 7# Ü‚!{P³¹Á 8ã	B@w0†„`f& <ƒpÀ`D€Â Ì$ƒì`7Ì2(L@w0Æ‚RŒÈƒ` Hdc<!@…Á<`0B`–`¡<¨#ö €Y‚d–À!RôƒBaŒ  ƒ¸*Ì8³‰Â Tã	0¡
Á ÌDƒ¥@©0ÆYŒX…` HÔ
c<!¨…ÁˆW`0B`– "Uä
Ã!ƒ° ÁÂnr!f¤)˜%°f	(j…pôÂ] À`D,0K0Ì      6CLØCŒ±qL¢„à0„d„Õó˜Á8a1Ã3Eöb8E!“R$ØÇ0H“É2IF4        a   š   R,      DŒ ”@!I# CH@ˆ!CŠ@ˆ!CÌ@ˆ!CAˆ! 3z@ŒÁ0Ä3p@ŒÁ0¡Ä3z@ŒÁ0¡Ä3z@ŒÁ0¡Ä3|@Œ0Äƒ‰5 ƒH5 ƒ5 „Œá† 
ƒY!#˜
 f	"RÆˆ m€A4Ü\a0Ë@5cÄ  €7˜‚YâiG €ƒ>2z=£‚m††`f
#1   ° è@#.0 €Y‚ˆ¨aÁ'‚ƒ ê€‚£¤10  J!ªÆˆA w`
ÁUÒ  §ŒÁUÒ °¨ÁUÒ À©uc¸! ƒ0˜e@€´1b@  ƒaÀ,Ba0†4ƒY%	F …21  @`a0¢Ü  f	"êÄD7p ³Ğƒ1b`  *Ô‚Ì@$â"†: ƒY§	¨ÄD7u ³ÎFœA ¥Á1  €‚Áˆ4€Ò`Œ dá„€æ`‚ƒAo . bÄà  _(ˆ! 8# ĞB0KğÌ@# ÜB9ŒÁˆ= `– ¢= „     F³ótÀ¤Sd H,D0„½(DÄ"a0ŒS1µNL€}ÏYH4q™"8ÌÃ"a3ã„Å ,,’        a   P   H,   	   DŒ ”@!40”Da0”¡Da0”ÁDa   3z@ˆÁ0„3z@ˆÁ0¡„3z@ˆÁ0¡„ƒÅ3 ƒ„3 TŒá†`	ƒY!# f	:Æˆ f3ÜDa0Ë@)cÄ   4p‚Â Ä`ÒS¤10  ì ˜ˆÄŒ
ªn‚1˜e(Œ`Ä€  7˜F hƒ=Œ˜4 ˜%8(d"1( Àú ¸HÚ âÀ‚¤1bP  üAp’´# Ì(İˆ r 
4Áˆ, €Y‚ƒ2A8   öÈB4 CØŠrÀ@D,’ÆÂ8E!SëtÀH4qYÀÂ"    a   ,   F,      DŒ ”@!40”`0”¡`   3z@„Á0D3z@„Á0!(@Ân0˜e‚`0¢X `–  bŒ l ÃA³ÄĞ1F
 %1  {ôiG  ƒ8JFĞF4 ÌÔ€Â    öÈB4 CŠrÀ@D,’      a   4   D,      D”À I# CPAŒ1    3z@ˆÁ0á„3p@ˆÁ0¡„3z@ˆÁ0A001,0!(@Ã aŒ °	Á` £‚FF  ƒ€”1@Ë `7PÌ2A0b@ @@ƒĞ ³=ƒ‚AĞ hŒ  ƒP4#¬  f	²@á@     ‚ÈB4 CØÇğL‘…H3—©’        a   Ä   X,      DŒ ”@!AQ40”Äc0”¡Äc0”ÁÄc0”áÄc    3z@Á03p@Á0¡3z@Á0¡3z@Á0¡3z@Á0Á3z@Á0ƒ‹6 ƒJ6 ƒ	6 ƒÈ5 ¤Œá†@
ƒY!# f	.bÆˆ qÀÁ4Üha0Ë@=cÄ  €9¨‚YâiG  ƒP8ŠA£o††`f
#1   ´ ğÀ#²1 €Y‚‹¬aˆ`Ä  €<@…à*iG àƒTÈ€¬1bP À¨Bp–´# øÁ*fp–´# ü+gp–´# €B+g@ÜnÖÀf&ŒÀØ` #06€Y„°Aßn4˜eH–€¾AŞ(!€
Ü F
 8[h‰Á(!€
ä #Î €3iG p…]ìàÌ@Ú ^‚;83vÄÀ  Xè…àf	2ƒa€`0‚˜%@f	Šƒ1ÜàAÌ28M@m0F …`0¢‚˜%p¨ÆpCÀa0Ë =Áˆ ¹# à‚9FäÁ( À,ÁEp . b¸!(0˜eˆ¤€ö`Œ |a„`–À¢:1Ü¤Ì2PS@x . b¸!P0˜e ª`0"Ra ˆÆˆ âFìA0 ´ƒş`Œ €õ t
ƒü`Ğ(q# ĞCA‰Â1  @‚Y‚j–À1   öNaF¼B  ³½È     †³ótÀ¤Sd H,D0„‰,2D#6q™ŒrÀ@D,’ö1<Sd3ŒS1µNL€…H3—İˆÕ ‚Ã<,’fC0Î@ÀÂ"      a   ~   N,   	   DŒ ”@!I# CH@ˆ!CŠ@ˆ!CÌ@ˆ! 3z@ŒÁ0Ä3z@ŒÁ0¡Ä3z@ŒÁ0¡Ä3z@ŒÁ0¡Ä3z@ŒÁ0P0qL0aH@Ènœ0˜e‚`0b™ `– !eŒ °v<ÃA³ÄP3F
 hƒ(1 à.=FÚ Ü`‚‹AÎ¨ ›á†!ƒY†ÂF ˜kÄ€  9 …ÁË€Y‚†¨aA'‚ƒ æ@‚›¤10 ÀF!øˆ# Ô)GI;b`  ”BGI;b` @˜B ”á† Ì`–á`‚ÁË`0Â2ƒ˜%@ÈÄá!@ƒY†d	ˆ´¨ `Ä   Px…€À`Ğ7J ‚6€Á2àÆ@Ú N8¸1vÄÀ  T¨… f	ƒaÁ€`0¢‚˜%@f	˜ RáèÆ`„ 0KĞ€Â     öÈB4 CXÈr Ã@4b3—¹(DÄ"a/ŒS1µNL€H3—ÉˆÅ ‚Ã<,’ƒD°°HF       a   :   D,      D”À I# CPAA    3z@ŒÁ0áÄ3p@ŒÁ0¡Ä3z@ŒÁ0¡Äƒ…3 ƒD3 ƒ3 ƒÂ2 D"cÄÀ €l‚Áˆ" *FŒ 01c0"€šAÁn¤0˜e‚`Ä€  6#¤
 f	Šƒ¤AÒ iŒ €Ä 4Áˆ, €Y‚2A8 	   ‚ÈB4 C˜Èr Ã@4b3—}ÏYH4q!!         /** @file interface.c
	@brief
	This file contains in-game interface routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "interface.h"
#include "sdlengine.h"
#include "main.h"
#include "lbaengine.h"
const int32 INSIDE = 0; // 0000
const int32 LEFT = 1;   // 0001
const int32 RIGHT = 2;  // 0010
const int32 TOP = 4; // 0100
const int32 BOTTOM = 8;    // 1000

int32 checkClipping(int32 x, int32 y)
{
	int32 code = INSIDE; 
	if (x < textWindowLeft) code |= LEFT;
	else if (x > textWindowRight) code |= RIGHT;
	if (y < textWindowTop) code |= TOP;
	else if (y > textWindowBottom) code |= BOTTOM; 
	return code;
}

/** Draw button line
	@param startWidth width value where the line starts
	@param startHeight height value where the line starts
	@param endWidth width value where the line ends
	@param endHeight height value where the line ends
	@param lineColor line color in the current palette */
void drawLine(int32 startWidth, int32 startHeight, int32 endWidth, int32 endHeight, int32 lineColor) {
	int32 temp;
	int32 flag2;
	uint8 *out;
	int16 color;
	int16 var2;
	int16 xchg;
	int32 outcode0, outcode1;
	int32 x, y, outcodeOut;
	int32 currentLineColor = lineColor;

	// draw line from left to right
	if (startWidth > endWidth) {
		temp = endWidth;
		endWidth = startWidth;
		startWidth = temp;

		temp = endHeight;
		endHeight = startHeight;
		startHeight = temp;
	}	

	// Perform proper clipping (Cohenâ€“Sutherland algorithm)
	outcode0 = checkClipping(startWidth, startHeight);
	outcode1 = checkClipping(endWidth, endHeight);
 
	while ((outcode0 | outcode1) != 0) {
		if (((outcode0 & outcode1) != 0) && (outcode0 != INSIDE)) return; // Reject lines which are behind one clipping plane

		// At least one endpoint is outside the clip rectangle; pick it.
		outcodeOut = outcode0 ? outcode0 : outcode1;

		if (outcodeOut & TOP) {           // point is above the clip rectangle
			x = startWidth + (int)((endWidth - startWidth) * (float)(textWindowTop - startHeight) / (float)(endHeight - startHeight));
			y = textWindowTop;
		} else if (outcodeOut & BOTTOM) { // point is below the clip rectangle
			x = startWidth + (int)((endWidth - startWidth) * (float)(textWindowBottom - startHeight) / (float)(endHeight - startHeight));
			y = textWindowBottom;
		} else if (outcodeOut & RIGHT) {  // point is to the right of clip rectangle
			y = startHeight + (int)((endHeight - startHeight) * (float)(textWindowRight - startWidth) / (float)(endWidth - startWidth));
			x = textWindowRight;
		} else if (outcodeOut & LEFT) {   // point is to the left of clip rectangle
			y = startHeight + (int)((endHeight - startHeight) * (float)(textWindowLeft - startWidth) / (float)(endWidth - startWidth));
			x = textWindowLeft;
		}

		// Clip the point
		if (outcodeOut == outcode0) {
			startWidth = x;
			startHeight = y;
			outcode0 = checkClipping(startWidth, startHeight);
		} else {
			endWidth = x;
			endHeight = y;
			outcode1 = checkClipping(endWidth, endHeight);
		}
	}

	flag2 = 640;//SCREEN_WIDTH;
	endWidth -= startWidth;
	endHeight -= startHeight;
	if (endHeight < 0) {
		flag2 = -flag2;
		endHeight = -endHeight;
	}

	out = frontVideoBuffer + screenLookupTable[startHeight] + startWidth;

	color = currentLineColor;
	if (endWidth < endHeight) {    // significant slope
		xchg = endWidth;
		endWidth = endHeight;
		endHeight = xchg;
		var2 = endWidth;
		var2 <<= 1;
		startHeight = endWidth;
		endHeight <<= 1;
		endWidth++;
		do {
			*out = (uint8) color;
			startHeight -= endHeight;
			if (startHeight > 0) {
				out += flag2;
			} else {
				startHeight += var2;
				out += flag2 + 1;
			}
		} while (--endWidth);
	} else {   // reduced slope
		var2 = endWidth;
		var2 <<= 1;
		startHeight = endWidth;
		endHeight <<= 1;
		endWidth++;
		do {
			*out = (uint8) color;
			out++;
			startHeight -= endHeight;
			if (startHeight < 0) {
				startHeight += var2;
				out += flag2;
			}
		} while (--endWidth);
	}
}

/** Blit button box from working buffer to front buffer
	@param left start width to draw the button
	@param top start height to draw the button
	@param right end width to draw the button
	@param bottom end height to draw the button
	@source source screen buffer, in this case working buffer
	@param leftDest start width to draw the button in destination buffer
	@param topDest start height to draw the button in destination buffer
	@dest destination screen buffer, in this case front buffer */
void blitBox(int32 left, int32 top, int32 right, int32 bottom, int8 *source, int32 leftDest, int32 topDest, int8 *dest) {
	int32 width;
	int32 height;
	int8 *s;
	int8 *d;
	int32 insideLine;
	int32 temp3;
	int32 i;
	int32 j;

	s = screenLookupTable[top] + source + left;
	d = screenLookupTable[topDest] + dest + leftDest;

	width = right - left + 1;
	height = bottom - top + 1;

	insideLine = SCREEN_WIDTH - width;
	temp3 = left;

	left >>= 2;
	temp3 &= 3;

	for (j = 0; j < height; j++) {
		for (i = 0; i < width; i++) {
			*(d++) = *(s++);
		}

		d += insideLine;
		s += insideLine;
	}
}

/** Draws inside buttons transparent area
	@param left start width to draw the button
	@param top start height to draw the button
	@param right end width to draw the button
	@param bottom end height to draw the button
	@param colorAdj index to adjust the transparent box color */
void drawTransparentBox(int32 left, int32 top, int32 right, int32 bottom, int32 colorAdj) {
	uint8 *pos;
	int32 width;
	int32 height;
	int32 height2;
	int32 temp;
	int32 localMode;
	int32 var1;
	int8 color;
	int8 color2;

	if (left > SCREEN_TEXTLIMIT_RIGHT)
		return;
	if (right < SCREEN_TEXTLIMIT_LEFT)
		return;
	if (top > SCREEN_TEXTLIMIT_BOTTOM)
		return;
	if (bottom < SCREEN_TEXTLIMIT_TOP)
		return;

	if (left < SCREEN_TEXTLIMIT_LEFT)
		left = SCREEN_TEXTLIMIT_LEFT;
	if (right > SCREEN_TEXTLIMIT_RIGHT)
		right = SCREEN_TEXTLIMIT_RIGHT;
	if (top < SCREEN_TEXTLIMIT_TOP)
		top = SCREEN_TEXTLIMIT_TOP;
	if (bottom > SCREEN_TEXTLIMIT_BOTTOM)
		bottom = SCREEN_TEXTLIMIT_BOTTOM;

	pos = screenLookupTable[top] + frontVideoBuffer + left;
	height2 = height = bottom - top;
	height2++;

	width = right - left + 1;

	temp = 640 - width; // SCREEN_WIDTH
	localMode = colorAdj;

	do {
		var1 = width;
		do {
			color2 = color = *pos;
			color2 &= 0xF0;
			color &= 0x0F;
			color -= localMode;
			if (color < 0)
				color = color2;
			else
				color += color2;
			*pos++ = color;
			var1--;
		} while (var1 > 0);
		pos += temp;
		height2--;
	} while (height2 > 0);
}

void drawSplittedBox(int32 left, int32 top, int32 right, int32 bottom, uint8 e) { // Box
	uint8 *ptr;

	int32 offset;

	int32 x;
	int32 y;

	if (left > SCREEN_TEXTLIMIT_RIGHT)
		return;
	if (right < SCREEN_TEXTLIMIT_LEFT)
		return;
	if (top > SCREEN_TEXTLIMIT_BOTTOM)
		return;
	if (bottom < SCREEN_TEXTLIMIT_TOP)
		return;

	// cropping
	offset = -((right - left) - SCREEN_WIDTH);

	ptr = frontVideoBuffer + screenLookupTable[top] + left;

	for (x = top; x < bottom; x++) {
		for (y = left; y < right; y++) {
			*(ptr++) = e;
		}
		ptr += offset;
	}
}

void setClip(int32 left, int32 top, int32 right, int32 bottom) {
	if (left < 0)
		left = 0;
	textWindowLeft = left;

	if (top < 0)
		top = 0;
	textWindowTop = top;

	if (right >= SCREEN_WIDTH)
		right = SCREEN_TEXTLIMIT_RIGHT;
	textWindowRight = right;

	if (bottom >= SCREEN_HEIGHT)
		bottom = SCREEN_TEXTLIMIT_BOTTOM;
	textWindowBottom = bottom;
}

void saveClip() { // saveTextWindow
	textWindowLeftSave = textWindowLeft;
	textWindowTopSave = textWindowTop;
	textWindowRightSave = textWindowRight;
	textWindowBottomSave = textWindowBottom;
}

void loadClip() { // loadSavedTextWindow
	textWindowLeft = textWindowLeftSave;
	textWindowTop = textWindowTopSave;
	textWindowRight = textWindowRightSave;
	textWindowBottom = textWindowBottomSave;
}

void resetClip() {
	textWindowTop = textWindowLeft = SCREEN_TEXTLIMIT_TOP;
	textWindowRight = SCREEN_TEXTLIMIT_RIGHT;
	textWindowBottom = SCREEN_TEXTLIMIT_BOTTOM;
}
/** @file interface.h
	@brief
	This file contains in-game interface routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef INTERFACE_H
#define INTERFACE_H

#include "sys.h"
#include "main.h"

/** Screen top limit to display the texts */
#define SCREEN_TEXTLIMIT_TOP	0
/** Screen left limit to display the texts */
#define SCREEN_TEXTLIMIT_LEFT	0
/** Screen right limit to display the texts */
#define SCREEN_TEXTLIMIT_RIGHT	SCREEN_WIDTH-1
/** Screen bottom limit to display the texts */
#define SCREEN_TEXTLIMIT_BOTTOM	SCREEN_HEIGHT-1

int32 textWindowTop;
int32 textWindowTopSave;
int32 textWindowLeft;
int32 textWindowLeftSave;
int32 textWindowRight;
int32 textWindowRightSave;
int32 textWindowBottom;
int32 textWindowBottomSave;

/** Draw button line
	@param startWidth width value where the line starts
	@param startHeight height value where the line starts
	@param endWidth width value where the line ends
	@param endHeight height value where the line ends
	@param lineColor line color in the current palette */
void drawLine(int32 startWidth, int32 startHeight, int32 endWidth, int32 endHeight, int32 lineColor);

/** Blit button box from working buffer to front buffer
	@param left start width to draw the button
	@param top start height to draw the button
	@param right end width to draw the button
	@param bottom end height to draw the button
	@source source screen buffer, in this case working buffer
	@param leftDest start width to draw the button in destination buffer
	@param topDest start height to draw the button in destination buffer
	@dest destination screen buffer, in this case front buffer */
void blitBox(int32 left, int32 top, int32 right, int32 bottom, int8 *source, int32 leftDest, int32 topDest, int8 *dest);

/** Draws inside buttons transparent area
	@param left start width to draw the button
	@param top start height to draw the button
	@param right end width to draw the button
	@param bottom end height to draw the button
	@param colorAdj index to adjust the transparent box color */
void drawTransparentBox(int32 left, int32 top, int32 right, int32 bottom, int32 colorAdj);

void drawSplittedBox(int32 left, int32 top, int32 right, int32 bottom, uint8 e);

void setClip(int32 left, int32 top, int32 right, int32 bottom);
void saveClip(); // saveTextWindow
void loadClip(); // loadSavedTextWindow
void resetClip();

#endif
BCÀŞ!  ”  ‚        #‘AÈI29’„%‹b€EB’BÄ28I
2D$H
!#ÄR€!r$Èˆb¨ ¨@Æğ   Q  N   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØ@    I     ‚`‚   ‰   "   2"ˆ	 d…#¤„#ã„¡LŒŒ„ÄLˆÁ0G€@CB? T$rÀ@G" ”Ì@´$ÁBÍYÒQÂäkÂäD¦SìQÂ„ˆeY zÊ   E# Å˜    ¢J2   0UŒ	  @ ¬   i%˜ˆ˜#¦ f   °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:¤H #DD †¥ 34˜á)ÀQf˜
0ƒRÀ”Î p¥€“xœ+àJgP
8ƒRÀ”Nâp"­€SqœA)àJgP
8UÀÈ¬JfP2«€’Y”Ì* $^'ñ
8‰WÀI¼Nâp2«€’Y”Ì* dV%³
(X@”NfP2«€’Y”Ì* dV%³
(ƒRÀ”NfP2«€’xœÄ+à„bgP
8ƒRÀ”Î p¥€“Y”A)àC	 €     †,      Y.      ²T      0dÉ      `È²     À¥      €!K @     C– €     ²@    2˜LŒ	&GÆCF J 
¡ H e€Š :F ( a€š zF   y     C/X ;„ƒ;œØC9ÈÃ<¤Ã;¸ÌĞŒPØì¡Ü È¡Ü¦     y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   Ñ   öó`±Ï‚L1lÎe
‘$DÑ”£POa@MfD„$!a…0tHd6Îâ8GEÑL$™É&PQD4SêHÈ„8ØlÎ€¥SÔ‘P9Zƒ0âp¥+Ú¢©Æ‘† MÄ5ÁH38ÖæL“ÃØN#„ pò<HcX"Á-Èc'KàL“Ã”D1Å†²Î49LI“l)KàL“Ã”D1Í&3‘ÓL/2ÎFˆdÅ*‚ak‹ôDÈD´@°&RDähÂˆÃ¥àê±¬øzæ#`µĞHÍ´9—5LqM0Òµ"Æ1±@EX Qz_kCIDHÄÄ-Èc+Éä<+b“l#ÓADÖ Œ8\Èr«×z¦’LÎ³"Æ1ÅvĞLÄ5ÁH38Vë<†Q=Q!%…DälÄTˆCE–=Q!%…Däh±Ös2mÎe,Éä<+bÓl5ÖâPRé8O’D$YÌc9‘ò"álTQ‘•,9Zƒ0âp‡t‘ã52aZ–^+rñHO„L‹dDaÔAD×LÈ„i ¸z,+¾âÉŠgÓAD×LÈ„¥+Ú¢©Æ‘&qH08Vl‡t ƒcÍæ@MÄ5ÁH38ÖæL“Ã°@EØÄ!ÀàX²Ñ8‹ã<iDH1f:Jæ8+DÑŒ!Æ1™%VàLÄ5ÁH38VI“	!‹Ü‚<–SˆÁ
A4+!ÍDD60´hj“t ƒcqÎ² â4-öö’,D1™%Æƒ`•HCØM´8Î#6ÑLN„‰Á˜Es‘³P!™Ë±@‹0„1DqM0ÒÕ:T„D9Zƒ0âpèjj¥…L9Zƒ0âpimXz­ÈÙÌ²8Îc:‘N‘i@Bä<›3MÃ
A4†Ó,óhÂäDìD<¶DäxÍ„LØ‰®¦VĞ!· Ú¶¨iÒD\Œ4ƒc•D1±@EXTDN3½È@8UDdÏD\Œ4ƒc­ˆqLÖ‚@2 C˜‡t‘ã52aÈr«×z  a   +   ËLD ”Â0 ¥0ÌD@)ƒC1 ƒ1 ƒ4 4’…1Ü h0Ë£‚j#Œ` f	
BÙÂn3˜eˆ€’QA¶ƒK0 ³Ä,AAÌ ]ÃB€³Æ3*èv0
`–@¡h/Œá!0ƒY$	h„ÁFTÁ Ì$³
U#ƒp      \&`VEÎ@     a   b  j     Ô@*   3P
ÃLD ”Â0 ¥0ÌD@)3P
ÃLD ”Â0 ¥0ÌD@)3P
ÂL”‚0Á ¥ ÌD@)3P
ÃLD ”Â0 ¥0ÌD@)3P
Ã`D„À`tÀ`ÄcÀ`„SÀ`DC 5c0B€¤AÑn3˜e„€¦1@ÖŒ¨‚ iF`Á P5#¨` ƒW0 TÁ-€Y¶AÛ1( @„`0b
€¸AÜ1(  „`0¢
`–` k5Jv¸!Àƒ0˜e ²€´AÚ(!Ğá†€Â`–¡8òÆpCàa0Ë`Á,AŒá† Â`–Iƒ1K ŒYe  !Œƒ` (F¢ Ã)„Á,ÃÂ4ƒä`P‚\¥Ä <&!¸ ´*!=ÔÃ„ „VE@ dP ‚Áˆ;€jbFÜA0 ³ÙÁ¨Àt¸!Ø…0˜ehœ€PaĞ)R…aB‚B£Ô
Ã„ „VE ô
ƒda˜„à‚Ğªè€
@0Á
Á PZŒÁV`–€¢U´ƒ7ğ³/Ú…A¾0LBpAhDƒÆa˜„à‚Ğª„Êa:‚\Z] A#À! 1!Á ÌL£‚‘Ğá† $Â`–!’Š‡Ağ0h†	A.Tc>‚\Z>ê‡aB‚B«"  2( Á`D=@¶1#î!€Yi–`š% f	*ª‡Aú0†„ f¬+ }ƒ( éÃŒ@‰` (%¥Ä1(  -„`0"$‚˜%ÀèÆ`ÄJ@ÿ0#V" b‰A,1F
 h!Œ(‰` f	°Y‚a0b%db (&ÁÄ°@Á`„L@31H&†B#h" ¢‰1Ü°Ì2h[@31Ì-‚FÔD0 „Ãà"Á`„N0K°{ê‰1ŞĞsP0Æˆ€ÄbŒ'Á`DO@41.X`0Â' ²Dc¸AĞ`–ƒ€Îb\°À`DX@h1#Ô" q ƒk ±Å¸`Áˆ³€ÎB\ H¥q,0± \ŒÁº€äbT7AÁ P]VƒwÀ,AGq!.€èbFB P^â‹a‚Á¿€üb7´a³ŞĞ^Ú‹1ƒ}À,Ğ^ˆ ¡Ò Œ8` H4†¼1ƒ¥À,Ì„©Æ°à5@0ÁÁ 7â³³i@­1.X`05 Ô RyÜF°F  4c0¢6‚ Ù¨ÇFÔF0 dÃö Á`n0K@$â¨6Æ`D  ÙÆOâc07‚ ŞôÃ!ƒá …ÇnîfÊÀÚq TÃƒç ‰Ç ñã	0AÁ Ì˜Á,ÁPzÜƒëÀpC"a0Ë@hÌ¤†    6†8Ô$8AâP“àDmR‹4ÑˆqLV•,HCpÎâD&F\ÂaØ™âP“àJMæU`Ø†	TÍT"Á9‹Y”"M@4ÁÈ0F•ÍˆqLÖELóØB4ŒÓa_ƒCMV\f`FT@dX!8‹      a   ƒ   I,       B   3P
ÃLD ”Â0 ¥0ÌD@)3P
ÃLD ”Â0 ¥0ÌD@)3P
ÃLD ”Â0A ¥0ÌD@)3P
ÃLD ”Â0 ¥0ÌD@)ƒ6 ƒO6 ƒ6 ƒÍ5 ƒŒ5 ƒK5 ƒ
5 ƒÉ4 ôŒñq@ƒ€‚AÏOªÆx‚F4Á P4ÆÒá
Mc<!èã	B01@Ü o˜„À‚; Á`„ }ƒÄ`˜„À‚= Á`D yÃÒ Á` ¡ÁŒà‚ 4üAF¬A0 ä
Ú@#À €Á`–  oPŒá!@ƒY	#Äà`–` 1”c¸AĞ`–0Jƒ1¨Â`Ä@B 5ã	A+F´A0 ƒÂ ³©Á°à@0ÁÁ Ìäƒà`Œ'Â`„@q0ˆÆxB FØA0 ³ÅÁ°à@01Á Ì    6VXÈ0vuLÎÓÒdfÁ`g
ÒHÈ@”HCZ1Ìs[Z€X±ÅdjAbXÄ@H“U’CEaRÃä<VHFeÎ49Œ‘ÇdVÈBSGH“Mb     a   ¯   Z,      ”BùÔ@*ø@y  3P
ÃLD ”Â0 ¥0ÌD@)3P
ÃL”Â0 ¥0ÌD@)3P
ÃLD ”Â0 ¥0ÌD@)3P
ÁLÄ ”B0ád0Ñ`0Á\0±X0¡T@În*3˜e„`– #g7i€³Ìdá† 3ƒY†Âf	2ŠÆpCĞh0Ëp Á,AFÖnŞ f%ŒÀà` f	²ÆpCğ™Á,ÃÂƒÀ,CÙnæ f'ŒØè` f	ÊÆpC f0Ëğ@Á`Ä60K Q7Æâá
ÑÃOƒ1 ƒ` ‰Á 2&!Œƒ` #À  ƒa(€`0B‚ 4´Ã„ #Ğ  Bƒar„`0â‚ 6ƒgÀ,ADk0#Î €Y‰Ú`P#Ğ €Áˆ3€Î \ Hx 0±A „ ©`ô#à  ’ƒAq. Ä‚!0QA P„ nvf&* ;ƒyÀ,AEx. „ö \ ˆ.`0â‚ ˜%¨èÂOÈa0"‚Œ†  QÌ#J!€Y‹Ja7é`³ÒP*r…1ƒ° µÂ°@@0ñ
Á Ì`ô
c¸!€3˜eˆ² Ã      &VXÈ0E,D1ÙqˆqL¶U!‚³8‘6$f–, ,¦3–fÎâD¶…#™Ô09Q3MceÄD0ÇdgDDµMb“¡‚³8        a   ^   Q,      ”Bù    3P
ÃLD ”Â0 ¥0ÌD@)3P
ÁL”Â0 ¥0ÌD@)3P
Ã`DÀ`À`ÄñÀ`„áÀ`DÑ %c¸!hÌ`–!‚Yˆ’1Ü„Ì2D0K 3†Èf
#˜%€ˆÃA Á,Ã³=ƒ¤aBª˜!Œ€‚ sdñ†shƒ€‚1@´ñ!ŒÀ‚ nF\Á Ì$tâÆpƒ Á,ƒc0B`–`!mPŒá!@ƒYÆ	(…ÁOö`0b‚Œ† ˜%h†} ‚Á1`–`!2dc<!#Ğ €Y‚‡Ì`X 
 Œ@ƒ` f	   &5LÎcTFàL“ÃXU@˜×ğL‘}NQHÄd`ÁeafQÄB“Mb     a   4   I,       Bù'ğAù 3P
ÃLD ”Â0 ¥0ÌD@)ƒ3 ƒÃ2 ƒ‚2 ƒA2 DŒá†@CƒY†@#Œm f	2Æ`Ä.@Æn:4˜eˆ`0ñ`–€ dFğB0 „Œá†à9ƒY†Â#”g f	RÆ`8@Ên 3˜e8`0‚`– !fF„C0    &5LÎcTFàL“ÃX±ÅdSE„Ç     a   
   ±ÂŒ8…` hÆ`Ä)@­0#N! b…1q
Á     a   
   ™ÂŒh…` ÈÆ`+@¦0#\! 2…1Ñ
Á     a      A,      ”Bù  ƒ®ğÀ`+<0Ñ
Â F¬B0     /** @file keyboard.c
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "keyboard.h"

/** Initialize engine auxiliar keymap */
uint8 pressedKeyMap[29] = {
	0x48, // 0
	0x50,
	0x4B,
	0x4D,
	0x47,
	0x49,
	0x51,
	0x4F, // 7

	0x39, // 8
	0x1C,
	0x1D,
	0x38,
	0x53,
	0x2A,
	0x36, // 14

	0x3B, // 15
	0x3C,
	0x3D,
	0x3E,
	0x3F,
	0x40, // LBAKEY_F6
	0x41,
	0x42,
	0x43,
	0x44,
	0x57,
	0x58,
	0x2A,
	0x0, // 28
};

uint16 pressedKeyCharMap[31] = {
	0x0100, // up
	0x0200, // down
	0x0400, // left
	0x0800, // right
	0x0500, // home
	0x0900, // pageup
	0x0A00, // pagedown
	0x0600, // end

	0x0101, // space bar
	0x0201, // enter
	0x0401,  // ctrl
	0x0801,  // alt
	0x1001,  // del
	0x2001,  // left shift
	0x2001,  // right shift

	0x0102,  // F1
	0x0202,  // F2
	0x0402,  // F3
	0x0802,  // F4
	0x1002,  // F5
	0x2002,  // F6
	0x4002,  // F7
	0x8002,  // F8

	0x0103,  // F9
	0x0203,  // F10
	0x0403,  // ?
	0x0803,  // ?
	0x00FF,  // left shift
	0x00FF,
	0x0,
	0x0,
};
/** @file keyboard.h
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef KEYBOARD_H
#define KEYBOARD_H

#include "sys.h"

/** Pressed key map - scanCodeTab1 */
extern uint8 pressedKeyMap[29];
/** Pressed key char map - scanCodeTab2 */
extern uint16 pressedKeyCharMap[31];

/** Skipped key - key1 */
int16 skippedKey;
/** Pressed key - printTextVar12 */
int16 pressedKey;
//int printTextVar13;
/** Skip intro variable */
int16 skipIntro;
/** Current key value */
int16 currentKey;
/** Auxiliar key value */
int16 key;

int32 heroPressedKey;
int32 heroPressedKey2;

#endif
BCÀŞ!  ½   ‚        #‘AÈI29’„%‹b€EB’B„28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   ‰      2"	 d…"¤„"ã„¡LˆŒ„„L(sHv Å”CD3G t   °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:„H #DD Šba@š¥YPš¥YPš%Rp"Ï   2˜LŒ	&GÆCº š ¢±>!@P Ñ D@8‘
Á …$B	ADDDHDAD!ƒ¡FPøÿ  
åĞeó˜Œ>sœnª²íx=ß‰W¬
 y     C„$X ;„ƒ;œØC9ÈÃ<¤Ã;¸ÌĞŒPØì¡Ü È¡Ü¦     y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q      †ğDä¤!IÄ@˜m‰¤ ØL‘cŠ¤ ÏC$™Á ˜DODH1Æ@d(ED3‘f Í’D$™ÀcÎADN’D$Ù€òD„$I`        /** @file lbaengine.c
	@brief
	This file contains the main game engine routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "lbaengine.h"
#include "main.h"
#include "sdlengine.h"
#include "screens.h"
#include "grid.h"
#include "debug.grid.h"
#include "scene.h"
#include "menu.h"
#include "interface.h"
#include "text.h"
#include "redraw.h"
#include "hqrdepack.h"
#include "resources.h"
#include "renderer.h"
#include "animations.h"
#include "movements.h"
#include "keyboard.h"
#include "gamestate.h"
#include "sound.h"
#include "script.life.h"
#include "script.move.h"
#include "extra.h"
#include "menuoptions.h"
#include "collision.h"

#ifdef GAMEMOD
#include "debug.h"
#endif

int32 isTimeFreezed = 0;
int32 saveFreezedTime = 0;

enum InventoryItems {
	kiHolomap = 0,
	kiMagicBall = 1,
	kiUseSabre = 2,
	kiBookOfBu = 5,
	kiProtoPack = 12,
	kiPinguin = 14,
	kiBonusList = 26,
	kiCloverLeaf = 27
};

void freezeTime() {
	if (!isTimeFreezed)
		saveFreezedTime = lbaTime;
	isTimeFreezed++;
}

void unfreezeTime() {
	--isTimeFreezed;
	if (isTimeFreezed == 0)
		lbaTime = saveFreezedTime;
}

void processActorSamplePosition(int32 actorIdx) {
	int32 channelIdx;
	ActorStruct *actor = &sceneActors[actorIdx];
	channelIdx = getActorChannel(actorIdx);
	setSamplePosition(channelIdx, actor->X, actor->Y, actor->Z);
}

/** Game engine main loop
	@return true if we want to show credit sequence */
int32 runGameEngine() { // mainLoopInteration
	int32 a;
	readKeys();

	if (needChangeScene > -1) {
		changeScene();
	}

	previousLoopPressedKey = loopPressedKey;
	key  = pressedKey;
	loopPressedKey = skippedKey;
	loopCurrentKey = skipIntro;

#ifdef GAMEMOD
	processDebug(loopCurrentKey);
#endif

	if(canShowCredits != 0) {
		// TODO: if current music playing != 8, than play_track(8);
		if (skipIntro != 0) {
			return 0;
		}
		if (pressedKey != 0) {
			return 0;
		}
		if (skippedKey != 0) {
			return 0;
		}
	} else {
		// Process give up menu - Press ESC
		if (skipIntro == 1 && sceneHero->life > 0 && sceneHero->entity != -1 && !sceneHero->staticFlags.bIsHidden) {
			freezeTime();
			if (giveupMenu()) {
				unfreezeTime();
				redrawEngineActions(1);
				freezeTime();
				saveGame(); // auto save game
				quitGame = 0;
				cfgfile.Quit = 0;
				unfreezeTime();
				return 0;
			} else {
				unfreezeTime();
				redrawEngineActions(1);
			}
		}

		// Process options menu - Press F6
		if (loopCurrentKey == 0x40) {
			int tmpLangCD = cfgfile.LanguageCDId;
			freezeTime();
			pauseSamples();
			OptionsMenuSettings[5] = 15;
			cfgfile.LanguageCDId = 0;
			initTextBank(0);
			optionsMenu();
			cfgfile.LanguageCDId = tmpLangCD;
			initTextBank(currentTextBank + 3);
			//TODO: play music
			resumeSamples();
			unfreezeTime();
			redrawEngineActions(1);
		}

		// inventory menu
		loopInventoryItem = -1;
		if (loopCurrentKey == 0x36 && sceneHero->entity != -1 && sceneHero->controlMode == kManual) {
			freezeTime();
			processInventoryMenu();
			
			switch (loopInventoryItem) {
			case kiHolomap:
				printf("Use Inventory [kiHolomap] not implemented!\n");
				break;
			case kiMagicBall:
				if (usingSabre == 1) {
					initModelActor(0, 0);
				}
				usingSabre = 0;
				break;
			case kiUseSabre:
				if (sceneHero->body != GAMEFLAG_HAS_SABRE) {
					if (heroBehaviour == kProtoPack) {
						setBehaviour(kNormal);
					}
					initModelActor(GAMEFLAG_HAS_SABRE, 0);
					initAnim(24, 1, 0, 0);

					usingSabre = 1;
				}
				break;
			case kiBookOfBu: {
				int32 tmpFlagDisplayText;

				fadeToBlack(paletteRGBA);
				loadImage(RESSHQR_INTROSCREEN1IMG, 1);
				initTextBank(2);
				newGameVar4 = 0;
				textClipFull();
				setFontCrossColor(15);
				tmpFlagDisplayText = cfgfile.FlagDisplayText;
				cfgfile.FlagDisplayText = 1;
				drawTextFullscreen(161);
				cfgfile.FlagDisplayText = tmpFlagDisplayText;
				textClipSmall();
				newGameVar4 = 1;
				initTextBank(currentTextBank + 3);
				fadeToBlack(paletteRGBACustom);
				clearScreen();
				flip();
				setPalette(paletteRGBA);
				lockPalette = 1;
			}							 
				break;
			case kiProtoPack:
				if (gameFlags[GAMEFLAG_BOOKOFBU]) {
					sceneHero->body = 0;
				} else {
					sceneHero->body = 1;
				}

				if (heroBehaviour == kProtoPack) {
					setBehaviour(kNormal);
				} else {
					setBehaviour(kProtoPack);
				}
				break;
			case kiPinguin: {
				ActorStruct *pinguin = &sceneActors[mecaPinguinIdx];
				
				pinguin->X = destX + sceneHero->X;
				pinguin->Y = sceneHero->Y;
				pinguin->Z = destZ + sceneHero->Z;
				pinguin->angle = sceneHero->angle;

				rotateActor(0, 800, pinguin->angle);

				if (!checkCollisionWithActors(mecaPinguinIdx)) {
					pinguin->life = 50;
					pinguin->body = -1;
					initModelActor(0, mecaPinguinIdx);
					pinguin->dynamicFlags.bIsDead = 0; // &= 0xDF
                    pinguin->brickShape = 0;
					moveActor(pinguin->angle, pinguin->angle, pinguin->speed, &pinguin->move);
					gameFlags[GAMEFLAG_MECA_PINGUIN] = 0; // byte_50D89 = 0;
                    pinguin->info0 = lbaTime + 1500;
				}
			}
				break;
			case kiBonusList: {
				int32 tmpLanguageCDIdx;
				tmpLanguageCDIdx = cfgfile.LanguageCDId;
				unfreezeTime();
				redrawEngineActions(1);
				freezeTime();
				cfgfile.LanguageCDId = 0;
				initTextBank(2);
				textClipFull();
				setFontCrossColor(15);
				drawTextFullscreen(162);
				textClipSmall();
				cfgfile.LanguageCDId = tmpLanguageCDIdx;
				initTextBank(currentTextBank + 3);
			}
				break;
			case kiCloverLeaf:
				if (sceneHero->life < 50) {
					if (inventoryNumLeafs > 0) {
						sceneHero->life = 50;
						inventoryMagicPoints = magicLevelIdx * 20;
						inventoryNumLeafs--;
						addOverlay(koInventoryItem, 27, 0, 0, 0, koNormal, 3);
					}
				}
				break;
			}


			unfreezeTime();
			redrawEngineActions(1);
		}

		// Process behaviour menu - Press CTRL and F1..F4 Keys
		if ((loopCurrentKey == 0x1D || loopCurrentKey == 0x3B || loopCurrentKey == 0x3C || loopCurrentKey == 0x3D || loopCurrentKey == 0x3E) && sceneHero->entity != -1 && sceneHero->controlMode == kManual) {
			if (loopCurrentKey != 0x1D) {
				heroBehaviour = loopCurrentKey - 0x3B;
			}
			freezeTime();
			processBehaviourMenu();
			unfreezeTime();
			redrawEngineActions(1);
		}	

		// use Proto-Pack
		if (loopCurrentKey == 0x24 && gameFlags[GAMEFLAG_PROTOPACK] == 1) {
			if (gameFlags[GAMEFLAG_BOOKOFBU]) {
				sceneHero->body = 0;
			} else {
				sceneHero->body = 1;
			}

			if (heroBehaviour == kProtoPack) {
				setBehaviour(kNormal);
			} else {
				setBehaviour(kProtoPack);
			}
		}

		// Press Enter to Recenter Screen
		if ((loopPressedKey & 2) && !disableScreenRecenter) {
			newCameraX = sceneActors[currentlyFollowedActor].X >> 9;
			newCameraY = sceneActors[currentlyFollowedActor].Y >> 8;
			newCameraZ = sceneActors[currentlyFollowedActor].Z >> 9;
			reqBgRedraw = 1;
		}

		// TODO: draw holomap

		// Process Pause - Press P
		if (loopCurrentKey == 0x19) {
			freezeTime();
			setFontColor(15);
			drawText(5, 446, (int8*)"Pause"); // no key for pause in Text Bank
			copyBlockPhys(5, 446, 100, 479);
			do {
				readKeys();
				SDL_Delay(10);
			} while (skipIntro != 0x19 && !pressedKey);
			unfreezeTime();
			redrawEngineActions(1);
		}
	}

	loopActorStep = getRealValue(&loopMovePtr);
	if (!loopActorStep) {
		loopActorStep = 1;
	}

	setActorAngle(0, -256, 5, &loopMovePtr);
	disableScreenRecenter = 0;

	processEnvironmentSound();

	// Reset HitBy state
	for (a = 0; a < sceneNumActors; a++)
    {
        sceneActors[a].hitBy = -1;
    }

	processExtras();

	for (a = 0; a < sceneNumActors; a++) {
		ActorStruct *actor = &sceneActors[a];

		if (!actor->dynamicFlags.bIsDead) {
			if (actor->life == 0) {
				if (a == 0) { // if its hero who died
					initAnim(kLandDeath, 4, 0, 0);
					actor->controlMode = 0;
				} else {
					playSample(37, Rnd(2000) + 3096, 1, actor->X, actor->Y, actor->Z, a);

					if (a == mecaPinguinIdx) {
						addExtraExplode(actor->X, actor->Y, actor->Z);
					}
				}
				
				if (actor->bonusParameter & 0x1F0 && !(actor->bonusParameter & 1)) {
					processActorExtraBonus(a);
				}
			}

			processActorMovements(a);

			actor->collisionX = actor->X;
			actor->collisionY = actor->Y;
			actor->collisionZ = actor->Z;

			if (actor->positionInMoveScript != -1) {
				processMoveScript(a);
			}

			processActorAnimations(a);

			if (actor->staticFlags.bIsZonable) {
				processActorZones(a);
			}

			if (actor->positionInLifeScript != -1) {
				processLifeScript(a);
			}

			processActorSamplePosition(a);

			if (quitGame != -1) {
				return quitGame;
			}

			if (actor->staticFlags.bCanDrown) {
				int32 brickSound;
				brickSound = getBrickSoundType(actor->X, actor->Y - 1, actor->Z);
				actor->brickSound = brickSound;

				if ((brickSound & 0xF0) == 0xF0) {
					if ((brickSound & 0xF) == 1) {
						if (a) { // all other actors
							int32 rnd = Rnd(2000) + 3096;
							playSample(0x25, rnd, 1, actor->X, actor->Y, actor->Z, a);
							if (actor->bonusParameter & 0x1F0) {
								if (!(actor->bonusParameter & 1)) {
									processActorExtraBonus(a);
								}
								actor->life = 0;
							}
						} else { // if Hero
							if (heroBehaviour != 4 || (brickSound & 0x0F) != actor->anim) {
								if (!cropBottomScreen)
								{
									initAnim(kDrawn, 4, 0, 0);
									projectPositionOnScreen(actor->X - cameraX, actor->Y - cameraY, actor->Z - cameraZ);
									cropBottomScreen = projPosY;
								}
								projectPositionOnScreen(actor->X - cameraX, actor->Y - cameraY, actor->Z - cameraZ);
								actor->controlMode = 0;
								actor->life = -1;
								cropBottomScreen = projPosY;
								actor->staticFlags.bCanDrown |= 0x10;
							}
						}
					}
				}
			}

			if (actor->life <= 0) {
				if (!a) { // if its Hero
					if (actor->dynamicFlags.bAnimEnded) {
						if (inventoryNumLeafs > 0) { // use clover leaf automaticaly
							sceneHero->X = newHeroX;
							sceneHero->Y = newHeroY;
							sceneHero->Z = newHeroZ;

							needChangeScene = currentSceneIdx;
							inventoryMagicPoints = magicLevelIdx * 20;

							newCameraX = (sceneHero->X >> 9);
							newCameraY = (sceneHero->Y >> 8);
							newCameraZ = (sceneHero->Z >> 9);

							heroPositionType = kReborn;

							sceneHero->life = 50;
							reqBgRedraw = 1;
							lockPalette = 1;
							inventoryNumLeafs--;
							cropBottomScreen = 0;
						} else { // game over
							inventoryNumLeafsBox = 2;
							inventoryNumLeafs = 1;
							inventoryMagicPoints = magicLevelIdx * 20;
							heroBehaviour = previousHeroBehaviour;
							actor->angle  = previousHeroAngle;
							actor->life = 50;

							if (previousSceneIdx != currentSceneIdx) {
								newHeroX = -1;
								newHeroY = -1;
								newHeroZ = -1;
								currentSceneIdx = previousSceneIdx;
							}

							saveGame();
							processGameoverAnimation();
							quitGame = 0;
							return 0;
						}
					}
				} else {
					processActorCarrier(a);
					actor->dynamicFlags.bIsDead = 1;
					actor->entity = -1;
					actor->zone = -1;
				}
			}

			if (needChangeScene != -1) {
				return 0;
			}
		}
	}

	// recenter screen automatically
	if (!disableScreenRecenter && !useFreeCamera) {
		ActorStruct *actor = &sceneActors[currentlyFollowedActor];
		projectPositionOnScreen(actor->X - (newCameraX << 9),
								   actor->Y - (newCameraY << 8),
								   actor->Z - (newCameraZ << 9));
		if (projPosX < 80 || projPosX > 539 || projPosY < 80 || projPosY > 429) {
			newCameraX = ((actor->X + 0x100) >> 9) + (((actor->X + 0x100) >> 9) - newCameraX) / 2;
			newCameraY = actor->Y >> 8;
			newCameraZ = ((actor->Z + 0x100) >> 9) + (((actor->Z + 0x100) >> 9) - newCameraZ) / 2;

			if(newCameraX >= 64) {
				newCameraX = 63;
			}

			if(newCameraZ >= 64) {
				newCameraZ = 63;
			}
			
			reqBgRedraw = 1;
		}
	}

	redrawEngineActions(reqBgRedraw);

	// workaround to fix hero redraw after drowning
	if(cropBottomScreen && reqBgRedraw == 1) {
		sceneHero->staticFlags.bIsHidden = 1;
		redrawEngineActions(1);
		sceneHero->staticFlags.bIsHidden = 0;
	}

	needChangeScene = -1;
	reqBgRedraw = 0;

	return 0;
}

/** Game engine main loop
	@return true if we want to show credit sequence */
int32 gameEngineLoop() { // mainLoop
	uint32 start;

	reqBgRedraw = 1;
	lockPalette = 1;
	setActorAngle(0, -256, 5, &loopMovePtr);

	while (quitGame == -1) {
		start = SDL_GetTicks();

		while (SDL_GetTicks() < start + cfgfile.Fps) {
			if (runGameEngine())
				return 1;
			SDL_Delay(1);
		}
		lbaTime++;
	}
	return 0;
}
/** @file lbaengine.h
	@brief
	This file contains the main game engine routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef GAMEENGINE_H
#define GAMEENGINE_H

#include "sys.h"
#include "actor.h"

int32 quitGame;
volatile int32 lbaTime;

int16 leftMouse;
int16 rightMouse;

/** Work video buffer */
uint8 *workVideoBuffer;
/** Main game video buffer */
uint8 *frontVideoBuffer;
/** Auxiliar game video buffer */
uint8 *frontVideoBufferbis;

/** temporary screen table */
int32 screenLookupTable[2000];

ActorMoveStruct loopMovePtr; // mainLoopVar1

int32 loopPressedKey;         // mainLoopVar5
int32 previousLoopPressedKey; // mainLoopVar6
int32 loopCurrentKey;    // mainLoopVar7
int32 loopInventoryItem; // mainLoopVar9

int32 loopActorStep; // mainLoopVar17

/** Disable screen recenter */
int16 disableScreenRecenter;

int32 zoomScreen;

void freezeTime();
void unfreezeTime();

int32 gameEngineLoop();

#endif
BCÀŞ!  Ş  ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q  ¢   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l À6Ä ˆÁ¢ la ¶8 Û@ €m À6Ê`   I     ‚`B LaÂ0Â¤ŒIaQ†0!&1á(ã@eÂP ‰   ¯   2"
 d…$¤„$ã„¡LŒ„MœÄÀ’‡ISD	“ÏNÀ„ß;E”0¡`à2iŠ(aò;¬DøÀØ)¢„	$0G #M%Lşü¦ÒLH888Fš"J˜üùİœgISD	“¯	“™NE°SD	" N“¦ˆ&_k¦E"ê€	`§ˆ&$ œ$M%L¾&LNÄN%LÈ
                                             ’Œè€"r@à"iŠ(aò9§)ãC}                          D‘ d‘,„‘€¤‘€Ä‘äA
‰`@!‰ @#dd’Ğ „’€¤r‘4E”0ù¬@4Dê Í„†ƒƒƒ[¤)¢„É§AÄÁÁÁÁ)Tƒ84Nƒ‚–‹¤)¢„ÉŸ†`§ˆ&T°°¸$ÙÁ$r É$” ÑäÀÙ$Øá&M%L>ZÑ`%"MìQÂ„ƒƒƒƒƒƒƒTĞ¡ä ´ Ÿô  T  ¡”8 ¢ä0 £ä  $zÈà€bJlrJl ‚Êù ’Êù  ¢J ²:Kš"J˜|ïš" D¤‰"J˜Ptpppppp ppppp ppp2X”5P‚-â*Â y €ÀJ±   @b%  ²l‘Y ­
 ¤V†-€b+ À  ¹aË€à
±  @r¥Ø   !º‚l]!¶  ¯  ¤WŠ­ƒƒâ+È       ù   € æ‚) "    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD 
Ì R@*8Rg ©à œ¤‚óÁTP>˜
ÊSAù`*(Hg ©àŒXœ¤‚³ x  œ¤‚ïP²€U’  € àƒ© |0”­‚1€Tpn´
ÆSAÙá*Le ©à œ¦‚òÁTP>˜
ÊSAù`*(Hg ©à œ¦‚îP¾àU’  €  ªà œ¤‚óÁTP
Î RÁ@*8Låƒ© |0”¦‚2€Tp>˜
ÊSAù`*(Le ©à  >˜
JXÁI+8Hg ©à œ¥‚ñÁTP–œ
Î’SÁYr*8KNgÉ©à|0”¦‚òÁTP>˜
ÊSAy"+(Hçƒ© |0”¦‚òÁTP>˜
ÊSAù`*(LeÉ©à,9œ%§‚3eVp
Î’SÁ¹B+Låƒ© |0”%§‚s£U0–œ
ÎSAù`*(KNgÉ©à œ¤‚3€Tp
ÎYAy"+(Odåƒ© |0”¦‚òÁTP>˜
ÊSAù`*(Låƒ© |0”¦‚òÁTP>˜
ÊSA@*8cje ©àœ±”¦‚òÁTPÖÜ
Æ RÁ@*8;\ã® Aœ¤‚3€Tp
Î RÁ@*8Hg ©à œ¤‚³äTp–œ
Î RÁ@*8Hg ©à œ¤‚3€Tp
Î RÁ@*8Hg ©à œ¤‚3€Tpv¸
ÆWÁXr*8KNg ©à œ¤‚3€Tp
Î RÁ@*8KNg ©à œ¤‚3€Tp
Îœ\A@*8Hg ©àìpŒ¤‚3€Tp
Î RÁ@*8Le ©à œ¤‚3€Tpòè
ÊSAù`*(Låƒ© |0”¦‚òÁTPúì
F ^Á(Ô+‰|g ©à4ú”¤‚	\p*…Î RÁù`*(Låƒ© |0”¤‚3€Tp
Î RÁ¹¤*8Le ©àl”Kª‚ói\pF‘ÎSAù`*(Låƒ© |0”¦‚²äTp–œ
Î’SÁYr*8KNçƒ© |0”¦‚òÁTP>˜
ÊˆUÁù`*(Låƒ©  œ¦‚2€Tp
Î©rÁYe.8¯ÎçÕ¹àÔBœ®‚Ñ T0
Î RÁ@*8Hg ©à œ¤‚3€Tğ!K/      À¥      `Èò      0d	      ²Œ     YÊ €     †,ç €     C–s @    €!K:      Àå€     `Èr@     0d9      ²ü     YÒ     †,ç €     C–s @    €!Ë:      À¥€     `Èò@     0dy      ²Ä     YÚ€    †,ç €     C–_ @    €!Ë/      Àå€     `Èr@     0d9      ²Ä     Yæ     †,á €     C–z @    €!Ë= P    Àå€     `Èò@     0dÉ      ²Œ     Y~     †,û €     C–~ À    €!Ë9      Àå€     `Èò@     0d)      ²„     Y~     †,¿ €     C–_ @    €!Ë/      Àå€     `Èò@     0d		      ²„     YÎ     †,¿ €     C–r       €!K9      @/   2˜$LŒ	&GÆC  : ƒ R † z ˆ ÂĞ5¨ÎË ¤Û^vÓßò<h»N#ßìw;ï‚Üo:(İ†³Ëí²›^&‡¤1@# ä±E
PA!# 42@&# „2@*# 3@2# D3@6# „3@;# Ô3@?# 4@C# T4@G# ”4@L# ä4@P# $5@T# d5@Y#    y     C‘HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q     v <!IÄ@˜1<qM0Òµ"Æ1Ù €"8Ë‚HˆÓÄF( Î² â4²
(‚³,ˆ„8Íl„/M‘•
Å‚<¦*  Ã€VD´ ˜ ŒS&ÑP¶DDähÂˆÃ•®h‹¦G£€öD@H’&LNÄÌ³©#!â4V	Tu°´Ä5yÍaæ MÄ5ÁH38ÖæL“Ã…BIHc°@ Â´@°†5‘ÓL/2ÎFˆdÉÒTD39vRHÆà°´Ä5mÎÕ:	,NED€•ˆ4™B")È#6Säf@4 ÀÒ×ÄNÎÃ9‹Yu€óDN’:’Ì
A4¶+=‘#’¤	“ÍNCH–TDähÂˆÃ¥àê±¬øzÖ¶H ó,ÄêPÍ`¢D@µUØ6æPÁË‚4!ƒU
0@I0ÏBHÖ*€`µÄ5™Õc9‘ò"álTQ‘¹9À<a"MG, fz’@EÑL¬!ÏôEX§ ‚4È¤5cÎâ8O’D$ÙÀ"	DChÂäD’­
POä„$mÄTˆCE&ÑPf4DäxÍ„LXº¢-šjiºKD4­ˆqLÆÆH ó,ÄJ<0YÄ#PQD4SK\Ó4ŠU4,ÜDì„}D,-qM›s¥@0µY,°ÓD¬à¦…4ÑLN„™€©ƒ4“d¹Ñ9!I¦S¬!Ïd‡P²°´Ä5mÎ•ÀØVC!ME4“a'Å”PH›sÙ¢ C5EDÑ"a‘‹p A°Ñ¦ °´Ä5mTQ‹d„™,mÆJ`Y¯@dÓ!‚Â:T3´ØCØt@…H®„4N9	!LˆÓŞs‘#oDáDÄ,‹A0Âá ¡5’EDà ME4“a-,„Á1À<‘. FàTÎ"Ã@4b3—İ
XOä„$iÂäDŞ5EÀæ4”dŸÉâ ƒÈ aµD4ƒ‰-ÁâÊF™i€óDH3µÄ5ñ/Õ¦&I ó,„ÆÑD‹0„¡8O„4SK\ÿÑmÁ0„×HC”óØi€óDH3µÄ5ñ/Ù*IÄô9ÍÄE$qÎâD¦à<ÒL-qMüD¹¥4‹ã<š09;u8³`+ÑDÔba­Î!ÍÔ×Ä¿@Äª &„ pÎ² â402š09‘d«Î!ÍÔ×Ä¿@¤›t€„4ÑLN„±HF´@°F+ <€± ó,„‰XED3-Øç,‹cƒ&LNdKCX À/á–)@=‘#’$6ÑLN„™DC™kÀÒ0ÄD¹õ8À<!¥€!aM›@EÑL©#!â4b³9–NQV 	TÍ´`iä„$ƒ&LN$—¥L­·?GEÑL%1MD@ƒH-Â_D1ôDD…8”Ä
DCˆÃe¾’@EÑI1h±CX›skÀÔzqûsTÍTÓDD²É)’@4DHDNlsŠ$‘#"	DC„DäÌö·HÑmŠd9%_DÀ`NKàL“Ã”D1Åö´Î49LI“lPKàL“Ã”D1Ív 	TÍô:×4Ê‡,„yD,-qM›smÎ49Œ)8HSÍäDØ· †d;‹ôDÈD´@°ÆàH0Zc,D·]
,Î3!N#™DCË! ±µÀ ›Ë! ³Õ%™Ó!9±Ù%™Ó!9²İ%™Ó!9³!
}€óDD…8”¤	“Å6¢4„Å±…T"ÁB°BDÍJD3‘•(aq CDÀlºÖ9!Iš09‘Ö 0!N#‰Ò0DÈ§HÑ&%!‚HE&ÑP-qMUDd±DLš09‘ÖaõÎâP’&LN$›}€óDD…8”¤	“Í–'	TÍ¤	“‰Íì4„ñ0ÑD´9Óä0<+ÑDôÖÆ´DähÂˆÃeãÕ9!I«3â4¦5cDÔAD×LÈ„i ¸z,+¾5$’@4DHD0` Â,‹8\ÖsH08Vl>‡t ƒcÉösH08Öl°ŒAL+,/°P„=PqM0Òµ9Óä0,Pæ*ĞÎƒm‹#(éI¦âHÑ'ÅhÂäD’½(9š0!NcøŠ@EÑL$Ù`@$PQdÕ×$6qĞ$ÀàXœ³,ˆ„8M‹=„Q%QL¦CI„Í<ED3±Ñâp™D´8Î#6ÑLN„‰Án€$Õ!Àâ±QA°&p,Ğ"aGÑADÖ Œ8\'ºšZiŞKC1hñÑD\öÀ€"Ã@4¯spÀPA°š09‘i$Àß’Y8Oä$©#Í¬Dc+9ÏæL“Ã°BD‘9±,Hc€2ˆÃe—Ò€ KK\;ÑÄ9‹ €ò, FD'ÀÆu<ÀBLaa M
,Ä4+¸iF °° 1YÑØš#Ì³ @#¦)`<ÒL…‘8O„4SK\ŸNQm„@E‘I4TK\Ó4Š$ÈD0Zc,„-HqM0ÒUÅÄaËâJ
,Ä4Æ I ó,„Ä"ÑÁBØq „4ÑLN„C˜d‚Š$ñ-€!Yi€óDH3µÄ5ñéÙV$DäxÍ„LX'²Üêµ±,@ƒ0UDT[{À4³QEAD¶DÁ>2b3—5 59š’„T„,ÀÜ<™¤€b A=&ÑP¶à,ópTÍD˜a
4!QÁÌ³’‘
,ÂB +DÑØ¨@3×Ä-ÈÃ2À²ØsÀd Á"KLÒ’©,
}ÀéÙV!Ù|ÀóD@H’&LN”N‘)
(EDÑ"a¯	Û•G, f›Ï€ KK\Óæ\%QLÆ+=‘#’T"Á
òL¶0 Ò¤ÀBLaé˜@EÑLš09‘Ö ŒwMN‘¾4Eµ5,ÀÜá !Ù}À4‘ALš09Q‡HĞ„
DOä„$qÎ² â4±
DOä„$qÎ² â4²!
DOä„$qÎ² â4³ù9’@4ÄI1mŠdĞ€ KK\Óæ\+b“q!M±y)°¬„DLÄ`Å@HÓlJÓADÖ Œ8\Èr«×z6)0EÄ–×HChÂ„8df”ôDÈDlÕHclÎ•N‘É4À0”HCl(±m!M²ÙTODTˆCI!9q âP‘å(ÑDTÅd7ÑâPRHDÖa»ID4µÎcÓD\Œ4ƒc­ˆqL,Pf 1€°,umÕ„á
TOä„$iÂäD¦SÑL’™0ED3±ñÄvÀTÍÄNÄ#z #PQD4;Ïl<ôDÈD°HF´@°Ö§HÑ³Ó’Y4,-qMœ³8‘­< M$}ÀéÙ£@Q0„×HC˜¨€4D€Õ×ôQË"	A4ö‚<‘“¤$›òDN’:Rl”ˆT0„] Oä$©#Í¦¥dÃ°BD¹$9¦Sƒ)8qM0ÒUÅdÍADÎF@…8TdeôDÈD°08V:Eæ@I ó,„”. †4†&LN$Ùo€ÓPZ¬ÄÖæ\ÆàH@E¤€Ñ	0„í0À<!µ@°–MÄ5ÁH38Vë<,P¦ğDä¤!IÄ@˜m 4ìáX\DÈ$™£@$0ÏB¤„LˆÓØ3‹‚4†&LNdÔÎ9IêH1+DÑFô 1MÄ
nGI“ÃØ©À90š09‘ù
\Oä$„0¥„LˆÓ +DÑ˜G„4ÑLN„S@!y öD@HR	HÓêLÀ„8Öa‰ P¡	“u „<Â4±:óQM[`À#@c«ã0/Õµ<AÜ4Á
DCÄ„>â4’I4KLÒ’Å<O„4SK\SM¿@TÛ¯ öD@H0„S‘Ö 0!Nc³Í9!IŞ5E€d™Ğ€ KK\;‹d„½EÀ<a"MG, ¶6ƒ]AEä4Ó‹„³QEAD¶)à 2™Î@,š09‘eE’DS:B=-,„å89iDH1fœŒDLq âP‘M0,-qM,’öÑ0€%Q‹8\à<ÒL-qM/Õ·LOä„$iÂäDEYv€âDÓá¤‘“È† 8Ñt8iä$±ÍÏÄK¸i(N4N9Él4ĞADNêHÈ„8M‹=„ı$Ä5E@‰H“QED3 C ±Ñ&Ğ Â°HF´@°•LÎ³"Æ1Å&•LÎ³"Æ1É6•LÎ³"Æ1Íæ 4Ã"’y
,0­³-€ b@3×#ÍàX­óX|@óD@H’&LN$|@óD@H’&LN[ZP"Æ1Ù†Ã"A!8\f`=Q!%•ó¤!IÄ@˜É4Oä„$iÂäD³%(’‚<1fCÒAD×LÈ„imXz­ÈY•!Æ1™%Æ×HÑ'ÅÌNCH&pN3¥Sd0HCX!9±Å a…DäÈÖ(ğÄ¤	“qĞ4Äb2HCX!9³Y
0HƒL-qMĞ( 	Tu°´Ä5±HF¤ À@˜d¶QC\S‡ KK\“×LfÈÒTD39vR	H!š,Ï”ˆqL*ÀLÄ5qò|Ô²˜° ÃvåS‹Šd¬ŒDLŸÓLœ³8‘<P_D1´CÒt‘£5#—Ö†¥×Šœ¡,‹ã<¦SéYq€Ä "lÀ²œ³9T#(0ÍDDé`DtñQm‚ÑLD”. FD'À/Ù¶ÀÎâ0Àó-€!mÀöDH3µÄ5ñiD<@DlTQÑD¶¥
$ŒSš09‘E<E,-qMéYo€4D€%6 Àm4Òæ\&DäxÍ„LØ‰®¦VZWò GI“ÃØw@TÑD\œãDÒ !™©€"S
,Ä4ö5Q¡-5ÀD¤ÀBLaD!0„É
\Oä„$yM…DNÃÍÄ:T3˜­ÀƒwMà]Ïâ    a      C,      P ”.c¸!8ƒ0˜e‚€ÒeF¬K0 ³±Ë°  Á`„»€    a      C,      P ”.Ãƒë ­ËnÒ f! vƒìÁ,€    a   $   A,      PEQ…3.ÃLD ¤Ë0é2FÈ Ğ0ÆÜÅ‚Áˆ! *Æˆ æFÁ 1ÈãÁ0JÆxC`ƒ˜1ŞäDÁ18  ”ƒ0   ö.P ÂäD†.€ ÂäDâp™»€"@Ó‹8\     a   ±  `  K   P…Q5PEP6eP%QRd¥P$Q€P…R:…SeW2ÅoP SJ~PàP~ÅV4SÂÌP"…V¸eRÄ…WzÅWH…P¾ÅS>%T*%U¶¥m@ƒ# 5@ˆP@5PeS%Qƒ%PePÅPC¥Pd0”ñ0*À¨et0*@ºet0*€¾el0*À¨ed0*À¨et0*€¿el0*À¨PÀPFõ £ô=e\0*@½P—í¤€í¥€í¨€íÙ¨€íY¤€íY¥€í¦€íY¦€í©€íY©€íÙª€í™¬€íÙ¬€íÙ¯ •Ù¦I
Ø¦]
PÀPFõ £ÔËPFõ £¼  3€.ÃLD  Ë0 è2ÌD º3€.ÃLD  Ë0è2ÌD º3€.ÃLD Ë0b0  G³3†‚v0ƒY†@F Ğf	¢1A;Á ĞìˆÁˆÙ	€dG\  ƒ¸ Í¸ @#h' š1ÜôDÌ2J@·#. á† ,Â`–(‚Áˆ+, `–à'¨wÄ 2ÜŒEÌ2G0¡‘ Ìüù¸ @†³ƒY$	#º³ €Y‚Ÿ˜%ˆq€7$³‹øŒñ†`-@‚‚1Ü´…Ì20R@ä3Æ‚·(	
ÆpCa0ËĞH¡Ïoæb..xX
D±€À‚7v³’Œ  # ÌÁpC a0Ëğ@ÁˆÁ  ó1b@ ÀzØÄˆÁ  ô1b0 €(FÀÏ^À`D)ìÅ Œ 0ƒq° 0Kğ# ÌÇˆ ëa³Ñ,Dó3†“ ƒY†‰
ˆÆ`„0b0 À}Œ 
ƒ§ 0Q~1 # ¬‡_Œ p4c0â‚ ùÔF x`Ä`  R1 @?F ˜% #æG'€ôg7ı ³Õ¤?c¼!( `7?³Öä?c¼!H› `7f³×# ”ÈˆÁ  ­@ı3†™€@FC—¬]¸z	ƒt}I•awiƒ ìCf	ä€úG\  ÃÁZ€Á,ƒ¶#ÅäGl¼Æ,Á6B¯! ³r@'4ÆÙ0
ÆpC a0ËĞA@#$. á† -À`–Áû‚ ş7f	¾ƒâ @Ä-lcÄà@ ÿ€‰x¸ÜŒ@!y€Y0˜%ƒ üƒFŠè¶‡ Lä-#J(7`Ä` €_1  `?Ø‚baF´B0 ƒ²P0b@ À~ÄµÂŒ˜…` F  ‡Áˆ²‹ ÀF P‘`Ä€  Y‡ƒ zaÄ`  ^1  @?Ğa0â„ìA f	ä€Ò!7½³c@ÕĞoÀƒ.#‚ğ€Y‚2 ãxØÅ`Dà0KPCâ nìfÌà‚ ZÄ<f	Ğ`Ä€ €¹‹Y4˜%r!q€Œ7 zƒ» ÁĞ 0ãÁzÃˆ c¼!xÔŒ† 3ãA| ƒÊaŒ7ô±ƒÁ0 ´CƒØhŒ7÷#;Œñ†`?jc0"€ähŒ7ıÑŠ‡1Ş€lFÃ Ğ<Œñ†@Ddƒ‚1b`  ˜ˆ^ÄFâ 1   L‚á†àDÂ`–aÔ  }ãAŠøÆ`D@ü0Æ‚ùÁˆ€<€èHŒP'-Ğ?Œñ†ÀEÒã‚‡¥@TP:1@$1Æ‚ÁÁˆ€F€LbŒ75RJ‰1ŞàzP0ˆ%ÆxC°#°AÁ —ãÈÆˆÁ y’C0á> NÓ‚Ù ÍÄoÄ„6#‚a f	Ö`–@H'Æ`DM0b0  ¯Œ @+ÿ1b0 @¯Fì™Àˆ ±¢# ¨Åˆ ¦r# ”JmŒ Tc0‚'‚ [èF  •`–@¨—ÆxC€&ıAÁnòfÜ ‚%q€7mb³o ‘ÓoŞ„D#‚ÿ ¢%q€X "¸à #n) Ê%QAkÀ`Ä.0b $À«´ÆlĞ	Ğ	´Æ,ÌÄÁ,Œ à.# ˜KŒÌÌ¹Ónüfğ€‚§1ÜôÌ2àA$Oc¸!X0˜eÀ;ˆÆpCÀ`0Ë€w=á† =À`–ú  {ãA¨Üc¸!Ø‘0˜eÈƒ>HŸÆxCP*2BÁnÄfô ©1ÜÀHÌ2ì$RÃ‚	Á0±O ÌğÁˆÁ  &3b0 ÀjŒ P2# ôšÌô•ÔnöfüÀúp@7l³`
ùFnd%f@!R©1ŞÔJšF¶2 ³¢@,5Æ‚[Y“Áˆ`N`–@È¤Ä 2Ü¬	Ì2Œ)# ˆÌ®Ì”Âˆ "Ã&³¥0K`
”S£9Ñá† WÂ`–áR! ÃA¯„Á,C* B@!%. ñ±—`¼!>¡`Tp'9aRÁ ĞI‰ d¼­Ğ%oÒT(ÜIF¬T0 ÔRâ op+w	Æ‚wI
F£’ƒ0À`ÄK­ˆ Ì¤©ÕnìfT‚ƒ ÚfÄ€ €•9• TFTì¤DF HQ±0ù‘Y‚U1 €?F @™V™%`j+q€7y³­à
Í•nì%*Ø%p…Š‘Ğ#VZa–a^!1 `nF X[™%€…Y‚X1  Àelj0Â¦‚ ›ÃA¿„Á,Ã,ÈB0S¹2 ³³0bp( ÌğÄHNF€¿ÀˆÁ  û11ş2 ³´@ó1§Æpƒ Á,C-ÜB@ö1ÆDKd‚ñ†`dXe0"à•˜%°Êa¸€`0b?‚˜% …ƒ Dd0b?Lf f	pöcXá!@ƒY†\x‰€ücŒ7¨–Êƒû íÇoXæ\.xX
Db‚¤‰7/³-¡‰Èof](ÃAÍ€Á,Ã.C@+2†‚›ƒY^è…`Äà@ ¿‰5¹œ¡ãÎœË`D°30K # ¤M½bô
ÈEÆxCğ3øBÁ ãØäƒhdŒ7eó/â‘1b  ÀİœË22H!Ô#ƒbK\  ÃC ³¾ğñÈoÚÆd(ô#c¼!€›“¡`˜Œñ†`nZ†‚1b` €èD0Kğ³à@f2Æ‚»Q
F÷¢ÃŞ„Á,C8ŒC@k2Æ¾y
F9£ÃÁß„Á,Ã8ˆC@u2F h`–`f	ÈìdŒ Ğ:ÉÉoF‡g(T'c¼!0–Œ† ;ãêüƒôdŒ7«#3ƒÁ0 Ä'c¼!h³¡`ĞŸŒñ† vôe0"€BeŒ7²³/Œá†€mÂ`–¡Ì! U# €O0K`´*cÄ€  ğ	èTÆxC€;¸sÁÃR *ˆ¬ ^t¸!Ø0˜e8thVÆˆ çÌ ½ÊoÀe(ÃŞ„Á,C:¨C@¸2F XŸ`–@(WÆˆ <á†ÀoÂ`–aØ! ƒ¾ À,ÁO®Œñ† }Òç‚‡¥@T2XÉèpCÀ>a0ËĞşĞ¯Œñ† ~R‡‚Aâ2Æ‚ùQ
†°2—1ŞÜOìP0F ø„#Ò% J—Aë2ÆşYÁˆ` b—QÁŞèpCÀ7`0ËàıĞ»Œ
hG‡‚ŞƒY†wà‡€ğe7$³ğPÁˆÁ  3TÁé˜§‚Á{	€ìeP¾Œñ†@…Æ‡‚Aü2Æ‚"
ıËo`H}(t2cÄ@ 1’Å}BhdÆxC@CçCÁ¨€vt¸!¸¡0˜eˆzeÆxCCìCÁ¨À~t¸!à¡0˜e˜yHfÆˆ jÌÌ¹Ìo~ˆ~#0€Yz˜%Ør5q€7ó³÷`ÉÌ¨à~”jfŒ7ft?Œá"ƒY†{Ğ‡€BM7h³ù€ÁˆÁ ±$;}£FkD<3Æ‚62!
™Ú0!…Íoä(…(¤jÃ„ d6c¼!¸£¢`«‚Œ  J‹¬‰ÁˆZ`– ¨mÆxCàG7DÁ [&! ¹ãÁ(éƒvm˜„€îfŒ7¨$FúµaB‚ bi1ê›1Ş¸ÒF¯4 ô7c¼!€¥2ŒÒh ¨ÜÄ`„º@¢3Æ‚Yš¥–QÁú`ğ£ Di´ ¢„úÑ
äçjè­@ØÁ&€Y}˜%Ø‡Y~˜%è‡Y ØãA8Ùc¸!§4˜eø•(wÆpCPNa0Ë€ íŒñ†àœDé‚‡¥@T BX	épC Na0Ë'Ì‰ d¸!x'3˜e‰‘häÄ Bh7Æ‚yb¥Áˆ` 29q€Ûñ†à\i0"€RN\  wc¼!Ø§ZŒ† –ƒ| …¸ @,8%\p ƒd İİoDj—(ØRF”]0 ´wc¼!0©^¢`T@K9vÁ Ğßñ†@¥È‰‚Q/å`ÄÚ0Ásd$ 4zc¼!p©qŒ|i #Ø`0"ïĞH ˆîDhƒvÀ`DÚ½” Ì˜Ä`ÄÏ‘ FØ	 Õ¸ @,Ø%\p ƒx ‰Œ ½@ HìÄ B(4Æ‚œJ§Áˆ` R¡1Şì<Fë4 tvƒÚn7AÌ2DIƒrwG0ww$ ƒpwG@j7#à.€Y‚’1 àŒF Ø¡ÁˆÚ«Œ°!°€Y‚Ÿ˜%8‰Y‚” # U@14Æ±ê§–QAi¦´ƒD  tCc¼!@+ŒBj (‡ÆxC V°4ŒÔ Ì¤Ä,Júá†€¤Â`–a%X"Œ£¶€Y‚Ÿ˜%h‰Y— 1¤#È(€Y\ ØÃ[…Á,ÃNÀD@{7†¹
ƒY†ˆ‰€hO\  ãõWWÁ`Ä@c4Æ‚»‚)
åŞ¨€¥Î† ”Fc¼!è+š¢`ï
XêlB@o4Æ‚Ñê)
ß¨ §Î† # ´Vs${â nN
fjB&ª=q€7ód³51Ÿ¸ @†‚–BƒY†š ‰€ÌO\  Ã>™Á,CMèD@¢4ÆÛz+
†c‚
Ö*é”ÆxC°[tEÁ° ­@P\%ıß0!AwE– ŒÁ  ‚¥1Ş×^Q0*«Œ0Á  ¢¥1Ş —hQ0,¨+TĞWI¹4Æ‚ö:-
†z‚
D+éƒaB‚
R‹,	@01ƒA0 TƒÁn@ëflâ&‚Áˆäj f	n‚j0ÃhÁ,NäD0qƒ]À,ANFØ` S0K ³;A6ˆ dÄ€ €5hq€7ı³<áí` . á†`·À`–¡'|" ;ÆxC b"vÁÃR *ø)­à¬v0‚`Ä€ €;/êÃ`Œ7(†b<,¢‚²ÒÁˆ!€YŸŒXÅ€¼`0"€Á‘b1 ˜%ø	)A8     æ< &= MÌSAÁuâpõ€Dˆ °ÕV=0DÍ`ĞÒÄ<ß"=€µÄ5Ùô@“Ùó@21O	4×YôÀñ A!Y€09Q      a   1   J,      P5P*tP
%P0”Q=À¨ ê 3€.ÃLD  Ë0±*… FàJ! #‡€FªÌ4.c¸!HÀ`–A@‚ƒ â`0‚`–`1 @¨„Œn 2˜e `Ä`  unî f
#Œ`& ˜%HF `…i–` |™P ŒØ—`f	‚ÁG `– !d   /PHM         /** @file main.c
	@brief
	This file contains the main engine functions.
	It also contains configurations file definitions.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "main.h"
#include "resources.h"
#include "sdlengine.h"
#include "screens.h"
#include "music.h"
#include "menu.h"
#include "interface.h"
#include "flamovies.h"
#include "hqrdepack.h"
#include "scene.h"
#include "grid.h"
#include "lbaengine.h"
#include "redraw.h"
#include "text.h"
#include "renderer.h"
#include "animations.h"
#include "gamestate.h"
#include "keyboard.h"
#include "actor.h"
#include "sound.h"
#include "fcaseopen.h"

/** Engine current version */
const int8* ENGINE_VERSION = (int8*) "0.2.0";

/** Engine configuration filename */
const int8* CONFIG_FILENAME = (int8*) "lba.cfg";

/** Engine install setup filename

	This file contains informations about the game version.
	This is only used for original games. For mod games project you can
	used \a lba.cfg file \b Version tag. If this tag is set for original game
	it will be used instead of \a setup.lst file. */
const int8* SETUP_FILENAME = (int8*) "setup.lst";

/** Configuration types at \a lba.cfg file

	Fill this with all needed configurations at \a lba.cfg file.
	This engine version allows new type of configurations.
	Check new config lines at \a lba.cfg file after the first game execution */
int8 CFGList[][22] = {
	"Language:",
	"LanguageCD:",
	"FlagDisplayText:",
	"FlagKeepVoice:",
	"SvgaDriver:",
	"MidiDriver:",
	"MidiExec:",
	"MidiBase:",
	"MidiType:",
	"MidiIRQ:",  
	"MidiDMA:", // 10
	"WaveDriver:", 
	"WaveExec:",
	"WaveBase:",
	"WaveIRQ:",
	"WaveDMA:",
	"WaveRate:",
	"MixerDriver:",
	"MixerBase:",  
	"WaveVolume:",
	"VoiceVolume:", // 20
	"MusicVolume:",
	"CDVolume:",
	"LineVolume:",
	"MasterVolume:",
	"Version:",
	"FullScreen:",
	"UseCD:",
	"Sound:",
	"Movie:",
	"CrossFade:", // 30
	"Fps:",
	"Debug:",
	"UseAutoSaving:",
	"CombatAuto:", 
	"Shadow:",
	"SceZoom:",
	"FillDetails:",
	"InterfaceStyle", 
	"WallCollision" // 39
};

int8 LanguageTypes[][10] = {
	"English",
	"Français",
	"Deutsch",
	"Español",
	"Italiano",
	"Português"
};
ConfigFile cfgfile;

/** Allocate video memory, both front and back buffers */
void allocVideoMemory() {
	int32 i, j, k;

	workVideoBuffer = (uint8 *) malloc((SCREEN_WIDTH * SCREEN_HEIGHT) * sizeof(uint8));
	frontVideoBuffer = frontVideoBufferbis = (uint8 *) malloc(sizeof(uint8) * SCREEN_WIDTH * SCREEN_HEIGHT);
	initScreenBuffer(frontVideoBuffer, SCREEN_WIDTH, SCREEN_HEIGHT);

	j = 0;
	k = 0;
	for (i = SCREEN_HEIGHT; i > 0; i--) {
		screenLookupTable[j] = k;
		j++;
		k += SCREEN_WIDTH;
	}

	// initVideoVar1 = -1;
}

/** Gets configuration type index from lba.cfg config file
	@param lineBuffer buffer with config line
	@return config type index */
int getConfigTypeIndex(int8* lineBuffer) {
	int32 i;
	char buffer[256];
	char* ptr;

	strcpy(buffer, lineBuffer);

	ptr = strchr(buffer, ' ');

	if (ptr) {
		*ptr = 0;
	}

	for (i = 0; i < (sizeof(CFGList) / 22); i++) {
		if (strlen(CFGList[i])) {
			if (!strcmp(CFGList[i], buffer)) {
				return i;
			}
		}
	}

	return -1;
}

/** Gets configuration type index from lba.cfg config file
	@param lineBuffer buffer with config line
	@return config type index */
int getLanguageTypeIndex(int8* language) {
	int32 i;
	char buffer[256];
	char* ptr;

	strcpy(buffer, language);

	ptr = strchr(buffer, ' ');

	if (ptr) {
		*ptr = 0;
	}

	for (i = 0; i < (sizeof(LanguageTypes) / 10); i++) {
		if (strlen(LanguageTypes[i])) {
			if (!strcmp(LanguageTypes[i], buffer)) {
				return i;
			}
		}
	}

	return 0; // English
}

/** Init configuration file \a lba.cfg */
void initConfigurations() {
	FILE *fd, *fd_test;
	int8 buffer[256], tmp[16];
	int32 cfgtype = -1;

	fd = fcaseopen(CONFIG_FILENAME, "rb");
	if (!fd)
		printf("Error: Can't find config file %s\n", CONFIG_FILENAME);

	// make sure it quit when it reaches the end of file
	while (fgets(buffer, 256, fd) != NULL) {
		*strchr(buffer, 0x0D0A) = 0;
		cfgtype = getConfigTypeIndex(buffer);
		if (cfgtype != -1) {
			switch (cfgtype) {
			case 0:
				sscanf(buffer, "Language: %s", cfgfile.Language);
				cfgfile.LanguageId = getLanguageTypeIndex(cfgfile.Language);
				break;
			case 1:
				sscanf(buffer, "LanguageCD: %s", cfgfile.LanguageCD);
				cfgfile.LanguageCDId = getLanguageTypeIndex(cfgfile.Language) + 1;
				break;
			case 2:
				sscanf(buffer, "FlagDisplayText: %s", cfgfile.FlagDisplayTextStr);
				if (!strcmp(cfgfile.FlagDisplayTextStr,"ON")) {
					cfgfile.FlagDisplayText = 1;
				} else {
					cfgfile.FlagDisplayText = 0;
				}
				break;
			case 3:
				sscanf(buffer, "FlagKeepVoice: %s", cfgfile.FlagKeepVoiceStr);
				break;
			case 8:
				sscanf(buffer, "MidiType: %s", tmp);
				if (strcmp(tmp, "auto") == 0) {
					fd_test = fcaseopen(HQR_MIDI_MI_WIN_FILE, "rb");
					if (fd_test) {
						fclose(fd_test);
						cfgfile.MidiType = 1;
					}
					else
						cfgfile.MidiType = 0;
				}
				else if (strcmp(tmp, "midi") == 0)
					cfgfile.MidiType = 1;
				else 
					cfgfile.MidiType = 0;
				break;
			case 19:
				sscanf(buffer, "WaveVolume: %d", &cfgfile.WaveVolume);
				cfgfile.VoiceVolume = cfgfile.WaveVolume;
				break;
			case 20:
				sscanf(buffer, "VoiceVolume: %d", &cfgfile.VoiceVolume);
				break;
			case 21:
				sscanf(buffer, "MusicVolume: %d", &cfgfile.MusicVolume);
				break;
			case 22:
				sscanf(buffer, "CDVolume: %d", &cfgfile.CDVolume);
				break;
			case 23:
				sscanf(buffer, "LineVolume: %d", &cfgfile.LineVolume);
				break;
			case 24:
				sscanf(buffer, "MasterVolume: %d", &cfgfile.MasterVolume);
				break;
			case 25:
				sscanf(buffer, "Version: %d", &cfgfile.Version);
				break;
			case 26:
				sscanf(buffer, "FullScreen: %d", &cfgfile.FullScreen);
				break;
			case 27:
				sscanf(buffer, "UseCD: %d", &cfgfile.UseCD);
				break;
			case 28:
				sscanf(buffer, "Sound: %d", &cfgfile.Sound);
				break;
			case 29:
				sscanf(buffer, "Movie: %d", &cfgfile.Movie);
				break;
			case 30:
				sscanf(buffer, "CrossFade: %d", &cfgfile.CrossFade);
				break;
			case 31:
				sscanf(buffer, "Fps: %d", &cfgfile.Fps);
				break;
			case 32:
				sscanf(buffer, "Debug: %d", &cfgfile.Debug);
				break;
			case 33:
				sscanf(buffer, "UseAutoSaving: %d", &cfgfile.UseAutoSaving);
				break;
			case 34:
				sscanf(buffer, "CombatAuto: %d", &cfgfile.AutoAgressive);
				break;
			case 35:
				sscanf(buffer, "Shadow: %d", &cfgfile.ShadowMode);
				break;
			case 36:
				sscanf(buffer, "SceZoom: %d", &cfgfile.SceZoom);
				break;
			case 37:
				sscanf(buffer, "FillDetails: %d", &cfgfile.FillDetails);
				break;
			case 38:
				sscanf(buffer, "InterfaceStyle: %d", &cfgfile.InterfaceStyle);
				break;
			case 39:
				sscanf(buffer, "WallCollision: %d", &cfgfile.WallCollision);
				break;
			}
		}
	}

	if (!cfgfile.Fps)
		cfgfile.Fps = DEFAULT_FRAMES_PER_SECOND;

	fclose(fd);
}

/** Initialize LBA engine */
void initEngine() {
	// getting configuration file
	initConfigurations();

	// Show engine information
	printf("TwinEngine v%s\n\n", ENGINE_VERSION);
	printf("(c)2002 The TwinEngine team. Refer to AUTHORS file for further details.\n");
	printf("Released under the terms of the GNU GPL license version 2 (or, at your opinion, any later). See COPYING file.\n\n");
	printf("The original Little Big Adventure game is:\n\t(c)1994 by Adeline Software International, All Rights Reserved.\n\n");

	if (cfgfile.Debug)
		printf("Compiled the %s at %s\n", __DATE__, __TIME__);

	sdlInitialize();

	srand(SDL_GetTicks()); // always get a different seed while starting the game

	allocVideoMemory();
	clearScreen();

	// Toggle fullscreen if Fullscreen flag is set
	toggleFullscreen();

	// Check if LBA CD-Rom is on drive
	initCdrom();

#ifndef _DEBUG

	// Display company logo
	adelineLogo();

	// verify game version screens
	if (cfgfile.Version == EUROPE_VERSION) {
		// Little Big Adventure screen
		loadImageDelay(RESSHQR_LBAIMG, 3);
		// Electronic Arts Logo
		loadImageDelay(RESSHQR_EAIMG, 2);
	} else if (cfgfile.Version == USA_VERSION) {
		// Relentless screen
		loadImageDelay(RESSHQR_RELLENTIMG, 3);
		// Electronic Arts Logo
		loadImageDelay(RESSHQR_EAIMG, 2);
	} else if (cfgfile.Version == MODIFICATION_VERSION) {
		// Modification screen
		loadImageDelay(RESSHQR_RELLENTIMG, 2);
	}

	playFlaMovie(FLA_DRAGON3);

#endif

	loadMenuImage(1);

	mainMenu();
}

void initMCGA() {
    drawInGameTransBox = 1;
}

void initSVGA() {
    drawInGameTransBox = 0;
}

/** Initialize all needed stuffs at first time running engine */
void initAll() {
	blockBuffer = (uint8 *) malloc(64*64*25*2 * sizeof(uint8));
	animBuffer1 = animBuffer2 = (uint8 *) malloc(5000 * sizeof(uint8));
	memset(samplesPlaying, -1, sizeof(int32) * NUM_CHANNELS);
	memset(itemAngle, 256, sizeof(itemAngle)); // reset inventory items angles

    bubbleSpriteIndex = SPRITEHQR_DIAG_BUBBLE_LEFT;
    bubbleActor = -1;
    showDialogueBubble = 1;
    
	currentTextBank = -1;
	currMenuTextIndex = -1;
	currMenuTextBank = -1;
	autoAgressive = 1;
	
	sceneHero = &sceneActors[0];

	renderLeft = 0;
	renderTop = 0;
	renderRight = SCREEN_TEXTLIMIT_RIGHT;
	renderBottom = SCREEN_TEXTLIMIT_BOTTOM;
	// Set clip to fullscreen by default, allows main menu to render properly after load
	resetClip();

	rightMouse = 0;
	leftMouse = 0;

	initResources();

    initSVGA();
}

/** Main engine function
	@param argc numner of arguments
	@param argv array with all arguments strings */
int main(int argc, char *argv[]) {
	initAll();
	initEngine();
	sdlClose();
	printf("\n\nLBA/Relentless < %s / %s >\n\nOK.\n\n", __DATE__, __TIME__);
	printf("TwinEngine v%s closed\n", ENGINE_VERSION);
	if (cfgfile.Debug) {
		printf("\nPress <ENTER> to quit debug mode\n");
		getchar();
	}
	return 0;
}

// AUX FUNC

int8* ITOA(int32 number) {
	int32 numDigits = 1;
	int8* text;

	if (number >=10 && number <= 99) {
		numDigits = 2;
	} else if (number >=100 && number <= 999) {
		numDigits = 3;
	}

	text = (int8 *)malloc(sizeof(int8) * (numDigits + 1));
	sprintf(text, "%d", number);
	return text;
}


/** \mainpage Twinsen's Engine Doxxy Documentation

	\section intro_sec Introduction

	TwinEngine is a reimplementation project upon the popular 
	Little Big Adventure games released respectively in 
	1994 (Relentless in North America) and 	1997 (Twinsen's Odyssey). 

	\section doc_sec Documentation

	This document, allows you to easily search for particulary things among
	the code. We plan to comment as best as we can and with the most necessary
	informations. The source code is also shared in this document and you can
	use it in the terms of the license.

	Feel free to contact us if you wanna help improving this documentation and
	the engine itself.

	\section copy_sec Copyright

	Copyright (c) Adeline Software International 1994, All Rights Reserved.\n
	Copyright (c) 2002-2007 The TwinEngine team.\n
	Copyright (c) 2008-2013 Prequengine team \n
	Copyright (c) 2013 The TwinEngine team 

	\section licenc_sec License

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

	For a full license, check the license file in source code.
*/
/** @file main.h
	@brief
	This file contains the main engine functions. It also contains
	configurations file definitions.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef MAIN_H
#define MAIN_H

#include "sys.h"

/** Definition for European version */
#define EUROPE_VERSION 0
/** Definition for American version */
#define USA_VERSION 1
/** Definition for Modification version */
#define MODIFICATION_VERSION 2

/** Original screen width */
#define DEFAULT_SCREEN_WIDTH			640
/** Original screen height */
#define DEFAULT_SCREEN_HEIGHT			480
/** Scale screen to double size */
#define SCALE					1
/** Original screen width */
#define SCREEN_WIDTH			DEFAULT_SCREEN_WIDTH * SCALE
/** Original screen height */
#define SCREEN_HEIGHT			DEFAULT_SCREEN_HEIGHT * SCALE
/** Original FLA screen width */
#define FLASCREEN_WIDTH			320
/** Original FLA screen height */
#define FLASCREEN_HEIGHT		200
/** Default frames per second */
#define DEFAULT_FRAMES_PER_SECOND	19

/** Number of colors used in the game */
#define NUMOFCOLORS		256


/** Configuration file structure

	Used in the engine to load/use certain parts of code according with
	this settings. Check \a lba.cfg file for valid values for each settings.\n
	All the settings with (*) means they are new and only exist in this engine. */
typedef struct ConfigFile {
	/** Language name */
	int8 Language[10];
	/** Language CD name */
	int8 LanguageCD[10];
	/** Language Identification according with Language setting. */
	int32 LanguageId;
	/** Language Identification according with Language setting. */
	int32 LanguageCDId;
	/** Enable/Disable game dialogues */
	int8 FlagDisplayTextStr[3];
	/** Enable/Disable game dialogues */
	int32 FlagDisplayText;
	/** Save voice files on hard disk */
	int8 FlagKeepVoiceStr[3];
	/** Save voice files on hard disk */
	int32 FlagKeepVoice;
	/** Type of music file to be used */
	int8 MidiType;
	/** Wave volume */
	int32 WaveVolume;
	/** Chacters voices volume */
	int32 VoiceVolume;
	/** Music volume */
	int32 MusicVolume;
	/** CD volume */
	int32 CDVolume;
	/** Line-In volume */
	int32 LineVolume;
	/** Main volume controller */
	int32 MasterVolume;
	/** *Game version */
	int32 Version;
	/** To allow fullscreen or window mode. */
	int32 FullScreen;
	/** If you want to use the LBA CD or not */
	int32 UseCD;
	/** Allow various sound types */
	int32 Sound;
	/** Allow various movie types */
	int32 Movie;
	/** Use cross fade effect while changing images, or be as the original */
	int32 CrossFade;
	/** Flag used to keep the game frames per second */
	int32 Fps;
	/** Flag to display game debug */
	int32 Debug;
	/** Use original autosaving system or save when you want */
	int32 UseAutoSaving;
	/** Shadow mode type */
	int32 ShadowMode;
	/** AutoAgressive mode type */
	int32 AutoAgressive;
	/** SceZoom mode type */
	int32 SceZoom;
	/** FillDetails mode type */
	int32 FillDetails;
	/** Flag to quit the game */
	int32 Quit;
	/** Flag to change interface style */
	int32 InterfaceStyle;
	/** Flag to toggle Wall Collision */
	int32 WallCollision;
} ConfigFile;

/** Configuration file structure

	Contains all the data used in the engine to configurated the game in particulary ways.\n
	A detailled information of all types are in \a main.h header file. */
extern ConfigFile cfgfile;

/** CD Game directory */
int8 * cdDir;

void initMCGA();
void initSVGA();

int8* ITOA(int32 number);

#endif
BCÀŞ!  ì  ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q     f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l † À6D ,ˆâÿÿÿÿ@   I     ‚`B La‚@‚ ‰   ¿   2"
 d…$¤„$ã„¡LŒ„MàÅ’ @ 4 T
 t ‰’@
ip@s`Ğô ‘" 4‘ Tq‘4E”0ùœÓˆñ!¾ƒ‡‡ ºÈ ÊH
 ÚH	 êÈ úH 
É I *I :É JÉ	 ZÉ$ jI8 zI7 ŠÉ šÉ ª™#€è&A('ÿnh‡R à0iŠ(aòÙ	˜á[ Cb§ˆ&ø\&M%L~‡5 ƒß;E”0¡ÀçiŠ(aòç7ufBÂÍÍ1ÒQÂäÏïæ\h

:Kš"J˜|M˜œÈt*‚"J˜qssãpš4E”0ùZƒ0-ÂQL ;E”0!aÀá$iŠ(aò5ar"vŠ(aBvğäàààà0à0àààààààààààààààààààààà0à0àààààààààààààààà 4D”dEdDE„”$ ¤”# Ä”€ ä” •– $• D•
d•7„•¤•Ä•€ ä•€ –È$–ÈD–7dFC	H? @iISD	“Ï
DC¤ÒLh¸¹¹¹Eš"J˜| qDÜÜÜÜœB5ˆÓø@ã4(`»Hš"J˜üÙivŠ(aBÅÚÚMÛM’¹Ñ["¬Q\BĞÜaÒQÂä£- V"ÒÄN%Lè¸¹¹¹¹¹¹I…:²K°Â#œ¸¡½Ä& ¾Ä&p ¿œ Àœp Á€’a±…¤X‡b,ÃÀÀ 9–a`À Ëà00@’÷HSD	“ÿ‹èÿ‰¥7F e*È²
„Yˆ‡JÒ¬ƒÃÀ qÁ¡’<kà@ E(t Ñ8i
É´…„Z„ÂR-Bá±ÎÅ( ppp¥×288Pì@À %P%    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:I #DD€Š¼M   $à*ğÅb%	   xx‡‚´’   	À
Ì'±Ê@$28	¤N)ƒ‚Êà;)X™$    v(Tà2I  @ ìP¬àe’  €  ™Áw(Z03I  @ ìP¸ g’  € Ø¡HË$  °Cñ‚œI  `‡b0“  ÀI  € `‡AÏ$  °CÑšI  `‡"Ï$  °Cƒàg’  € Ø¡XAÌ$  °CÑ‚šI  `‡BAØ$  °C1ƒ`l’  € Ø¡hÍ$  °CA‚]I  `‡‚¼’  À	z%	  €
f“  ÀÅd%	  €
øJ   ;/Ğ™$    v(Zp3I  @ ìPÔ 8›$    v(fM   ;1À&	  €
h“  ÀÅv&	  €
b“  ÀÅ‚´I  `‡Ú$  °C‘ƒ`m’  € Ø¡ĞAÀ6I  @ ìPÌ (›$    v(v¸M   ;#˜•$    ˆƒUPHœR'”Á©#npò”=ZgVÁÙ£Upöhœ=ZgVÁ‰ƒUP¡œIêgVÁÙ£Upöhœ=Z'VA‰ƒUĞÊ*v“  À…‚¶I  `‡Ò
Áİ$  °C‘‚–I  €Rç¼ÁˆƒUPâ`”8X%VA‰ƒUPâ`”8X%VA‰ƒUPâ`”8X%VA%o0NÑŒUöã¾ÁÙ£Upfé”=Zç¿ÁÙåop~ŒaBc˜ĞÁˆƒUPâ`”8X%VAI ep†	Œ=ZçÑÁYftpöhœ=ZgVÁ9`U0â`”8X%VA‰ƒUPHœR'”ÁI epHœ8X%VA‰ƒUPâ`”8XåÒAÙ£Upâ`”8X%VA‰ƒUPâ`”8Xå¼Áˆfnpöhœ=ZgVÁÙ£Upöhœ=ZgVÁÙ£Upª)Œ=ZgVÁÙ£UpHœRgVÁÙ£Upöhœ=ZçÒAy†tP!”8X%VA‰ƒUPâ`”8X%VA‰ƒUPâ`”8X%VA‰ƒUPâ`”8X%VA‰ƒUPöhœ8X%VA‰ƒUPâ`”8XeVÁ	ÇtPöhœrN%VA‰ƒUPÒAŒ=ZgVÁÙ£Upöhœ=ZgVÁ‰ƒUPâ`”=ZgVÁ‰fnpöhœ=ZgVÁÙ£Upöhœ8XeVÁ‰ƒUPöhœ=ZçÔAÙ£UpHœRgVÁÙ£Upöhœ=ZgVÁÙ£Upöhœ=ZgVÁÙ£Upöhœ=ZgVÁÙ£UpöhœOğã¼ÁH epHœ=ZgVÁÙ£Upöhœ=ZgVÁÙ£UpHœ=ZgVÁÙ£Upöhœ=ZgVÁ™GuPöhœ=ZgVÁùo0öhœ8X%VA‰ƒUPâ`”8X%VAÙ£Upöhœ=ZgVÁÙ£Upöhœzà'VAÙ£UpòY”zà§ÖÁ	¨upâ`”8X%VA‰ƒUPâ`”8X%”ÁI epHœ8X%VA‰ƒUPâ`”8XeVÁÙ£Up
rœ„^§¸Á‡,' @     C–” @    €!ËJ      À¥%      `Èò@     0d‰	      ²´     Yf     †,- @     C–“       €!ËM      À%'€     `È²@     0dé	      ²ü     YN €     †,a€     C–± @    €!KY      Àå,€     `Èr@     0d	      ²œ     YÒ     †,k€     C–¶ `    €!ËY      Àå$      `Èr      0d9	      ²À     YÎ     †,g€     C¹       €!ËY      À¥,€     `È’      0dé	      È    2˜$LŒ	&GÆC › r ¡pXÅa•¡CpXÅa•¡„pXÅa*Øc	 _(=Œğ¹T"ï1D€á47l"õø‹4¥RävÆ–6‡  Š‘\˜ÛyXÚ @*Deutsch   ©ÍÁ…Å¿±  ¤’DÆ–æö 0Iï ôPçPê1šTçå!Q*‘5™¾ën²T"kÒ|ÛÓe¨DÖ„X×Ï:P‰L	i1…¹Õ…•é             ¤ÅævVvV6D¤          –[ØQÚ[XU     @ZFlagKeepVoice:        iMÙ…É¥Ù•Éé           ¤Õ”F–F$—fW&§          VSYZ^Ù˜            @ZMidiBase:             i5¥‘¥QåÁ•é             ¤Õ”F––$¥             VSYQS             @ZWaveDriver:           i]…Ù•á•é             ¤ufW&6W¦            ÖU˜]Y’T”             @ZWaveDMA:              i]…Ù•I…Ñ•é             ¤Õ”†W&G$—fW&§         VS^™œPØ\™           @ZWaveVolume:           iY½¥•Y½±Õµ•é          ¤ÕT7—6fõÆV×V¦         Ö‘Õ[][™            @ZLineVolume:           i5…ÍÑ•ÉY½±Õµ•é         ¤eU&7—öæ¦             –QÛÔ˜\Y™›          @ZUseCD:                iM½Õ¹‘é                ¤Õôf—V¦               ÖÜÛÜœQY™           @ZFps:                  i•‰Õé                ¤U5WTG÷6f—æv¦       ÖĞ[›X]Pİ›          @ZShadow:               iM•i½½µé              ¤e”ÆÆFTF–Æ6§         V’]™œYØXÙ][       @ZWallCollision         ¤€hàõ+Ø°bÇ’-kö,Ú´j×²mëö-Ü¸rçÒ­k÷.Ş¼z÷òíë÷/àÀ‚.LhP­jõ*Ö¬40@# ±B¬€*”È4¡aP”ËßrhvŸè sÚMßnsú2§ÙePi® 
e˜a÷¹>—u Ò\™fšœ¦æáe¨4WfH´¾ÙõvY*‘éb€2Ôa†İçzø\u Ò\kØ^¶¾ÙõvY*‘Õa¦İeë›]o—u YcÍåå²[*‘Õ¾Ûâ0=X§¿u ™6t2²Ãgbzg‡óÔ2®•æÔ¡‘‘>/Ëe¸õ—u Ò\£ê¼¬ÓßÓ°=í>ë@%²F×0›=|³ÙéyúíÖJdúX &g	
ÑÇúNËÖ7»Ş.ë@%²>Íú<=¶¾ÙõvY*‘õ1¦Ùlb™N³ç:P‰L#
5ÃszYn}³ëí²T"+D½§İE÷9í.ƒì¥¹BA%ºXËòyúíÖJd]¦ã²öınë@%².Ê:ªd°XN´Êßó¹1L.ë@%2¥¨2E‡Éï»T"ÓŠJI7½,7‡Çå)=Ï.ë@%2µ(* Æ)&QÑeõvİç´»¢—ÃmHZ6—å ú¬R‘OédN³Ë ó[2×åttY"—éá4{îRĞ‹¾ƒ´Ì.‡çe2¨î&—å :º¢—åí9èmÑÑeĞÑY¡L;=.»çe½,Ÿ§ßn„zËY 0”×å 7<íN¿İ,PØ±Ãô²<åMËeĞğ	Í&G9Í.»
ŠÑv ¢Ë ·<}N»Ãl3M§³Ë aú
’íe7½./ƒÎáv”ë	Ô8Ëåh q$—Ùiw4}›é÷°¼Jºée¹;LO¿İa6d³AÒôMŸƒ¤åyYn/“]
Í¨5|·áiv™¢£Ë Ò¦ƒJs…ZÔ{Ú]tŸÓî2È^šƒÆì÷¼LVP"1›6ÓÁh°íÛ>M8# ”3@;# 44@F# „4@J:
S|IËì²›Î.Ïç ¨4½@¥9È§P<—.…‚˜TPyy>ñŠNjQêÑß x=M‘ËâúÔ~“Ë
r ¨ ’ ª ² ¬ Ò ® ò °  ² 2 ´ z ¸ š » Â ½ ê ¿ 
 Á   y     C„¹HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   Ö  †*`HS$<˜¾4E&@DähÂˆÃ•®h‹¦Gc Â8aeÁÒ “¶,¦	Tu°´Ä5yÍaö( Â´@°6 MÄ5ÁH38ÖæL“ÃØ–BIHc°@–0‘ÓL/2ÎFˆdZÒTD39vRHà°´Ä5mÎÕ:M,NED€•ˆ4™° µ,ã3#“ÿĞï#·mœ‰¤ ØL‘cÜÑ€ KK\;9ç,NdÿÎ9IêH2+DÑ`@u‘£5#—‚«Ç²âëYhÀ"Ì³«C5ƒ™UÔv@Taq€CIG,Ò`„†ğXN¤¼È@8UDd¸ĞäÆB|Ô²HBD‰8À<a"MG, fµ’@EÑL¬!ÏôEØASAÑb!™Ğ"	DChÂäD’‘
@À²8Â‹„cŒa–à,ó¤!IÄ@˜-ÑD´"Æ1Yßt‘ã52aéŠ¶hªq¤0À<±LæóTÍÔ×´bÙÍ€ w û a†/MQM[…áKST×vaøÒÕ¶a¾4Eõm†/MQ›†áKSTç¶aøÒÕºq¾4Eõn‡P²ÖaøÒÕ¼y¾4EuoWÒTD39vRLI …´9—yH,-qMUDÄ"afË,Ä4+¸i6æ ME4“a-,„A,mÆJ`Y­@!E@3ØkÀs‘#oDáDÄ,‹‘D,-qM›s¥@0¶eQHSÍäD˜	ˆ:H3I&+`ÂâH„õTˆäJHc Ñá¤‘“Â„8‰1Âá ¡5’ED6°´Ä5mÎ•ÀÔFÀH ó,Dº 1X}€S9WˆÑˆÍ@\¦à<ÒL-qMüDµ HƒLìjf³‹#(UDdìÎ!ÍÔ×Ä¿@t›g€$Ì³ D#-ÂöaøÒÙ´¾4Evm!†/M‘m›ˆáKSdß6bøÒÙ¸‘¾4Evn%†/M‘­›‰áKSdïVà°^ë¦ÿ'–Ş©™¾4E6o(†/M‘İ™„4ÑLN„±HF´@°ÖĞ,óhÂäDìD<6ğpèù‰àÿ‰¥wj¦gîÎ!ÍÔ×Ä¿@”[©€Á Ëâf,€HÃÂ-DØz€óDH3µÄ5ñ/Ù¶(à<Î‚­D3Q‹=„ÍXED3-Øç,‹cƒ&LNdÇ‡ALÂDà<ÒL-qMüD¼É,a C¼@„Û|ÀÒ0ÄD¹½8O„4SK\ÿ‘n90ÏBHé`HcXŠáKStÓ¦bøÒİµ­¾4E·m,†/MÑ}›© „4ÈÄ
A4UDd-†/MÑÛ‹áKStëcøÒİ»¹¾4Ewn1†/MÑÍ›ŒáKSt÷F,Ğ 2­„äP‘@H† =Q!%±Ñâp™i€"	DC„DäÄV°Î49LISl†KàL“Ã”D1Év°Î49LIÓl\ÒTD39ö-€!j€"	DC„DäÌ&°´Ä5mÎµ9Óä0 	Tƒ+1D€µ9—½-Ò!ÑÁB˜nÀ"	DC´ (’E1` Â,‹8\ÆdNC„DäÄÖdNC„DäÈv HÑ!9²¹$™Ó!9³lED3¥„LˆÓˆÍæX:E-XpÀ! ±	À ÛpÀ! ³M
hED3-X9!IÄ 	“‰Ãe3†/MNáKS„×¦døÒá¶$!· -¾4EømL†/M[“áKS„çV HÑ&%!‚-HE&ÑP-qMUDdğSëÅíÏQQD4SILÉvÄDD3ÑæL“ÃØo€Ò0DÈ 4„Å³,9Zƒ0âpm€$PQD4“&LN$6³Óæ 4„Å±íQ9^3!¦àê±¬øz6”HÑ!9æ(<+ÑDôÖwH08Vlr‡t ƒcÉ6wH08Öl”ÔD\Œ4ƒcmÎ49T„é
,À@,HC”áX¤@õD@HÒêLÀ„8Í†iÂ˜§À ˜µL­·?GEÑL%1MD›s@5 ,+DÑ¬„@4€$PQD4Óë\Ğ(²àHÑ'ÅhÂäD’u
(ED3‘fŠt ¡5ÆB´@pÛO$PQdÕ×$6qYR²Åd:”Dİ$ÀàXœ³,ˆ„8M‹=„]<ED3±ÑâpY$Õ!Àâ±QA°¦*`HS´1D‹ã<bSÍäD˜8ŒK ´C˜_t‘£5#×‰®¦V£ÀÒPZ¼D4—ñ,¡	“} s RˆÑ¼ÎeO‰0Ä· †d€Î9IêH3+DÑ$DÎ³9Óä0¬DcÅ@,Ò`„âpÙv€4 ÀÒ×ÄN@4qÎâDV°QEADfA…êú›b'ş¦øÃâùbéYÙñ 1M„á,@ƒ0UDTÛÍ4³QEAD¶AE&ÑP-qMĞ(ö*`<ÒL…¡8O„4SK\ŸNQmŸ0ÏBhL€ @Xª€!M‘pD MÄ5ÁH38VIT„©-‹#()°ÓDX¯@³8À`%2€AX„4ÑLN„C˜d;Q@ÁB°O„L„ØÄe:	2ŒÖa|ÒAD×LÈ„u"Ë­^ëY¬€!IĞµ CpğLDdA@MfD„$!am M
,Ä4+¸iæTC‡Dv+°D¬Dca“0w8ˆ@H,1MHcHÖ HÑß’a
,
}Àé™ÁÁ}`‰H“‰
@À<!±HF´@°–à<ÒL-qM|:E¶-8‹ã<ED3‘fßÏ€ KK\Óæ\%QLÆ¶0 Ò¤ÀBLa—˜@EÑLš09‘Ö ŒwMN‘	¾4Eµ¾4E¶1¾4E·5¾4E¸9¾4E¹A¾4EºE¾4E»µ
HHƒLœÓˆAEÀ„8d…/Mo…/MQo_‹0w8ˆ@H6%1€°,umÕ„å8’@4ÄI1mŠd‡Å@HSliÊ,+!1˜dÀ4×#ÍàX+bT„)ÑDTÅdÓADÖ Œ8\Èr«×z¦@IO„LÄæPÍ€4Ææ\éÙ}@C‰4Ä€¢@1Ò$›]õDD…8”‘³P!Ù®€³8À 2€AtÄ`V”DD3Që<–(P„4Ív=Q!%…Däh±F)ÀTÍÄNÄ[¥ #PQD4;l–Œ@EÑLìD<³Á=Ò!Á"ÑÁBXx 4 ÀÒ×´9×ŠÇd¸Š$1;!v 4 ÀÂ>€@lÄdDcÚÍ€ KK\ç,Nd™ÏHI`_0D:EæÆTÍdR"Øs€’9Ã
A4(€<‘“¤›  òDN’:’lÎD\Œ4ƒc•D1Ù  òDN’:Òl¿Ò “ÉšÕ59q âP‘e<Ò!ÁÀàXéÙ¨ %Ì³Rº Òš09‘dÒNC1h±CX›s™—#‘. FD'À*ÀH ó,„ÔÁB˜c@4×#ÍàX­ó°@E¨Às‘“F„$I`¶Ù0°(HchÂäDæà<‘“¤³BDE°ÓD¬à¦q”49ŒaEHSÍäDØI1%’I
`Oä„$•€4­ÎLˆÓh±†,@ˆ-ªÙnÀ#@c«ã0/Õ´ñ<Â4±:óQ]›eÀÓÄÀ@c¬@4„Ù<O„4SK\SM¿@T­@#‹Ø ,HFXw 4 ÀÒ×ÄNÄÃ"a°Ea“d
P9Íô"álTQ‘DÀ<a"MG, ¶6ƒ-D’DS:B=-,„å
$HƒLÜ9Œñ
0Ï`ß˜N…ö)àDä¤!IÄ@˜­
Ò	Ìc×Ì€ KK\‹d„Q5` BITÄ"—•8O„4SK\ÓDõm„ŠM‡“FN[¡€âDÓá¤‘“Èf( 8Ñt8iä$³áÏÄK¸Á@9©#!â4-ö–,pHO„4Sa›”@EÑL ÀhED¬@4„A
4@ƒ0,’-,„!$“ó¬ˆqL±%$“ó¬ˆqL²)$“ó¬ˆqL³)Åp‡ƒ„dÍD\Œ4ƒcµÎc®I! á<DcI@L@‰Çd²C@Š4…4âp™r€õDD…8”T:Î“F„$I`¦'DäxÍ„L˜Ö†¥×Šœi
(’‚<1f¬”AL%Ğ`-öb3—!)b“éPa³
Ò “×HCØm@#	DCœ3;!™uÀQ8Í”N‘¥ a…DäÄ¦€4„‘#Ûj ÒVHDÎlûQC\S‡ KK\“×LfÔ@EQ‡ KK\‹d„ù
 €4&ÑPf%!ME4“a'Å€t’u1‡³8ğ|`HÆ  Ës %b“Ù
0lWş 1µˆ HV,@0 ÒØßt‘£5#—Ö†¥×Šœ!,‹ã<¦Sé™”Ä "lÀ²œ³9T#–°=ÒL-qM|UDô‘m5Ò–Ø€ C´ĞH›sÙ©€dç4b´ØCˆÍ@\VğTu°´Ä5¥SdyĞAD×LÈ„èjj¥¡%°p”49Œ5
DMÄÅ9N4 0’E<qM0Òµ"Æ1Y€ã xzÿë­¬ˆ¶6Q¡-5ÀD¤ÀBLaÆD!0„m
(ODH1 a   2   E,      äP\R€
|P   3}à¼Î0ÑÎë3}à¼Î0b@ €\ƒ°Àˆ sFÀN0 ƒ¯ ½Î10 €.‚Œ(\b #—€Á€Y‚€Œ1Ü¼„Ì2D@Æ dŒ7ÌLƒÁ0 ¤"F0Á Ğ2,ˆ@0Ñ0K0Ğ3,ˆ@00K`8      F= V=$f=(        a   F   L,      äPTP5 3}àÀÎ0A8°3ÌDô;ÃLÄ+8°ÌDìƒ„2 ãBK´cÄ  €¹‚ñ†&`bÄ   º˜Á# 2ÆpCpa0Ë!c0"¸‰ ˜%#–š€Y‚–1Ü@d0Ë@(5c¼Áwp"or"'F à‹`¸!Ø‰0˜e(€¤1Ş0>=Œ7>áãÔOüÄˆA ¡!ÃAX„Á,Ãa„Áˆ- €Y‚e– ™%H(€#¶` f	†ÁˆÎ€Y‚…:A8    ö< ,HClTQ‘aÏ™õ@€Øõ€PEAD        a   E   L,      äPT  3}àÀÎ0A8°3ÌDô;ÃLÄ+8°ÌDìƒD2 ãK°cÄ   ¹‚ñ†â%^bÄ  €¹–Á# 2ÆpC`a0Ë!c0"°‰ ˜%#š€Y‚–1Ü<d0Ë@(5c¼wn"op'F Ø‹`¸!Ğ‰0˜e(€¤1Ş><Œ7=Ñã”OøÄˆA  !ÃX„Á,Ãa„Áˆ- €Y‚e– ™%H(| ŒØ‚˜%#:² €Y‚…:A8    ö<€,@cP€AØõÀğL‘UˆYUD     a   ˜  q  ’   PäP$%R åQ¥QeQ%Q¥PåTL¥THeTD%T@åS8EIS€ÅS:eS4%S0åR,¥R(QeREP40”á±Ã*«e°Á8¬â°ÊP†¨Ã*«e˜A8¬â°ÊP† Ã*«ehgà°ŠÃ*C8¬â°ÊPR«8¬2”aÃ*«e Á8¬â°ÊP"«8¬2”„Ã*«e `à°ŠÃ*CÚç°ŠÃ*Cfà9¬â°ÊPt«8¬2”¡q«8¬2”am«8¬2”!šÃ*«eˆAæ°ŠÃ*Cæ°ŠÃ*C`p9¬â°ÊPT«8¬2”aQ«8¬2‚=«8ºã°ÊP†79¬â°ÊP†$9¬â°ÊP9¬â°ÊPö8¬âĞÃ*Cä°ŠÃ*C–ã°ŠÃ*CTã°ŠÃ*C!Øã°ŠÃ;«eHŒÃ*«…`Ã*«8¬2”=«8óC=CØã°Š?CØã°Š³;CØã°Š“;CØã°Šƒ;CØã°Šs?CØã°Šƒ?CØã°Šs;CØã°Šc;CØã°ŠS;CØã°ŠC;CØã°Š3;CØã°Š#;CØã°Š;CØã°Š;CØã°ŠS?CØã°Š#?CØã°Š?CØã°Šó>CØã°ŠÓ>CØã°Šã>CØã°ŠÃ>CØã°Š³>CØã°Š£>CØã°Š“>T9   3váĞÏ0aı3¯àĞO0!ı3}àĞÏ0”Â ƒ \$ƒÁˆ# :ÆpC„Á,ƒÄGcÄ  €Aƒ`–@˜%Æ’ú¨bÆˆ 3"ìB0ÜğEÌ2nŒ74ù‘# ôHğƒAÀxÃ³û1b@ @˜ƒO0 ôŒá†€Â`–¡hƒ€¢1Ì8°ŠA?Çı øÃÌOS?—ü`ñ“Áö>›ûpíÓ±·>Ÿù€ú„AúˆAùŒùÁø”ø˜Aøœø Áï¤ï¨Aï¬Áx" 2b`  v # ˆÉF¸A0 ³l0ŞpÈˆŒ ğ#ìÁˆ ebø#â €Y6oØNäDF “ ö`Ä   5áQnT$f”$ŒÈƒq€Y‚e0"Vd f	–Y6oøVdEF 8“ÀNa–€ÆÂ EZd¼!\ÄEF Pa‚ñ†1€1( @NWndf) T# ÈI`
ƒj ©ÁnÚ f( 6# ÈI0‘
6 ³Ñ`D*ìH ÌD³ÖxäHŒ °'.7;³F°BNÀ,A5Á
> ³Õ,5KÀãpÀ#<2b`  ¼ 
´
c0b‚˜%`ƒñ†9ø‘10 `Op`…Y6o¨ƒ0	“ ú$‡U˜%`ƒñ†;“110 àOs`…Y6oÈƒ2)“ B%H‡V˜%`ƒñ†=8“310 `Tvp…Y6oèƒ4I“ J%x‡W˜%`ƒñ†?X“510 àTy€…Y6o…6i“ R%¨‡X˜%`ƒñ†Qx“710 `U|…Y6o(…8‰“ Z%Ø‡Y˜%`ƒñ†S˜“910 àU …Y6oH…:©“ b%‰r˜%`ƒñ†U¸“;10 `V’¸…Y6oh…<É“ j%8	\˜%`ƒñ†WØ“=10 àV•È…Y6oˆ…>é“ r%h	]˜%`ƒñ†Yø“?10 `W˜Ø…Y6o¨…P	• z%˜	^˜%`ƒñ†[•Q10 àW›è…Y6oÈ…R)• Â%È	_˜%`ƒY‚6˜%ÈÆpC€*a0Ë oFàXÀ,Ğ/Œ È%Àp   	   –K0LÌcº‡PövKpÃ?Òd¶B1.PEAD     a   \   K,   #   tSäP%VÅR…VE@C8¬â°ÊP†ÌÃ*«e˜8¬â°ÊPÄÃ*«eÈ8¬â°ÊP¼Ã*«e¸8¬â°ÊP´Ã*«PÏPö8¬âÈÎPö8¬âÌÚŞ
Øâ
Øê
Øú
P©m(­€mh®   # ìÏ1( @/”`Ä€ €½`F àgÄ€ €¾€ˆÃX„Á,C # €UY³ÂˆÁ  ÊˆÁ  {1b@ @_# ¸ÆˆÁ  ĞˆÁ  ÏˆÁ  ËˆÁ  Mc¸!@0˜eˆ`Ä   ½ ƒoÄ   ½ o–@¡j7f ³…Œ Àc# ğ…€Á,AB×nÂ f$1( À/Ê@f	Y‚d–@1   /Â`Ä€( ¾Pƒƒ (   a      A,      tS ƒ;  a      Á`„Î„    a   :   A,      Pä:@7%@5P€€éT€…PüEP¶%Pş	å{@¶<:„4”q
¢à°ŠÃ*th{:,`{J,@¶:9   # ôÅ3Ñ6Á Œ àÏ`DÛ0Á6Á Œ   Cõ8Ôˆ bqèDÃPƒi³À`ÚH0q6Ê F˜4 ƒe#À`ÙH016“ F„1 ƒ`ƒ0ñ381 ƒ>“À`DÏ 0b0 @1Á39! ƒ;“0b0  1b0  Y   a   5   C,      äP,%@Cv0«8¬2”A«à°ŠÃ*C­À
«8¬2”arà°ŠÃ*C« 
«8¬B=CØã°Š;th{j,    3}àÈÎ0Ñì3wáÈÎ01Ä FÎ FÍ Œ À# ¨ÅˆÁ  Äˆ na
õÎ1(  .–€1ÜÔDÌ2B0b@ À\4# ğÄ,8      =@ ‘QÙó D†        a   3   H,      äP%PeP…PÎ40”!µ‚Ã*«   3}àÄÎ0ÑNì3„;Ã`ÄÀÀ`„  c¸!PÎ`–!*ÆpC°¤Á,ƒ0ƒÆ2 ³c¸!XÎ`–0JÆpCÀ¤Á,CaƒÊ4 ³Æ,ÁAÊ°`AQŒ Á`D 5ƒ 1b`  XR@ĞÈ    –=4Ó!2I¦=@LÄ5Ùó€ÑPL@D            CC=gcc
SDL_CFLAGS = `sdl-config --cflags`
SDL_LIBS = `sdl-config --libs`
CFLAGS=-ggdb -DUNIX -DGAMEMOD -Wall $(SDL_CFLAGS)
OBJS=actor.o \
	animations.o \
	collision.o \
	debug.o \
	debug.grid.o \
	debug.scene.o \
	extra.o \
	fcaseopen.o \
	filereader.o \
	flamovies.o \
	gamestate.o \
	grid.o \
	holomap.o \
	hqrdepack.o \
	interface.o \
	keyboard.o \
	lbaengine.o \
	main.o \
	menu.o \
	menuoptions.o \
	movements.o \
	music.o \
	redraw.o \
	renderer.o \
	resources.o \
	scene.o \
	screens.o \
	script.life.o \
	script.move.o \
	sdlengine.o \
	sound.o \
	xmidi.o \
	text.o

LIBS=$(SDL_LIBS) -lSDL_mixer -lSDL_ttf -lm
TARGET=twin-e
INSTALLDIR=../bin

all: $(TARGET)

$(TARGET): $(OBJS)
	$(CC) -o $@ $(OBJS) $(LIBS)

.c.o:
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	@rm $(OBJS)

install: $(TARGET)
	cp $(TARGET) $(INSTALLDIR)
CC=emcc
SDL_LIBS=-lSDL
LDFLAGS=-mwindows $(SDL_LIBS)
CFLAGS=-DEMSCRIPTEN
OBJS=actor.o \
	animations.o \
	collision.o \
	debug.o \
	debug.grid.o \
	debug.scene.o \
	extra.o \
	fcaseopen.o \
	filereader.o \
	flamovies.o \
	gamestate.o \
	grid.o \
	holomap.o \
	hqrdepack.o \
	interface.o \
	keyboard.o \
	lbaengine.o \
	main.o \
	menu.o \
	menuoptions.o \
	movements.o \
	music.o \
	redraw.o \
	renderer.o \
	resources.o \
	scene.o \
	screens.o \
	script.life.o \
	script.move.o \
	sdlengine.o \
	sound.o \
	sys.o \
	xmidi.o \
	text.o

LIBS=$(LDFLAGS)

VERSION=v0.2.1
TARGET=twin-e_$(VERSION).html
INSTALLDIR=..\bin

all: $(TARGET)

$(TARGET): $(OBJS)
	$(CC) -o $@ $(OBJS) $(LIBS) --preload-file . -s ALLOW_MEMORY_GROWTH=1

.c.o:
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	@del $(OBJS)
	@del $(TARGET)
	@del *.bak
	@del stderr.txt
	@del stdout.txt

install: $(TARGET)
	move $(TARGET) "$(INSTALLDIR)"
CC=gcc
SDL_CFLAGS = `sdl-config --cflags`
SDL_LIBS = `sdl-config --libs`
CFLAGS=-ggdb -DMACOSX -DGAMEMOD -Wall $(SDL_CFLAGS)
OBJS=actor.o \
	animations.o \
	collision.o \
	debug.o \
	debug.grid.o \
	debug.scene.o \
	extra.o \
	fcaseopen.o \
	filereader.o \
	flamovies.o \
	gamestate.o \
	grid.o \
	holomap.o \
	hqrdepack.o \
	interface.o \
	keyboard.o \
	lbaengine.o \
	main.o \
	menu.o \
	menuoptions.o \
	movements.o \
	music.o \
	redraw.o \
	renderer.o \
	resources.o \
	scene.o \
	screens.o \
	script.life.o \
	script.move.o \
	sdlengine.o \
	sound.o \
	xmidi.o \
	text.o

LIBS=$(SDL_LIBS) -framework SDL_mixer -framework SDL_ttf -lm
TARGET=twin-e
INSTALLDIR=../bin

all: $(TARGET)

$(TARGET): $(OBJS)
	$(CC) -o $@ $(OBJS) $(LIBS)

.c.o:
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	@rm $(OBJS)

install: $(TARGET)
	cp $(TARGET) $(INSTALLDIR)
CC=gcc
SDL_LIBS=-lSDLmain -lSDL -lSDL_mixer -lSDL_ttf
LDFLAGS=-mwindows -lmingw32 -lm $(SDL_LIBS)
CFLAGS=-DMINGW32 -fsigned-char
OBJS=actor.o \
	animations.o \
	collision.o \
	debug.o \
	debug.grid.o \
	debug.scene.o \
	extra.o \
	fcaseopen.o \
	filereader.o \
	flamovies.o \
	gamestate.o \
	grid.o \
	holomap.o \
	hqrdepack.o \
	interface.o \
	keyboard.o \
	lbaengine.o \
	main.o \
	menu.o \
	menuoptions.o \
	movements.o \
	music.o \
	redraw.o \
	renderer.o \
	resources.o \
	scene.o \
	screens.o \
	script.life.o \
	script.move.o \
	sdlengine.o \
	sound.o \
	sys.o \
	xmidi.o \
	text.o

LIBS=$(LDFLAGS)

VERSION=v0.2.1
TARGET=twin-e_$(VERSION).exe
INSTALLDIR=..\bin

all: $(TARGET)

$(TARGET): $(OBJS)
	$(CC) -o $@ $(OBJS) $(LIBS)

.c.o:
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	@del $(OBJS)
	@del $(TARGET)
	@del *.bak
	@del stderr.txt
	@del stdout.txt

install: $(TARGET)
	move $(TARGET) "$(INSTALLDIR)"
#!/bin/sh
make -f Makefile.MacOSX clean
make -f Makefile.MacOSX
make -f Makefile.MacOSX install
emmake make -f Makefile.emscripten clean
emmake make -f Makefile.emscripten
emmake make -f Makefile.emscripten install
pause
mingw32-make -f Makefile.mingw clean
mingw32-make -f Makefile.mingw
mingw32-make -f Makefile.mingw install
pause/** @file menu.c
	@brief
	This file contains main menu create and processing routines.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "sys.h"
#include "main.h"
#include "menu.h"
#include "menuoptions.h"
#include "resources.h"
#include "music.h"
#include "sound.h"
#include "screens.h"
#include "sdlengine.h"
#include "hqrdepack.h"
#include "lbaengine.h"
#include "text.h"
#include "interface.h"
#include "redraw.h"
#include "keyboard.h"
#include "scene.h"
#include "animations.h"
#include "actor.h"
#include "movements.h"
#include "gamestate.h"
#include "renderer.h"
#include "grid.h"
#include "gamestate.h"

/** Main menu background image number
	Used when returning from credit sequence to redraw the main menu background image */
uint32 kPlasmaEffectFilesize = 262176;

/** Menu buttons width */
uint16 kMainMenuButtonWidth = 320;
/** Used to calculate the spanning between button and screen */
uint16 kMainMenuButtonSpan = 550;


/** Main menu types */
enum MainMenuType {
	kNewGame		= 20,
	kContinueGame	= 21,
	kOptions		= 23,
	kQuit			= 22,
	kBackground		= 9999
};

/** Give up menu types */
enum GiveUpMenuType {
	kContinue		= 28,
	kGiveUp			= 27 // quit
};

/** Options menu types */
enum OptionsMenuType {
	kReturnGame		= 15,
	kReturnMenu		= 26,
	kVolume			= 30,
	kSaveManage		= 46,
	kAdvanced		= 47
};

/** Volume menu types */
enum VolumeMenuType {
	kMusicVolume	= 1,
	kSoundVolume	= 2,
	kCDVolume		= 3,
	kLineVolume		= 4,
	kMasterVolume	= 5
};

/** Main Menu Settings

	Used to create the game main menu. */
int16 MainMenuSettings[] = {
	0,          // Current loaded button (button number)
	4,          // Num of buttons
	200,        // Buttons box height ( is used to calc the height where the first button will appear )
	0,          // unused
	0,
	20,         // new game
	0,
	21,         // continue game
	0,
	23,         // options
	0,
	22,         // quit
};

/** Give Up Menu Settings

	Used to create the in-game menu. */
int16 GiveUpMenuSettings[] = {
	0,			// Current loaded button (button number)
	2,			// Num of buttons
	240,		// Buttons box height ( is used to calc the height where the first button will appear )
	0,			// unused
	0,
	28,			// continue game
	0,
	27,			// quit game
};

/** Give Up Menu Settings

	Used to create the in-game menu. This menu have one extra item to save the game */
int16 GiveUpMenuSettingsWithSave[] = {
	0,			// Current loaded button (button number)
	3,			// Num of buttons
	240,		// Buttons box height ( is used to calc the height where the first button will appear )
	0,			// unused
	0,
	28,			// continue game
	0,
	16,			// save game
	0,
	27,			// quit game
};

/** Options Menu Settings

	Used to create the options menu. */
int16 OptionsMenuSettings[] = {
	0,			// Current loaded button (button number)
	4,			// Num of buttons
	0,			// Buttons box height ( is used to calc the height where the first button will appear )
	0,			// unused
	0,
	24,			// return to previous menu
	0,
	30,			// volume settings
	0,
	46,			// save game management
	0,
	47,			// advanced options
};

/** Advanced Options Menu Settings

	Used to create the advanced options menu. */
int16 AdvOptionsMenuSettings[] = {
	0,			// Current loaded button (button number)
	5,			// Num of buttons
	0,			// Buttons box height ( is used to calc the height where the first button will appear )
	0,			// unused
	0,
	26,			// return to main menu
	0,
	4,			// aggressive mode (manual|auto)
	6,
	31,			// Polygon detail (full|medium|low)
	7,
	32,			// Shadows (all|character|no)
	8,
	33,			// scenary zoon (on|off)
};

/** Save Game Management Menu Settings

	Used to create the save game management menu. */
int16 SaveManageMenuSettings[] = {
	0,			// Current loaded button (button number)
	3,			// Num of buttons
	0,			// Buttons box height ( is used to calc the height where the first button will appear )
	0,			// unused
	0,
	26,			// return to main menu
	0,
	41,			// copy saved game
	0,
	45,			// delete saved game
};

/** Volume Menu Settings

	Used to create the volume menu. */
int16 VolumeMenuSettings[] = {
	0,			// Current loaded button (button number)
	7,			// Num of buttons
	0,			// Buttons box height ( is used to calc the height where the first button will appear )
	0,			// unused
	0,
	26,			// return to main menu
	1,
	10,			// music volume
	2,
	11,			// sfx volume
	3,
	12,			// cd volume
	4,
	13,			// line-in volume
	5,
	14,			// master volume
	0,
	16,			// save parameters
};


/** Plasma Effect pointer to file content: RESS.HQR:51 */
uint8 *plasmaEffectPtr;

/** Hero behaviour menu entity */
uint8 *behaviourEntity;
/** Behaviour menu anim state */
int16 behaviourAnimState[4]; // winTab
/** Behaviour menu anim data pointer */
AnimTimerDataStruct behaviourAnimData[4];

int32 inventorySelectedColor;
int32 inventorySelectedItem; // currentSelectedObjectInInventory

#define PLASMA_WIDTH 320
#define PLASMA_HEIGHT 50
#define SCREEN_W 640

void plasmaEffectRenderFrame() {
	int16  c;
	int32  i, j;
	uint8 *dest;
	uint8 *src;

	for (j = 1; j < PLASMA_HEIGHT - 1; j++) {
    	for (i = 1; i < PLASMA_WIDTH - 1; i++) {
            /*Here we calculate the average of all 8 neighbour pixel values*/

		    c  = plasmaEffectPtr[(i-1) + (j-1) * PLASMA_WIDTH];  //top-left
		    c += plasmaEffectPtr[(i+0) + (j-1) * PLASMA_WIDTH];   //top
		    c += plasmaEffectPtr[(i+1) + (j-1) * PLASMA_WIDTH]; //top-right

		    c += plasmaEffectPtr[(i-1) + (j+0) * PLASMA_WIDTH]; //left
		    c += plasmaEffectPtr[(i+1) + (j+0) * PLASMA_WIDTH]; //right

		    c += plasmaEffectPtr[(i-1) + (j+1) * PLASMA_WIDTH]; // bottom-left
		    c += plasmaEffectPtr[(i+0) + (j+1) * PLASMA_WIDTH];   // bottom
		    c += plasmaEffectPtr[(i+1) + (j+1) * PLASMA_WIDTH]; // bottom-right

		    c = (c >> 3) | ((c & 0x0003) << 13); /* And the 2 least significant bits are used as a 
              randomizing parameter for statistically fading the flames */

            
		    if (!(c & 0x6500) &&
                (j >= (PLASMA_HEIGHT-4) || c > 0)){
			    c--; /*fade this pixel*/
		    }

            /* plot the pixel using the calculated color */
            plasmaEffectPtr[i + (PLASMA_HEIGHT+j)*PLASMA_WIDTH] = (uint8) c;
        }
	}

    // flip the double-buffer while scrolling the effect vertically:
	dest = plasmaEffectPtr;
	src = plasmaEffectPtr + (PLASMA_HEIGHT+1) * PLASMA_WIDTH;
	for (i = 0; i < PLASMA_HEIGHT * PLASMA_WIDTH; i++)
		*(dest++) = *(src++);

}

/** Process the plasma effect
	@param top top height where the effect will be draw in the front buffer
	@param color plasma effect start color */
void processPlasmaEffect(int32 top, int32 color) {
	uint8 *in;
	uint8 *out;
	int32 i, j, target;
	uint8 c;
	uint8 max_value = color + 15;

	plasmaEffectRenderFrame();

	in = plasmaEffectPtr + 5 * PLASMA_WIDTH;
	out = frontVideoBuffer + screenLookupTable[top];

	for (i = 0; i < 25; i++) {
		for (j = 0; j < kMainMenuButtonWidth; j++) {
			c = in[i*kMainMenuButtonWidth + j] / 2 + color;
			if (c > max_value)
				c = max_value;

        /* 2x2 squares sharing the same pixel color: */
            target = 2*(i*SCREEN_W + j);
			out[target] = c;
			out[target + 1] = c;
			out[target + SCREEN_W] = c;
			out[target + SCREEN_W + 1] = c;
		}
	}
}

/** Draw the entire button box
	@param left start width to draw the button
	@param top start height to draw the button
	@param right end width to draw the button
	@param bottom end height to draw the button */
void drawBox(int32 left, int32 top, int32 right, int32 bottom) {
	drawLine(left, top, right, top, 79);			// top line
	drawLine(left, top, left, bottom, 79);			// left line
	drawLine(right, ++top, right, bottom, 73);		// right line
	drawLine(++left, bottom, right, bottom, 73);	// bottom line
}

/** Draws main menu button
	@param width menu button width
	@param topheight is the height between the top of the screen and the first button
	@param id current button identification from menu settings
	@param value current button key pressed value
	@param mode flag to know if should draw as a hover button or not */
void drawButtonGfx(int32 width, int32 topheight, int32 id, int32 value, int32 mode) {
	int32 right;
	int32 top;
	int32 left;
	int32 bottom2;
	int32 bottom;
	int32 textSize;
	int8 dialText[256];
	/*
	 * int CDvolumeRemaped; int musicVolumeRemaped; int masterVolumeRemaped; int lineVolumeRemaped;
	 * int waveVolumeRemaped;
	 */

	memset(dialText, 0, sizeof(dialText));	

	left = width - kMainMenuButtonSpan / 2;
	right = width + kMainMenuButtonSpan / 2;

	// topheigh is the center Y pos of the button
	top = topheight - 25;		// this makes the button be 50 height
	bottom = bottom2 = topheight + 25;	// ||

	if (mode != 0) {
		if (id <= 5 && id >= 1) {
			int32 newWidth = 0;

			switch (id) {
			case 1: {
				if (cfgfile.MusicVolume > 255)
					cfgfile.MusicVolume = 255;
				if (cfgfile.MusicVolume < 0)
					cfgfile.MusicVolume = 0;
				newWidth = crossDot(left, right, 255, cfgfile.MusicVolume);
				break;
			}
			case 2: {
				if (cfgfile.WaveVolume > 255)
					cfgfile.WaveVolume = 255;
				if (cfgfile.WaveVolume < 0)
					cfgfile.WaveVolume = 0;
				newWidth = crossDot(left, right, 255, cfgfile.WaveVolume);
				break;
			}
			case 3: {
				if (cfgfile.CDVolume > 255)
					cfgfile.CDVolume = 255;
				if (cfgfile.CDVolume < 0)
					cfgfile.CDVolume = 0;
				newWidth = crossDot(left, right, 255, cfgfile.CDVolume);
				break;
			}
			case 4: {
				if (cfgfile.LineVolume > 255)
					cfgfile.LineVolume = 255;
				if (cfgfile.LineVolume < 0)
					cfgfile.LineVolume = 0;
				newWidth = crossDot(left, right, 255, cfgfile.LineVolume);
				break;
			}
			case 5: {
				if (cfgfile.MasterVolume > 255)
					cfgfile.MasterVolume = 255;
				if (cfgfile.MasterVolume < 0)
					cfgfile.MasterVolume = 0;
				newWidth = crossDot(left, right, 255, cfgfile.MasterVolume);
				break;
			}
			};

			processPlasmaEffect(top, 80);
			if (!(rand() % 5)) {
				plasmaEffectPtr[rand() % 140 * 10 + 1900] = 255;
			}
			drawSplittedBox(newWidth, top, right, bottom, 68);
		} else {
			processPlasmaEffect(top, 64);
			if (!(rand() % 5)) {
				plasmaEffectPtr[rand() % 320 * 10 + 6400] = 255;
			}
		}

		if (id <= 5 && id >= 1) {
			// implement this
		}
	} else {
		blitBox(left, top, right, bottom, (int8 *) workVideoBuffer, left, top, (int8 *) frontVideoBuffer);
		drawTransparentBox(left, top, right, bottom2, 4);
	}

	drawBox(left, top, right, bottom);

	setFontColor(15);
	setFontParameters(2, 8);
	getMenuText(value, dialText);
	textSize = getTextSize(dialText);
	drawText(width - (textSize / 2), topheight - 18, dialText);

	// TODO: make volume buttons

	copyBlockPhys(left, top, right, bottom);
}

/** Process the menu button draw
	@param data menu settings array
	@param mode flag to know if should draw as a hover button or not */
void drawButton(int16 *menuSettings, int32 mode) {
	int32  buttonNumber;
	int32  maxButton;
	int16  *localData = menuSettings;
	int32  topHeight;
	uint8  menuItemId;
	uint16 menuItemValue; // applicable for sound menus, to save the volume/sound bar
	int8   currentButton;

	buttonNumber = *localData;
	localData += 1;
	maxButton = *localData;
	localData += 1;
	topHeight = *localData;
	localData += 2;

	if (topHeight == 0) {
		topHeight = 35;
	} else {
		topHeight = topHeight - (((maxButton - 1) * 6) + ((maxButton) * 50)) / 2;
	}

	if (maxButton <= 0) {
		return;
	}

	currentButton = 0;

	do {
		// get menu item settings
		menuItemId = (uint8) * localData;
		localData += 1;
		menuItemValue = *localData;
		localData += 1;
		if (mode != 0) {
			if (currentButton == buttonNumber) {
				drawButtonGfx(kMainMenuButtonWidth, topHeight, menuItemId, menuItemValue, 1);
			}
		} else {
			if (currentButton == buttonNumber) {
				drawButtonGfx(kMainMenuButtonWidth, topHeight, menuItemId, menuItemValue, 1);
			} else {
				drawButtonGfx(kMainMenuButtonWidth, topHeight, menuItemId, menuItemValue, 0);
			}
		}

		currentButton++;
		topHeight += 56; // increase button top height

		// slow down the CPU
		sdldelay(1);
	} while (currentButton < maxButton);
}

/** Where the main menu options are processed
	@param menuSettings menu settings array with the information to build the menu options
	@return pressed menu button identification */
int32 processMenu(int16 * menuSettings) {
	int32 localTime;
	int32 numEntry;
	int32 buttonNeedRedraw;
	int32 maxButton;
	int16 *localData = menuSettings;
	int16 currentButton;
	int16 id;
	int32 musicChanged;
	int32 buttonReleased = 1;

	musicChanged = 0;

	buttonNeedRedraw = 1;

	numEntry = localData[1];
	currentButton = 0; // localData[0];
	localTime = lbaTime;
	maxButton = numEntry - 1;

	readKeys();

	do {
		// if its on main menu
		if (localData == MainMenuSettings) {
			if (lbaTime - localTime <= 11650) {
				if (skipIntro == 46)
					if (skippedKey != 32)
						return kBackground;
			} else {
				return kBackground;
			}
		}

		if (pressedKey == 0) {
			buttonReleased = 1;
		}

		if (buttonReleased) {
			key = pressedKey;

			if (((uint8) key & 2)) { // on arrow key down
				currentButton++;
				if (currentButton == numEntry) { // if current button is the last, than next button is the first
					currentButton = 0;
				}
				buttonNeedRedraw = 1;
				buttonReleased = 0;
			}

			if (((uint8) key & 1)) { // on arrow key up
				currentButton--;
				if (currentButton < 0) { // if current button is the first, than previous button is the last
					currentButton = maxButton;
				}
				buttonNeedRedraw = 1;
				buttonReleased = 0;
			}

			if (*(localData + 8) <= 5) { // if its a volume button
				id = *(localData + currentButton * 2 + 4); // get button parameters from settings array

				switch (id) {
				case kMusicVolume: {
					if (((uint8) key & 4)) { // on arrow key left
						cfgfile.MusicVolume -= 4;
					}
					if (((uint8) key & 8)) { // on arrow key right
						cfgfile.MusicVolume += 4;
					}
					musicVolume(cfgfile.MusicVolume);
					break;
				}
				case kSoundVolume: {
					if (((uint8) key & 4)) { // on arrow key left
						cfgfile.WaveVolume -= 4;
					}
					if (((uint8) key & 8)) { // on arrow key right
						cfgfile.WaveVolume += 4;
					}
					sampleVolume(-1, cfgfile.WaveVolume);
					break;
				}
				case kCDVolume: {
					if (((uint8) key & 4)) { // on arrow key left
						cfgfile.CDVolume -= 4;
					}
					if (((uint8) key & 8)) { // on arrow key right
						cfgfile.CDVolume += 4;
					}
					break;
				}
				case kLineVolume: {
					if (((uint8) key & 4)) { // on arrow key left
						cfgfile.LineVolume -= 4;
					}
					if (((uint8) key & 8)) { // on arrow key right
						cfgfile.LineVolume += 4;
					}
					break;
				}
				case kMasterVolume: {
					if (((uint8) key & 4)) { // on arrow key left
						cfgfile.MasterVolume -= 4;
					}
					if (((uint8) key & 8)) { // on arrow key right
						cfgfile.MasterVolume += 4;
					}
					musicVolume(cfgfile.MusicVolume);
					sampleVolume(-1, cfgfile.WaveVolume);
					break;
				}
				default:
					break;
				}
			}
		}

		if (buttonNeedRedraw == 1) {
			*localData = currentButton;

			drawButton(localData, 0); // current button
			do {
				readKeys();
				drawButton(localData, 1);
			} while (pressedKey == 0 && skippedKey == 0 && skipIntro == 0);
			buttonNeedRedraw = 0;
		} else {
			if (musicChanged) {
				// TODO: update volume settings

			}

			buttonNeedRedraw = 0;
			drawButton(localData, 1);
			readKeys();
			// WARNING: this is here to prevent a fade bug while quit the menu
			copyScreen(workVideoBuffer, frontVideoBuffer);
		}
	} while (!(skippedKey & 2) && !(skippedKey & 1));

	currentButton = *(localData + 5 + currentButton * 2); // get current browsed button

	readKeys();

	return currentButton;
}

/** Used to run the advanced options menu */
int32 advoptionsMenu() {
	int32 ret = 0;

	copyScreen(workVideoBuffer, frontVideoBuffer);

	do {
		switch (processMenu(AdvOptionsMenuSettings)) {
		case kReturnMenu: {
			ret = 1; // quit option menu
			break;
		}
		//TODO: add other options
		default:
			break;
		}
	} while (ret != 1);

	copyScreen(workVideoBuffer, frontVideoBuffer);
	flip();

	return 0;
}

/** Used to run the save game management menu */
int32 savemanageMenu() {
	int32 ret = 0;

	copyScreen(workVideoBuffer, frontVideoBuffer);

	do {
		switch (processMenu(SaveManageMenuSettings)) {
		case kReturnMenu: {
			ret = 1; // quit option menu
			break;
		}
		//TODO: add other options
		default:
			break;
		}
	} while (ret != 1);

	copyScreen(workVideoBuffer, frontVideoBuffer);
	flip();

	return 0;
}

/** Used to run the volume menu */
int32 volumeMenu() {
	int32 ret = 0;

	copyScreen(workVideoBuffer, frontVideoBuffer);

	do {
		switch (processMenu(VolumeMenuSettings)) {
		case kReturnMenu: {
			ret = 1; // quit option menu
			break;
		}
		//TODO: add other options
		default:
			break;
		}
	} while (ret != 1);

	copyScreen(workVideoBuffer, frontVideoBuffer);
	flip();

	return 0;
}

/** Used to run the options menu */
int32 optionsMenu() {
	int32 ret = 0;

	copyScreen(workVideoBuffer, frontVideoBuffer);

	stopSamples();
	//playCDtrack(9);

	do {
		switch (processMenu(OptionsMenuSettings)) {
		case kReturnGame:
		case kReturnMenu: {
			ret = 1; // quit option menu
			break;
		}
		case kVolume: {
			copyScreen(workVideoBuffer, frontVideoBuffer);
			flip();
			volumeMenu();
			break;
		}
		case kSaveManage: {
			copyScreen(workVideoBuffer, frontVideoBuffer);
			flip();
			savemanageMenu();
			break;
		}
		case kAdvanced: {
			copyScreen(workVideoBuffer, frontVideoBuffer);
			flip();
			advoptionsMenu();
			break;
		}
		default:
			break;
		}
	} while (ret != 1);

	copyScreen(workVideoBuffer, frontVideoBuffer);
	flip();

	return 0;
}


/** Used to run the main menu */
void mainMenu() {
	stopSamples();

	copyScreen(frontVideoBuffer, workVideoBuffer);

	// load menu effect file only once
	plasmaEffectPtr = (uint8 *)malloc(kPlasmaEffectFilesize);
	memset(plasmaEffectPtr, 0, kPlasmaEffectFilesize);
	hqrGetEntry(plasmaEffectPtr, HQR_RESS_FILE, RESSHQR_PLASMAEFFECT);

	while (!cfgfile.Quit) {
		initTextBank(0);

		playTrackMusic(9); // LBA's Theme
		stopSamples();

		switch (processMenu(MainMenuSettings)) {
		case kNewGame: {
			newGameMenu();
			break;
		}
		case kContinueGame: {
			continueGameMenu();
			break;
		}
		case kOptions: {
			copyScreen(workVideoBuffer, frontVideoBuffer);
			flip();
			OptionsMenuSettings[5] = kReturnMenu;
			optionsMenu();
			break;
		}
		case kQuit: {
			cfgfile.Quit = 1;
			break;
		}
		case kBackground: {
			loadMenuImage(1);
		}
		}
		fpsCycles(cfgfile.Fps);
	}
}

/** Used to process give up menu while playing game */
int32 giveupMenu() {
	//int32 saveLangue=0;
	int32 menuId;
	int16 * localMenu;

	copyScreen(frontVideoBuffer, workVideoBuffer);
	pauseSamples();

	if (cfgfile.UseAutoSaving == 1)
		localMenu = GiveUpMenuSettings;
	else
		localMenu = GiveUpMenuSettingsWithSave;

	do {
		//saveLangue = languageCD1;
		//languageCD1 = 0;
		initTextBank(0);

		menuId = processMenu(localMenu);

		//languageCD1 = saveLangue;

		initTextBank(currentTextBank + 3);

		fpsCycles(cfgfile.Fps);
	} while (menuId != kGiveUp && menuId != kContinue);

	if (menuId == kGiveUp)
	{
		stopSamples();
		return 1;
	}

	resumeSamples();
	return 0;
}

void drawInfoMenu(int16 left, int16 top)
{
	int32 boxLeft, boxTop, boxRight, boxBottom;
	int32 newBoxLeft, newBoxLeft2, i;

	resetClip();
	drawBox(left, top, left + 450, top + 80);
	drawSplittedBox(left + 1, top + 1, left + 449, top + 79, 0);

	newBoxLeft2 = left + 9;

	drawSprite(0, newBoxLeft2, top + 13, spriteTable[SPRITEHQR_LIFEPOINTS]);

	boxRight = left + 325;
	newBoxLeft = left + 25;
	boxLeft = crossDot(newBoxLeft, boxRight, 50, sceneHero->life);

	boxTop = top + 10;
	boxBottom = top + 25;
	drawSplittedBox(newBoxLeft, boxTop, boxLeft, boxBottom, 91);
	drawBox(left + 25, top + 10, left + 324, top + 10 + 14);

	if (!gameFlags[GAMEFLAG_INVENTORY_DISABLED] && gameFlags[GAMEFLAG_TUNIC]) {
		drawSprite(0, newBoxLeft2, top + 36, spriteTable[SPRITEHQR_MAGICPOINTS]);
		if(magicLevelIdx > 0) {
			drawSplittedBox(newBoxLeft, top + 35, crossDot(newBoxLeft, boxRight, 80, inventoryMagicPoints),top + 50, 75);
		}
		drawBox(left + 25, top + 35, left + magicLevelIdx * 80 + 20, top + 35 + 15);
	}

	boxLeft = left + 340;

	/** draw coin sprite */
	drawSprite(0, boxLeft, top + 15, spriteTable[SPRITEHQR_KASHES]);
	setFontColor(155);
	drawText(left + 370, top + 5, ITOA(inventoryNumKashes));

	/** draw key sprite */
	drawSprite(0, boxLeft, top + 55, spriteTable[SPRITEHQR_KEY]);
	setFontColor(155);
	drawText(left + 370, top + 40, ITOA(inventoryNumKeys));

	// prevent 
	if (inventoryNumLeafs > inventoryNumLeafsBox) {
		inventoryNumLeafs = inventoryNumLeafsBox;
	}

	// Clover leaf boxes
	for (i = 0; i < inventoryNumLeafsBox; i++)
	{
		drawSprite(0, crossDot(left + 25, left + 325, 10, i), top + 58, spriteTable[SPRITEHQR_CLOVERLEAFBOX]);
	}

	// Clover leafs
	for (i = 0; i < inventoryNumLeafs; i++)
	{
		drawSprite(0, crossDot(left + 25, left + 325, 10, i) + 2, top + 60, spriteTable[SPRITEHQR_CLOVERLEAF]);
	}

	copyBlockPhys(left, top, left + 450, top + 135);
}

void drawBehaviour(int16 behaviour, int32 angle, int16 cantDrawBox) {
	uint8 *currentAnim;
	int32 boxLeft, boxTop, boxRight, boxBottom, currentAnimState;
	int8 dialText[256];

	boxLeft   = behaviour * 110 + 110;
	boxRight  = boxLeft + 99;
	boxTop    = 110;
	boxBottom = 229;

	currentAnim = animTable[heroAnimIdx[behaviour]];
	currentAnimState = behaviourAnimState[behaviour];

	if (setModelAnimation(currentAnimState, currentAnim, behaviourEntity, &behaviourAnimData[behaviour])) {
		currentAnimState++; // keyframe
		if (currentAnimState >= getNumKeyframes(currentAnim)) {
			currentAnimState = getStartKeyframe(currentAnim);
		}
		behaviourAnimState[behaviour] = currentAnimState;
	}

	if (cantDrawBox == 0) {
		drawBox(boxLeft - 1, boxTop - 1, boxRight + 1, boxBottom + 1);
	}

	saveClip();
	resetClip();

	if (behaviour != heroBehaviour) { // unselected
		drawSplittedBox(boxLeft, boxTop, boxRight, boxBottom, 0);
	} else { // selected
		drawSplittedBox(boxLeft, boxTop, boxRight, boxBottom, 69);

		// behaviour menu title
		drawSplittedBox(110, 239, 540, 279, 0);
		drawBox(110, 239, 540, 279);

		setFontColor(15);

		if (heroBehaviour == 2 && autoAgressive == 1) {
			getMenuText(4, dialText);
		} else {
			getMenuText(heroBehaviour, dialText);
		}

		drawText((650 - getTextSize(dialText)) / 2, 240, dialText);
	}

	renderBehaviourModel(boxLeft, boxTop, boxRight, boxBottom, -600, angle, behaviourEntity);

	copyBlockPhys(boxLeft, boxTop, boxRight, boxBottom);
	copyBlockPhys(110, 239, 540, 279);

	loadClip();
}

void drawBehaviourMenu(int32 angle) {
	drawBox(100, 100, 550, 290);
	drawTransparentBox(101, 101, 549, 289, 2);

	setAnimAtKeyframe(behaviourAnimState[kNormal], animTable[heroAnimIdx[kNormal]], behaviourEntity, &behaviourAnimData[kNormal]);
	drawBehaviour(kNormal, angle, 0);

	setAnimAtKeyframe(behaviourAnimState[kAthletic], animTable[heroAnimIdx[kAthletic]], behaviourEntity, &behaviourAnimData[kAthletic]);
	drawBehaviour(kAthletic, angle, 0);

	setAnimAtKeyframe(behaviourAnimState[kAggressive], animTable[heroAnimIdx[kAggressive]], behaviourEntity, &behaviourAnimData[kAggressive]);
	drawBehaviour(kAggressive, angle, 0);

	setAnimAtKeyframe(behaviourAnimState[kDiscrete], animTable[heroAnimIdx[kDiscrete]], behaviourEntity, &behaviourAnimData[kDiscrete]);
	drawBehaviour(kDiscrete, angle, 0);

	drawInfoMenu(100, 300);

	copyBlockPhys(100, 100, 550, 290);
}

/** Process hero behaviour menu */
void processBehaviourMenu() {
	int32 tmpLanguageCD;
	int32 tmpTextBank;
	int32 tmpHeroBehaviour;
	int32 tmpTime;

	if (heroBehaviour == kProtoPack) {
		stopSamples();
		setBehaviour(kNormal);
	}

	behaviourEntity = bodyTable[sceneHero->entity];

	heroAnimIdx[kNormal]     = heroAnimIdxNORMAL;
	heroAnimIdx[kAthletic]   = heroAnimIdxATHLETIC;
	heroAnimIdx[kAggressive] = heroAnimIdxAGGRESSIVE;
	heroAnimIdx[kDiscrete]   = heroAnimIdxDISCRETE;

	setActorAngleSafe(sceneHero->angle, sceneHero->angle - 256, 50, &moveMenu);

	copyScreen(frontVideoBuffer, workVideoBuffer);

	tmpLanguageCD = cfgfile.LanguageCDId;
	cfgfile.LanguageCDId = 0;

	tmpTextBank = currentTextBank;
	currentTextBank = -1;

	initTextBank(0);

	drawBehaviourMenu(sceneHero->angle);

	tmpHeroBehaviour = heroBehaviour;

	setAnimAtKeyframe(behaviourAnimState[heroBehaviour], animTable[heroAnimIdx[heroBehaviour]], behaviourEntity, &behaviourAnimData[heroBehaviour]);

	readKeys();
	
	tmpTime = lbaTime;

	while (skippedKey & 4 || (skipIntro >= 59 && skipIntro <= 62)) {
		readKeys();
		key = pressedKey;

		if (key & 8) {
			heroBehaviour++;
		}

		if (key & 4) {
			heroBehaviour--;
		}

		if (heroBehaviour < 0) {
			heroBehaviour = 3;
		}

		if (heroBehaviour >= 4) {
			heroBehaviour = 0;
		}

		if (tmpHeroBehaviour != heroBehaviour) {
			drawBehaviour(tmpHeroBehaviour, sceneHero->angle, 1);
			tmpHeroBehaviour = heroBehaviour;
			setActorAngleSafe(sceneHero->angle, sceneHero->angle - 256, 50, &moveMenu);
			setAnimAtKeyframe(behaviourAnimState[heroBehaviour], animTable[heroAnimIdx[heroBehaviour]], behaviourEntity, &behaviourAnimData[heroBehaviour]);

			while (pressedKey) {
				readKeys();
				drawBehaviour(heroBehaviour, -1, 1);
			}
		}
		
		drawBehaviour(heroBehaviour, -1, 1);

		fpsCycles(50);
		lbaTime++;
	}

	lbaTime = tmpTime;

	setBehaviour(heroBehaviour);
	initEngineProjections();

	currentTextBank = tmpTextBank;
	initTextBank(currentTextBank + 3);

	cfgfile.LanguageCDId = tmpLanguageCD;
}

/** Draw the entire button box
	@param left start width to draw the button
	@param top start height to draw the button
	@param right end width to draw the button
	@param bottom end height to draw the button */
void drawMagicItemsBox(int32 left, int32 top, int32 right, int32 bottom, int32 color) { // Rect
	drawLine(left, top, right, top, color);			// top line
	drawLine(left, top, left, bottom, color);			// left line
	drawLine(right, ++top, right, bottom, color);		// right line
	drawLine(++left, bottom, right, bottom, color);	// bottom line
}

void drawItem(int32 item) {
	int32 itemX = (item / 4) * 85 + 64;
	int32 itemY = (item & 3) * 75 + 52;

	int32 left   = itemX - 37;
	int32 right  = itemX + 37;
	int32 top    = itemY - 32;
	int32 bottom = itemY + 32;

	drawSplittedBox(left, top, right, bottom,
                    inventorySelectedItem == item ? inventorySelectedColor : 0);

	if (gameFlags[item] && !gameFlags[GAMEFLAG_INVENTORY_DISABLED] && item < NUM_INVENTORY_ITEMS) {
		prepareIsoModel(inventoryTable[item]);
		itemAngle[item] += 8;
		renderInventoryItem(itemX, itemY, inventoryTable[item], itemAngle[item], 15000);

		if (item == 15) { // has GAS
			setFontColor(15);
			drawText(left + 3, top + 32, ITOA(inventoryNumGas));
		}
	}

	drawBox(left, top, right, bottom);
	copyBlockPhys(left, top, right, bottom);
}

void drawInventoryItems() {
	int32 item;

	drawTransparentBox(17, 10, 622, 320, 4);
	drawBox(17, 10, 622, 320);
	drawMagicItemsBox(110, 18, 188, 311, 75);
	copyBlockPhys(17, 10, 622, 320);

	for (item = 0; item < NUM_INVENTORY_ITEMS; item++) {
		drawItem(item);
	}
}

/** Process in-game inventory menu */
void processInventoryMenu() {
	int32 di = 1;
	int32 prevSelectedItem, tmpLanguageCD, bx, tmpAlphaLight, tmpBetaLight;

	tmpAlphaLight = alphaLight;
	tmpBetaLight  = betaLight;

	copyScreen(frontVideoBuffer, workVideoBuffer);

	setLightVector(896, 950, 0);

	inventorySelectedColor = 68;

	if (inventoryNumLeafs > 0) {
		gameFlags[GAMEFLAG_HAS_CLOVER_LEAF] = 1;
	}

	drawInventoryItems();

	tmpLanguageCD = cfgfile.LanguageCDId;
	cfgfile.LanguageCDId = 0;

	initTextBank(2);

	bx = 3;

	setFontCrossColor(4);
	initDialogueBox();

	while (skipIntro != 1) {
		readKeys();
		prevSelectedItem = inventorySelectedItem;

		if (!di) {
			key  = pressedKey;
			loopPressedKey = skippedKey;
			loopCurrentKey = skipIntro;
			
			if (key != 0 || skippedKey != 0) {
				di = 1;
			}
		} else {
			loopCurrentKey = 0;
			key = 0;
			loopPressedKey = 0;
			if (!pressedKey && !skippedKey) {
				di = 0;
			}
		}

		if (loopCurrentKey == 1 || loopPressedKey & 0x20)
			break;

		if (key & 2) { // down
			inventorySelectedItem++;
			if (inventorySelectedItem >= NUM_INVENTORY_ITEMS) {
				inventorySelectedItem = 0;
			}
			drawItem(prevSelectedItem);
			bx = 3;
		}

		if (key & 1) { // up
			inventorySelectedItem--;
			if (inventorySelectedItem < 0) {
				inventorySelectedItem = NUM_INVENTORY_ITEMS - 1;
			}
			drawItem(prevSelectedItem);
			bx = 3;
		}

		if (key & 4) { // left
			inventorySelectedItem -= 4;
			if (inventorySelectedItem < 0) {
				inventorySelectedItem += NUM_INVENTORY_ITEMS;
			}
			drawItem(prevSelectedItem);
			bx = 3;
		}

		if (key & 8) { // right
			inventorySelectedItem += 4;
			if (inventorySelectedItem >= NUM_INVENTORY_ITEMS) {
				inventorySelectedItem -= NUM_INVENTORY_ITEMS;
			}
			drawItem(prevSelectedItem);
			bx = 3;
		}

		if (bx == 3) {
			initInventoryDialogueBox();

			if (gameFlags[inventorySelectedItem] == 1 && !gameFlags[GAMEFLAG_INVENTORY_DISABLED] && inventorySelectedItem < NUM_INVENTORY_ITEMS) {
				initText(inventorySelectedItem + 100);
			} else {
				initText(128);
			}
			bx = 0;
		}

		if (bx != 2) {
			bx = printText10();
		}

		// TRICKY: 3D model rotation delay - only apply when no text is drawing
		if (bx == 0 || bx == 2) {
			sdldelay(15);
		}

		if (loopPressedKey & 1) {
			if (bx == 2) {
				initInventoryDialogueBox();
				bx = 0;
			} else {
				if (gameFlags[inventorySelectedItem] == 1 && !gameFlags[GAMEFLAG_INVENTORY_DISABLED] && inventorySelectedItem < NUM_INVENTORY_ITEMS) {
					initInventoryDialogueBox();
					initText(inventorySelectedItem + 100);
				}
			}
		}

		drawItem(inventorySelectedItem);

		if ((loopPressedKey & 2) && gameFlags[inventorySelectedItem] == 1 && !gameFlags[GAMEFLAG_INVENTORY_DISABLED] && inventorySelectedItem < NUM_INVENTORY_ITEMS) {
			loopInventoryItem = inventorySelectedItem;
			inventorySelectedColor = 91;
			drawItem(inventorySelectedItem);
			break;
		}
	}

	printTextVar13 = 0;

	alphaLight = tmpAlphaLight;
	betaLight = tmpBetaLight;

	initEngineProjections();

	cfgfile.LanguageCDId = tmpLanguageCD;

	initTextBank(currentTextBank + 3);

	while (skipIntro != 0 && skippedKey != 0) {
		readKeys();
		sdldelay(1);
	}
}
/** @file menu.h
	@brief
	This file contains main menu create and processing routines.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef MENU_H
#define MENU_H

#include "sdlengine.h"
#include "actor.h"

int32 currMenuTextIndex;
int32 currMenuTextBank;
int8  currMenuTextBuffer[256];

int16 itemAngle[255]; // objectRotation

extern int16 OptionsMenuSettings[];

/** Behaviour menu move pointer */
ActorMoveStruct moveMenu;

/** Plasma Effect pointer to file content: RESS.HQR:51 */
extern uint8 *plasmaEffectPtr;

/** Process the plasma effect
	@param top top height where the effect will be draw in the front buffer
	@param color plasma effect start color */
void processPlasmaEffect(int32 top, int32 color);

/** Draw the entire button box
	@param left start width to draw the button
	@param top start height to draw the button
	@param right end width to draw the button
	@param bottom end height to draw the button */
void drawBox(int32 left, int32 top, int32 right, int32 bottom);

/** Draws inside buttons transparent area
	@param left start width to draw the button
	@param top start height to draw the button
	@param right end width to draw the button
	@param bottom end height to draw the button
	@param colorAdj index to adjust the transparent box color */
void drawTransparentBox(int32 left, int32 top, int32 right, int32 bottom, int32 colorAdj);

/** Where the main menu options are processed
	@param menuSettings menu settings array with the information to build the menu options
	@return pressed menu button identification */
int32 processMenu(int16 * menuSettings);

/** Used to run the main menu */
void mainMenu();

/** Used to run the in-game give-up menu */
int32 giveupMenu();

/** Used to run the options menu */
int32 optionsMenu();

/** Process hero behaviour menu */
void processBehaviourMenu();

/** Process in-game inventory menu */
void processInventoryMenu();

#endif
BCÀŞ!    ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q  ¡   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l † X6Äÿÿÿÿ€´(
@6F `ˆC °2     I     ‚`B Lb‚PC˜0G0a0`aˆ0!(&ÆÁ@&Æ1a0   ‰   º   2"
 d…$¤„$ã„¡LŒ„MôÄÀDÉ @‰ @© @é @
)!@s9ĞCB? PD*8ä€ÃEÒQÂäsNS Æ‡,ú&&  ( (                       ¨"‘è"“¦ˆ&Ÿ€	¾0$vŠ(aBAÆeÒQÂäwX0ˆğ-€!±SD	
2Î‘¦ˆ&~Si&$#M%LşünÎ…³¤)¢„É×„É‰L§"Ø)¢„	 §ISD	“¯5Ó"uÀ°SD	 N’¦ˆ&_&'b§ˆ&d                                             B!	(à@#I @%‰Mğ@'IğA)ä‘Ä’ÿä’È “$“–D“d“
 „“ ¤“óÄ“ó ä“  ”€$”€D”`dt˜4E”0ùhED€•ˆ4±SD	:R‰’’„–.’¦ˆ&Ÿˆ†H¤™Ğ   p‹4E”0ù@ã4ˆ8…j§ñÆiPàt‘4E”0ù³ÓìQÂ„Š¦&'$ƒ¢¨Dh¢©„r ªÄ&  +Èà Ò(u• €¾JÁ   @aÅà     ±9‚ \  edV
     B+ ©ƒ   ÀØJÂ   ğ  ğ@nEà ¸2p<\ ˆ®\  dW® Â+À éÕ€‹øÊÀõğ@~Ex  ÀB << `¸ˆ°\dX
.  €B,— € )ÒG)  ©± \      ôX
.Š,×Mƒ à €*Á  @—5  Ì€)  °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD à
Ì]9°+ zäÁ¯€L ¾rA\@&„È†q	a.8!Ì§Ä¹à´  B˜Î€[Á9+(rå@® È” À€[Á‰.8EÔ'Éº`È”¹‚r WPä
Ê\A9+(MØ%J»à4a”æ‚SÅ]pä
Ê\A‰ È”¹‚r WPä
Ê•tÁp+8ngË»à|”¹‚2àVpÜ
Î€[Áp+8ngÀ­à„0œ1ñ‚3àVpÜ
Î€[ÁùÀ+rå@® È”æ‚Â\pB˜NsÁ	a.8reÀ­àÈ”¹‚r WPä
Ê\A9+(ngÀ­à$YŒ·‚“d]0>ğ
Æ€[Á9+(rå@® È”¹‚rF^0ÖÌÆzÁ˜S/8ng¹ ¸œ;ö‚3àVpöÜÎ|Á”/8ƒòç¾`,ÚŒEû‚q WPä
Ê\A9+(!ÌgÑ¾`¸œ¹‚r WPB˜Î•tÁp+8nç@® ¸œ·‚Â\pB˜Î€[Áp+8ngÀ­à¸œ·‚3àVpÜ
Î€[Áp+8ngÀ­à¸œ·‚“d]0’¬FsÁ	a.8ngÀ­à¸œ·‚3àVpÜ
Î€[Á	a.8ngÀ­à¸œ·‚3àVpÜ
Î#~Ap+8ngÀ­à$YŒ·‚3àVpÜ
Î€[Áp+8ngÀ­à¸œ·‚3àVpÜ
Î€[Áp+8rå@® ¸œ·‚3àVpÜ
N¥~A9+(ngÀ­à¸œ·‚3àVpB˜NsÁp+8n§	» 4a”&ì‚r WPä
Ê\A9+(rå@® È”¹‚r WPä
Ê\A9+(rå@® È”·‚“É_pä
Ê\A9+(rå@® ¸œRÿ‚2àVpRÊ\A9+(­B#–ÈàÈ”¹‚r WPä
Ê\A9+(!Ì'„¹à„0œæ‚Â\pä
Ê\A9+(rå@® Qœ¹‚r WPä
Ê€[Áp+8rå@® È”¹‚r WPä
Ê€[Áp+8ngÀ­à¸œ·‚3«\pä
Ê€[Á¹52(³ÊgÀ­à¸œ·‚3àVpÜ
Î€[Á	a.8rå@® C_       €!8      ÀE      `ÈB@     0d!      ²œ     YÒ     †,ë €     C–v €    €!Ë;      À…€     `È@     0d      ²Ì     Yê     †,÷ €     Cq @    €!K>      À%€     `È²      0dé      ²Ä     YÀ     †,ÿ €     C–u       €!K?      Àe      `È²      0dY      ²ô     Y| €     †,!€     C–‘ @    €!K<      À%€     `ÈÒ@     0dé      ²”     Yâ     †,ë  @     C–~ @    €!K?      Àå$  0    `ÈÒ@     0dI	      ²„     YV €    †,.€     C–z @    €!K=      À¥€     `È@     0dé      ²Ä      Y\     †,¾  @     C–x @    €!‹L €    À¥€     `ÈB      0d‰      ²Ğ     Yl     †,¾  @     C_       €!N      À%€     `ÈÒ@     0dé      ²Ä     Yt     ²@   <   2˜$LŒ	&GÆC(`@(À‚bF ‡ "‹Ô  
¨€°Æb   ğ 7 Ş€ÆB > €6BKø  €€m,  Ğ€4 Ú€Ær€   Œï $ˆa,	8  ĞEX†h
€F h`€F (b€.F Èc€BF hd€JF èd€RF ˆe€\F f€dF ˆf€lF g€tF ˆg€|F h€„F ˆh€ŒF (i€–F (j€¦F ¨j€®F Hk     y     C„HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   b  †*@òØ
Â8ae 	Ğ LaEÔADÖ Œ8\éŠ¶hªq¤uDE,-qM^3E˜@qM0Òµ9Óä0†¥PÒ,D„ PÜ‚<&7‘ÓL/2ÎFˆd0ÒTD39vRHV,IÄ¤5£M$ÀFà°´Ä5mÎÕ:Í,NED€•ˆ4¥ µ,ã3#“ÿĞï#·m"O@@…8Tä52a‘H
òˆÍ9°´Ä5±“ópÎâD¶+ `±O„L„Ù8Oä$©#É¬Dc)ÕADÖ Œ8\®ËŠ¯g™ÒVô ÑL›spÀ"Ì³«C5ƒ%UÔ¦@Ta[£€CIG,Ò`„æ)€`µÄ5™Ãc9‘ò"álTQ‘a
Á‚L›sÙ­ ó ”D° ó,„dÁ0ÏB˜HÓ€©ÀÂP"¼ÎB1„POä„$mÄTˆCE&ÑP°HÑš09‘d3Îâ8O’D$Ñt‘ã52aéŠ¶hªq¤©,ÑD´"Æ1Ùo #Ì³+ñÀd@EÑL-qMĞ(Ö×°p± v°´Ä5mÎ•ÀÔ†,IÄ¤	“i±,P¦A!ME4“a&` Bê Í$ÙÙò 1MÄ
nšM
4CX5MN—5BaÈBX¥ "D$uÎdÒTD39vRLI …´9—	H,-qMUDÄ"aˆÑ€ KK\Óæ\)Œm.ÒTD39ÖÁB˜kÀĞf¬Ä–ÑTˆäJHc Ñá¤‘“Â„89<9òFND|À²˜²@4D€e"ˆÁH›sÙ#"Z#YDd¾‘DL¦3‹Ö 0!NcˆT„û˜DC±Ä4!!ÁÈt°@Ef€S9WˆÑˆÍ@\Öà<ÒL-qMüDµY
Ğæà<ÒL-qMüD¶=8O„4SK\ÿÑm‘Î!ÍÔ×Ä¿@”›d€óDH3µÄ5ñ/éFà<ÒL-qMüD¼ED1}N3q‘#Iœ³8‘å
0CXbS8&ÑPV×,óhÂäDìD<&!ME4“a,’-,„õHÀ<¡1B4Ñ"a‚Îã,ØJ4µØCØp #Ì³é`Ä`Õ’@EÑL¬!ÏôE˜«€Á ËâÆ(°‹#(UDdÓ–@EÑLö9ËâXÄ 	“Y ¥˜ Ò˜DCmÔ49ŒÓaÏÔ9!IbSÍäD˜I4”Y,a C¼@”[eÀÒ0ÄD¸I<HƒL,A›s™#Ì³Rº Òf´	TÍ”:2!N#6›3`éµ@`!R@@…8T¤5ÃNÀD³ÀóDÄD„(9¦3‹…hED3-X9!IÄ 	“‰ÃeSëÅíÏQQD4SILÅ60µ^ÜşED3•Ä4‘l¹ĞâP+!—½HE'Å ÅJ`mÎeòÎâP’&LN4[q€"	DC„DäÄf HÑ!9²(’@4DHDÎl‘ÇÖæ\v´Î49LISlHKàL“Ã”D1É–,P!2y4D9	!LˆÓH–´Î49LIÓlYÒTD39ö-€!™a@4 ÀÒ×´9×æL“Ã‚Åa`&ÑP,1MHcHf±HO„LDaÚ‹$ÑF€ H¶*°8Ï„8deUˆ°Ë"—-$™Ó!9±1$™Ó!9²5$™Ó!9³}HED3½Îµò!a‰‡ 0DÄ¦(p CD€lƒB`à<Q!%iÂäD±é
$!· ÙU"ÁB°BDÍJD3‘©
(•³Pae†JCXÀq€"	DC˜”„ö$	T™DCµÄ5mTQ‘TJº xEAÓ‡,„„d„QHED3iÂäDb3;añÎâP’&LN$k Í@D›3Mc‡JCXÀ [¡@ò¬D3Ñ[ÛÇr‘£5#—}TOä„$­ÎLˆÓl˜Ö Œ
8Ò„ÖÑÁmBÔAD×LÈ„i ¸z,+¾]$’@4DHDåÒ›Î!ÀàX²íÒ5j 5×#ÍàX›3MÃaˆJCXÀ0Eªë¿z,ûbéÙ¢À! ³ ‹Ü‚<ö)ĞÎƒm‹#(éIàHÑ'ÅhÂäD’Ñ(ED3‘fëÊAD&LˆÓXS$PQdÕ×$6q™À¤˜ Ò˜DCmÔ49û Á%QL¦CI„ñLÒÅ9Ë‚HˆÓ´ØC˜¤ 2D€U"a5Ñâ8ØTD39&Nc ’t8V‡ ‹cPÄFÁBnÀ#PQD4+!—±
,Òä<,À<!ÙÃ±@‹0„D9Zƒ0âpèjj¥
,Å ÅKDqÙe s RˆÑ¼Îe±K@ÁBhÂäD†‘ C|`Hvà<‘“¤4³BDı@Bä<›3MÃ
A4)0=‘#’”.€Ä ^QÂd ÊÖFM“ÓØŸ4 ÀÒ×ÄN@4qÎâD¥<€Ñ	0„™°ÓD˜ÛÃ H“1MÄ
nšñA,ìÄFLA4æ	T™DCµÄ5m@£X¯@3D€µP!Ù¬ $8Í„4aeŒÎ!ÍÔ×Ä§SdÛK‚L£5ÆBØ¦@$Óç4S
D CLD$Ù$Ì³‹dDakËâJ
,Ä4Æ!ME4“a'Å&­@³8À`%2€A˜l@PA°ì!!6q§Àb“I4TK\“½
,Ää5S„Ùt‘ã52aÈr«×zv)ğ`±Ï‚L1lÎeT‹0w ÏDD, ÄÄN@4‘VD CXIP“£!IHE˜­€b A=&ÑP†+ĞD„D10ÏBHFã,ópTÍD˜İÂĞ!‘yMÀÜá !±Ä4!!™yÀ¢Ø‘N‘Å
8Ï`mŠIIˆ`µIñH&,„d¾0ÏBhL€ @Ø{ÀóD@H’&LN”N‘u(’@4Ä· †dóÓD1iÂäD"M@#6ğ°´Ä5mÎUÅdm M
,Ä4¶à<ÒL-qM|:Eµ9
8±,Hc€2ˆÃeå˜@EÑLš09‘Ö ŒwMN‘q-ÀÜá !µ ‚4ÈÔ×d¤ÒD\Œ4ƒc•D1±@EzÀ4³QEADµ9HCXbSÍäD˜8ŒdWˆ°Ë¢Q×æP@Xa 4 ÀÒ×´9×ŠÇdéĞ ÌFÙ¦¦<À²1ƒ™LqM0Òµ"Æ1±@E˜Êt‘£5#W'²Üêµ¥(ÑDTÅd»”ôDÈDlÕHclÎ•N‘i4À0”HCl(±©$9¦SƒõTODTˆCI!9q âP‘ùDODTˆCI!9Zc,„­$ÑDÔ:
!M³e8’@4ÄI1mŠdâŒ@EÑLìD<±0ED3±ñÈFÀTÍÄNÄ3Î#=2,’-,„™
(‚ó`¬DcØŠ$1;!™_3 ÀÒ×Ä9‹ÙyÀ³ ÒDØ‘N‘Dq âP‘Ö LL€…1ED3™”„v§dÃ°BDå Oä$©#É6àLÄ5ÁH38VI“é Oä$©#Í†€<‘“¤›@1ÒÛ@1Ò$Is‘³P!l€ÓPZ¬ÄÖæ\VFI ó,„”. †4†&LN$™° Í@Dq âP‘éÄbºôDÈD°08V:E¶,€`‰ÁØ–#‘. FD'À&MÄ5ÁH38Vë<,P&ÆH ó,„ÔÁB”# {82IfğDä¤!IÄ@˜mÖÌ,
Òš09‘Õ8Oä$©#Å¬DchÑ,Ä4+¸i%McÒTD39vRLI …dàØ9!I% M«3â4Zc,„XÚP¡Ï„8dÅÓ„4†d¼„Ø¢šq<Â4±:óQ][fÀóDH3µÄ5ÕôDµİ<AÜ4Á
DC˜Á„>â4’I4KLÒ’…
 Ò°Ä`&*°<‘#’deÓÒ “ØTD39Ö!Àâ±9—@,-qMìD<,’¶ğĞÄê8ÌD5mÂ‘0ÏB˜HÓ€­Í`P9Íô"álTQ‘%H¯³PaÅÓ„4†d‘$DÑ”£POaµÎADN’D$Ù± #ÓF@…8Td{Ì€ KK\‹d„e4` BITÄ"—Ù8O„4SK\ÓDõmûŠM‡“FN€âDÓá¤‘“ÈÖ 8Ñt8iä$³mÏÄK¸=@9©#!â4-öÆR!ME4“a,±ÂDâD0Æ@	TÍVDÄ
DC˜w@4Ã"ÑÁB˜R29ÏŠÇÛR29ÏŠÇ$Û dHcÅÓ„4†dLÉä<+bÓl]JC1Üá !Yh@3×#ÍàX­ó{@óD@H’&LN[{@óD@H’&LN$›{@óD@H’&LN4›LP"Æ1™t€Ã"A!8\F HE¸I4KLÒ’=
\ÏHà!L+ÑDôE CØ¯ÀcÓI1$À’E(’‚<1fAÒAD×LÈ„imXz­ÈÙ©€•óLˆÓH&ÑPÖ)°ÄÔ×Ä"a&IàXaqJ„Çd:”DõDD…8”T:Î“F„$I`¦wN3¥Sd×$qRÌì4„dQC\S‡ KK\“×LfÈHCX!9±% a…DäÈV-°<ÒL-qM5m°Ò SK\Ó4ŠáAE,-qM,’6*€D0&™¬ÀÒ0„I4”•
0À<ñ:ÅÖ*€0 Ò˜DC™r ÒVHDÎlZÌá,<ß’Å(Àò@‰ÇdÒTD39vR	H!™Âó,€Ä ^QÂ”N‘i
01}N3qÎâDÖ,0ED3‘ØTD39&Nc(ÓADÖ Œ8\Z–^+r6·,ó˜NE¤SdVˆ°ËrRÌæP@±@4D€µP!™DCÙÔD4¥€Ñ	0ÄD¶IMD3Qº  C¼@T[ª€#Á `&ÑPÆ°=ÒL-qM|UDô‘m­Ò–Ø€ C´ĞH›sYŞ#PQÔ!ÀÒ×”N‘A9^3!v¢«©•Öb!ME4“a,±ÂDœ³8‘A81•ˆqL/!LNdiÉ,%Mc„QEDqqHL„d¥ÏD\Œ4ƒc­ˆqLÆ6Q¡-5ÀD¤ÀBLaoD!0„I(ODH1a   Ã   Q,      PXP%Vş¥Q€”ÅUdøP€ú$P   302ÂLD ŒÌ0 #3ÌD@ÀÈ302Ã`ÄÀ,A@Ãn4˜e˜`0Â˜`–` c7Ì2J@È°À
%Ã,`"0" ÑÌO
Â11@Ò° @@Ó°@B`ˆÀˆ ä3c<!( uâ ±` Á0 Ü Ã8p #ÛŒñ„@  \ ´â ±` Á0ñ ø ôÃ‚u ~ #ŞŒñ„@  \ ”â ±` Á0Ñ TÔÃ‚| ¬ #êŒñ„@  \ t
â ±` Á0±
 *p!´
Ã] º #íŒñ„@  \ Tâ ±` Á0‘ .f”Ãt è #ùŒñ„@  \ 4â ±` Á0q 9ètÃ{ ö #üŒñ„@  \ â ±` Á0Q P=ˆ ¤‚HÂq€T@ZH\Á^  ƒş ùƒ¸ @*0	nô"f" ÃJœÁ,ÃaDâ nşÂf$ “¤F¤D  ³¥„¸ÀH%©Ä°˜@`ANˆÀˆ TCc<!#$ f	Š‰aÁO€`0b&‚˜%f	’‰aAX€`0‚&‚˜%h‡Æ`M@<4Æ‚Œ¨‰` #pB6`– !œÃO Á,ƒtc<!@‹Áˆœ€„@;1Æ‚µŒè‰` #„! f	ú‰aA[€`0",‚˜%h0     &9@„4Ùã@ ØäÀ E‚AˆE	        a   u   K,      P¨PåQ€%   3P2ÃLD ”Ì0%3ÌD@@É3P2ÃLD ”Ì0 %3ÌD<@É3P2Á`DÀ` !Ã‚8À`ÀˆÁ  (A-3Æ‚g0‚	€\fĞ3Æ^¦
ÆxF@Á F<¨0 ³=c¸!¨Ğ`–AP‚ÁH`–` hØˆ b¸aĞ`–@ª‘¸  lD@Ø0! uc<!( Dg@4Ã„ 8À`@`. 
ƒp@7Ì2F@d#Ì €YƒÒ`X0" 5& °:D0ÁÁ ĞjƒAq0Æa0" €Ş Pü dc<!#‚" ˆÙÁ°@@@{0Æa0"(€ò ĞN¤(ÆxB FF Ì
Ã‚V Á`Ä(0K0Ì$D
Ã‚W Á`„)0K`8    690ÀõWÀB680LÎc’`Ò˜ãÀàP“=ˆA‰EÄd„…à,N       a   0   A,      PåP’    3p2ÃLD œÌ0 '3ÌDÀÉƒÄ2 ƒƒ2 ƒB2 ƒ2 D"ƒŒ1b€  Hƒ(„B)ƒ1b€  Iƒ8¤b†#œ` ¨ÔŒ R¢„@¢hXP`0b
€ AÒ iŒ  àÄ †    F80LÎc†FàL“ÃØà ±Åd…E„Ç     a   '  i     På?P¥P2…PHPeQ…QÅQ …)PØP€HVQ$T6@…P0”a5€­ 43”a5€­ 53”a5€­ 33”a5€­ 23”a5€­ 1 3€2ÃLD  Ì0 (3ÌD Ê3€2ÃLD  Ì0 (3ÌD Ê3€2ÃLD  Ì0 (3ÌD€2ÁLD  Ì0ÑÄÁ F0p0 ƒËÀ`„â0‘´Á œğ°# „E fĞ9ƒèF\ ¸„`0‚	€¦Ay#. ˆ
æ€Œ@01@×°€B0A@Ù°À@0A01@ØnÜ!f‚3ˆÃÁ¤Á,ƒ yc¸! …3˜eÀ Œ°æa Æ0t(C¨L3NËL+ƒŒá†@Ì`–¡0‚Á3…˜%0ÈÆpCph0Ëp Á`àÃ Ì ƒÆ`Œƒ øbP!Œø‚˜%è¨ÆpC 
f0Ë ,Á`Ä¬Â Ì,ôc¸!ø4˜e`š`0"@b f	BƒAk0hÆˆÁ ¤1°FœA0 ³ÙÁndÁf(ŒÀƒY€Yˆğ`7'³‘FèJÀ,Dp0hñÁ18 €5‚Áˆ7`– #PÃ.˜Á,Uƒ¢°0KP‘(Œá†à%Ğ`–Áº‚ÁR€‰˜%¸íÁ S# ĞÆ €C0qÁ Ìtt
c¸!3˜eÈ´`0"Æa f	4J…1ÜÜÌ2l\0±
81 ³Â QÔ
cÄà  Şt#ş €Y‚JaŒ 0A/Œ Ğ¤ƒ7?³ŸŒ  €ƒY "° @@ğ3Æa0"Ø… ˜%ø(ÁÂ Yô
cÄ I€ô ! ‡Y‚1 Y# ÄG€# ¬G÷`ÃA[„Á,ƒ„A0b0 €{T°f>ˆÀv ùÏO„Áˆ `–@f	Æ€Âa7 ‘³d`ÃnJâfÊÀ‚Y3˜%@‡Aâ0ˆ…Ã TƒÎa
ƒ ü9Œ‚„€Ğa:b‡Aê0F b‚–˜%@b‡Aî0µÃ18  EˆAF  ‘1( `Dh"$ˆÆxC;¤FjŒ @"B0Şàª¡# H0Á Ğ>’‡QNAÈ†)‚ñ{Ù10 `E! }Ôƒşa?Œƒ \„„ Ã    68PXÈ0;€LÄ5±HFØá Á8a¯GàL“ÃØ6;€4„#Ãt˜ë ±Åd„Éä<Çd…2XëÀ09Á3Mc†E,a¬E„Çd²È€ KK\      a   —   Q,      PEPFÅPdG%   3¹ ”Ì0 %3ÌD@É3P2ÃLD. %3ÌD@É3P2ÁLÄ ”Œ0ñ %F$Ò F Ñ P2#Œ` Èˆ d0b	€’1TƒK0 ´
Ä 2ñ@ÎO´Á( ‚â Œ‚ iŒ'Ş`D Qc¸!€0˜e„`0Âƒ˜%È”È ˆˆŒl@P!A#¾` f	
ƒ1ÜìBÌ2E0K Fx· ³‰Á @\à ƒc •ÁOâ`0â‚ 3ˆÁ3€Ò`Œ'u0±Á Œá†ÀÂ`–áPJƒp€PŒá! ƒY$	tÄ Ar0HÂ As . ˆ êÂ(†`f	’Y‡è \  Äc¸AÀ`–aaZq@Pêƒp@ˆ bÄ  Ğ0Š!p…Y‚†dG\ D
ƒH!\ T
â€1@ à4ŒbHb– ™%pÈB° ƒ¨ ­Â°`@0Ñ
Á Œ Ğ¹0Kğ*„ „ba7Ì2P€á@     &9 0DC‰Áˆƒ=$pmÔ49M4ÑPâD0/°P„Œ368À0DC±Ä4!!™ã PÓä4'ÅDdÉâÀÒ`‘Éä<!Çd”@EÑL5MN      a   t  ¤     P…PEP
åÉPEhP\TeQ…QÅAe50@5P0”a5€­ 33”a5€­ 23”a5€­ 1CCÅ Ø
`+äeÛ7*@CVØ
 3CVØ
ğ2   3@2ÃLD. $3ÌD É3@2ÃLD Ì0 $3ÌDä@2ÃLÄ Œ01 $#ÌD É3@2Ã`„r@ÊŒ0‚ŒÎ` #†Z€Áä€Œ1 â Œh‚ŒHnA læ`Ä 9Ã‚6Á`„ÀˆÁ  Ö,A@Ín00˜e”€Êf5LB0Ü°AÌ2H@h#. á†ÀÀ`–8Rq€7p³…F|u  ³£0KpÌ$ƒ_ À,Á(Ì(Ä6â nÔf&ŒÀú` f	ÂÆpCÀa0ËĞÌA@q##â& Šq\ €‚7ò³NĞˆ
æ #Ê  *q€ĞŒá! ƒY†
#Òà`– Œ`ƒU€Á3È‡˜%ˆˆoÄp@Tà
:ÜôCÌ2HU@n *øŒ€ƒ@ Ä 2ÜˆÌ2LT@u0.€Áˆ:`–€ŒÀƒ[€Á9(‰˜%¨ÈÆxB`ˆ d¸!¸…4˜e°ä  =´â ±€D0@ã	8P #@! q€Ó Ìu2œË„AÉ˜Ê¬Ù¸À. ˆ
ÎA‡‚›ƒY,†ê‚ÁY`– £Ş8À QA;èpCàa0Ë mİÂ° @0‘Á Ìl”cÄ€  Úf	â€ÊG\à  Dö ÃY„Á,CçÃ‚|Á`„80Kàûˆà€¨€t¸!h‹0˜eøÀ  s€#Ò!€Y0 t# ˆG?³q@ô#.p€ ¢‚’Ğá† .Â`–AÆ  y D#è!€Y‚1 ı8À QÁJèpCÀa0Ë@eP>^ƒûÀ,AÌÄ‰¸À. ˆ
fB‡‚ÑƒY†3@ƒ€BbX`!Œ‰` f	Ğ€RH\à  D9¡Ãj„Á,C¨A@(1,è	F¨D0 ³j0KCâ¸  *nb#fØ ‚‰aY„`0B&‚˜%hº!q\ œ…7¸³nğİÄ°`-@0‘Á Ì¼ÍÄ1  ÀEª‰1bP €‹¤E0K³q0K ³s@01†¸ ƒY:Øƒ€^BPLŒÁˆ@ ’‰1bP  â1KP# ğÍÄ1(  G‚º˜%°:#q€7å³w­‘¸ @†ô ƒY<Èƒ€ŞH\  ÃÁz€Á,At”ƒ®Ü®Ø€³u Á`X´Ç ÌøíÄnÜ#fø ‚Y‚>Œ‹÷ ‹1bP €™¢1b0 €Zâ£1bP €˜Á,Ìüİ‘¸ @*nê#fBÚ#q€T :ÜäGTÀ<K
å€/ €Â,C 
µÅOVƒÜB\  ¼†Æˆ€11 Œ Ğ4â Œà‹  f	Fød      –:àÔ49ÍJ, ƒ‰ ÅxÍaF:0ÀµQÓä4V:, ,068À0DC±Ä4!!Yè@²8°´Cê ÃP"pĞÄ`£P@M“Óœ1¬Ä–È`¦@EÑL5MN     a   "   G,      PECCËØ
`+äeÛ‡* 302Ã`D @ú2È_ÆˆA ä ³Áˆ èPS Á@2Â`À,1K@ÌDŒá† 	ƒY†Àè_Ì1(  „`Ä` €$ó      v80DÄ      a   "   G,      PECC	Ø
`+äeÛ‡* 302Ã`D @ú2È_ÆˆA ä ³Áˆ èPS Á@2Â`À,1K@ÌDŒá† 	ƒY†Àè_Ì1(  „`Ä` €$ó      v80DÄ      a   "   G,      PECCMØ
`+äeÛ‡* 302Ã`D @ú2È_ÆˆA ä ³Áˆ èPS Á@2Â`À,1K@ÌDŒá† 	ƒY†Àè_Ì1(  „`Ä` €$ó      v80DÄ      a   <   J,      PåQ4ÅS\åEC…Ø
`+äeÛ‡*`ÛÇ*   302Ã`Dp@ÿ2hdÆˆA é # ³Áˆ í`Ó A2BÉ&3œ2Å`ÑÀ,ÁA"3ÈdÆˆA ì #  #  Ã,ÁA%3(eÆˆA ï # ,# °Ã,ÁA(3ˆeÆˆA ò # 8# ÄÃ,Á1KpÌ ÔŒá†à
ƒY† 	¨eÅÌ1( à„`Ä` €)O!     Æ80DÄ      a   I   J,      P¥Rf…S…R.ÅRœ¥@e50@ES40”Q€­ ¶2”Q€­ ,C^¶}¬¶}²¶}³¶}¨0”a5€­ $3”a5€­ &   # ä2ƒXfŒ PB@;3F p‡`0bf‚ ™ä3cÄ €•H!à"ª™A,3F !àf	RÆpCĞ
aPÁÅ³BŒ P¯0b@  =x# H# Œ5LÊ$C¤L¡2ÆÊ# H³ÈˆÁ  Ñ,B83ˆgÆˆA "!# HƒV& # ôÃ,2™Á Ì #„ÔC6K€4F ¨‡`– @ a   J   L,      PeS.eP*…Ce# 0”a5€­ 'CCØ
`+CIØ
`+äeÛw+`ÛÇ*`Û‡+@CVØ
P2    302ÃLD ŒÌ0‘ÀÈ”2ƒNfŒ  B0b0 @BÆn(0˜e„`0¢h`–`Œ(˜˜%f	ˆ ĞA¨# ÜC0@%3,¨@0b@  ;$ Ğ!˜%(hÃ³ÆP3†,f	Šr€ƒB0f$ h7Ì2$J0b0 €51… Ì,# Tƒ“+ À,ÁBÈ       69, ,&ÑP&9`0DC‰      a   /  P,   %   P%SPŠeT„…Pd¥Pe+Pä%xP%QeSˆÅQŒ…T(…ZPåVUt%U…Wå(@eP–ô0”A`+@ÎeØ
À21”Y€­ ,3”Y€­ .3”Y€­ =3”Y€­ ?3”Y€­ b3”Y€­ eC^¶}º    3P2ÂLÄ ”Œ0 %3ÌD@É3P2ÃLD ”Ì0 %3ÌD@É3P2Ã`D‚0Ü Œ  P". RÄ B¸ @,°Ğ#. ø # ĞErMâ ±@@@•¸ @,(P&. ö ´‰ Ä‚> Áˆ’ z¡D`ô‰ Ä‚? Á`Ä mƒÄ@\  ˆ¨ÆˆÁ >1…Ğˆ ÄY Á`„@j . pƒg Á 5¤:c¼!`	V `Œ ğqÁ`D@r . Àƒs Õ¸ @, FĞA0 4ƒî`Pºƒ1b€$ nƒ õ¸ @,XĞˆ Ä‚v ‚¸ @, P)ˆ Ä‚y ã ‚ƒ ÖcAŠ€f!7b³E-„ b¸!P‹0˜eŠ€PaĞ+ˆ Äu åÂ18 `5à¢jq€7ra³P,ºq€X   Z„ƒêG\  # ğ1¤D@¿ . N#Hø“A;Ì4â ± &@@å . `”â ! ˆ7!#X`  w ˆ:l# ÔÈÃÁ,AAô . Xƒõ ÕÃ { ˆ=‰1bp À|àF!# ĞˆO?ˆ Ä‚Ÿ ùƒ¸ @,(P‰ dÄ€  ıF È‘ƒh$•„¸ @,à	PKŒƒ BÄ<
!1  @LØ‚TB\  ´ˆ%Ä bAX€€ÌH\  #  H0b` À™D@h$. J#q€7Ì2G@l$#Ü(€Y‚c0"&êc f	Š‰An$. á†!@ƒY†d	¨'Ä bÁj€€ÀB\  ¬h'ÆˆÁ ¡R¯Yˆ Ä¼ ­Å18  LJ¤‚Y…ÂbXp Œ‹` f	Áˆ±8‘˜%`h,…’¸ @†† fš' · ˆ½’q€XĞ  ¶# ÌJ!„G`i€€îB\   ¨/ÆˆÁ s‚#…Ì8DÃõ Á`„]0KÀ_ˆ „şB\  $â ±`=@@¤!. f# ìJr†     –;°4„µ9WI“m„Ãä<F;pÎUÅd¶Hà\+b“éˆQLV;`ÎÕ:İ$smÎ49Œá(amÎUÅ      a   Â   N,      PÅPŞ…‹P®EPÆ¥<P…P”
>P±	äPŠäeÛ,`Û§+`Û7, 3`2ÂLD ˜Ì01 &#ÌD@€É3`2ÃLD ˜Ì0 &3ÌD€É3`2ÃL &F( F$İ F œ ". 8XĞ`0B	€”a‚Á%€Áˆ`0"Ñ€ q€Œ7¨Ì,ˆ d¼el! `FPÁ Ğ%. ñ†—Ñ…€q€FPÁ 5H43ƒ>q€Œ7ÔŒ8# ìƒQÁpC@a0ËqÃ; Á`„ yƒÈ`Œ  ÁpÃœÁ,ƒ0tcÄ€  ‘#È €Y‚È`\  äâ o0›x#B f	zq€7ô ³…L!ÃTÉÁ°@@@s0,`Œ  G1³ÆˆÁ  0b0 €ˆ „âF\  ÃC³PêƒA}0¨Æˆ’ ¥AB³…Â P
ƒBaŒ 	Ä ­0b€$@jä.Ü‚-”ÄˆÁ ¯‘¸p¶0b@ €iÈñ¸ @†‚[ ƒY†d	ÈoÄ 2ÜüÌ2(K0Ş`
0# ¬.³¸ @ÆRa&fbÄ   ×‚Yf¼Ah‚&F pÀx!Aâ@ã®€81b` @l¾Ì4Dƒha-¢…A»0HvÆˆ saÄ0B@º0HéÂ ]# è1ÁˆÁ º!ñ ï0b0 À8`8   ¶9pÎUÅdƒI@@…8Td„Ğaš‹@EÑLZƒ0ö9 	TÍ¤5ÃNÀDXç 8×ŠÇdœFà\­óXáÀ" ÍÔE€µ9—y$smÎ49Œ ,-qM        a   b   A,   %   P…PePÌELPÊ¥ŒPÂ$PEP…PØ40”aa Ø
`+Cfğ¶ØÊP†„`+ Ée˜ÁØ
@2Cf€­ &3”a`+€Ée˜A ¶œÌP†|€­ 'CŒCj0€­ ¶2”¡c Ø
@2Cj0€­ &3”¡c Ø
p2  3@2Ã`DÀÀˆÁ .¡i—5b€ €IT5eÔˆ „q€Œ7ŒL+™1bp @8BÀP2FŒXX`(q€P%. ñ–±…€‚A,3F PC(’Æˆ± ô@A.Ğ&. âÄ 2ŞP3¿P0¨fÆˆÁ ó`GÛ10 Ø q€Ğˆ d¼ÁgĞ! `ÏŒƒ øÁ2 2#Æ˜ë0bP0€JÌŒ @~à{      68P ±     a   ï   W,      PRePEP€eW|QdTV$PEVe@e# 40”a`+ÀÈe˜ÁØ
€2Cfğ¶˜yÙö
Øö±
Øö%ĞÀP†|€­ ¶BCVØ
`2  302ÃLD ŒÌ0 #3ÌDÀÈÄ/â n:0˜e„`Ä` €eÄ€  ^h…YXfŒ7®ÀQ0Æ@
Æ`„É@!##@ (dÄ`„ …ŒŒ° ƒV  T3c¼!¸…4 `\  ”3c¼!Ø…6 `X !¸@ Fh#(•!µ„6cÄ  €˜âÆ`À`D'@c3#¸` #ÈF`Ä€ €”›1ŞƒP0F À‡€pF\  ƒ` éŒ¸ @Æ~F
Ä B?#. ñ³y‡€q€Œ7 <B›Ag#. ñµ¹‡`Äà €”`
"1  tæ`D0K0Ğßˆ ¤‚VĞá† Â`–á "q€7¬p³…Ğéˆ d¸!p…4˜%0*ÊÁ%¡˜%8*ÊA'Á˜e@¬`Ä` €R Õƒª ©¸ @*˜nT"f% ¾ÌFüM  ³
Á¸ @* n`"f& ÑÜF”N  ³•¸ @†‚š@ƒY†Æ	#PG`–À!Ô ÈpCg0Ëğ@Á`ÄêÜ„ Ì@ƒXG\  ÃC³QP-Œ€|gŒ7`!Œcö‚ÒhG\  ƒ¼ ÏoÊâ( ÏoÒb(àC.€ƒ£öÂæwèwÄ 2Ş@>oP . "q€Œ7¬]ˆ d¼¡}î" `Pûbq€Œ7¼_# ¸SÁ,D"$†‚¾ƒY†‰
F ø’1b`,€n0³Ò,AEó#FŒØ &RbÄ€ €ñX	J¡iM€`0b…‚!˜%hÆ`C@÷#.  l#1 €$$Æ`D
@)4,È	Œ  ‘ÄŒ0‰` 0      ö9pLÌÓ"aËÄ<-qMĞ(æ9 MÌ‘³P!ç@31O	4×       a   5   A,      P 3€2ÃLD  Ì0 (3ÌD Ê3€2Ã`D±À`¡À`ÄÀ`„€À`Dp ƒŠAÅ cP1F ‰‚„€”AÊ f2H# ˜DAB@Í gX `0"
€ AĞ hŒ  À1UÃ‚ƒW0 D²Yƒ¬1b€ €LÄ    	   F80LÎc†FàL“ÃØà ±Åd…E„Çd‡…à,N      a      J,   
   PT¥T…PªP–…VŒ…S«@Cd€¶¸ 3@2ÃLD Ì0 $3ÌD É3@2ÃLD Ì0 $3F× Ğ1*ÈIH ŒP‚ eT©”, @0Ñ@Î°€Á`„ AÃƒO0 Ä ƒP0 4È ƒQ0 DšUƒ¨A"3ˆÃB ³ÉŒY‚a–`¨ „ /„`Ä I€Pä(ÆxCÏüB@A¸  †qƒY"	èÂpCğa0Ë¡ÁnÚ fŒ$ 5ã0ƒcÄ€  z¨ÆxƒÌ¬C@¸ @, \  ƒE  $ƒä`PŒñ†™‡€‚Ax0ÆzÆ
Ä 2b€ €H$HøñÁnPf$1  à.Rö`XÀ
  =¼¨lÄ 2b@ ÀN# è…A³È,AB¢0(Â Q# ¬1™Â Rt
ƒLaŒ Ä       †90LÎc™FàL“Ãå@L[å@L#›å ±Åd—E„Çdƒ2     a   %   E,      P"EQÜ	XP…PÜERøåNP–…  3p2Ãˆ ÷Ğ0‹‚Œ ğ³(# ˜ÂaÄ0bp @<4Ì¢Fz0 ³c¸!Ğ`–A Æˆ ¨ÌDFÁ Ì      ö8@ Á      a   W  ¡     PeP8EPeSÈèPì…P@5PÅP€åQ¶T6@%@Cd€¶ÀÌP`€­ (C^¶}Ó¶}£¶}Ò¶}É0”a5€­ $Ck¶šÕ    302ÃLD ŒÌ0 #3ÌDÀÈ302ÃLD ŒÌ0a„Á Ğ¼ŒÁˆ! š—11@;3(gÆˆA "!# à‚×ÉÂ`Ä¾p@+#. á†€Ì`–!‚ÁÊ
€YaÄ` €^ gF0Á F@¶0 # ğƒF,h0 # ìBŒ  ÍÄ3â nÖ fˆ=F °hdÆ`D Ic¸!Ø…0˜eHŠ€ÀFF€M  $6â Œ™` ¨lÄ 212Á Ùˆ d¸!‡0˜e8Œ€ÒF\  Ã9„Á,ÃƒŸÀ,2KĞF¤Ì9À`„Ú”ƒ F¨Ì9 ­nÌ!f% ·Ã:„Á,³ƒc°0KÀÌ4Ô2c¸!ø0˜exœ€`fTp:Ü¼CÌ2<P0K°47â ©@t¸!˜‡0˜eˆ¨€|fX€
 Œ ›` lÆpC€
g0Ë MÁ`„ØàÃ ÌLôcÄ€  ’#Ü``–€"¾ H® Ã?„Á,C…t6ÃS Á`DÚ@i3†@ƒYë
#Öæ`–à"<# ´D0q´0 ³•¸ @*˜nJ"f2. ¸ØB#ä& ’›1Ü¤Ì2h[@t3,àFØM0 ³Â1   '‚ÁQø…˜%àvÄ R-èpC a0ËĞA@{3,FôM0 Ô7c¸!(‡3˜eğ¾€şfXp!Œ` f	>r…1b@ ÀXƒ­ 0K Ô
c¸!X0˜eƒ3F À"1Ş;;P. ˆá† À`–AÊ  _ÃÁN„Á,CŒA@«3†‚y@ƒY2(ƒ€ZgX 1  à,‚Y31  à,Ôa–À#t¡,`–àHÆpC`a0Ë€iŒ  ƒ½À,AP/Œá† -À`–aÔ  _ÃÁ>€Á,Ã°A0b@ @xÀÃ,ĞëŒ
@B‡·ƒY†6¨ƒ€Èa7 ³nğÁˆÁ  ï0aq1 ³t@»3ÆàG.
Â 1Ü Ì2ÀÁda¸!‹0˜e˜ƒ8H|ÆpC h0Ë sŒ €D>Ã” Áˆ ~ÌÌÁ,ÌÔ™Ï1   5ŸQKèpCğa0Ë`zúŒñ†ÿ	€‚p@77³w •DnB#fô ŠŸ1ÜäÌ2ä4?c0b}‚Œ˜Ÿ– ¢Ÿ1b@ €m³{0K0F¬Ïj ıÃŒˆŸ` èÆ`Dü0b0  JĞHŒÁ”€^hX 1  À>‚Y>  ÈpC a0ËĞ~‰ d¸!¨0˜%ğƒŠr€>ú`–á@!1 €&F `µ˜%à     ö9 =Q±ÄB1ˆÁØè 31ÏFL@‰Çd¡Bpè@31O	4×™ç€0 &:ĞLÌ£-Ï”ˆqL         /** @file menuoptions.c
	@brief
	This file contains menu routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "menuoptions.h"
#include "lbaengine.h"
#include "main.h"
#include "screens.h"
#include "resources.h"
#include "sdlengine.h"
#include "text.h"
#include "gamestate.h"
#include "music.h"
#include "keyboard.h"
#include "flamovies.h"
#include "scene.h"
#include "interface.h"
#include "menu.h"
#include "text.h"

/** Main menu continue game option key */
#define MAINMENU_CONTINUEGAME		21
/** Main menu enter players name */
#define MAINMENU_ENTERPLAYERNAME	42

int8 allowedCharIndex[] = " ABCDEFGHIJKLM.NOPQRSTUVWXYZ-abcdefghijklm?nopqrstuvwxyz!0123456789\040\b\r\0";


void newGame() {
	int32 tmpFlagDisplayText;

	stopMusic();

	tmpFlagDisplayText = cfgfile.FlagDisplayText;
	cfgfile.FlagDisplayText = 1;

	// intro screen 1 - twinsun
	loadImage(RESSHQR_INTROSCREEN1IMG, 1);

	newGameVar4 = 0;
	newGameVar5 = 1;

	initTextBank(2);
	textClipFull();
	setFontCrossColor(15);

	drawTextFullscreen(150);
	readKeys();

	if (skipIntro != 1) {
		// intro screen 1 - twinsun
		loadImage(RESSHQR_INTROSCREEN2IMG, 1);
		drawTextFullscreen(151);
		readKeys();

		if (skipIntro != 1) {
			loadImage(RESSHQR_INTROSCREEN3IMG, 1);
			drawTextFullscreen(152);
		}
	}

	newGameVar5 = 0;
	textClipSmall();
	newGameVar4 = 1;

	fadeToBlack(paletteRGBACustom);
	clearScreen();
	flip();
	
	playMidiMusic(1, 0);
	playFlaMovie(FLA_INTROD);

	clearScreen();
	flip();

	// set main palette back
	setPalette(paletteRGBA);

	cfgfile.FlagDisplayText = tmpFlagDisplayText;
}

void showCredits() {
	int32 tmpShadowMode, tmpLanguageCDIdx;
	
	canShowCredits = 1;
	tmpShadowMode = cfgfile.ShadowMode;
	tmpLanguageCDIdx = cfgfile.LanguageCDId;
	cfgfile.ShadowMode = 0;
	cfgfile.LanguageCDId = 0;
	initEngineVars(1);
	currentSceneIdx = 119;
	needChangeScene = 119;
	
	gameEngineLoop();

	canShowCredits = 0;
	cfgfile.ShadowMode = tmpShadowMode;
	cfgfile.LanguageCDId = tmpLanguageCDIdx;
	
	clearScreen();
	flip();

	playFlaMovie(FLA_THEEND);

	clearScreen();
	flip();
	setPalette(paletteRGBA);
}

void drawSelectableCharacter(int32 x, int32 y, int32 arg) {
	int8 buffer[256];
	int32 centerX, left, top, centerY, bottom, right, right2;

	buffer[0] = allowedCharIndex[y + x * 14];

	centerX = y * 45 + 25;
	left = centerX - 20;
	right = centerX + 20;
	top = x * 56 + 200 - 25;
	buffer[1] = 0;
	centerY = x * 56 + 200;
	bottom = x * 56 + 200 + 25;

	if (arg != 0) {
		drawSplittedBox(left, top, right, bottom, 91);
	} else {
		blitBox(left, top, right, bottom, (int8 *) workVideoBuffer, left, top, (int8 *)frontVideoBuffer);
		right2 = right;
		drawTransparentBox(left, top, right2, bottom, 4);
	}

	drawBox(left, top, right, bottom);
	right2 = right;

	setFontColor(15);
	drawText(centerX - getTextSize(buffer) / 2, centerY - 18, buffer);

	copyBlockPhys(left, top, right2, bottom);
}

void drawSelectableCharacters(void) {
	int8 x, y;

	for (x = 0; x < 5; x++) {
		for (y = 0; y < 14; y++) {
			drawSelectableCharacter(x, y, 0);
		}
	}
}

// 0001F18C
void drawPlayerName(int32 centerx, int32 top, int8* playerName, int32 type) {
/*
	int v4; // ebp@0
  int v6; // [sp+0h] [bp-14h]@0
  int v7; // [sp+0h] [bp-14h]@4
  int v8; // [sp+4h] [bp-10h]@0
  int v9; // [sp+4h] [bp-10h]@4

  LOWORD(v8) = a1 - buttonDrawVar1 / 2;
  if ( !a4 )
  {
    v6 = (signed __int16)(a2 + 25);
    blitRectangle(v4);
    drawBoxInsideTrans(v4);
  }
  if ( a4 == 1 )
  {
    makeFireEffect(v4);
    if ( !(rand(v6, v8) % 5) )
      *(_BYTE *)(10 * rand(v7, v9) % 320 + bufSpeak + 6400) = -1;
  }
  if ( a4 == 2 )
    Box(v4);
  DrawCadre();
  CoulFont(0xFu);
  SizeFont(a3);
  Font(v4);
  return CopyBlockPhys(v4);
	*/

	// TODO: implement the other types (don't seam to be used)
	/*if (type == 1) {
		processPlasmaEffect(top, 1);
	}
	
	drawBox(x, top, dialTextBoxRight, dialTextBoxBottom);
	drawTransparentBox(dialTextBoxLeft + 1, dialTextBoxTop + 1, dialTextBoxRight - 1, dialTextBoxBottom - 1, 3);

	setFontColor(15);
	drawText(centerX - getTextSize(playerName) / 2, top, playerName);

	copyBlockPhys(x, y, x + 320, y + 25);*/
}

int32 enterPlayerName(int32 textIdx) {
	int8 buffer[256];

	while(1) {
		copyScreen(workVideoBuffer, frontVideoBuffer);
		flip(); //frontVideoBuffer
		initTextBank(0);
		getMenuText(textIdx, buffer);
		setFontColor(15);
		drawText(320 - (getTextSize(buffer) / 2), 20, buffer);
		copyBlockPhys(0, 0, 639, 99);
		playerName[0] = enterPlayerNameVar1;
		drawPlayerName(320, 100, playerName, 1);
		drawSelectableCharacters();

		do {
			readKeys();
			do {
				readKeys();
			} while(skipIntro);
		} while(skippedKey);

		enterPlayerNameVar2 = 1;

		do {
			readKeys();
		} while(pressedKey);

		while (!skipIntro) {
			readKeys();
			// TODO
			drawPlayerName(320, 100, playerName, 1);
		}

		// FIXME: remove this lines after implementing everything
		if (skipIntro)
			break;
	}

	enterPlayerNameVar2 = 0;
	copyScreen(workVideoBuffer, frontVideoBuffer);
	flip(); // frontVideoBuffer

	return 1;
}

/** Main menu new game options */
void newGameMenu() {
	//TODO: process players name
	if(enterPlayerName(MAINMENU_ENTERPLAYERNAME))
	{
		initEngineVars(1);
		newGame();

		if (gameEngineLoop()) {
			showCredits();
		}
		
		copyScreen(frontVideoBuffer, workVideoBuffer);
		// TODO: recheck this
		do {
			readKeys();
			do {
				readKeys();
			} while(skippedKey != 0);
		} while(skipIntro != 0);
	}
}

/** Main menu continue game options */
void continueGameMenu() {
	//TODO: get list of saved games
	//if(chooseSave(MAINMENU_CONTINUEGAME))
	{
		initEngineVars(-1); // will load game
		if (gameChapter == 0 && currentSceneIdx == 0) {
			newGame();
		} else {
			newGameVar5 = 0;
			textClipSmall();
			newGameVar4 = 1;
		}

		if (gameEngineLoop()) {
			showCredits();
		}

		copyScreen(frontVideoBuffer, workVideoBuffer);
		// TODO: recheck this
		do {
			readKeys();
			do {
				readKeys();
			} while(skippedKey != 0);
		} while(skipIntro != 0);
	}
}
/** @file menuoptions.h
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef MENUOPTIONS_H
#define MENUOPTIONS_H

#include "sys.h"

int32 canShowCredits;

int8 playerName[256];
int8 enterPlayerNameVar1;
int32 enterPlayerNameVar2;

/** Main menu new game options */
void newGameMenu();

/** Main menu continue game options */
void continueGameMenu();

#endif
BCÀŞ!  Ñ  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  ›   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l À6Dˆ    I     ‚`B La‚@‚aB@   ‰      2"È	 d…“#¤„“#ã„¡LŒ„äLĞÃ’H 
¤` r p‘4E”0ùœÓˆñ!¾Á€@(
 @ @ @ d ÂD‰D Ğ" ÔH =@‘ Ğ$‘"TIä ]’ A™„~ Ğæ,iŠ(aò5ar"Ó©vŠ(aBD"‘ P' ôI …Ò2 @£ô P)tJ‰¥’#B«ä P+ÁôJ@ú ÅR p˜4E”0ùìLˆğ-€!±SD	
f—ISD	“ßaÀ Â· †ÄN%L(˜#M%Lşü¦ÒLHH$‘¦ˆ&~7çBƒÍf;Mš"J˜|­A˜aˆ¨&€"J˜!œ$M%L¾&LNÄN%LÈh5@ D@ @ @ "„@ @ Â­ƒK²é(G¼‹¤)¢„Ég¢!Ri&4$‰[¤)¢„É§AD"‘HœB5ˆÓø@ã4(ø]$M%Lşì4;E”0¡ÂçK I$a"øˆ˜P 2æ@‚# %PÒ²Jj–AIHĞ³JE‹ ŒĞ´Jª5 ĞµJ@Ùb(	@Û’(	!B D¨[%@ è[
%@ P¸J!Bã""T.…’@ˆè\ÒePF"´.ƒ’¡ö@ÀA0PÉ   °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD 
˜Ä  ByàD(œ
ä’á<°Š G   d8Œå¡<p"”¾C‚ôH  €êSB=pFŒFŠõÀ¨@(Ê§y T ”ì£=p"”N„òÀ‰P8#Æ£y T ”
äR<P*J	õÀ)¡8%Ô§„zà”Pœ
äR<P*Jò@©@(5Ü%ByàT ”
äR<P*Jò@©@(Ê'ByàT ”
äRB=pr¼NøÀ‰P8Ê'ByàD(œåS<P"”N	õÀ	È¥y T ”
äRB=p2œFŠõÀ¨@(È¥y T ”
äR<P*Jò@©@(È¥y ‘Œ$óÑ„>0¢ÔN„òÀ©b(Ê'Ë}àtÁœå¡<pJ¨N	õÀ‰P8Ê'ByàD(œå¡<p"”N„òÀ‰P8Ê'ByàD(œå¡<p"”NŠõÀH±%Ô§„zàD(œå¡<p"”N„òÀ‰P8Ê§„zàD(œå¡<p"”N˜ü@‰P8Ê'Byà¤XŒå¡<p*Jò@‰P8Ê§Œ~`D(œêSB=p"”N„òÀ‰P8Ê§†{ Ôp”îR<P*Jò@©@(È¥y T ”
äR<P*Jò@©@(È¥y T ”åsg?pöğNò@©@(È¥y T ”ås¨?P"”Î"ÿ@©@(ÈåÑ`D(œå¡<p"”N„òÀ‰P8Ê'ByàD(œå“b=0&JøÀ‡,¬  @     CW @    €!, 0    ÀE€     `Èâ
@     0d‘      ²È     Y\     †,® €     CZ @    €!‹+      ÀÅ€     `Èb@     0d¡      ²Ğ     YX €     †,² €     C\ @    €!‹.      À…€      `Èâ@     0d      ²ˆ     Yd     †,ä €     Cs @    €!‹8      À…      `È‚      0dQ      ²°     YÜ     †,¬  @     CV       €, 2   2˜$LŒ	&GÆCŒ Pb€# HT 	"*2:BJRZbjrqz‚Š’š¢ª²ºÂÊÒj	#+3;CKS[ckûq{ƒ‹“›£«³»ÃËÓ‰‘™¡©±¹ÁÉAh   Å 5Ö@š)rzì1ÄO4EF h2@• ºŒ Pf€6# Ô Ï …F h4@¥ : Pj€V# Ô × ÅF H7@¼  q€Œ# „    y     C„wHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   ×  f@øÒÙr Q,Èc(ÔADÖ Œ8\éŠ¶hªq¤DE,-qM^3E˜ı ŒS&ÑP– MÄ5ÁH38ÖæL“Ã˜”BIHc°@V3‘ÓL/2ÎFˆdQÒTD39vRH–æ°´Ä5mÎÕ:q8CXé`Dta‰¤ ØL‘ceÑ€ KK\;9ç,Nd&ÕADÖ Œ8\®ËŠ¯gÕÒVô ÑL›seÀ"Ì³«C5ƒ½UÔGTav 2D€Õ×dÔG° Óæ\ÆğXN¤¼È@8UDd•0ÏB˜HÓ€™j€$PQD4+DÈ3½ÀB†ã,ó¤!IÄ@˜•,’@4„&LN$ÙÈt‘ã52aéŠ¶hªq¤M0À<±LÆõTÍÔ×´bbÍ€ w û alÑ€ KK\Óæ\)LmË,Ä4+¸iE!ME4“a&` Bê Í$Y[4 ÀÒ×´9W
D c[À!F,„9QHSÍäDØI1%Òæ\v&°´Ä5mTQ‹d„i9HSÍäDXa¢ÏAD¼…°,–Å‡ƒ„ÖHŸS9WˆÑˆÍ@\vÀH ó,Dº 1˜p@²8À 2€ApÀÑ0„Í9O„4SK\ÿQmuÎ!ÍÔ×Ä¿@tóDH3µÄ5ñ/Ùvç<ÒL-qMüD¹E8À^c Q:ÎczÎ!ÍÔ×Ä¿@Ä[q@$Óç49’Ä9‹O³8Î£	“±ñØ–„4ÑLN„±HF´@°†ç<ÒL-qMüDºEHÀ<¡1B4Ñ"a¨–@EÑLö9ËâXÄ 	“™ÀÒ0ÄD¸,a C¼@”›Ê&PQD4SêHÈ„8ØlÎ€¥SÔÙM­·?GEÑL%1MD[ŞÔzqûsTÍTÓDD²-@ODTˆCI¬@4„8\– HÑ!9±i(’@4DHDl›Š$‘3›uÀ1D€µ9—­,3MSÅË8Óä0%QL²µ,3MSÅ4Û”ƒ4ÑLN„}`H6 	TÍô:×4Ê‡,„­E,-qM›smÎ49ŒQ,Ò!ÑÁBØkÀ"	DC´ (’!1` Â,‹8\ödNC„DäÄdNC„DäÈdNC„DäÌv0(f=Õ€H@°¬D³ÑLDdÏ‹t82I† HÑ&%!‚õHE&ÑP-qMUDd©’@EÑLš09‘ØÌNCXÊr‘£5#—…P9^3!¦àê±¬øzfHÑ!9fqH08Vl‡t ƒcÉ†qH08ÖlºÔD\Œ4ƒcmÎ49T„i4‚ó`ÛâJz`’‘8’@4ÄI1š09‘d†Š@EÑL$Ùn@$PQdÕ×$6qYÆ$ÀàXœ³,ˆ„8M‹=„Í$QL¦CI„%<ED3±Ñâpa€$Õ!Àâ±QA°¶-óˆME4“aâD0ÆĞ<€™È€˜”„&s,Ğ"a$ÑADÖ Œ8\'ºšZi{ÌH!2Dó:—%Àß’y@Bä<›3MÃ
A4F&°´Ä5±Mœ³8‘)$ÅlTQ‘=(Ï`Dta@Ç,Ä4fô0 Ò¤ÀBL±‚›faĞ€ û ±“EÉ9O„4SK\ŸN‘m’0ÏBhL€ @Xx $8Í„4ae¼@E‘I4TK\Ó4Šù$ÈD0Zc,„Å9O„4SK\ŸNQmCËâJ
,Ä4Æ!ME4“a'Å&ÙwÀb“I4TK\“É(’@4Ä· †d¶ÒD\Œ4ƒc•D1±@E˜ˆt‘ã52aÈr«×z ËâXÄÀ@$6qÙtÀ3D€Å>2MÄ°9—M,ÀÜ<ÙFP“£!IHEr@3×Ä-ÈÃ2À²˜rÀ",±BDé8‹ã<ED3‘fX“0w8ˆ@H,1MHcHöSC‡D†ö°´Ä5mÎUÅdE M
,Ä4¶PøÒÕfµ Cp‡ƒ„dĞÒ “×HC¼@$™’Ä "lÀ²hÔµ9T#&¤<À²1ƒáLqM0Òµ"Æ1±@EØÉt‘£5#W'²Üêµ©A,-qM›s­ˆqLÖ@IO„LÄæPÍ€4Ææ\é™_C‰4Ä€›tÀ5D€Å!L@°ÜD€0‘qTODTˆCI!9q âP‘uDODTˆCI!9Zc,„¹8’@4ÄI1mŠdôDÈD°HF´@°æ Îƒ±BDµ(’@4Äì4„dcÍ€ KK\ç,Nd…Œ@EÑL&%!‚ù(™ã0¬DcÆÒVK\ÓG-‹$DÑXm€3×#ÍàX%QL¦ÑDälÄTˆCEÆğHO„L{ ƒc¥SdUTDº  CXbÀs‘“F„$I`¶ÑDqM0ÒÕ:T„!8Ğ°‡cq1 “d«Ì,
Òš09‘D°ÓD¬à¦q”49Œ=EHSÍäDØI1%’õ=O„4SK\SM¿@TlÀ#@c«ã0/Õ´Å<Â4±:óQ]›ÂÓÄÀ@c¬@4„™A,-qMìD<,’fI ó,„‰4± ØÚÖ ‘ÓL/2ÎFÙv 6D€Å!L@°ÜD€0‘d6‘$DÑ”£POaÍÌ³ Ø· ¦S!„!89iDH1f`Ì€ KK\‹d„-5` BITÄ"—¹9O„4SK\ÓDõmÅ3ñn£ĞADNêHÈ„8M‹=„9PED3 C ±Ñæ’LÎ³"Æ1Åö’LÎ³"Æ1É“LÎ³"Æ1Ív¥4Ã"’%,0­³-€ Øl@3×#ÍàX­ód@P"Æ1Ùi€Ã"A!8\–c=Q!%•ó¤!IÄ@˜A(’‚<1f ÒAD×LÈ„imXz­ÈYvÀbSK\‹d„$Òä<&%!‚Ñ(b“éPaİÑLD”. FD'ÀöuN3¥Sd¬$qRÌì4„d‚QC\S‡ KK\“×LfœHCX!9±u a…DäÈæ€4„‘3Ûp ƒ4ÈÔ×´b]@EQ‡ KK\‹d„ $I°4„aeMÒTD39vR	H!Ùc€,Ï”ˆqLFÀLÄ5qò|Ô²Øu #Óç4ç,NdTÌá,<ß’•L9Zƒ0âpimXz­È™ÃD4¥€Ñ	0ÄDµELD3Qº  C¼@d[’Ä "lÀ²œ³9T#v³,ó˜NE¤Sd€Û!ÍÔ×Ä§ñ ±QEAD/ÙæõTu°´Ä5¥SdĞAD×LÈ„èjj¥%°p”49Œ9(1¥ÀBLaD%Ú2QLD
,Ä4ƒ@2 CØmÀ3×#ÍàX+b“I(ODH1   a   U   E,      D(ò(…"(V)W2)XJ” !†2€ BD(2”Áyä1”áyä1”ÁyäAL[çq€­S9ÀÖ¹`ë°uØ:‘    3"ÃˆÁ  -c0B`0‚±`Ä ( Z¨šÁ‘ƒŒ˜k F ˜…iÄ`  bÄ€ €X¨F €iÄ`  „dD\@á† ƒY†€FŠ¸
1  `¦ƒ ªqA†‚-f„!1(
@ªiÄ€  [ f	†Yb0"Gğ` F H#t„€ f!1  1 €1(  8<1  à ƒ šƒ ˜ \á!dFLÁ `8      F) MÌó-€Ñ!Ò³ XK\       a   ;   A,      D(r(˜2 ÄPÆäAˆÈPÆäAŒE†2 … ‚<†2˜ƒ ‚<ˆiëT°u.ĞÜ   3"ÃLB€È0Q"Í P2#†` (ƒC0 ƒËÀ`„²0b@ À<ƒ&âÀ`D‰80b0 @1"l0 TŒÁˆ& *Æ`DÀˆÁ  ÊˆÁ  Éˆ ¥ÀŒ  Œ Œ @
†     Æ( MÌSAÁuâpÙ¢@31{ ƒc™Î@        a   „   D,      (Û "”@É\AJq”V!”G	 3A"ÃLBÈ0$2ÌDP‰3A"ÃLBÈ0$2ÌD ‰3A"ÃLBÈ0$2F,Ú F(Ù F$Ø 2ˆL"°! ÁxƒèA@Aopø€#! (`"°ÀÁ`D EÃ‚.ƒR0 4>F@Á P6,X0 °ÀB0q0Ş ¡F« äĞ@ #´` (†k Ö ¸#º` hÆpCa0Ë‰Á 1ƒÄ`Œ pÄ w0K02ƒAd0ÈÉÉ 5´ƒèdŒ, àÈaÄ ¤c0B‚ 7ôƒØ`ĞŒ ä„€f	šƒAs0(ÍÁ18  ˆAhÆ`Ä0b@ @=€åÁoØƒtH‡ ê!¨@Èˆ ´ÃRÁxC(¼Ã;Œ À„(…A}0ÆˆÁ ş@B€á@   –)`DˆqL¶U
“óØ¥€8Óä0(\(`&(0 ‘a’F@Ù¤À!ÍDD±Y
ÑLD$¥ ±Åd˜E„Ç       a   &   I,      ("”@)   3"ÁLDD„H0!A Ì$„2Üh0Ë  Á`q0K0. ÈpC€ Á,a„„BI¸€ # øÁ°Á,AAK¨ ‚Áˆ&€Y‚a–à 'T0Á`À,A€á@     F(\V(`        a      A,      D( 3A"ÃLBÈ0!$2ÌD ‰ƒD2 ƒ2 ƒÂ1 ƒ1      6(@LØCX À09
ÑLDt™ €ò, FD'À     a   \   Q,   
   D(,(ä€ò(‚B)ÿ„2 xÓÖy`ë\ ÈPõäA 3"ÃLE„H0!<0KĞˆ‘1bP ÀÁˆÁ  Æˆ ®ĞDŒñÂÜ`Ä   :‚ øào(ŞàF Øƒ ˆŒ
B0ŞÌÁŒ  
‚Œ àt@D*#š  F èƒËj°ƒ ü`–@1 à™%F xf	ª1ÜÜAÌ2E0K`ĞŠˆá† Â`–A8‚Áá`– 1 `š%HhEÄpC°a0Ë€(Á,ÁB;"†‚>ƒ
0e`š`Ä`  lÄà  S ƒÏ
ƒY‚…|D7 ³ÎÌ@³Á`ÄŒ€Â Â‘1bP  *ÁˆÁ  [–A8    (pLÄ5‰ÃeF@       a   %   K,      D(ª ¦­ó8€æ¶Øè  # œ1Ü„AÌ2J0b@ €# ˜ÂˆÁ  ÃpC0a0Ë ÁˆÁ  y0K0Ğ~ê1bP  Á,1b0  2KPŒ €Ì¤â‚7h³ÅÌ ”"â‚7k³DÌ(a   .   M,      D¨ ¦­ó8ÀÖ‰@s[lt  # ÔAAò!. ÈpC0`0ËıÇnÊ f„!1 @f	ˆÁˆ1ƒ1 àŒ@‘d f	ˆƒ Œá†àÂ`–¡0‚ƒ ú`–À ÿ"cÄ   8‚Y‚cÄ`  f– 1 €™%HÈ?ÄnØ f%˜%X¨EÄnŞ f&@     /** @file movements.c
	@brief
	This file contains 3d actor movement rendering routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <math.h>

#include "movements.h"
#include "actor.h"
#include "lbaengine.h"
#include "renderer.h"
#include "grid.h"
#include "scene.h"
#include "keyboard.h"
#include "animations.h"
#include "collision.h"
#include "gamestate.h"

/** Get shadow position
	@param X Shadow X coordinate
	@param Y Shadow Y coordinate
	@param Z Shadow Z coordinate */
void getShadowPosition(int32 X, int32 Y, int32 Z) {
	int32 tempX;
	int32 tempY;
	int32 tempZ;
	uint8* ptr;

	tempX = (X + 0x100) >> 9;
	tempY = Y >> 8;
	tempZ = (Z + 0x100) >> 9;

	ptr = blockBuffer + tempY * 2 + tempX * 25 * 2 + (tempZ << 6) * 25 * 2;

	while (tempY) { // search down until either ground is found or lower border of the cube is reached
		if (*(int16*)ptr) // found the ground
			break;

		tempY--;
		ptr -= 2;
	}

	shadowCollisionType = 0;

	collisionX = tempX;
	collisionY = tempY;
	collisionZ = tempZ;

	processActorX = X;
	processActorY = (tempY + 1) << 8;
	processActorZ = Z;

	if (*ptr) { //*((uint8 *)(blockPtr))
        uint8 *blockPtr;
        uint8 brickShape;
        
        blockPtr = getBlockLibrary(*(ptr) - 1) + 3 + *(ptr + 1) * 4;
        brickShape = *((uint8 *)(blockPtr));
        
		shadowCollisionType = brickShape;
		reajustActorPosition(shadowCollisionType);
	}

	shadowX = processActorX;
	shadowY = processActorY;
	shadowZ = processActorZ;
}

/** Set actor safe angle
	@param startAngle start angle
	@param endAngle end angle
	@param stepAngle number of steps
	@param movePtr Pointer to process movements */
void setActorAngleSafe(int16 startAngle, int16 endAngle, int16 stepAngle, ActorMoveStruct * movePtr) {
	movePtr->from = startAngle & 0x3FF;
	movePtr->to = endAngle & 0x3FF;
	movePtr->numOfStep = stepAngle & 0x3FF;
	movePtr->timeOfChange = lbaTime;
}

/** Clear actors safe angle
	@param actorPtr actor pointer */
void clearRealAngle(ActorStruct * actorPtr) {
	setActorAngleSafe(actorPtr->angle, actorPtr->angle, 0, &actorPtr->move);
}

/** Set actor safe angle
	@param startAngle start angle
	@param endAngle end angle
	@param stepAngle number of steps
	@param movePtr Pointer to process movements */
void setActorAngle(int16 startAngle, int16 endAngle, int16 stepAngle, ActorMoveStruct * movePtr) {
	movePtr->from = startAngle;
	movePtr->to = endAngle;
	movePtr->numOfStep = stepAngle;
	movePtr->timeOfChange = lbaTime;
}

/** Get actor angle
	@param x1 Actor 1 X
	@param z1 Actor 1 Z
	@param x2 Actor 2 X
	@param z2 Actor 2 Z */
#define PI 3.14159265
int32 getAngleAndSetTargetActorDistance(int32 x1, int32 z1, int32 x2, int32 z2) {
    /*
	//Pythagoras
    targetActorDistance = (int32)sqrt((int64)(((z2 - z1)*(z2 - z1) + (x2 - x1)*(x2 - x1))));

	if (targetActorDistance == 0)
        return 0;

    //given two points, we calculate its arc-tangent in radians
    //Then we convert from radians (360 degrees == 2*PI) to a 10bit value (360 degrees == 1024) and invert the rotation direction
    //Then we add an offset of 90 degrees (256) and limit it to the 10bit value range.
    return (256 + ((int32)floor((-1024 * atan2((int64)(z2-z1), (int32)(x2-x1))) / (2*PI)))) % 1024;
	*/

	int32 newX, newZ, difX, difZ, tmpX, tmpZ, tmpEx, flag, destAngle, startAngle, finalAngle;

	difZ = tmpZ = z2 - z1;
	newZ = tmpZ * tmpZ;

	difX = tmpX = x2 - x1;
	newX = tmpX * tmpX;

	// Exchange X and Z
	if (newX < newZ) {
		tmpEx = difX;
		difX = difZ;
		difZ = tmpEx;

		flag = 1;
	} else {
		flag = 0;
	}

	targetActorDistance = (int32)sqrt((int64)(newX + newZ));

	if (!targetActorDistance) {
		return 0;
	}

	destAngle = (difZ << 14) / targetActorDistance;

	startAngle = 0;
//	stopAngle  = 0x100;

	while (shadeAngleTab3[startAngle] > destAngle) {
		startAngle++;
	}

	if (shadeAngleTab3[startAngle] != destAngle) {
		if ((shadeAngleTab3[startAngle - 1] + shadeAngleTab3[startAngle]) / 2 <= destAngle) {
			startAngle--;
		}
	}

	finalAngle = 128 + startAngle;

	if (difX <= 0) {
		finalAngle = -finalAngle;
	}

	if (flag & 1) {
		finalAngle = -finalAngle + 0x100;
	}

	return finalAngle & 0x3FF;
}

/** Get actor real angle
	@param movePtr Pointer to process movements */
int32 getRealAngle(ActorMoveStruct * movePtr) {
	int32 timePassed;
	int32 remainingAngle;

	if (movePtr->numOfStep) {
		timePassed = lbaTime - movePtr->timeOfChange;

		if (timePassed >= movePtr->numOfStep) {	// rotation is finished
			movePtr->numOfStep = 0;
			return movePtr->to;
		}

		remainingAngle = movePtr->to - movePtr->from;

		if (remainingAngle < -0x200) {
			remainingAngle += 0x400;
		} else if (remainingAngle > 0x200) {
			remainingAngle -= 0x400;
		}

		remainingAngle *= timePassed;
		remainingAngle /= movePtr->numOfStep;
		remainingAngle += movePtr->from;

		return (remainingAngle);
	}

	return movePtr->to;
}

/** Get actor step
	@param movePtr Pointer to process movements */
int32 getRealValue(ActorMoveStruct * movePtr) {
	int32 tempStep;

	if (!movePtr->numOfStep)
		return movePtr->to;

	if (!(lbaTime - movePtr->timeOfChange < movePtr->numOfStep)) {
		movePtr->numOfStep = 0;
		return movePtr->to;
	}

	tempStep = movePtr->to - movePtr->from;
	tempStep *= lbaTime - movePtr->timeOfChange;
	tempStep /= movePtr->numOfStep;

	return tempStep + movePtr->from;
}

/** Rotate actor with a given angle
	@param X Actor current X coordinate
	@param Z Actor current Z coordinate
	@param angle Actor angle to rotate */
void rotateActor(int32 X, int32 Z, int32 angle) {
    double radians = 2*PI*angle/0x400;
    destX = (int32)(X*cos(radians) + Z*sin(radians));
    destZ = (int32)(-X*sin(radians) + Z*cos(radians));
}

/** Get distance value in 2D
	@param x1 Actor 1 X coordinate
	@param z1 Actor 1 Z coordinate
	@param x2 Actor 2 X coordinate
	@param z2 Actor 2 Z coordinate */
int32 getDistance2D(int32 x1, int32 z1, int32 x2, int32 z2) {
	return (int32)sqrt((int64)((x2-x1)*(x2-x1) + (z2-z1)*(z2-z1)));
}

/** Get distance value in 3D
	@param x1 Actor 1 X coordinate
	@param y1 Actor 1 Y coordinate
	@param z1 Actor 1 Z coordinate
	@param x2 Actor 2 X coordinate
	@param y2 Actor 2 Y coordinate
	@param z2 Actor 2 Z coordinate */
int32 getDistance3D(int32 x1, int32 y1, int32 z1, int32 x2, int32 y2, int32 z2) {
	return (int32)sqrt((int64)((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1)));
}

/** Move actor around the scene
	@param angleFrom Current actor angle
	@param angleTo Angle to rotate
	@param speed Rotate speed
	@param movePtr Pointer to process movements */
void moveActor(int32 angleFrom, int32 angleTo, int32 speed, ActorMoveStruct *movePtr) { // ManualRealAngle
	int32 numOfStepInt;
	int16 numOfStep;
	int16 from;
	int16 to;

	from = angleFrom & 0x3FF;
	to   = angleTo & 0x3FF;

	movePtr->from = from;
	movePtr->to   = to;

	numOfStep = (from - to) << 6;

	if (numOfStep < 0) {
		numOfStepInt = -numOfStep;
	} else {
		numOfStepInt = numOfStep;
	}

	numOfStepInt >>= 6;

	numOfStepInt *= speed;
	numOfStepInt >>= 8;

	movePtr->numOfStep = (int16)numOfStepInt;
	movePtr->timeOfChange = lbaTime;
}

void processActorMovements(int32 actorIdx) {
	ActorStruct *actor = &sceneActors[actorIdx];

	if (actor->entity == -1)
		return;

	if (actor->dynamicFlags.bIsFalling) {
		int16 tempAngle = 0;

		if (actor->controlMode != 1)
			return;

		if (key & 4)
			tempAngle = 0x100;

		if (key & 8)
			tempAngle = -0x100;

		moveActor(actor->angle, actor->angle + tempAngle, actor->speed, &actor->move);

		heroPressedKey = key;
	} else {
		int16 tempAngle;

		if (!actor->staticFlags.bIsSpriteActor) {
			if (actor->controlMode != kManual) {
				actor->angle = getRealAngle(&actor->move);
			}
		}

		switch (actor->controlMode) {
		case kNoMove:
			break;
		case kManual:
			if (!actorIdx) { // take this out when we want to give manual movements to other characters than Hero
				heroAction = 0;

				// If press W for action
				if (skipIntro == 0x11) {
					heroAction = 1;
				}

				// Process hero actions
				switch (heroBehaviour) {
				case kNormal:
					if (loopPressedKey & 1) {
						heroAction = 1;
					}
					break;
				case kAthletic:
					if (loopPressedKey & 1) {
						initAnim(kJump, 1, 0, actorIdx);
					}
					break;
				case kAggressive:
					if (loopPressedKey & 1) {
						if (autoAgressive) {
							heroMoved = 1;
							actor->angle = getRealAngle(&actor->move);
							if (!(previousLoopPressedKey & 1) || !actor->anim) {
								int32 aggresiveMode = Rnd(3);

								switch (aggresiveMode) {
								case 0:
									initAnim(kKick, 1, 0, actorIdx);
									break;
								case 1:
									initAnim(kRightPunch, 1, 0, actorIdx);
									break;
								case 2:
									initAnim(kLeftPunch, 1, 0, actorIdx);
									break;
								}
							}
						} else {
							if (key & 8) {
								initAnim(kRightPunch, 1, 0, actorIdx);
							}

							if (key & 4) {
								initAnim(kLeftPunch, 1, 0, actorIdx);
							}

							if (key & 1) {
								initAnim(kKick, 1, 0, actorIdx);
							}
						}
					}
					break;
				case kDiscrete:
					if (loopPressedKey & 1) {
						initAnim(kHide, 0, 255, actorIdx);
					}
					break;
				}
			}

			if ((loopPressedKey & 8) && !gameFlags[GAMEFLAG_INVENTORY_DISABLED]) {
				if (usingSabre == 0) { // Use Magic Ball
					if (gameFlags[GAMEFLAG_HAS_MAGICBALL]) {
						if (magicBallIdx == -1) {
							initAnim(kThrowBall, 1, 0, actorIdx);
						}

						heroMoved = 1;
						actor->angle = getRealAngle(&actor->move);
					}
				} else {
					if (gameFlags[GAMEFLAG_HAS_SABRE]) {
						if (actor->body != GAMEFLAG_HAS_SABRE) {
							initModelActor(GAMEFLAG_HAS_SABRE, actorIdx);
						}

						initAnim(kSabreAttack, 1, 0, actorIdx);

						heroMoved = 1;
						actor->angle = getRealAngle(&actor->move);
					}
				}
			}

			if (!loopPressedKey || heroAction) {

				if (key & 3) {  // if continue walking
					heroMoved = 0; // don't break animation
				}

				if (key != heroPressedKey || loopPressedKey != heroPressedKey2) {
					if (heroMoved) {
						initAnim(kStanding, 0, 255, actorIdx);
					}
				}

				heroMoved = 0;

				if (key & 1) { // walk forward
					if (!currentActorInZone) {
						initAnim(kForward, 0, 255, actorIdx);
					}
					heroMoved = 1;
				}

				if (key & 2 && !(key & 1)) { // walk backward
					initAnim(kBackward, 0, 255, actorIdx);
					heroMoved = 1;
				}

				if (key & 4) { // turn left
					heroMoved = 1;
					if (actor->anim == 0) {
						initAnim(kTurnLeft, 0, 255, actorIdx);
					} else {
						if (!actor->dynamicFlags.bIsRotationByAnim) {
							actor->angle = getRealAngle(&actor->move);
						}
					}
				}

				if (key & 8) { // turn right
					heroMoved = 1;
					if (actor->anim == 0) {
						initAnim(kTurnRight, 0, 255, actorIdx);
					} else {
						if (!actor->dynamicFlags.bIsRotationByAnim) {
							actor->angle = getRealAngle(&actor->move);
						}
					}
				}
			}

			tempAngle = 0;

			if (key & 4) {
				tempAngle = 0x100;
			}

			if (key & 8) {
				tempAngle = -0x100;
			}

			moveActor(actor->angle, actor->angle + tempAngle, actor->speed, &actor->move);

			heroPressedKey  = key;
			heroPressedKey2 = loopPressedKey;
			
			break;
		case kFollow: {
			int32 newAngle = getAngleAndSetTargetActorDistance(actor->X, actor->Z, sceneActors[actor->followedActor].X, sceneActors[actor->followedActor].Z);
			if (actor->staticFlags.bIsSpriteActor) {
				actor->angle = newAngle;
			} else {
				moveActor(actor->angle, newAngle, actor->speed, &actor->move);
			}
		}
			break;
		case kTrack:
			if (actor->positionInMoveScript == -1) {
				actor->positionInMoveScript = 0;
			}
			break;
		case kFollow2:		// unused
		case kTrackAttack: // unused
			break;
		case kSameXZ:
			actor->X = sceneActors[actor->followedActor].X;
			actor->Z = sceneActors[actor->followedActor].Z;
			break;
		case kRandom: {
			if (!actor->dynamicFlags.bIsRotationByAnim) {
				if (actor->brickShape & 0x80) {
					moveActor(actor->angle, (((rand() & 0x100) + (actor->angle - 0x100)) & 0x3FF ), actor->speed, &actor->move);                     
					actor->info0 = Rnd(300) + lbaTime + 300;
					initAnim(0, 0, 255, actorIdx);
				}

				if (!actor->move.numOfStep) {
					initAnim(1, 0, 255, actorIdx);
					if(lbaTime > actor->info0) {
						moveActor(actor->angle, (((rand() & 0x100) + (actor->angle - 0x100)) & 0x3FF), actor->speed, &actor->move);
                        actor->info0 = Rnd(300) + lbaTime + 300;
                    }
				}
			}
		}
			break;
		default:
			printf("Unknown Control mode %d\n", actor->controlMode);
			break;
		}
	}
}
/** @file movements.h
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef MOVEMENTS_H
#define MOVEMENTS_H

#include "sys.h"
#include "actor.h"

/** Control mode types */
enum ControlMode {
	kNoMove			= 0,
	kManual			= 1,
	kFollow			= 2,
	kTrack			= 3,
	kFollow2		= 4,
	kTrackAttack	= 5,
	kSameXZ			= 6,
	kRandom			= 7
};

/** Hero moved */
int16 heroMoved; // twinsenMove
/** Hero Action */
int16 heroAction; // action

/** Process actor X coordinate */
int16 processActorX;
/** Process actor Y coordinate */
int16 processActorY;
/** Process actor Z coordinate */
int16 processActorZ;

ActorStruct *processActorPtr; // processActorVar1

/** Previous process actor X coordinate */
int16 previousActorX; // processActorVar2
/** Previous process actor Y coordinate */
int16 previousActorY; // processActorVar3
/** Previous process actor Z coordinate */
int16 previousActorZ; // processActorVar4

int32 targetActorDistance; // DoTrackVar1


/** Get shadow position
	@param X Shadow X coordinate
	@param Y Shadow Y coordinate
	@param Z Shadow Z coordinate */
void getShadowPosition(int32 X, int32 Y, int32 Z);

/** Set actor safe angle
	@param startAngle start angle
	@param endAngle end angle
	@param stepAngle number of steps
	@param movePtr time pointer to update */
void setActorAngleSafe(int16 startAngle, int16 endAngle, int16 stepAngle, ActorMoveStruct * movePtr);

/** Clear actors safe angle
	@param actorPtr actor pointer */
void clearRealAngle(ActorStruct * actorPtr);

/** Set actor safe angle
	@param startAngle start angle
	@param endAngle end angle
	@param stepAngle number of steps
	@param movePtr time pointer to update */
void setActorAngle(int16 startAngle, int16 endAngle, int16 stepAngle, ActorMoveStruct * movePtr);

/** Get actor angle
	@param x1 Actor 1 X
	@param z1 Actor 1 Z
	@param x2 Actor 2 X
	@param z2 Actor 2 Z */
int32 getAngleAndSetTargetActorDistance(int32 x1, int32 z1, int32 x2, int32 z2);

/** Get actor real angle
	@param movePtr time pointer to process */
int32 getRealAngle(ActorMoveStruct * movePtr);

/** Get actor step
	@param movePtr time pointer to process */
int32 getRealValue(ActorMoveStruct * movePtr);

/** Rotate actor with a given angle
	@param X Actor current X coordinate
	@param Z Actor current Z coordinate
	@param angle Actor angle to rotate */
void rotateActor(int32 X, int32 Z, int32 angle);

/** Get distance value in 2D
	@param x1 Actor 1 X coordinate
	@param z1 Actor 1 Z coordinate
	@param x2 Actor 2 X coordinate
	@param z2 Actor 2 Z coordinate */
int32 getDistance2D(int32 x1, int32 z1, int32 x2, int32 z2);

/** Get distance value in 3D
	@param x1 Actor 1 X coordinate
	@param y1 Actor 1 Y coordinate
	@param z1 Actor 1 Z coordinate
	@param x2 Actor 2 X coordinate
	@param y2 Actor 2 Y coordinate
	@param z2 Actor 2 Z coordinate */
int32 getDistance3D(int32 x1, int32 y1, int32 z1, int32 x2, int32 y2, int32 z2);

/** Move actor around the scene
	@param angleFrom Current actor angle
	@param angleTo Angle to rotate
	@param speed Rotate speed
	@param movePtr Pointer to process movements */
void moveActor(int32 angleFrom, int32 angleTo, int32 speed, ActorMoveStruct *movePtr);

void processActorMovements(int32 actorIdx);

#endif
BCÀŞ!    ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  ì   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l † À6„ `ˆb °µaüÿÿÿÿ H E°C9ÌÃ<´<ÈC9ŒC:ÌC9´9ÀC;„9 æì0å îğm`òíPm ïî@å mPìí Ğƒ<ÔC9 ƒ;¼C˜ƒ<„C;”CÀÃ;¤ƒ;ĞC9ÈC”;¤C;´;¼ƒ;´;”C8˜@¸Ã;´A:¸ƒ9ÌC˜<´A;„= `áÀóP áïĞîî0m`ğĞíô€€9„;ÌC9 Ä<ĞC8ŒÃ:´<ÈÃ;ĞC9Œ=¼ƒ<´8Ôƒ9˜C9ÈCÌC:èC9 x õàóæPm`ğĞíô€€9„;ÌC9 D=ÌC9´Á<¼ƒ9ĞC˜;¼C8Ğ`áÀóPÀâ 1Ø` ÿÿÿÿ? @  I  	   ‚`B L ¢&Æ„8„	!L¢˜ â˜   ‰      2"È	 d…“#¤„“#ã„¡LŒ„äLÃB 
Ì€æ *! ‡ISD	“ÏNÀ„ß;E”0¡ q™4E”0ùÖ "|`HìQÂ„Ä9ÒQÂäÏoê Í„„BáiŠ(aòçws.4,‹³¤)¢„É×„É‰L§"Ø)¢„	…Bapš4E”0ùZƒ0-ÂQL ;E”0!!08Iš"J˜|M˜œˆ"J˜$ƒÁ`0ƒÁ`0ƒÁ`0ƒÁ`0Á`0ƒÁ`0FÃ‘d‚$  €$™ J"È’ÈÂ$A4ô NB?ÈC(Pè"iŠ(aòYhˆÔAš	…BáiŠ(aòÆiQ(
§Pâ4>Ğ8
HISD	“?;ÁN%L¨
¥B’™è”È#J%€V‰M Vbèu–4E”0ùŞ5E@‰H;E”0¡¨P(
…B£P(
ƒB¡21’%€hi  [z —
Ò¥Dx# …ğú!0 `|–ÂW(@T,‚CÇRƒÁ€’C EX.‰Y„ˆœåƒÁ`@ĞRøƒˆ¤¥
€QK0 k|ƒa«0v `
`  Ğ -IA	    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD 
Lg`40J'¡4pJ§4PH¥4PJ'¡4pJ'¡4pJçá4pJ'¡4pFR§4PJ§4PH¥4PJ§4PH%¡4pNT£4PH%¡4pHİ¡TÁj$  ÀkàÌ´Ni 4Ji ˜Nià˜Nià˜Ni 4Ji 4Ji Ü¸JBià4Ji 4Ji 4Ji ì¼Ni 4Ji $”Ni 4Jià˜NiàüÀNjà$”NBià$”Ni $”NBià4Ji 4Ji 4Ji $”NBià$”NBià4JBiàÅÊÃià$”NBià$”NBià$”NBià4Ji $”NBià$”Nià˜NBià$”NBià$”Îk Ü¸Êk 4Ji 4Ji 4Ji 4Ji 4Ji 4Ji 4Ji 4JBiàì¼Ni 4Ji 4JBiàDÉJBiàTÍJi 4Jm`4Ji 4JWmà„ÙNi 4Ji 4Ji 4Jià˜Nià˜NiàœİNBià$”NBià$”Ni 4Ji 4Ji 4Ji 4Ji 4Ên`¼åÆœn`ÜíNBiàìñJBiàCP       €!‹(      À…€     `Èb
      0dA      ²˜      YT €     †,­      C–W       €!Ë+      À      `ÈÒ
@     0di      ²¨      Yb €     †,³  @     CR       €!K- P    Àå€     `È’@     0dÙ      È     2˜ LŒ	&GÆCŒ Pa€#  Ã 5F 2@’ ¢(Vu¯İï»4|»éò7Ô~“Ë YA– ÂŒ f€8# ä Ğ F (5@« j Ğk€d# D Û áF H7@¼  y     C^HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   ]  & Î² â4±(‚³,ˆ„8lŠà,"!N3ÛáKSd.ÔADÖ Œ8\éŠ¶hªq¤)$@ƒ0-,„m(”„4a@S9Íô"álTQQ€HVğ ME4“a'Å€€d‰¤ ØL‘cJÎ9IêH2+DÑKu‘£5#—‚«Ç²âë™Ú"Ì³«C5ƒu9”DpÄ² FÈ`>åDÊ‹„³QEAD¶æH ó,„‰4± ˜ùIED3±B„<Ó,a¾Ò “Ö ŒA,’@4„&LN$™…³8Î“F„$I`–2DäxÍ„LXº¢-šjiiŒ0ÏB¬ÄC “ÁD1iÂäDZc,„½P$”4iÂäD©#!â4F@!ME4“a&` Bê Í$Yl€#,­°h±&@!ME4“a'Å”PH›sR…H®„4N9	!LˆÓŞs‘#oDáDÄ,‹±0Âá ¡5’EDÖÆH ó,Dº 1Øo Í` K°8‚²QEAD6å<Î‚­D3Q‹=„IÀ<¡1B4Ñ"aEÍâ8&LNÄNÄc}–@EÑLö9ËâXÄ 	“™kÀcÓ¶8‚R"AD˜ÁlED3¥„LˆÓˆÍæX:E-óDD…8”¤	“Å–ã<Q!%iÂäD²é8ODTˆCIš09ÑlaĞâP+!—½)’@4DHDNlpŠ$‘#[ƒ#À@h±-Ü§HÑ!9³Å,3MSÅ›Ì8Óä0%QL²Í,3MSÅ4›i€ƒ4ÑLN„}`H6°HÑmŠdš@EÑL–F@H1hÂäDâpÈ"=2-,„é41uˆ4@Øq0` Â,‹8\¶u CD€l\‡ 0DÌV—dNC„DäÄf—dNC„DäÈ¦u CD@lƒB`v—dNC„DäÌVÀÄ´À¢5ÆB˜l@#“&LN¤5ÆB˜Q5 ,+DÑ¬„@4Ù•Ò0DÄæ!	TÍ¤	“‰Íì4„¹)’@4„IIˆ`XJCXÀ [–Ò0DÌÆP=‘#’´:0!N³aZƒ0f•<+ÑDôÖö²DähÂˆÃe'ÔAD×LÈ„i ¸z,+¾í%’@4DHD!Ò[Â!ÀàX²)Ò5›m cÓJ Ë,a»AL"M@#wgz$qRŒ&LN$Ù„r‘£	â4– TÍD˜LÒÅ9Ë‚HˆÓ´ØCO²Åd:”DØ#PQD4+!—E‹ã<bSÍäD˜8Œ-K ´C˜Jt‘£5#×‰®¦VÕÒPZ¼D4—i$Àß’-9Oä$©#Í¬Dc$9ÏæL“Ã°BDy9±,Hc€2ˆÃe•Ğ ÌFÕf° ÂlTQ‘mh0ÏBhL€ @Xp€ñDH3 !ME4“a'Å&™a€"	DC|`H&€	TÍ¤	“iÂx×éŠt‘ã52aÈr«×zÆ° CpğLDd@MfD„$!aCÎâ8GEÑL$ÙjÀd Á"KLÒ’M,
}ÀéÃ4‘ALš09Q‡HĞ„İ<Oä„$iÂäDéYjÀb Á"’aDOä„$qÎ² â4±eDOä„$qÎ² â4²iDOä„$qÎ² â4³	8’@4ÄI1mŠdˆ°Ë¢Q×æP@˜C1ÒFr‘c:1XnÀ !=!M³QÒ!±9T3 ±9W:EÖ2DähÂˆÃÕ‰,·z­gRÅ@H“l"ÕâPRHDÎF@…8Td#ÑâPRHDÖa½Õ9!Iš09‘éTC4“dŒ@EÑLìD<±A0ED3±ñÈÀTÍÄNÄ3[È#=2,’-,„(’@4Äì4„d”ÏHI`_0D:Ev¤dÃ°BD1!Oä$©#ÅÖ„<‘“¤$›òDN’:ÒlÍADÎF@…8TdbôDÈD°08V:E†àH@E¤€Ñ	0„u<9iDH1fÛ3‹‚4†&LNdIÎ9IêH1+DÑØmÀ90š09‘m@@I„&LNÔ`F@HP4Yc öD@HR	HÓêLÀ„8Öa£ÒTD39vRLI …d„p A¬Ã¼@TÓVğĞÄê8ÌDum_OCw A°ÑÆI ó,„‰4± ØÚö‘ÓL/2ÎFp€ƒ4Èd:±hÂäDIBDMé8
õ´@°&áDä¤!IÄ@˜}4` BITÄ"—=)N4N9IlPŠM‡“FN"[”âDÓá¤‘“Ìv×%"M–Dä¤„LˆÓ´ØC%PQD40Z+a‹Ğ ‹dDa4Éä<+bSl5Éä<+b“l6Éä<+bÓlªJC1Üá !YAóD@H’&LN›AóD@H’&LN$ÛAóD@H’&LN4Ûl@Ä¤5ÆBhÍÀSD1iÂäD"M@#f–Ä”ˆqL–a=Q!%•ó¤!IÄ@˜ñ9! )ÒÒˆÃe&ÒAD×LÈ„imXz­ÈÙa€")ÈóI`ÖÄÄÀàX©#!â4Ö£DˆqL¦CI„4’@4ÄI1³Ó’É!a…DäÄ6‡4„‘#ÒVHDÎl¡ÒTD39vR	H!Y™,Ï”ˆqLvÀÎâ0Àó-€!nÀ 8’­L9Zƒ0âpimXz­È™Ğ²8Îc:‘N‘uH` Â,ËI1›C5a¼	ãT„&LNd%ĞAD×LÈ„èjj¥UEMÄÅ9N4 0’í …L À† <!IÄ@ a   €   H,      4("(@‚’(ˆ’)†¨‚2( 3ÄğÃL1üÆ0A¿1ÌDÃo3ÄğÃL1üÆ0!¿1ÌDÃo3ÁğÁ`DrÀ`bÀ`ÄQ %Ã‚	L9‘@Ë¨€ÊÁ% b†*Àr0‚	€öc3,èD00$8X"O ¢FßY"°ÀD0PƒX0 ³ic¸!(…0˜eŠ€´qa)Ã*„Á,Ã@³Á° @0!Á Œñ„@#Ä €Y‚`0"F`! ¨Æ`DŒ@e0#b$ *ƒ1#Á ĞŒ
0!# Pò ØÁ]P€Áˆ	€Ş`\P€Á	€Ú`P†‚^ƒYãá‚AX@
!1  À‚ñ„ ÈÆxB€
„aA(ˆ`<Á#ö  ÚƒAAŒàƒ  ˆÂ`„›@n.Èˆ "ÌÄ&â‚F¬I0 Ô&â‚F°I0 ä&â‚F´I0     öPLóÌ€‹#(é|ÀğL‘q±u²y³É(A„
{ aíÅD0OlîÅD0     a   2   A,      4(ò(‚2    3Æ ÂL„1€‡0aà!ÌDüÂ Ã`ÁÀ`Ä°À`„ À`D â‚Tè bŒ7iƒÁ  ”ˆRÁ£€–1Ş¼Á4@¸` TzA(ãA\ƒÁ  ô“¨1ŞàA6€á@  
   æHñh±Æ HMZc,„}ŒSéYw B4ƒÖ     a      A,      4((4  3İàÃ`DP c¼!ğ

Æ bŒ7bP0.( %c¼!0ƒeÄà8€=840   Æ€ ÂäDé      a   +   A,      4("(  3Æ ÂL„1€‡0aà!ÌDüÂ Ã`±À`Ä À`„À`D€ ‚„1Ş”AFƒ !¨ã0ƒÁ  „BÆxC°Î`D0 •Ç¤eŒ7n FÃ `8 
   æHñh±Æ HMZc,„}ŒSéYw B4ƒÖ     a   §   R,      4(â(‚(@$(ÿ 3Ä ÃL1€Ç0Aà1ÌDx3Ä ÃL1€Ç0Aà1ÌDx3Ä ÃL1€Ç0Aà1ÌDx3Ä ÃL1€Ç0Aà1ÌDxƒÏ6 ƒ6 ƒM6 ƒ6 Äz†	A#’` #–` (¤F@Á Ğ4È&!Œ€‚Œ‚ hP4LD0q@× k7Ì2B@ØŒ¨‚ lFhÁ 5#´` #¬4€Y‚a0Â*…˜%¨Ô\ ¶–8b@ €.h0‚D‚ ÃA+„Á,CAƒkà
 0KÑŒ
äàEF	FˆA0 ƒa 0K`PR‘1ˆBg0†„Àf$ 4ø#Ô €YƒÔ`ĞŒŒñ„@ @\0‚ƒ1Ü a0Ë0ÅÁ°àB@;2ÆqÁ@èÉO
Ä1# A°@ôc¸AÒ`–AY…aÁ,€`0B‚˜%Xf	…a´€`0b‚ UÃ=¤Á,CãT
Ãğ!Á`Ä)0Kà*Œ
|A‡‚}ƒY†
H†õCzƒ­À,D­0*ğŒğ…  f	"òA8      Æ@4„[{ ÑÖlÜÂU›w€pÙ@LÌ3[w€Õö d¶Éóx—ÁóÄö@H1›{ 1 ElöJ4À¢5ÆBX}€"M@4i±F„4i±6@`       a   a   K,      4("(@ˆ2¨@„D   3ÄĞÃLÄ/½1ÌDCo3ÄĞÃ`Ä° c¼! …1ÜœAÌ2I@à1	ãA4#‚F,Á Ğ2¨ãPˆ2ÜPg0Ë Ic¼!˜ƒl0"¨ jŒ7uÀQ .È`D À,BØoò („¸1ŞôAP .ˆA#¾` èÃA Á,QÃ‚4 Á`Ä0K€ĞŒá† Ì`–Á8*ƒaA„`0â‚˜%8f	BƒAh0,D0¡Á Œñ† æ€qÁ@ÈFFÀA0 $c¼!˜…Y @\0¢ƒa ‚Á;€ì`FèA  ³
åÁot!(d0Â ˜%PÈ@á@   	   fàD ÒZc,„qŒSéYy€2!‘’D       a   J   F,      4("(  3ÄĞÃLÄ/½1ÌDCoƒÂ1 $Œñ† 
ÄpC0a0Ë c¼! ƒ…qÁ@#–  f	
IËoÒÀ¡`„€1Ş´ÁD¸` ÃE€³Ä5Æ9À#: ²ÆxC@â‚Fl Ì¤ñ† >
Ä!oŒ7|ÀˆbE‚Á1€òcŒñ†@Î€‚aD:ƒa ‚Áˆ4€Ô`Œ7¨àˆBm0*h0â‚ 7c¼!x…W @\0+FÜA  ³İÈ      &€Ló°ñwÀÁ8‘N      a   7   A,      4(ZÄgóiû‡©	c ‚ ‚ H†    3ÄğÃL1üÆ0A¿1ÌD„ÃğÄ`¡À`ÄÀ`„€ 	ã‚¥HF2.XdÄ€@€:j„˜qÁÒˆ!#äAPC epÁ€#Ğ# ¢†ÍA‚–F1  ‚¡l\°4ÊÈˆ §ÔH\0 Áú Ã    VpDÀ€ dŞĞaÜAlİÁ    a   $   A,      4( 3Ä ÃL1€Ç0Aà1ÌDxƒD2 ƒ2 ƒÂ1 ƒ1 $*†	A¨„‚ˆ€AË0!-ƒœaB#€à°]°ÄD!¸`@„   Æ \µy—mİBVÛw€Ù     a   2   A,      4( 3Ä ÃL1ˆÇ0Aâ1ÌDƒx3Ä ÃL1ˆÇ0a40Q00A,01(0!$0 @Ã c˜„€ŒAÊ0!(Ô‚3&!0"!D‚Ğ4è&!0"!. ÛK1 À‚”A8     Æ \µuXmŞBVx€€Ùö \¶…™       a   Z   D,      4(ò(†‚(‚2 3Ä ÃL1€Ç0Aà1ÌDüÂ ÃL1€Ç0aà!ÌDx3Æ Â`"À`ÄÀ`„À`Dñ !£G/(À`D )£‚H/(À`Ä !‚˜1ŞÈFƒ "èãAdƒÁ  äˆB¸` 6!¨ »
0a@–¸` ÃÁ Á,C ”‰b¢„`0¢`–` N\0Áˆ/€Y‚¾Qä`D@c0H†‚#È  "ƒQä`„@f0.( ¥Áo^á#‚A (E&±Áod!#‚a 0    æPHA¶4ƒìD<Ö L±Eä0Öp ±­cÜ	ĞñEcêLC1hÁNÄ#6“}ŒSé    a   ˜  ø     ¨*DQT AĞ 
¤ĞŠ J¤HÊ  Ê¤\Š¢0
 °	j Ê§üJ¡Š£Ê£ ¨På@¡ŒêHc ¡ŒIHc(¡ŒIHc¡ŒIHcÀ  3Ä ÃLD7ˆÇ0aâ!ÌDƒx3Ä ÃL1ˆÇ0a¬Á 1Æğƒ‚Áˆ# :ÆxC`
e@Án60˜e„`–àhã*°Á†¥@T0XÁ¥Ã,„Á,Ã ƒQ, Ic¼!ˆ…6 `7u³DÌÜˆ¸` Ğ7·³ÆFd{  ³­ˆ¸` Ğ7»³HFt   ³	yc¼!è? `PŒñ† B‚Ac .ˆèÆxC`£@Á 5ãA:¤ÂˆÁ òÀC@=".È`„0Kpäc¼!h‡v¸À°ˆ
j+Ğnæ!fœ% :ã=Àc¸!À…0˜e`š€ò`Œ7ø€#  D@|0Æ‚}à…Áˆ`€Y‚f–À!?ãA?äc˜iê4ñ€ÊcÒãÌCêCäcìƒf	ìDa7 ³qƒr"@q".ÈpC `0Ë MÁ`D´‚ ÌL4'â‚³%WyhéÑD'£‚tĞá† %Â`–¡²‚Á=‘˜%°f	à€îdTÀ:Ü¬DÌ2`Y@¯0F˜	]°…—f	²Y8 >Äƒ70³ä'b¸!˜‰0˜eàÈ Œø^ ª…1ŞĞ=Œ @áÂon#‚a hTFû ÃN„Á,CçÔc¼!à	} `7>³cà# Eû`ƒà Ã&1 O<À <Â€ÊaŒ	 ÁeÌˆÃ18`-BÂÎ"˜%J‡1bp$@[€<¤E0K ³c0K°´+â‚T@:Ü¬EÌ2”ôcÄàH€¹H	{x‹`–À(\Ä©À%t¸!ˆ‹0˜e84¨ÆˆÁ‘ yÁüPÁ,Ğ¹ˆRNèpCpa0ËjĞ>Œƒ#şÂ&Db/‚Y5˜%XƒY6˜%€B—QAOèpCÀa0ËàoHŒƒ#Hã'ş¢,‚Y‚7˜%€ƒY‚8 vè„7¡³rğ™DnJ#fş`jqÁ@†Ó ƒY:Èƒ€X"7ª³u€Å‹¸` ÃO€Á,ƒÜA@/1F˜œ°‰×f	î`0B_nB &ÆxCğo1b@ Ào4c¼!¹Œ†˜%ÀƒY? œÃm„Á,ƒôA@71ÆÛˆ
ÆpCpa0Ë°|OŒ
0bP(ÀoèE0KÀäcÄàH ñ ‹²ğ`0"eÌB è'ÆxCà~1b@ €{$c¼!ÑŒ†˜%èƒY?˜%ø‚™1ÜŒGÌ2€B(T3â‚7æ³¡àéŒ¸` †7ê³¢0
Á`ÄÍ°‡ ÌŒùŒ¸` ô3c¸AÂ`–¡H! t3c¸AÂ`–¡P! ŸÃ}„Á,ƒ)œB@w1FØú°Şf	Na– #Äæ>€ÒF\0
tC‡‚üƒY†T`…€ÀF7ü³« 
ıÅ18`D~Ã?È#˜%X…Áµ9˜%`ŠqÁ@*ønB$fZáªqÁ@*0nJ$f^ÁJ1bp$@‹˜Š¸G0A7±! ³¯@{#.Hè¡ÃÁŠ„Á,,ØB07µ! äc¼!h‘õ `7/³± ÍÆ18àFØCFğ#˜%¨¢1ŞÌH}\`X
D¾€‡79³´0íÆotD?F P“€|cŒ7=âƒÁ0 ³´0KP³¶@±#.Hú¡ÃA˜„Á,Ã-ôB0á:ë! Dc¼!“¡`7e³¸¥Ç18 MJM\$˜%àR1Ş¤ÉŠ\`X
DôØ‡7o³» ÅÇoàFF  •€ècŒ7sB#ƒÁ0 ³»0KÀ³½0KàƒôQ'@ç#.H4¢ÃÁ„Á,Ã/€C0;" ³à@ë#.H4¢ÃÁ„Á,C8ˆC0Á`" ³â@ş1Æ‚>ñ
…Èo@%L($"â‚Ø€€NdŒ7¦2&R‘1Ş¤JšŒ  +Œ1Ô?â‚FøO0 ¤?c0‚~‚˜%°z‘1Ş¸J™P0HFÆxC+gBÁ ã­°	c¼A…l%onÅM(´#c¼!Ğ9¡`Œ7À¯ãA¯Ì	cÄà  xš#Œğ‘` HLÆxC.ára)¤
Và&:ÜœKÌ2C9T&ƒÔdŒ7é¢*ƒÁ0 ³æ@l2Æ‚ua
­É 8ãÁ»°
ƒædŒ7ò"+# ìËaÁ,9ÌØÕÉoè¥T(ÃAª€Á,:¤C@y2Æ|I•Áˆ _`– f	ìa–ÀhOÆxC /²BÁo€#~	Æ‚~¡
…Êo@æV#‚a hTÆxC 2ºBÁoÀ#’	Æ‚’Ù
¥ÊoPÆW#‚a f	ìVeŒ7*Ã.–QA­`·¢ÃÌ„Á,=´C@²2Æ‚˜
F½¢ÃÍ„Á,ƒ;¼C@·2Æ›¹
ÆˆÁ  =S»(ñÊov†_(ÈK¬@PÁ»(‰ËoÂÆ_(T.c¼! ’18  mcF P›
ôÅœ¦	,è»Œñ†`mHf0"€ŞeŒ	07mã64Ì¼ÁËoŞæeÆ¸y
ÄpC07a0Ë0ğ½Œƒ#ôÆfêfgr§Iø2Æ‚»
Æp˜Á,C<ÈC@ü2Æ‚½á
ÆˆÁ  ¢SÁÌ(…Ìo@'l(ÜL¬@PÍ(ÌoLgl(¤2c¼!H´18 @vcF x
~Æ¨¤¦	,PÌŒñ† vÒf0"`–@f	æa–€f	ìffŒ7²ã6Œƒ ngg‚Y{˜%¸     f(€4„¥5ÆBX¡@FDHHE˜Î@˜ @“Ù @2Ì£5ÆBw “‰Ãe„ÊD0ÖQ        /** @file music.c
	@brief
	This file contains music playing routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <SDL/SDL.h>
#ifndef MACOSX
#include <SDL/SDL_mixer.h>
#else
#include <SDL_mixer/SDL_mixer.h>
#endif

#include "music.h"
#include "main.h"
#include "sdlengine.h"
#include "hqrdepack.h"
#include "resources.h"
#include "xmidi.h"

/** MP3 music folder */
#define MUSIC_FOLDER	"music"
/** LBA1 default number of tracks */
#define NUM_CD_TRACKS	10
/** Number of miliseconds to fade music */
#define FADE_MS			500

#ifndef EMSCRIPTEN
/** SDL CD variable interface */
//SDL_CD *cdrom;
#endif
/** CD drive letter */
const int8 *cdname;

/** SDL_Mixer track variable interface */
Mix_Music *current_track;

/** Auxiliar midi pointer to  */
uint8 * midiPtr;


/** Music volume
	@param current volume number */
void musicVolume(int32 volume) {
	// div 2 because LBA use 255 range and SDL_mixer use 128 range
	Mix_VolumeMusic(volume / 2);
}

/** Fade music in
	@param loops number of*/
void musicFadeIn(int32 loops, int32 ms) {
	Mix_FadeInMusic(current_track, loops, ms);
	musicVolume(cfgfile.MusicVolume);
}

/** Fade music out
	@param ms number of miliseconds to fade*/
void musicFadeOut(int32 ms) {
	while (!Mix_FadeOutMusic(ms) && Mix_PlayingMusic()) {
		SDL_Delay(100);
	}
	Mix_HaltMusic();
	Mix_RewindMusic();
	musicVolume(cfgfile.MusicVolume);
}


/** Play CD music
	@param track track number to play */
void playTrackMusicCd(int32 track) {
#ifndef EMSCRIPTEN
	/*if (!cfgfile.UseCD) {
		return;
	}

	if (cdrom->numtracks == 10) {
		if (CD_INDRIVE(SDL_CDStatus(cdrom)))
			SDL_CDPlayTracks(cdrom, track, 0, 1, 0);
	}*/
#endif
}

/** Stop CD music */
void stopTrackMusicCd() {
#ifndef EMSCRIPTEN
	/*if (!cfgfile.UseCD) {
		return;
	}

	if (cdrom != NULL) {
		SDL_CDStop(cdrom);
	}*/
#endif
}

/** Generic play music, according with settings it plays CD or MP3 instead
	@param track track number to play */
void playTrackMusic(int32 track) {
	if (!cfgfile.Sound) {
		return;
	}
	
	if (track == currentMusic)
		return;
	currentMusic = track;

	stopMusic();
	playTrackMusicCd(track);
}

/** Generic stop music according with settings */
void stopTrackMusic() {
	if (!cfgfile.Sound) {
		return;
	}
	
	musicFadeOut(FADE_MS);
	stopTrackMusicCd();
}

/** Play MIDI music
	@param midiIdx music index under mini_mi_win.hqr*/
void playMidiMusic(int32 midiIdx, int32 loop) {
	uint8* dos_midi_ptr;
	int32 midiSize;
	int8 filename[256];
	SDL_RWops *rw;

	if (!cfgfile.Sound) {
		return;
	}

	if (midiIdx == currentMusic) {
		return;
	}

	stopMusic();
	currentMusic = midiIdx;

	if (cfgfile.MidiType == 0)
		sprintf(filename, "%s", HQR_MIDI_MI_DOS_FILE);
	else
		sprintf(filename, "%s", HQR_MIDI_MI_WIN_FILE);

	if (midiPtr) {
		musicFadeOut(FADE_MS / 2);
		stopMidiMusic();
	}

	midiSize = hqrGetallocEntry(&midiPtr, filename, midiIdx);

	if (cfgfile.Sound == 1 && cfgfile.MidiType == 0) {
		midiSize = convert_to_midi(midiPtr, midiSize, &dos_midi_ptr);
		free(midiPtr);
		midiPtr = dos_midi_ptr;
	}

	rw = SDL_RWFromMem(midiPtr, midiSize);

	current_track = Mix_LoadMUS_RW(rw);

	musicFadeIn(1, FADE_MS);

	musicVolume(cfgfile.MusicVolume);

	if (Mix_PlayMusic(current_track, loop) == -1)
		printf("Error while playing music: %d \n", midiIdx);
}

/** Stop MIDI music */
void stopMidiMusic() {
	if (!cfgfile.Sound) {
		return;
	}
	
	if (current_track != NULL) {
		Mix_FreeMusic(current_track);
		current_track = NULL;
		if (midiPtr != NULL)
			free(midiPtr);
	}
}

/** Initialize CD-Rom */
int initCdrom() {
#ifndef EMSCRIPTEN
	//int32 numOfCDROM;
	//int32 cdNum;

	//if (!cfgfile.Sound) {
	//	return 0;
	//}

	//numOfCDROM = SDL_CDNumDrives();
	//
	//if (cfgfile.Debug)
	//	printf("Found %d CDROM devices\n", numOfCDROM);

	//if (!numOfCDROM) {
	//	fprintf(stderr, "No CDROM devices available\n");
	//	return 0;
	//}

	//for (cdNum = 0; cdNum < numOfCDROM; cdNum++) {
	//	cdname = SDL_CDName(cdNum);
	//	if (cfgfile.Debug)
	//		printf("Testing drive %s\n", cdname);
	//	cdrom = SDL_CDOpen(cdNum);
	//	if (!cdrom) {
	//		if (cfgfile.Debug)
	//			fprintf(stderr, "Couldn't open CD drive: %s\n\n", SDL_GetError());
	//	} else {
	//		SDL_CDStatus(cdrom);
	//		if (cdrom->numtracks == NUM_CD_TRACKS) {
	//			printf("Assuming that it is LBA cd... %s\n\n", cdname);
	//			cdDir = "LBA";
	//			cfgfile.UseCD = 1;
	//			return 1;
	//		}
	//	}
	//	// not found the right CD
	//	cfgfile.UseCD = 0;
	//	SDL_CDClose(cdrom);
	//}

	//cdrom = NULL;
#endif

	printf("Can't find LBA CD!\n\n");

	return 0;
}

/** Stop MIDI and Track music */
void stopMusic() {
	stopTrackMusic();
	stopMidiMusic();
}
/** @file music.h
	@brief
	This file contains music playing routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef MUSIC_H
#define MUSIC_H

#include "sys.h"

/** Track number of the current playing music */
int32 currentMusic;

/** Music volume
	@param current volume number */
void musicVolume(int32 volume);
/** Play CD music
	@param track track number to play */
void playTrackMusicCd(int32 track);
/** Stop CD music */
void stopTrackMusicCd();
/** Play MP3 music
	@param track track number to play */
void playTrackMusicMp3(int32 track);
/** Stop MP3 music */
void stopTrackMusicMp3();
/** Generic play music, according with settings it plays CD or high quality sounds instead
	@param track track number to play*/
void playTrackMusic(int32 track);
/** Generic stop music according with settings */
void stopTrackMusic();
/** Play MIDI music
	@param midiIdx music index under mini_mi_win.hqr*/
void playMidiMusic(int32 midiIdx, int32 loop);
/** Stop MIDI music */
void stopMidiMusic();

/** Initialize CD-Rom */
int32 initCdrom();

/** Stop MIDI and Track music */
void stopMusic();

#endif
BCÀŞ!  Ë  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  ˜   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å    I     ‚`B    ‰   L   2"È	 d…“#¤„“#ã„¡LŒ„äLÀÂEÒQÂäÿ&rı&%!Â@ 
Ì ©0˜# ƒ\$M%L>ç4b|ÈB @(CaP(
…B¡P(
…B¡P(
…¨@Ğ"AÔÈŠ=P`@‘9ˆ&É1 JZè’Ê¤B6)1¡Nr,è“
 aT R
2•aT(ª…@¡@ªˆU‚¹êPX,VˆcQ Y!
‹ƒhE-ÈFÁBp…åJQÀ-
Ú¡€£Ş-ÒQÂäÓ a±XœB5ˆÓø@ã4(ø$M%L>Û•ÿ
;„ç+ Ë€[HX„ ˆe(
d¬BaAÈ"Œ¤˜˜# °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD 
H' ˜ğ|‡¢    @ 
øÅ	B!	  €
ˆB   d€NÉ(`¤ôJJ ¤ôJJ ¤ôJJ ¤ôJJ ¤ôJJ ¤ôJJ ´”FŒ)`ÔœF*àLøNO* LøN*à­N(àC–2       €!Ë      À%      `È²@     0d)      ²œ     YÚ      †,e €     C–6 @    €!Ë      À¥      `Èò      0d)      ²¼      YÒ  €     †,q €     C–9 @    €!K      Àå€     `È2
@     0d)      ²œ     YR     †,o  @     C–U @    €!K      Àå          2˜LŒ	&GÆCšŒ Pa€*”æ´ †~E¹ü-İÑivg‡ói÷Ô®ÏÓc¨D)è¡Ô0ì>ÑAæ´›b
ƒ !1¤PPd€# T Ë eF h3@ úŒ Ph   y     CVHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   ±   ¶° CpğLDd3D„±@Òä<mŠIIˆÀfÓ˜Èõ§€™”„–PC‡D6@øÒ™N‚4ÈÄ‘ÃXc"×_:À`ºì¿ÂÖâ<€µ (&%!‚qLÀÜá !±Ä4!!JÂvåß€Ù
ô, ÖF€ ˜”„Ü`
%!ÁAD@#PQD4Ó?E€ ØAáKST›ÁÁ ’N‘!¾4E¶]8HSÍäDØ· †dÒTD39vRHFÓ°]ù¯ğ9ŒI0öĞ0€%Q‹8\ÆÀ0€°,âpÙ	d"×Ÿ. †4†IIˆ`0‡ôDH3æ 1€°,umÕ„Å@Ä,‹#xÍa¦± Cp‡ƒ„dJC1Üá !YNc"×ÿEaR"˜Êc"×¿Ò&%!‚…,%!Âë,C˜ #PQD4“IIˆ`2à4Mÿäü2 ¶“H“ó˜”„VÂ0”„0(5N#MÎc"bR"…4ÑLN„™€©ƒ4“d‡P²&A!ME4“a'Å”PH›s™‡ƒ4ÑLN„µ@°öÒ<€™È€˜”„ÖÁ‡ƒ„ÖHY„„4ÑLN„CÒAH†ÁÎâ0Àó-€!Y†#‘. FD'À&ò˜Èõ¿ÎB1„IIˆ`T¨®¿)vâoŠ‡²ÿ'–,%!Â„ØØD„4ÑLN„S@!™Bb ñ-€!YƒÄ "lÀ²œ³9T#V@…êú›b'ş¦øÃâùbéÙ‡„4ÑLN„±HF´@°bC0„İO„4Sa$‰\ÿ„Ø˜”„f™ÈõÀ@ ÔdR"XJc"×ËdR"„4ÑLN„C˜d.49O‚bR" a      A,      T("    3IÁ
Ã`D@ £‚F xƒ Ã       ¶dTÎB1     a      A,      T(² ÄP}P¸  3IÑ
ÃLDR´Â0!0@²0h4Œ â`:Æˆ v`8    Æ$0’-‹ã<      a   #   F,      T(B(r Pb(	Š>(\    3IÁ
Ã`DpÀ,A@Á1   ‚á†à
ƒY†AF pƒá† ƒY‚a Â @fˆ"1   –Y‚`Ä` €71 à(# äA€á@    ¶$0        a      A,      T( 3IÁ
Ã`D0 †     ¶TL (      a      a      F,      T("¡ÄP}P´  3IÁ
Ã`DP 	c¸! Â`–A‚Y‚‚†A±0†„ f"˜%(Èƒ´ÀˆÁ  cÄ€  6f	
   ¶TL (      a      D,      T(’B? ÄP}P¬ Œá†@
ƒY!f	† Ö€1 €f	  a   w   O,      T(")ˆ¢(ôƒ²¨Je AÑ…+e AÑ…,Ğb(	Š>(^a(CŠ>(ú`(Ã9Š>(ú    3IÑ
ÃLDR´Â0Á­0ÌD$E+3RÑ
ÁLÄ+­0FÔ FÓ Ğ2†‚1ƒY!f	BÃn0˜eˆ`–À1  hƒã =á‚‚7j ³…Œ7,k°TcÄÀ  =¦`–àopÜÀèÆˆ } XÁ,ÁAè0†8ƒY$	F X01  f	’ñ†iæ€°1b` @(°ƒF\Á Ğ7†‚3 ƒY…	èd¸!Ğ0˜eX˜€äaP7F @!ø#¾` ¨Æˆ ©PŒÁˆ{`–€¡{$cÄ  €U‚Á1€Ä`Œ À
Á`„H0bP À/ÔAPŒ Ä! ‘¤cÄ  €W‚á†`À`–¡qrƒ1bP @,ÀA0Kà`8     Ö…ÈB4 CØÒÁ "—y	‘eLÄâ8m1ƒ#ı2 ÿ3EÆ…0È€°HF        a      G,      T(Je AÑÅ*    Œá† 
ƒY!f	z…1Ü4a0Ë0ÅÂ1   #dá b…1ÜPa0Ë@¹Â1  @‚Y‚b–À@ a      A,      ´Ê€¢Š>   # TAB a      ÁˆÁ  İˆÁ        /** @file redraw.c
	@brief
	This file contains engine redraw actions routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "redraw.h"
#include "sdlengine.h"
#include "lbaengine.h"
#include "renderer.h"
#include "interface.h"
#include "screens.h"
#include "grid.h"
#include "scene.h"
#include "actor.h"
#include "hqrdepack.h"
#include "resources.h"
#include "menu.h"
#include "animations.h"
#include "keyboard.h"
#include "movements.h"
#include "text.h"
#include "collision.h"
#include "sound.h"

#ifdef GAMEMOD
#include "debug.scene.h"
#endif

typedef struct RedrawStruct {
	uint16 left;
	uint16 top;
	uint16 right;
	uint16 bottom;
} RedrawStruct;

RedrawStruct currentRedrawList[300];
RedrawStruct nextRedrawList[300];

typedef struct DrawListStruct {
	int16  posValue;
	uint16 index; // field_2
	uint16 X;
	uint16 Y;
	uint16 Z;
	uint16 field_A;
	uint16 field_C;
	uint16 field_E;
	uint16 field_10;
} DrawListStruct;

/** Draw list array to grab the necessary */
DrawListStruct drawList[150];

int16 overlayRotation = 0;

/** Add a certain region to the current redraw list array
	@param left start width to redraw the region
	@param top start height to redraw the region
	@param right end width to redraw the region
	@param bottom end height to redraw the region */
void addRedrawCurrentArea(int32 left, int32 top, int32 right, int32 bottom) {
	int32 area;
	int32 i = 0;
	int32 leftValue;
	int32 rightValue;
	int32 topValue;
	int32 bottomValue;

	area = (right - left) * (bottom - top);

	while (i < numOfRedrawBox) {
		if (currentRedrawList[i].left >= left)
			leftValue = left;
		else
			leftValue = currentRedrawList[i].left;

		if (currentRedrawList[i].right <= right)
			rightValue = right;
		else
			rightValue = currentRedrawList[i].right;

		if (currentRedrawList[i].top >= top)
			topValue = top;
		else
			topValue = currentRedrawList[i].top;

		if (currentRedrawList[i].bottom <= bottom)
			bottomValue = bottom;
		else
			bottomValue = currentRedrawList[i].bottom;

		if ((rightValue - leftValue) *(bottomValue - topValue) < ((currentRedrawList[i].bottom - currentRedrawList[i].top) *(currentRedrawList[i].right - currentRedrawList[i].left) + area)) {
			currentRedrawList[i].left = leftValue;
			currentRedrawList[i].top = topValue;
			currentRedrawList[i].right = rightValue;
			currentRedrawList[i].bottom = bottomValue;

			if (currentRedrawList[i].bottom >= SCREEN_WIDTH)
				currentRedrawList[i].bottom = SCREEN_TEXTLIMIT_BOTTOM;
			return;
		}

		i++;
	};

	currentRedrawList[i].left = left;
	currentRedrawList[i].top = top;
	currentRedrawList[i].right = right;
	currentRedrawList[i].bottom = bottom;

	if (currentRedrawList[i].bottom >= SCREEN_WIDTH)
		currentRedrawList[i].bottom = SCREEN_TEXTLIMIT_BOTTOM;

	numOfRedrawBox++;
}

/** Add a certain region to redraw list array
	@param left start width to redraw the region
	@param top start height to redraw the region
	@param right end width to redraw the region
	@param bottom end height to redraw the region */
void addRedrawArea(int32 left, int32 top, int32 right, int32 bottom) {
	if (left < 0)
		left = 0;
	if (top < 0)
		top = 0;
	if (right >= SCREEN_WIDTH)
		right = SCREEN_TEXTLIMIT_RIGHT;
	if (bottom >= SCREEN_HEIGHT)
		bottom = SCREEN_TEXTLIMIT_BOTTOM;

	if (left > right || top > bottom)
		return;

	nextRedrawList[currNumOfRedrawBox].left = left;
	nextRedrawList[currNumOfRedrawBox].top = top;
	nextRedrawList[currNumOfRedrawBox].right = right;
	nextRedrawList[currNumOfRedrawBox].bottom = bottom;

	currNumOfRedrawBox++;

	addRedrawCurrentArea(left, top, right, bottom);
}

/** Move next regions to the current redraw list */
void moveNextAreas() {
	int32 i;

	numOfRedrawBox = 0;

	for (i = 0; i < currNumOfRedrawBox; i++) {
		addRedrawCurrentArea(nextRedrawList[i].left, nextRedrawList[i].top, nextRedrawList[i].right, nextRedrawList[i].bottom);
	}
}

/** Flip currentRedrawList regions in the screen

	This only updates small areas in the screen so few CPU processor is used */
void flipRedrawAreas() {
	int32 i;

	for (i = 0; i < numOfRedrawBox; i++) { // redraw areas on screen
		copyBlockPhys(currentRedrawList[i].left, currentRedrawList[i].top, currentRedrawList[i].right, currentRedrawList[i].bottom);
	}

	numOfRedrawBox = 0;

	for (i = 0; i < currNumOfRedrawBox; i++) { //setup the redraw areas for next display
		addRedrawCurrentArea(nextRedrawList[i].left, nextRedrawList[i].top, nextRedrawList[i].right, nextRedrawList[i].bottom);
	}
}

/** Blit/Update all screen regions in the currentRedrawList */
void blitBackgroundAreas() {
	int32 i;
	RedrawStruct* currentArea;
	currentArea = currentRedrawList;

	for (i = 0; i < numOfRedrawBox; i++) {
		blitBox(currentArea->left, currentArea->top, currentArea->right, currentArea->bottom, (int8 *) workVideoBuffer, currentArea->left, currentArea->top, (int8 *) frontVideoBuffer);
		currentArea++;
	}
}

/** Sort drawing list struct ordered as the first objects appear in the top left corner of the screen
	@param list drawing list variable which contains information of the drawing objects
	@param listSize number of drawing objects in the list */
void sortDrawingList(DrawListStruct *list, int32 listSize) {
	int32 i;
	int32 j;

	DrawListStruct tempStruct;

	for (i = 0; i < listSize - 1; i++) {
		for (j = 0; j < listSize - 1 - i; j++) {
			if (list[j+1].posValue < list[j].posValue) {
				memcpy(&tempStruct, &list[j+1], sizeof(DrawListStruct));
				memcpy(&list[j+1], &list[j], sizeof(DrawListStruct));
				memcpy(&list[j], &tempStruct, sizeof(DrawListStruct));
			}
		}
	}
}

/** */
void addOverlay(int16 type, int16 info0, int16 X, int16 Y, int16 info1, int16 posType, int16 lifeTime) {
	int32 i;
	for (i = 0; i < OVERLAY_MAX_ENTRIES; i++) {
		OverlayListStruct *overlay = &overlayList[i];
		if (overlay->info0 == -1) {
			overlay->type = type;
			overlay->info0 = info0;
			overlay->X = X;
			overlay->Y = Y;
			overlay->info1 = info1;
			overlay->posType = posType;
			overlay->lifeTime = lbaTime + lifeTime * 50;
			return;
		}
	}
}

/** */
void updateOverlayTypePosition(int16 X1, int16 Y1, int16 X2, int16 Y2) {
	int32 i;
	int16 newX, newY;

	newX = X2 - X1;
	newY = Y2 - Y1;

	for (i = 0; i < OVERLAY_MAX_ENTRIES; i++) {
		OverlayListStruct *overlay = &overlayList[i];
		if (overlay->type == koFollowActor) {
			overlay->X = newX;
			overlay->Y = newY;
		}
	}
}

/** This is responsible for the entire game screen redraw
	@param bgRedraw true if we want to redraw background grid, false if we want to update certain screen areas */
void redrawEngineActions(int32 bgRedraw) { // fullRedraw
	int16 tmpProjPosX;
	int16 tmpProjPosY;
	int32 i;
	int32 tmpVal;
	int32 modelActorPos;  // arg_1A
	int32 spriteActorPos; // top6
	int32 shadowActorPos; // top2
	int32 drawListPos;    // a12
	ActorStruct *actor;

	tmpProjPosX = projPosXScreen;
	tmpProjPosY = projPosYScreen;

	resetClip();

	if (bgRedraw) {
		freezeTime();
		if (needChangeScene != -1 && needChangeScene != -2)
			fadeOut(paletteRGBA);
		clearScreen();
		redrawGrid();
		updateOverlayTypePosition(tmpProjPosX, tmpProjPosY, projPosXScreen, projPosYScreen);
		copyScreen(frontVideoBuffer, workVideoBuffer);

		if (needChangeScene != -1 && needChangeScene != -2) {
			fadeIn(paletteRGBA);
			setPalette(paletteRGBA);
		}
	} else {
		blitBackgroundAreas();
	}

	// first loop
	
	modelActorPos = 0;
	drawListPos = 0;
	spriteActorPos = 0x1000;
	shadowActorPos = 0x0C00;

	// Process actors drawing list
	for (modelActorPos = 0; modelActorPos < sceneNumActors; modelActorPos++, spriteActorPos++, shadowActorPos++) {
		actor = &sceneActors[modelActorPos];
		actor->dynamicFlags.bIsVisible = 0; // reset visible state

		if ((useCellingGrid == -1) || actor->Y <= (*(int16 *)(cellingGridIdx*24 + (int8 *)sceneZones + 8))) {
			// no redraw required
			if (actor->staticFlags.bIsBackgrounded && bgRedraw == 0) {
				// get actor position on screen
				projectPositionOnScreen(actor->X - cameraX, actor->Y - cameraY, actor->Z - cameraZ);

				// check if actor is visible on screen, otherwise don't display it
				if (projPosX > -50 && projPosX < 680 && projPosY > -30 && projPosY < 580) {
					actor->dynamicFlags.bIsVisible = 1;
				}
			} else {
				// if the actor isn't set as hidden
				if (actor->entity != -1 && !(actor->staticFlags.bIsHidden)) {
					// get actor position on screen
					projectPositionOnScreen(actor->X - cameraX, actor->Y - cameraY, actor->Z - cameraZ);

					if ((actor->staticFlags.bUsesClipping && projPosX > -112 && projPosX < 752 && projPosY > -50 && projPosY < 651) ||
					   ((!actor->staticFlags.bUsesClipping) && projPosX > -50 && projPosX < 680 && projPosY > -30 && projPosY < 580)) {
						
						tmpVal = actor->Z + actor->X - cameraX - cameraZ;

						// if actor is above another actor
						if (actor->standOn != -1) {
							tmpVal = sceneActors[actor->standOn].X - cameraX + sceneActors[actor->standOn].Z - cameraZ + 2;
						}

						if (actor->staticFlags.bIsSpriteActor) {
							drawList[drawListPos].index = spriteActorPos; // > 0x1000
							if (actor->staticFlags.bUsesClipping) {
								tmpVal = actor->lastX - cameraX + actor->lastZ - cameraZ;
							}
						} else {
							drawList[drawListPos].index = modelActorPos;
						}

						drawList[drawListPos].posValue = tmpVal;

						drawListPos++;

						// if use shadows
						if (cfgfile.ShadowMode != 0 && !(actor->staticFlags.bDoesntCastShadow)) {
							if (actor->standOn != -1) {
								shadowX = actor->X;
								shadowY = actor->Y - 1;
								shadowZ = actor->Z;
							} else {
								getShadowPosition(actor->X, actor->Y, actor->Z);
							}

							tmpVal--;
							drawList[drawListPos].posValue = tmpVal; // save the shadow entry in the drawList
							drawList[drawListPos].index = 0xC00;     // shadowActorPos
							drawList[drawListPos].X = shadowX;
							drawList[drawListPos].Y = shadowY;
							drawList[drawListPos].Z = shadowZ;
							drawList[drawListPos].field_A = 2;
							drawListPos++;
						}
					}
				}
			}
		}
	}

	// second loop
	for (i = 0; i < EXTRA_MAX_ENTRIES; i++) {
		ExtraListStruct *extra = &extraList[i];
		if (extra->info0 != -1) {
			if (extra->type & 0x400) {
				if (lbaTime - extra->lifeTime > 35) {
					extra->lifeTime = lbaTime;
					extra->type &= 0xFBFF;
					// FIXME make constant for sample index
					playSample(11, 0x1000, 1, extra->X, extra->Y, extra->Z, -1);
				}
			} else {
				if ((extra->type & 1) || (extra->type & 0x40) || (extra->actorIdx + extra->lifeTime - 150 < lbaTime) || (!((lbaTime + extra->lifeTime) & 8))) {
					projectPositionOnScreen(extra->X - cameraX, extra->Y - cameraY, extra->Z - cameraZ);

					if (projPosX > -50 && projPosX < 680 && projPosY > -30 && projPosY < 580) {
						drawList[drawListPos].posValue = extra->X - cameraX + extra->Z - cameraZ;
						drawList[drawListPos].index = 0x1800 + i;
						drawListPos++;

						if (cfgfile.ShadowMode == 2 && !(extra->info0 & 0x8000)) {
							getShadowPosition(extra->X, extra->Y, extra->Z);
			
							drawList[drawListPos].posValue = extra->X - cameraX + extra->Z - cameraZ - 1;
							drawList[drawListPos].index = 0xC00;
							drawList[drawListPos].X = shadowX;
							drawList[drawListPos].Y = shadowY;
							drawList[drawListPos].Z = shadowZ;
							drawList[drawListPos].field_A = 0;
							drawListPos++;
						}		
					}
				}
			}
		}
	}

	sortDrawingList(drawList, drawListPos);

	currNumOfRedrawBox = 0;
	// if has something to draw
	if (drawListPos > 0) {
		int32 pos = 0;
		uint32 flags;
		int32 actorIdx;
		ActorStruct *actor;

		do {
			actorIdx = drawList[pos].index & 0x3FF;
			actor = &sceneActors[actorIdx];
			flags = ((uint32) drawList[pos].index) & 0xFC00;

			// Drawing actors
			if (flags < 0xC00) {
				if (!flags) {
					setModelAnimation(actor->animPosition, animTable[actor->previousAnimIdx], bodyTable[actor->entity], &actor->animTimerData);

					if (!renderIsoModel(actor->X - cameraX, actor->Y - cameraY, actor->Z - cameraZ, 0, actor->angle, 0, bodyTable[actor->entity])) {
						if (renderLeft < 0)
							renderLeft = SCREEN_TEXTLIMIT_LEFT;

						if (renderTop < 0)
							renderTop = SCREEN_TEXTLIMIT_TOP;

						if (renderRight >= SCREEN_WIDTH)
							renderRight = SCREEN_TEXTLIMIT_RIGHT;

						if (renderBottom >= SCREEN_HEIGHT)
							renderBottom = SCREEN_TEXTLIMIT_BOTTOM;
						
						setClip(renderLeft, renderTop, renderRight, renderBottom);

						if (textWindowLeft <= textWindowRight && textWindowTop <= textWindowBottom) {
							int32 tempX;
							int32 tempY;
							int32 tempZ;

							actor->dynamicFlags.bIsVisible = 1;

							tempX = (actor->X + 0x100) >> 9;
							tempY = actor->Y >> 8;

							if (actor->brickShape & 0x7F)
								tempY++;

							tempZ = (actor->Z + 0x100) >> 9;

							drawOverModelActor(tempX, tempY, tempZ);

							if(cropBottomScreen) {
								renderBottom = textWindowBottom = cropBottomScreen + 10;
							}

							addRedrawArea(textWindowLeft, textWindowTop, renderRight, renderBottom);

							if (actor->staticFlags.bIsBackgrounded && bgRedraw == 1) {
								blitBox(textWindowLeft, textWindowTop, renderRight, renderBottom, (int8 *) frontVideoBuffer, textWindowLeft, textWindowTop, (int8 *) workVideoBuffer);
							}
						}
					}
				}
			}
			// Drawing shadows
			else if (flags == 0xC00 && !cropBottomScreen) {
				int32 spriteWidth, spriteHeight, tmpX, tmpY, tmpZ;
				DrawListStruct shadow =	drawList[pos];

				// get actor position on screen
				projectPositionOnScreen(shadow.X - cameraX, shadow.Y - cameraY, shadow.Z - cameraZ);

				getSpriteSize(shadow.field_A, &spriteWidth, &spriteHeight, spriteShadowPtr);

				// calculate sprite size and position on screen
				renderLeft   = projPosX - (spriteWidth / 2);
				renderTop    = projPosY - (spriteHeight / 2);
				renderRight  = projPosX + (spriteWidth / 2);
				renderBottom = projPosY + (spriteHeight / 2);

				setClip(renderLeft, renderTop, renderRight, renderBottom);

				if (textWindowLeft <= textWindowRight && textWindowTop <= textWindowBottom) {
					drawSprite(shadow.field_A, renderLeft, renderTop, spriteShadowPtr);
				}
				
				tmpX = (shadow.X + 0x100) >> 9;
				tmpY = shadow.Y >> 8;
				tmpZ = (shadow.Z + 0x100) >> 9;

				drawOverModelActor(tmpX, tmpY, tmpZ);

				addRedrawArea(textWindowLeft, textWindowTop, renderRight, renderBottom);

				// show clipping area
				//drawBox(renderLeft, renderTop, renderRight, renderBottom);
			}
			// Drawing unknown
			else if (flags < 0x1000) {
				// TODO reverse this part of the code
			}
			// Drawing sprite actors
			else if (flags == 0x1000) {
				int32 spriteWidth, spriteHeight;
				uint8 *spritePtr = spriteTable[actor->entity];

				// get actor position on screen
				projectPositionOnScreen(actor->X - cameraX, actor->Y - cameraY, actor->Z - cameraZ);

				getSpriteSize(0, &spriteWidth, &spriteHeight, spritePtr);

				// calculate sprite position on screen
				renderLeft = projPosX +  *((int16 *)(spriteBoundingBoxPtr + (actor->entity * 16)));
				renderTop = projPosY + *((int16 *)(spriteBoundingBoxPtr + (actor->entity * 16) + 2));
				renderRight = renderLeft + spriteWidth;
				renderBottom = renderTop + spriteHeight;

				if (actor->staticFlags.bUsesClipping) {
					setClip(projPosXScreen + actor->info0, projPosYScreen + actor->info1, projPosXScreen + actor->info2, projPosYScreen + actor->info3);
				} else {
					setClip(renderLeft, renderTop, renderRight, renderBottom);
				}

				if (textWindowLeft <= textWindowRight && textWindowTop <= textWindowBottom) {
					drawSprite(0, renderLeft, renderTop, spritePtr);

					actor->dynamicFlags.bIsVisible = 1;

					if (actor->staticFlags.bUsesClipping) {
						drawOverSpriteActor((actor->lastX + 0x100) >> 9, actor->lastY >> 8, (actor->lastZ + 0x100) >> 9);
					} else {
						int32 tmpX, tmpY, tmpZ;

						tmpX = (actor->X + actor->boudingBox.X.topRight + 0x100) >> 9;
						tmpY = actor->Y >> 8;
						if (actor->brickShape & 0x7F) {
							tmpY++;
						}
						tmpZ = (actor->Z + actor->boudingBox.Z.topRight + 0x100) >> 9;

						drawOverSpriteActor(tmpX, tmpY, tmpZ);
					}

					addRedrawArea(textWindowLeft, textWindowTop, textWindowRight, textWindowBottom);

					if (actor->staticFlags.bIsBackgrounded && bgRedraw == 1) {
						blitBox(textWindowLeft, textWindowTop, textWindowRight, textWindowBottom, (int8 *) frontVideoBuffer, textWindowLeft, textWindowTop, (int8 *) workVideoBuffer);
					}

					// show clipping area
					//drawBox(renderLeft, renderTop, renderRight, renderBottom);
				}
			}
			// Drawing extras
			else if (flags == 0x1800) {
				ExtraListStruct *extra = &extraList[actorIdx];
				
				projectPositionOnScreen(extra->X - cameraX, extra->Y - cameraY, extra->Z - cameraZ);

				if (extra->info0 & 0x8000) {
					drawExtraSpecial(actorIdx, projPosX, projPosY);
				} else {
					int32 spriteWidth, spriteHeight;

					getSpriteSize(0, &spriteWidth, &spriteHeight, spriteTable[extra->info0]);

					// calculate sprite position on screen
					renderLeft = projPosX + *(int16 *)(spriteBoundingBoxPtr + extra->info0 * 16);
					renderTop = projPosY + *(int16 *)(spriteBoundingBoxPtr + extra->info0 * 16 + 2);
					renderRight = renderLeft + spriteWidth;
					renderBottom = renderTop + spriteHeight;

					drawSprite(0, renderLeft, renderTop, spriteTable[extra->info0]);
				}

				setClip(renderLeft, renderTop, renderRight, renderBottom);

				if (textWindowLeft <= textWindowRight && textWindowTop <= textWindowBottom) {
					int32 tmpX, tmpY, tmpZ;

					tmpX = (drawList[pos].X + 0x100) >> 9;
					tmpY = drawList[pos].Y >> 8;
					tmpZ = (drawList[pos].Z + 0x100) >> 9;

					drawOverModelActor(tmpX, tmpY, tmpZ);
					addRedrawArea(textWindowLeft, textWindowTop, renderRight, renderBottom);

					// show clipping area
					//drawBox(renderLeft, renderTop, renderRight, renderBottom);
				}
			}

			resetClip();
			pos++;
		} while (pos < drawListPos);
	}

#ifdef GAMEMOD
	displayZones(skipIntro);
#endif

	for (i = 0; i < OVERLAY_MAX_ENTRIES; i++) {
		OverlayListStruct *overlay = &overlayList[i];
		if (overlay->info0 != -1) {
			// process position overlay
			switch(overlay->posType) {
			case koNormal:
				if (lbaTime >= overlay->lifeTime) {
					overlay->info0 = -1;
					continue;
				}
				break;
			case koFollowActor: {
				ActorStruct *actor = &sceneActors[overlay->info1];

				projectPositionOnScreen(actor->X - cameraX, actor->Y + actor->boudingBox.Y.topRight - cameraY, actor->Z - cameraZ);
				
				overlay->X = projPosX;
				overlay->Y = projPosY;

				if (lbaTime >= overlay->lifeTime) {
					overlay->info0 = -1;
					continue;
				}
			}
				break;
			}

			// process overlay type
			switch(overlay->type) {
			case koSprite: {
				int16 offsetX, offsetY;
				int32 spriteWidth, spriteHeight;
				uint8 *spritePtr = spriteTable[overlay->info0];

				getSpriteSize(0, &spriteWidth, &spriteHeight, spritePtr);

				offsetX = *((int16 *)(spriteBoundingBoxPtr + (overlay->info0 * 16)));
				offsetY = *((int16 *)(spriteBoundingBoxPtr + (overlay->info0 * 16) + 2));

				renderLeft   = offsetX + overlay->X;
				renderTop    = offsetY + overlay->Y;
				renderRight  = renderLeft + spriteWidth;
				renderBottom = renderTop + spriteHeight;

				drawSprite(0, renderLeft, renderTop, spritePtr);

				if (textWindowLeft <= textWindowRight && textWindowTop <= textWindowBottom) {
					addRedrawArea(textWindowLeft, textWindowTop, renderRight, renderBottom);
				}
				
			}
				break;
			case koNumber: {
				int32 textLength, textHeight;
				int8 text[10];
				sprintf(text, "%d", overlay->info0);

				textLength = getTextSize(text);
				textHeight = 48;

				renderLeft   = overlay->X - (textLength/2);
				renderTop    = overlay->Y - 24;
				renderRight  = overlay->X + (textLength/2);
				renderBottom = overlay->Y + textHeight;

				setClip(renderLeft, renderTop, renderRight, renderBottom);

				setFontColor(overlay->info1);

				drawText(renderLeft, renderTop, text);

				if (textWindowLeft <= textWindowRight && textWindowTop <= textWindowBottom) {
					addRedrawArea(textWindowLeft, textWindowTop, renderRight, renderBottom);
				}
			}
				break;
			case koNumberRange: {
				int32 textLength, textHeight, range;
				int8 text[10];

				range = getAverageValue(overlay->info1, overlay->info0, 100, overlay->lifeTime - lbaTime - 50);

				sprintf(text, "%d", range);

				textLength = getTextSize(text);
				textHeight = 48;

				renderLeft   = overlay->X - (textLength/2);
				renderTop    = overlay->Y - 24;
				renderRight  = overlay->X + (textLength/2);
				renderBottom = overlay->Y + textHeight;

				setClip(renderLeft, renderTop, renderRight, renderBottom);

				setFontColor(155);

				drawText(renderLeft, renderTop, text);

				if (textWindowLeft <= textWindowRight && textWindowTop <= textWindowBottom) {
					addRedrawArea(textWindowLeft, textWindowTop, renderRight, renderBottom);
				}
			}
				break;
			case koInventoryItem: {
				int32 item = overlay->info0;

				drawSplittedBox(10, 10, 69, 69, 0);
				setClip(10, 10, 69, 69);

				prepareIsoModel(inventoryTable[item]);
				setCameraPosition(40, 40, 128, 200, 200);
				setCameraAngle(0, 0, 0, 60, 0, 0, 16000);

				overlayRotation += 1; // overlayRotation += 8;

				renderIsoModel(0, 0, 0, 0, overlayRotation, 0, inventoryTable[item]);
				drawBox(10, 10, 69, 69);
				addRedrawArea(10, 10, 69, 69);
				initEngineProjections();
			}
				break;
			case koText: {
				int32 textLength, textHeight;
				int8 text[256];
				
				getMenuText(overlay->info0, text);

				textLength = getTextSize(text);
				textHeight = 48;

				renderLeft   = overlay->X - (textLength/2);
				renderTop    = overlay->Y - 24;
				renderRight  = overlay->X + (textLength/2);
				renderBottom = overlay->Y + textHeight;

				if(renderLeft < 0) {
					renderLeft = 0;
				}

				if(renderTop < 0) {
					renderTop = 0;
				}

				if(renderRight > SCREEN_TEXTLIMIT_RIGHT) {
					renderRight = SCREEN_TEXTLIMIT_RIGHT;
				}

				if(renderBottom > SCREEN_TEXTLIMIT_BOTTOM) {
					renderBottom = SCREEN_TEXTLIMIT_BOTTOM;
				}

				setClip(renderLeft, renderTop, renderRight, renderBottom);

				setFontColor(sceneActors[overlay->info1].talkColor);

				drawText(renderLeft, renderTop, text);

				if (textWindowLeft <= textWindowRight && textWindowTop <= textWindowBottom) {
					addRedrawArea(textWindowLeft, textWindowTop, renderRight, renderBottom);
				}
			}
				break;
			}
		}
	}

	resetClip();

	// make celling grid fade
	// need to be here to fade after drawing all actors in scene
	if (needChangeScene == -2) {
		crossFade(frontVideoBuffer, paletteRGBA);
		needChangeScene = -1;
	}

	if (bgRedraw) {
		flip();
		moveNextAreas();
		unfreezeTime();
	} else {
		flipRedrawAreas();
	}

	if (lockPalette) {
		if (useAlternatePalette) {
			fadeToPal(paletteRGBA);
		} else {
			fadeToPal(mainPaletteRGBA);
		}
		lockPalette = 0;
	}

	if (zoomScreen) {
        //zoomScreenScale();
    }
}

void drawBubble(int32 actorIdx) {
    int32 spriteWidth, spriteHeight;
    uint8 *spritePtr;
    ActorStruct *actor = &sceneActors[actorIdx];
    
    // get actor position on screen
    projectPositionOnScreen(actor->X - cameraX, actor->Y + actor->boudingBox.Y.topRight - cameraY, actor->Z - cameraZ);
    
    if (actorIdx != bubbleActor) {
        bubbleSpriteIndex = bubbleSpriteIndex ^ 1;
        bubbleActor = actorIdx;
    }
    
    spritePtr = spriteTable[bubbleSpriteIndex];
    getSpriteSize(0, &spriteWidth, &spriteHeight, spritePtr);

    // calculate sprite position on screen
    if (bubbleSpriteIndex == SPRITEHQR_DIAG_BUBBLE_RIGHT) {
        renderLeft = projPosX + 10;
    } else {
        renderLeft = projPosX - 10 - spriteWidth;
    }
    renderTop = projPosY - 20;
    renderRight = spriteWidth + renderLeft - 1;
    renderBottom = spriteHeight + renderTop - 1;
    
    setClip(renderLeft, renderTop, renderRight, renderBottom);
    
    drawSprite(0, renderLeft, renderTop, spritePtr);
    if (textWindowLeft <= textWindowRight && textWindowTop <= textWindowBottom) {
        copyBlockPhys(renderLeft, renderTop, renderRight, renderBottom);
    }
    
    resetClip();
}

void zoomScreenScale() {
    int h, w;
	uint8 * dest;
    uint8 * zoomWorkVideoBuffer = (uint8 *) malloc((SCREEN_WIDTH * SCREEN_HEIGHT) * sizeof(uint8));
    memcpy(zoomWorkVideoBuffer, workVideoBuffer, SCREEN_WIDTH*SCREEN_HEIGHT);

	dest = workVideoBuffer;

    for (h = 0; h < SCREEN_HEIGHT; h++) {
		for (w = 0; w < SCREEN_WIDTH; w++) {
			*dest++ = *zoomWorkVideoBuffer;
			*dest++ = *zoomWorkVideoBuffer++;
		}
		//memcpy(dest, dest - SCREEN_WIDTH, SCREEN_WIDTH);
		//dest += SCREEN_WIDTH;
	}
	copyScreen(workVideoBuffer, frontVideoBuffer);
    //free(zoomWorkVideoBuffer);
}
/** @file redraw.h
	@brief
	This file contains engine redraw actions routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef REDRAW_H
#define REDRAW_H

#include "sys.h"

#define OVERLAY_MAX_ENTRIES		10

/** Auxiliar object render left position on screen */
int32 renderLeft;
/** Auxiliar object render right position on screen */
int32 renderRight;
/** Auxiliar object render top position on screen */
int32 renderTop;
/** Auxiliar object render bottom position on screen */
int32 renderBottom;

int16 drawInGameTransBox;

/** Request background redraw */
int16 reqBgRedraw;

/** Current number of redraw regions in the screen */
int32 currNumOfRedrawBox; // fullRedrawVar8
/** Number of redraw regions in the screen */
int32 numOfRedrawBox;

/** Save last actor that bubble dialog icon */
int32 bubbleActor;
int32 bubbleSpriteIndex;

enum OverlayType {
	koSprite = 0,
	koNumber = 1,
	koNumberRange = 2,
	koInventoryItem = 3,
	koText = 4
};

enum OverlayPosType {
	koNormal = 0,
	koFollowActor = 1
};

/** Overlay list structure */
typedef struct OverlayListStruct {
	int16 type;
	int16 info0; // sprite/3d model entry | number | number range
	int16 X;
	int16 Y;
	int16 info1; // followed actor | total coins
	int16 posType;
	int16 lifeTime;
} OverlayListStruct;

OverlayListStruct overlayList[OVERLAY_MAX_ENTRIES];

void addOverlay(int16 type, int16 info0, int16 X, int16 Y, int16 info1, int16 posType, int16 lifeTime);

/** Add a certain region to redraw list array
	@param left start width to redraw the region
	@param top start height to redraw the region
	@param right end width to redraw the region
	@param bottom end height to redraw the region */
void addRedrawArea(int32 left, int32 top, int32 right, int32 bottom);

/** Flip currentRedrawList regions in the screen

	This only updates small areas in the screen so few CPU processor is used */
void flipRedrawAreas();

/** Blit/Update all screen regions in the currentRedrawList */
void blitBackgroundAreas();

/** This is responsible for the entire game screen redraw
	@param bgRedraw true if we want to redraw background grid, false if we want to update certain screen areas */
void redrawEngineActions(int32 bgRedraw);

/** Draw dialogue sprite image */
void drawBubble(int32 actorIdx);

void zoomScreenScale();

#endif
BCÀŞ!    ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q  §   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l † X6„ ,@µ(şÿÿÿ ¤„ Øâ l ¶H Û@(€m À6Ì`ˆ¦ Ä   I  	   ‚`B L¢˜€’(L(ŒI‚	B#L ŒI&  ‰   Ñ   2"
 d…$¤„$ã„¡LŒ„MˆÅD s`@7ISD	“¿CXìQÂ„   €d  ‚9„á0iŠ(aòÑŠˆ +ib§ˆ&t       ¤‚-$ Â5¤ÀÁaÒQÂä³0!Â· †ÄN%L(x¸Lš"J˜ük ¾0$vŠ(aBÁÃ9ÒQÂäÏoê Í„ €c¤)¢„ÉŸßÍ¹Ğ !!q–4E”0ùš09‘éT;E”0!  @à4iŠ(aòµaZ„!¢˜ vŠ(aB‚ÀIÒQÂäkÂäDìQÂ„ì "B@@@@ A A@@@@@@@@@@@@@@@@@@@@@ A A@@@@@@@@@@@@@@@`‚¢"É,èâ"iŠ(aòYhˆÔAš	   ·HSD	“4Nƒ   €S¨qhœISD	“?;ÁN%L¨ÈÈ Ø H2ê¸Jš"J˜ü.¬‘&vŠ(aB	        @Z|H*äÀÁEÒQÂäsNS Æ‡,úDDFFˆä,iŠ(aò½kŠ€‘&vŠ(aB           €   @Ê˜ĞIb PJ" Ğ
$¹$r€ Á$ É$ôƒ Ñdp  á$ Áéñ$r@ù$Ô% À	%Ç¥eÀ¥Ç!¥‚ )¥ 1%‡ 9å  A%6 I% Qå| Yå|€ a%ˆ i ”‚K@@@€ºJÀE_%á@@ 0ú(×˜ ‘ÍÅàB@0£³‚p      PZ)¸    h­\ÔV.z+Å•æ
!   @u…à »‚p	PU”B@ aø
"      €@~¥à@ ÀRp	 `ˆ°dX.B,…€€€€ )ƒK@@@à€‹Á%    @eà@ È" ä@À %‘e’	m’EM   °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD ä	È=ÁiÀ'(ö§Ÿ Lğœ	~‚“áOPì	Î€<A'(ö§¨`Øœ¢‚3 OPä	JQA9°'8öçÀàÈ”y‚2„TP–  öçÀàØœ(¦‚SåTp²  öçÀàØœ{‚s`Opì	Î=Á9°'8òe‚ŸàdAœ	~‚ïPÚ (•$    ø’*8òe@ t Œ{‚s`Opì	Î€<A'(cT'‚`È”y‚2 OPä	Ê?Á™à'8üg‚ŸàLğœy‚2 OPä	Ê€<A'(gVåÀàÈ”y‚2 OPä	Ê€<A'(ög@ È”	~‚³†UpÚ„
Î=Á9°'8öçÀàØœy‚r`Opä	Ê€<A9°'8öçÀàØœ{‚s`OpŞô	Î€<A9°'8sZåMŸàLğœ{‚s`Opì	Î=Á¹ã*@c@ È”	~‚s`Opì	Î=Á™à'8öçÀàØœ{‚s`Opì	Î™UA9³*(gVe@ È”y‚2 OPä	Ê€<A'(òe@ È”y‚2 OPä	Ê€<A'({^g@ È”y‚2 OPä	Ê=Á9°'8`e@ È”A±‚qHV0ä	Ê€<A'(òe@ È”y‚2 OPä	Ê€<A'(òeÑ¬`<¢ŒIµ‚qÉVpì	Î¦[A9°'8ŸpçÀàØœC²‚1*WPÚ„
Î)]Á'(òe@ È”y‚2 OP&ø	Î?Á™à'8üg‚ŸàÈ”y‚2 OPä	Ê€<A9°'8ög@ È”y‚2 OPä	ÊWÁ'(òe@ Øœ{‚s`Op&ø	Î?Á9°'8öçÀàØœ{‚s`Opì	Î=Á9°'8öçÀàØœ{‚s`Opì	Î!YÁ8$+üg‚ŸàØœ{‚s`Opì	Î=Á9°'8ög‚ŸàØœ{‚s`Opì	Î=Á9°'8«våÀàØœ{‚sHV0ì	Î=Á9°'8öçÀàØœ{‚s`Op^ñ
Î¬^Á¹å+8·|²ø      Y| €     †,à  @     Cp       €!‹/      À      `È"@     0d)      ²      YÔ      †,ì  @    Cw       €!<      À€     `È"@     0d      ²À     Yè     †,ò €     Cy @    €!‹=      À€     `È¢@     0dé      ²ü     Y|     †,ø €     C– @    €!ËH      À€     `È‚@     0d)	      ²œ     YÜ     †,)€     C–• @    €!KK `    ÀE€     `Èò@     0dÑ      ²ø     Yà     †,1€     Cz @    €!<      À€     `È"@     0dq      ²€      Yf     ²@&   2˜$LŒ	&GÆC ƒ  ‚ 
 „ Z † ¢ ‹ ê  Q¡D¦“ J • r ˜ ’ š Â  â Ÿ  ¡ " £ B ¥ b § ‚ © ¢ « Â ­    y     CšHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   ï   <!IÄ@˜!
4ŒS'qMZD ’í(‚³,ˆ„8MlüŠà,"!N#[€"8Ë‚HˆÓÌ¶BøÒÙ£€ZÑ`&+@òXG4ÓÁBu‘£5#Wº¢-šji²ãT„I4”İDE,-qM^3E˜™@qM0Òµ9Óä0F* `y×ìC°Xi€BIHc°@5‘ÓL/2ÎFˆd¤ÒTD39vRHÖà°´Ä5mÎÕ:,NED€•ˆ4Yp@")È#6SäXv@4 ÀÒ×ÄNÎÃ9‹™¨€2D€Å>2¦à<‘“¤$³BDQ
0(5™Pu‘£5#—‚«Ç²âëYß"Ì³«C5ƒUÔF@Ta­@R Ñ:)°ØƒCIG,Ò`„†*€`µÄ5YÁc9‘ò"álTQ‘1
Á‚L›s™Ÿ#Ì³&ÒtÄ` 	TÍÄ
òL/°P„M9‹ã<iDH1f‹$¡	“I)QÏ LZÑ`-ö©#!â4²DD3ÑŠÇd?ÓAD×LÈ„¥+Ú¢©Æ‘ÆÇH ó,ÄJ<0tÀ#PQD4SK\Ó4ŠY4,ÜDì„±
D1q CD@êHÈ„81,°ÓD¬à¦Ùh …4ÑLN„™€©ƒ4“dàÑ€ KK\Óæ\)LmáÑ€ KK\Óæ\)Œm‡P²@!ME4“a'Å”PH›sÙ¬ C5EDÑ"aÛÒ€ KK\ÓF±HF‹ƒ4ÑLN„µ@°F³D´+1D€eY"¹Òht8iä$„0!Nc‹ÏAD¼…°,ÆÀ‡ƒ„ÖHY§@$“éÄ¢5LˆÓ` #Ì³é`Ä`òNå\!2D#6q™@$PQD4ÓJ`•ˆ4İ, lTQ‘9³`+ÑDÔba˜F„Ø˜$Ì³ D#-Â–à<ÒL-qMüD·8O„4SK\ÿQmèÎ!ÍÔ×Ä¿@d{€óDH3µÄ5ñ/éæ(-KÅøÁæ?4Âûğ>rÛvÕ,óhÂäDìD<Ö !ME4“a,’-,„­8O„4SK\ÿQnîÎ!ÍÔ×Ä¿@Ä§€ò, ÆÌ³v+`0À²8‚=XED3-Øç,‹cƒ&LNdïKCX À/á°4„ñQn„0ÏBHé`Hc˜Ñ&PQD4SêHÈ„8ØlÎ€¥SÔ­
<OD<@Dˆ’c:±˜m€&PQD4Ó‚¥‘#’Dš09‘8\6 	Tƒ+1D€µ9—ÙAODTˆCI¬@4„8\Æà<Q!%iÂäD±58ODTˆCIš09‘lÎÎâP’&LN4›`€"	DC„DäÄ6 HÑ!9²‰9Ò„ÖÑÁm®ÇÖæ\v´Î49LISlHKàL“Ã”D1É6*0`¡±O„L„&LNd¯Ò “×HC¤‘“Â„8d„Š$‘3[Ò8Óä0%QL³™8HSÍäDØ· †d)‹ôDÈD´@°V°HÑmŠd‡ 0DÄ6q CD€l‡ 0DÌ¦dNC„DäÌ†dNC„DäÄ–dNC„DäÈ¶À0€°,âpÙpÀ ˜I
$!· Y
(1D€FÈ`¶Oæ8+DÑ°°§4„Å±aU"ÁB°BDÍJD3‘Í)aq CDÀl°’@E‘I4TK\ÓF™œÒ0DÈ¦0µ^ÜşED3•Ä4QlíSëÅíÏQQD4SILÉ&ÂDD3ÑæL“Ã˜Yò¬D3Ñ[[Ñr‘£5#—(’@4„IIˆ`=ÔAD×LÈ„i ¸z,+¾µ
81q CD€Öa‰$‘c‡t ƒcÅ¦qH08–l‡t ƒcÍ¶FMÄ5ÁH38ÖæL“Ã°@Ed€$PQD4“&LN$6³Ó– 	TÍô:×4Ê‡,„)
4‚ó`ÛâJz`’58’@4ÄI1š09‘dÂŠ@EÑL$Ùq€r‘£	â4æ	T™DCµÄ5‰Í@\Ö(ğHN4u`!Q"Òd´Õ9!I«3â4¦5c6“t ƒcqÎ² â4-öæ”,D1™%V÷TÍÄ
DCˆÃeVÑâ8ØTD39&Ncú’t8V‡ ‹cPÄFÁBÂ±@‹0„}D,-qM›smÎ49ŒE9Zƒ0âpèjj¥‘-Å ÅKDqYÌPA°š09‘Å0 …È0Íë\v(Ğ Ã°CXZD ¦å<‘“¤4³BDA8±,Hc€2ˆÃe'9ÏæL“Ã°BDaH,-qMìDç,Nd™‰0Ä· †dlÇ,Ä4öò0 Ò¤ÀBL±‚›f½Ğ ÌFÕ¶çH ó,„ÆĞ„½@E&ÑP-qMĞ(æ° ÂlTQ‘mæÎ!ÍÔ×Ä§Sd[l@‚L£5ÆBXš4×#ÍàX%QL,PÖ², ¤ÀBLaƒ0ÏBH,’-,„Á
,1™DCµÄ5™LPA°ì!!6qf€"	DC|`Hö !ME4“a'Å&™t‘ã52aÈr«×zV °° 1YÑ˜ªÀ3D€Å>2MÄ°9—i,ÀÜ<NP“£!IHE˜n &PQD4“&LN¤5ã]S¤SdUÎâ8GEÑL$Y¥À",±BDÂĞ!‘­LÀÜá !±Ä4!!ÙnÀ¢Ø‘N‘=LÄ¤	“uˆ4@Xy€óDH3µÄ5ñéÕ¶ğ<‘#’¤	“¥Sd“JDF´CwÀ3 ÀÒ×´9WI“Á-€4)°ÓDXªÀc“V`/°P„¥,ÀÜá !Y­€2D€µQA°–(ğò¬Ä–€dşÑ9!Iœ³,ˆ„8MlÿÑ9!Iœ³,ˆ„8l€Ñ9!Iœ³,ˆ„8Íl”$qRL‚"Yg€Ä "lÀ²hÔµ9T#öU„4ÅV„4Éö¦<À²1ƒ}(ÑDTÅd‘SD`y4„&LˆÓH¦BIO„LÄæPÍ€4Ææ\éÙĞt‘£5#W'²Üêµ$9¦SƒåTODTˆCI!9q âP‘Ñ4À0”HCl(±…
41±O„L‹d„$ÑDÔ:…!M³éDODTˆCI!9Zc,„İ0ED3±ñÄ†ÀTÍÄNÄ#›Ú4×#ÍàX+bT„Õ<Ò!Á"ÑÁBØ¥€"8Æ
A4–ÀTÍÄNÄ3[„"	DCÌNCHÆğ,€4‘öE C¤Sd×Í€ KK\ç,NdŞĞ€ KK\Óæ\+b“U Oä$©#Åf<‘“¤$ÛòDN’:Òl#ÎD\Œ4ƒc•D1Œ’9Ã
A4ğ8- ¶:0!NcNC1h±CX›sÊ#=2ì•N‘
PÀ<!¥€!¡	“IvÓDälÄTˆCE†àH@E¤€Ñ	0„	
0À<!µ@°†MÄ5ÁH38Vë<,PVğDä¤!IÄ@˜m’Ì,
Òš09‘%8Oä$©#Å¬DcmÑ,Ä4+¸i%Mcš×9	!L©#!â4hÃ
A4&!ME4“a'Å”PHV€=‘#’TÒ´:0!N£5ÆBX  $ ”DhÂäDÀ a–p A¬Ã¼@TÓvğĞÄê8ÌDumOCw A°Ñ6ğ<ÒL-qM5ıQmŸ‡DLÜ‚<* `¡™Î@,š09‘i@,-qMìD<,’öI ó,„‰4± ØÚf ‘ÓL/2ÎF™§€Í@D¢ä˜Î@,Fà4Ä5­ÄV‰H“EE’DS:B=-,„] CX%"MFàDä¤!IÄ@˜Q0,-qM,’æĞ0€%Q‹8\Æ¥8Ñt8iä$±q$Ä5E@‰H“y)N4N9ÉlâÎ!ÍÔ×ôQ}[—âDÓá¤‘“ÈVP</áÆ Dä¤„LˆÓ´ØCX©À!=ÒL…İQED3 C ±Ñ6Ğ Â°HF´@°¦”LÎ³"Æ1Åf(@Ã°CXED3iS29ÏŠÇ4ÛR29ÏŠÇ$›j€ÒPw8ˆ@HVÒLÄ5ÁH38Vë<†Ğ<‘#’¤	“Å–Ğ<‘#’¤	“É¦Ğ<‘#’¤	“Í–—Ä”ˆqLæà0„ ¤HcPH#—y$3`-,„QYODTˆCI¥ã<iDH1f<ÒAD×LÈ„imXz­ÈÙo€")ÈóI`¶)ÄÄÀàX©#!â4f*°ÄÔ×Ä"aOJ„Çd:”DØd@#	DCœ3;!ÙtÀQ8Í”N‘ a…DäÄf€4„‘#Ûa ÒVHDÎløQC\S‡ KK\“×LfÑ@EQ‡ KK\‹d„-
LÁ‚L (FäPÍ E h€„4ÑLN„CÒAH†§ Ës %b“0‡³8ğ|`Hv*ÀHÄô9ÍÄ9‹YĞt‘£5#—Ö†¥×ŠœI-‹ã<¦Ség€Ä "lÀ²œ³9T#f°=ÒL-qM|UDô‘m3Ò–Ø€ C´ĞH›s™tÀ#PQÔ!ÀÒ×”N‘í@9^3!v¢«©•æ–<ÀÂQÒä0VUD4ç8Ñ€4ÀDH+‘#I0–) HÄ”1M„‘<qM0Òµ"Æ1YQÈa.%Ú2QLD
,Ä4    a   ò   W,      P¾$PeP¨    3ƒ0.ÃLÄ ŒË01ã2ÌDÂ¸3ƒ0.ÃLÄ ŒË01ã2ÌDÂ¸3ƒ0.ÃLÄ ŒË0¡L0‘H0D0q@0QÜÁ 2h&! eP3LB`D ‚Áˆ&€Y‚€˜Aø2†„ f„) gŒ7è‹(ãÁ(Œâ l7ÁÌ2D@ÛŒ°‚˜%(èã"£
ÁxC°
«@¸@ #¶` f	
âÆxÃÉ¼B0ŞÀBP ."ƒ1Ü i0Ë`™ÁŒƒ` f	"ƒ1Şğ2·Œ7¸Ğˆb0â‚˜%@(ÆxÍğB0ŞôP .’ƒ1Ü g0Ë(ÑÁŒpƒ` f	Šƒ1ŞÀ3äŒ7åÀˆb0b‚˜%XÈÆxCØ¤C0Ş¨(P .êƒ1Ü i0ËÀ4ıÁŒĞƒ` f	òƒ1Ş6ñŒ7ò€
ˆb0â‚˜%p(Â0!‰Â R&!0"©Âo¨›~Æ 
ÄA¯0ÆôF$‚ñ†`$tq@˜„€jaŒ7€JãAJøâ ]ã¥ÓÁxCà.A¸@ ÌB`L ‡aB ‚á-@ƒY†G
hÆ @æ0Æb''‚ñ†@'tb0" €Ìa\  ´c¼Áv|"o~Â#B ˆÆ @ğ0Ævg,‚ñ†€,òa0" €Şa\  Tc¼|Ğ"oÒâ#B ÆxÃø¬E0Ş°…HP .ˆá†`$Î`–Šò‡1Ş>qŒ7rƒÁJÀ,A4K`QHVƒ#À,A@(1.  *‰1Ş ?xŒ7y‘ƒ! Äã  •ãõÓÁxCà51@01.  z‰1Ş ?¢Œ7£ƒ! Dã  šãÿsÁxC€>1@71ÆDH5‚ñ†`5Â‚q@7bq³TPOŒñ‚`¼!ˆ³ŒÔB f	*Z¡aZ€`0¢…‚˜%°0      ö.€LÎóE¼À8Óä0/°P„}“óX¸€8Óä0Ö.,D1½ÀB¶.@ »@€˜· ±ÅdîJ„ÇôE¸@!Æ1     a   X   M,      $P¨Pş	|P¾EP    3ƒ .ÃLÄ ˆË01â2ÌD‚¸ƒÄ3 ƒƒ3 ƒB3 ƒ3 DŒá†€Ğ`–!‚Á£`–@ b7v€³Fw0 ³c¸!xÎ`–¡0‚Áä€Yƒ1Ü<g0Ëp Á`DòÀ,BÌ e7Ì2(I@Î f7Ì2(K0KÀ4.  Ò—1Ş /¤Œ7¥P
ƒ! d €şeŒ7üK*ã*ˆÁ`D@ iã  ’ã$ã
ÁxCğ
b0@Ş¸  (eÆxCÊÌB0ŞĞ‚F„ ËÜ ƒ. ¡Á 4„ƒĞ`Œ ğÄ ³†    ö-0LÎcáFàL“Ã˜· ±ÅdàE„Ç     a   *   E,      $PEP  3ƒà+Ã`D¸ Á Fh0 ³ƒÀe7Ì2D@Äo6Æ‚6h
ÄAÉo8—8Æ9p(9c¼]ì oî@¢@\ 4ñ†xÙƒ`¼!à‹q@Œ 0Ğb³aÃƒZ0 ³†   .         a   I   I,      $PEP  3ƒà+Ã`D€0KP0H\Æpƒ Á,ƒ@DŒñraƒ`¼!hƒ6 @\ ”Œñ†t‰ƒ`¼!‡q@3ÆÜÅ‚ñ†à$
ÄAÓo˜—=Æ>°(ÄˆÁ ï -F0K06,à@0¡0KFèK(À`„
0KP6(_Æpƒ Á,ƒÔñ†})…`¼!0S @\ $c¼dT!oVá(Áo(™WÆXX
ÄAl0ÆT†‚ñ† Ş€q@Œ ÀĞb³ÅÁ° @01Á Ì    .         a   5   E,      $PEPd9”a‚z3ƒà+ÃLÄM¾2FÃ Fj0 ³	ƒÈe7Ì2D@ÄoÜÀ(!c¼!‡q@3Æ;ˆ(Ac¼!ĞŠq@¼ªÆxCğ@¸@ (ãÁ(|ˆ‚ôeŒ, P×ô,Š!äñ„€#À €Y‚Â`X` Œƒ` f	   &. 6.°TÍ¤E     a   W   K,      $PERd6   38!€Ë01à2ÌD¸3ƒ .ÃLÄ8à"FË FÊ Fo0 ³ƒŠaÁ‚á†!@ƒYA	#Œ9€Y‚ŒAÉ°à	)Ã„ ÃE€³3, @@ÑO„ñ† ú€q€Ğ4èã	0ŞŒÂ(P .á†#@ƒY†Â.CXÚ†c ƒ1 ìˆ ù`fPd@`0,@PŒñ„@¸ a©¥ÁO„vÄ  ‘(‚7pƒ6 4Ôc<!.@Øc„1@ à$„€æ@f	ŒY‚ƒÜ`X` Œ€ƒ` f	†Y‚„â`X€ Œ˜ƒ` f		   ö-€,ˆ4±HF˜¹@€Ø¹@º€2ÌÃN%Læ-@,ˆ4     a   _   G,      $PEQEP…P
EV 3P.ÂLD ”‹0å"ÌDB¹3P.ÂLD ”‹0å"ÌDB¹3:!”Ë0‘d0`0q\0aX0QT0AP01L0!ôÁ Ì$Œá†@BƒYÁˆãó
Á`D c¼!…‹q€7Ì2D@’ eŒ7¨€
ƒÁ  D	rÆxC°
`0@– hŒ7® ƒÁ  „	¢ÆxCb0@š kŒ7´@ƒÁ  Ä	ÒÆxCpf0@*3éˆi #\  $c¼!ø6Œ˜%0f	
*ƒa€`0â‚˜%0     æ-@LØC˜½ÀáTD´ ˜#µØC¸@[¸@ [½@€Ø·@4…C›¸@4…S¹ ² Ñ"     a   I   G,      $PEQe 3 .ÂLD ˆ‹0â"ÌD‚¸3ƒ .ÃLD ˆ‹0â"ÌDè„ .Ã`	À`ÄñÀ`„áÀ`DÑ â!E\  6!¸  #’@ h=â±!Á 0á0Â Ìá† CƒYÁHãö2
Á`D Ec¼!(…R @\  Ã€Á,Ã@„	ºÆxC°
a0@š mŒ7®0ƒÁ  ³Ä,AAß° @0Á Ì     ¶.@4„» Ñ–lí‡SÑ`æ- Äµ}rmàBl[¸€ Û¦.         a   U  ¡  :   PeP#¥Q S%Q…Q$PEPeP5P…P€%QŠQ U0¥PTe¥Q`UP€0­P=…˜Pş	å{PfeUXEV€`HPş9Pá¾P–
QFåÿ~P€ÅQ¬åÿP€ğÅUj¨PÀER&…R*ÅRZ…P¶(Px¨P2d6@C#è‰ 'Cm°‚zbë1”á¼ '‚˜-œ¤€-Ü¤€-\¥€-œ¥€-Ü«€-œ¬€-Ü¬ e„Á%è‰ '40”Q˜ '¾  3ƒ .ÃLD ¨‹0ê"ÌD‚º3ƒ .ÃLÄ ¨Ë01ê2ÌD‚º3ƒ .ÃLDê2ÌDğ„ .ÃLÄ ¨Ë01ê2ÌD‚º3} ¨Ë01ê2ÌD‚º3ƒ .ÃLÄ ¨Ë01ê2ÌD‚º3ƒ .ÃLÄ ¨Ë01‚º3ƒ .ÃLÄ ¨Ë0‘ê2ÌD‚º3ƒ .ÃLÄ ¨Ë0Á‚º3ƒ .ÃLÄ ¨Ë01ê2ÌD‚º3ƒ .ÃL„Nê2ÌDô .ÃLD ¨‹0ê"ÌD‚º3ƒ .ÃLD"¨Ë01ê2ÌD‚º3=!¨K01ê2ÌD‚º3ƒ .ÃLDOêÌD‚º3ƒ .ÃLÄ ¨Ë01
‚ºƒvğ@ä##ì  "1a Œ 
„c¸!°‹0˜e`Ä`  Q óÃÁH„Á,ƒ@„>c¸!¨‡0˜eˆ`Ä€ €ğX…YbÄ` €R1 €¨õ ÷ä>bÄà8€ô ! ùT?cÄ   ò‚Ÿ1Ü´DÌ2G@ò3†‚ƒYãF 8Z1  À<ja–à˜%HF  Y‚d0bJc #@¡4`0BHb #Bá`0bJc f	…Aó3†„ f:ÈÆxCı¤F0A
Á )Œñ†`5vâ‚€¥@Tp:1@ú#.á†€'À`–¡ab…1ŞÌÆOP0èÄbANˆ`<Á‚ñ„À'.X
Ä2Üi0ËĞÈA@¸0Æ‚ßø–Q^`~¡ÄpCPa0ËàT¥ÃnÎf* qãAzÜƒfh˜„€ÎaŒ7î¡º¡aBb‡1ŞÌG_P0h‡†	AF ¸‘Å¨‡Ä2Üà…Ì2@T@`$.á†À.Ğ`–!¢#q€7xa³P‰d¸!Ğ4˜e˜¨€üaŒ7%R,¢‚ğĞ
Àc#ˆ@ f	¨Y‚8 ’ãÁŠèc¸!À0˜e°à  ”ãÁ‹¼ÈK¨À<°÷Ğá†ÀFÂ`–®€^bŒ76B¥aB¢‰1ŞìÈyP0ˆ”†	A('ÆxC &êAÁ T&!10 €T# Ÿã™˜ÉK¨`D°‚Ñb¸!`“0˜eÀ¸€dI\  ÃÁn˜Á,CÆTKânzf4. [ÈpC0f0Ë°qé’¸@@†ñ@ƒY†0àš‹1Şè‰\°ˆ
n+ÈnB%fŞ ¨œÄ2Ü€ˆÌ2xo:‰d¸!ğ4˜eøŞ  uÈpC "f0Ë oP;‰d¸!4˜eƒ7È4ÆxCĞ*7BÁ Ôã¬øÃˆ ´OÃ„ ´OÃ„ ƒ¶ ÅÆopeG(ÃA™„Á,ƒŒA@µ1Æ^ù
ÆxƒJùJ0ŞüJ›P0(¥†	A¨7ÆxC@.gBÁo)s	Æ‚s‰
†¦†	A,ØF°G0 ³c@ç1Æwq—–Q©`­¢ÃA½„Á,œA@ñ1.  Š1Ş S÷Œ7ø‚*ƒ! 4c¼!Ğ}¹ `)Ü
V+:Ü„LÌ2”¤c¼!:¡`ĞZ‚ĞŒñ†Àdğ„‚aD z«aB‚Á	`–Àf	Ğ€Rd\  „"c¼!®\&o^æW#B f	Ğ€^d\  Ô"c¼Á®f&oh†f#B F†æ‚Á	€vd78³iàÍÈotFg.X
Dï‚ä‹7a³n éÈoÂ†\(Ã»„Á,Ã°A@>2Æ‚²™
Æ`j@a2Æ´¡
†ú‚ÁˆÕ
€ÊdŒ7lc/ŒÁˆÖ
`– MÆxCğ6ıBÁ 5ãÜøƒÜdŒ7uó/Œ lç ‚Y‚6 ;Œ#ğ$ Â“q Œñ†ßâ›`¼!è›¾Œ <ãâõ7ÁxC :03ÜŒ x €üdŒ7œéãAéĞÌ`D@ ™×¸  hTÆx{¥N0Ş¨ÎÍF„ z €PeŒ7Ä—ëãÁëàÌ`D@ ­Êo ¯Ø	ÆÙ™™Áˆ€l€\eX@6 Œ€•` f	Ü`–àf	à`– f	ä`–`hV†f‚ÁˆZ	€heX€6 Œ°•` ¨V†j‚Áˆ[	`–@ŒØ•İ€Y‚: ]ÃAË Á,ƒ°B@½2ÆøËw‚Á\	€peŒ7à>ˆd¸!p›0˜e¸U¨WÆxCP>qC¸@@*ˆnÒ'fğ`â±Iä2ÆöI
†A†‚›1ƒY†<Ğƒ€Äl’ºŒñ†@~Şf0"€ØeŒ7ô:ˆ¤ŸÑ `0¢€äeŒ7ú£:ˆ„ìeŒ7şÓ:ˆ„ôeŒ7"ô:ˆdÄ@€1ŠÒ©¤`g–@f	RüeŒ7&$;ˆ¤‚ÜÑá†@…Â`–áø  ’ãáâ© nt¸!€¡0˜eøƒ>HeÆxC CwC¸@@ÈeÆxC`C³CÁ0" }bµ9Ü h0Ëğ~«M²™1ŞøĞîP0Œ@PùèpC Fa0Ë€
ÏŒñ†€Œè‡q€Ğ«‚ØŒñ†@ò‡q€­‚ÚŒñ† ú‡q€P®‚Œ PKÍĞ®‰d¸!°3˜e …SÈ×Ä2ÜĞÌ2„Â)nânìÇfDá7q€7øƒ³£p
íÍoFi†(¹Û0!…ÎoRÉ†(ˆhŞ†	A.  Z1Ş@o±Œ7²$Kƒ! 4;ÃH( Á @±3Æôí–‚ñ† —Ğh0" €hgX F Œ°` èwÆpC°F`0Ë@
¦íŒñ†À—|‰q€T C:ÜˆSÌ2˜B)Ä;c¼! ':¢@\  >c¼!@§;¢@\  D>c¼!`§<¢@\  # ¸TR„>c¼!€'P¢@\  ´sÃ„ ä>c¼!°§Q¢@\  V  °&!°€•Bp PşŒñ±û§`¼! )Œ şãe'RÁxC0R³4è’ PÙ €BhŒ7¨İIãJİÒ`D@ ¥İ¸  È„ÆxÃÛ±T0Ş´”.F„ PÛ €VhŒ7Ğ]LãLíÒ`D@ ¹Ğo¸;š
Æ‚š²¥Áˆ §€bhXpN Œ˜¡` f	La–àf	Pa– f	Ta–`‡†é‚Á
`– ¨†ÆˆA ¨FÁ`„ìíÔ á†€§Ì`–¡Z"Œ¨¡€YW ã¡çSÁxCğSïD¸@ *(%ŒÈ¡` (‡Æxì‘U0¡CÁ Pñ†Ô3«`¼!8«{¢@\ °’FˆQ0 $Fc¸!0'2˜exsˆŒÆpCàVa0ËP°ñ† ®Ø‰‚Ag4Æ‚¹¢%
ÆxƒìÕU@Á 6ã^c¼Áöô* `Pñ† ¯ziÄà €İj! :ãh¹ƒÔo˜„€òhŒ7¥Sr¿aBò£1Ş¨MQ0Hş†	Ah”ÆxCğZ3EÁ Sãl…c¼şh+ `Œ(  _““Ø–a[ÁpCp[a0Ë@±Ğüá† ·Ğ`–Af!Œ¨?İ€Y‚Y úÃÁn¡Á,-ÔB0a¼5 ³µ@õ7†~:ƒY[¸…`0âşhj f	nìo7ıt³¸Á`şÕÔ Ìäíß ı´ƒöoŒ ğ_Ä ´ƒöo7AÌ2èÂ8Äƒøo7AÌ2ìÂ8ôKc¼!X¯½º `)œ–V`Z;A@å4Æ‚øú+
†{‚
ö*#Ò) R§1ŞØ—hQ0*è«Œ`§` ÈÆxC _zEÁ¨@­t¸!è¯0˜eà…^(†¯‚Áˆy
`– ¨ÆxCb«EÁ°`µ@PÁjå`Ä=@ù4(ŸåÓ10 @Ì! ÄpC°ba0Ëà¿Pâ±@·@0†A0 ƒe0KğD†Á 1¡a0ƒ1bp  ©ƒIñ†@Ædì‚€¥@TĞ^XA|é1ÜàXÌ2€ƒ8ÄSc¸!P/0˜eqHƒAq²Ã`ƒf1t‡Á ;İb0F ˆ5ä0
b‚Yq˜%‡Yr˜%(‡Y• ÃoÁ,Ã9°C@xˆá† ÍÂ`–Ğ! Ÿã« Yp5…°' ìˆ ·&¨¥_|5ŞpSk¦_ˆ‚l1&!oà)8ë/
ÄAº‚Œ7„Uùâ _†	AF ĞµÅÆÎjÏø‹q@,cÄà  \àê­"Ç@\  $W£‚#‚Füb ¡c .²«Q‘A#Æ1€Ü1ñÕ¨`ÇÈ† ƒç@òˆ„@kT fdC ‚Áˆu‚ w¹c0ÈƒAîŒƒ ä„€Ü1äÁn‚4˜eH‡uèƒAïŒá!HƒYuX‡`¼!µzÍÇ(íc0hƒAôŒƒ ö„`–`Æ^kÜäŒq@Xàf ¨ÀÍr0â¶‚o -t«3
ÄQœå`„n0Ş€[ìVgˆÂ‚;Aw–ƒ¾ × ğ^cÄÀ  —„€V2¤’Á —½d0F X;b‚Y‚” ÷Ã‘Á,C;¸C0K€_c¸!Ğ30˜ex(¾ÆxCĞo¬FÁo€Éàß
Æ`„z@ö5Æ‘ƒ5
±e0LB@û5Æ‚“›5
Áe0LB@ 6Æ–³5
Ñe0LB0b`  Ü-F@ú5F X;™ë/ş
è.q€YƒTlŒ76WnxMã	EpAÀR .SFäe ‰f .‚Ë`ñ†@ìâ‚aº‰`<¡Æ‚z» `)ˆ-#J3€L3tcÃ„ ƒ§@¨Ê±aB ‚ÁˆÔ‚ 3ãÜÉİK¨àå°‚˜Óá† ïÂ`–â! ôÄBo6Æ‚½»5
†È=q€Pñ† ôx‚aD ªÏ@\  ´gc¼!8½p£`€€ô3…ÚoZÏÜ(F 18 `ı¦æf	äÖ3´Á õ­g0F x?b‚Yy õ­g0†„ fæ¡bÏ`{c¸AÒ`–ú! úÕg0¨ÔÆˆÁ õ×{ƒ¬ñ†À÷Üî‚€¥@T wZAŞí` áÚoÈü.X
D¡‡Œ7ë³õ`ıÚoÖÏç(Ô*¨»$rãü¡£‚»KB·1ŞĞŸÙQ0,ğ;Tàw9b` ÀŠÌäµÛoòïô(oc¼!à?¸oú¯ÿÆÿs=
ÄbG T¨^F°[0 ”oc¼!(Á ö(°^F¼[0 Ôoc¼!HÁ õ(ä7,„Á,Ã=àC@ô6,ğ=FØ[0 ³ø@$7Æt‚A'7Æ‚No¼! Á`üÆ‚Êq€Ø€À‚ğAá—ƒ! Ü ‘4rcÄÀ €:!˜%ÈªÓ`ƒì4T§Á18  bº¹1ŞŒa0†ÁK¨Àÿ°ônÒ0ƒY}à‡€Ún7û³ûÀj0HTƒA¤Õ`¹ƒP5tªÁ tÆˆÁ â ‡QƒÌğÃ,A?Ìœ­İnÊfşÁ$b»1ŞP«ÁÁ`DÏ@=7Æ‚<R0 @\  D®Á0!İoş0pÁ€q€PºÃ„ ”vc¼!(Å@
ÄBî‚Œ  Aswc¼!`Å€
ÄRÿépC ‹AÌ2€DHtzƒî5ák . Ø1(†`–@$hïÆxCp‹Á-ˆd¼a]]
ÆˆÁ õğb zPÈâ!w‘ŞoÀ1 Ç€q€Xp†ÆŒà‚€¥@\  ¶ Œ Ù  jÙ@\  ´¯Á ØãA;íP .è0Áx‚Œ'¡\°ˆÄ˜ ƒ1@2â½aB ‚Áˆ™‚ šùŞ0! Á`DÍÁ Îƒp6D~c¼! É $
Ä2Ş@³ÁHcÄà €J2@`–@$lƒA`Û`ØcÄà  ²ˆAlƒA`Œá!HƒY†‘(‰€Â6¶Án‚4˜e ‰’èƒ1Ş0·LÁxC“8ˆÂ^@P/9Á c¼Aoƒ›‚ñ† 'ƒr(Dàä`Dÿ@4ŒñĞz2ÆŸÎ1 @\ ¤c ‚
Ò1ÈÁˆ‚ •`0¨ƒ1b`  hƒPßƒø6ºÁ ĞÆˆÁ ½ƒÌ”Ä,IÌœÄ,JÌ¤Ä,JŒ `‡‰a0,ØÇ ƒd0K°D†Á 4Æpƒ Á,ƒ+°D0KĞƒo¼e0 ³.AoŒá†À4˜ex	º(ƒ1ŞP¾\Á`„Á c¼! Ë€$
Ä2Üˆd³0!İ`0Æ‚¼ô1 @\  ÃBpzêBä¾Á$ÆxCà—?ˆd¸¡Î`–A&f" 0ÆxC0šÁLƒAN0K0³7AcŒñ† 4—(Èxı¨ƒg@gŒñ†@5œ(D¿Á0!±a0Æ‚×v2 `Ğc¼!ÍÀ$ƒñ†`6ƒ±ÆÚÈ2 @\  v  ÿ†	Aƒ1ŞìfP–ƒF8&!10 à?É¨„A Œñ†@<ƒ¸#‚A è„A£Œñ† <¹#‚A ‡ƒI¦Œñ† =´(ÈpCœÁ,CMØD@«Œñ† =ƒ¾#‚Ñ`–`.f	n‚Z1ãÁ{ïP .a!ˆ=Á	uá‰u‹v!‹x)ŠÅ`Œ7óŒf@¸@@ÆN8°Ï  `FÄb Åb0F Ñ ?Zf1(…ƒA¹Œñ†`?ƒÕ(ˆ¢ˆ`<Á.X
Ä`Ä/ ƒÄ1ã‰´P .V3Áx‚Œ'¸\°ˆÁt tÄBíŒñ†àEß(ˆ#Ü8€Ş1Ñc0ÆÆ3 @\  V Œ ã  ªã`=Ã„ ƒv@wÂÇ`˜€`0ƒ` hƒA{ÚÇ`Œ °§Á˜ƒƒô8ÃB³9±íq0hƒ1Ü i0Ë ;(ƒş8DÊÁ RÆˆÁ àƒÌìÄ,A\Œ7ŒdĞ¦A›Ô’ÁoŞ4øÏ€q€Œ pªAšA0Ş’ÁœsŒ €ªA0Ñ’A0 ƒ,Äg0 D“Áoì4(Ñ€q€PL£‚È† ƒ·@;Œñ† O(ˆ"„`0b—ƒ` ,ƒ1Şˆj£â¡F5#Â9€Î2ãAª6P .Ë`˜€`0Âœƒ` (ƒAéJç`P:cÄà €vˆA(.ƒ1ŞÌjÀ£â1   ]ƒ€â9ÏÁopË W\F X×`‚ç`<c¸AÒ`–¡'~" xÅs0†„ f|â'²ç`P=ƒô9¤ÏÁ18 Àfb‚Y‚Ÿ˜%ˆÍ`Œ7ä´i@¸@@È4ƒ1Ş k€§â!ÕÆxCÀ®›ˆ„Â:˜&!°@LƒŒ 0²ƒ¤hF˜fÀxCióÌk@§Œ T6H4ÆP3°×À^ƒ V6#Z3`0‚5:€n3ãA¾¨P .ŠÍ`TÀªÙ„`0B§ƒ` È7ƒ1Ş€lĞªâ± TƒFøt g0Æ‚’h5 @\  Ô›Á¨ W²! Á`YÁ zc¼!`Ù W
ÄBãF¤u ±u0ˆ­ƒAlbë`Œ  ·1Áˆ h¬i@p‚ë`Œ7¤gp³ÁÍ# ¨m0½u0è­ƒ1Ü i0Ëc\ƒà:ÃB³b1Õu0ˆ®ƒAyÊë`Œ P»1Á,ÁXÌÄ…h0Æ‚±æ5 @\  ƒ÷0b€ €İôĞkÀ®»gŒ º½ô°kÀ®İg0Æê:8Û  `Œ €·A0b€ Àİì°kà§­¶Œ( `·AÚi¤mĞ§AÚiği@ãˆÄ‚}@p Fœw w .Ñ`Œ7øu ·A@Á1P Àu¹ä6Û@nBnƒ`Äà €¿B6Ù _ƒ|F 0ß dƒò5È×`Ä` €=f	â‚d4ãİ$P .ñ†î6¸Û`Ä   Ñ„`¼ÁD¼ğ61   uƒ`0BEƒ` #R4°×` (Gƒ1Şìm ²â!F.A#x;€À4ãè/P .N6Á`xÁ P™c¼!8İÀf
ÄB:Œ
t6 F˜w ±i0Æ×v6 @\  ¦Á0! Á`ÄzÁ {c¸! İ fÌâ,‚Áøj7€Y‚³ ÷ÆpC`»Ì2 EZƒñÜn0 ³iAğŒá†Àe3˜eP‹µ#ä;xÙ` f	Ö‚â;ÃÁËf0ËÀmFÌw ³Á Ì´Ùw0È¾ƒAö²ï`Œ  ¿1ùi0ÆğÒ6 @\  ã/ŒoŒ7äØk@Á1   ƒ€B<âÁo°Ó }ôF Øß`ñ`ˆc¸AÒ`–Á-à" …x0†„ fŞ.2ñ`P‰ƒT<¤âÁ18 ÀŒb‚Y¸˜%ˆ‹Y¹˜%˜š×`X@º#ê5`–À%F Ù€È<ÃAÜ`0ËPvĞšcÄ  €”#Î<İ` f	ì‚ö5ÃAşa0ËpxŒ ²ÁˆÁ  lŒ  ²Á,A^Œ °ÆÁ,A^Ğ‰b¸!èß fôÂ/Bñ@7ÿ„Á,Ã^ğE0b@  	.ÌôÅˆ $¬l0KĞƒ+€p  ³~A(Œá†àƒ0˜eøĞf	@Ã  ~   F=PLÌ3ëF>@LÄ5™ú 3×T16mŞH`¬Ä–ù8Ò¥	“¥d»ÆÄ</°XøÀ"=2éÕºá,ó¤‘“¤[îÀ21O9IêH²€09‘UÄ5EÀnÎ†t ƒc™ø€2×T1†=`LÌ×´Å’ióÌµmÆÅD0OlÇÅD0lÈÅD0ÏlÂÃãH¦<ÀHO„LDH Æ1Yú LcàôDÈD„bS[òÀ"=202L‡ñ4Œ3‹&LN”:’IóÄ¸(qM!Çdİ‡S1Åæ=p8E!“læÌD\SH Æ1Õ¼=0Ò!#ÃtØ=HO„LD:Ev>PD@cf=ÀHO„LŒÓÁú€1×T÷ö;°`•ˆ4¥dÜ LNTßF<€ ÂäDâpÙô@11œÛú 3×ˆqLvm½ôDÈDhÂäD©#ô@#=2!Çt[ğ@A\SØöÀáTD´ ˜éˆ€09QmÌÄÄ<²-óÄ–=`LÌ#×µ5óÌV>ÀLÄ5•DcLG½Ûõ@#=2!ÇÔû€1×dÛö=ĞHO„LŒÓQã       a   z   I,      $PEQeVEP(f')  3ƒğ+ÃLÄ üÊ01¿2ÌD$Â¯3} üÊ0Q8@Åoø•9#†` hãA<ú•aBBÆxC ƒ–1ŞôA5ŞøA6ŞüF¸@@ì@@ê2LB@ÔoL¡£`»‚Œ  ’7¨VÆpƒ„Á,C d+£5àÁ\	€Æ`FèJ0 ³åÊoY(ƒd ‘Á18 ÀjáÌ  ^Ã€Á,Ã@Ä/â±`@0Q/Á Ìô/â±ÀB@o0LB0¡/Á Ì42â±ÀB0Á/Á ò—aB @!ƒÿ İÁ & °€B0!2Á PÉ*™A%3¨dÆˆÁ )AB@)3(eÂ18  %âaB™A(3†„ f$ ””2c¸AÒ`–á@’™A23HfÉÌ18 `-ˆAf	ƒ ^Ã      –.ÀHO„LDH Æ1ºÀ"=202L‡­€09‘©$Ò!‘N‘y €09‘8\      a   B   I,      $P\RÀ¨@f#  3ƒà+ÃLÄ øÊ0‘¾2ÌD$‚¯# À2!@Â r# ğ‚,Bå2#Œ` #8€Y‚€1Ü0h0Ë  Á`D20K0P2†‚f# dPˆã	5á0!@ÍO¬Áˆ' Ec<!È#¦` #„! f	
¢†#¬` f	†Y‚ƒ®aA‚Áˆ,€Y‚€îeĞ½Œƒ ÎA0   	   V.@„4¹@`Ù¸@p˜¹À”9;‘ò"álTQ            /** @file renderer.c
	@brief
	This file contains 3d models render routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "renderer.h"
#include "main.h"
#include "sdlengine.h"
#include "shadeangletab.h"
#include "lbaengine.h"
#include "redraw.h"
#include "interface.h"
#include "menu.h"
#include "movements.h"

#define RENDERTYPE_DRAWLINE		0
#define RENDERTYPE_DRAWPOLYGON	1
#define RENDERTYPE_DRAWSPHERE	2

#define POLYGONTYPE_FLAT		0
#define POLYGONTYPE_COPPER		1
#define POLYGONTYPE_BOPPER		2
#define POLYGONTYPE_MARBLE		3
#define POLYGONTYPE_TELE		4
#define POLYGONTYPE_TRAS		5
#define POLYGONTYPE_TRAME		6
#define POLYGONTYPE_GOURAUD		7
#define POLYGONTYPE_DITHER		8

#define ERROR_OUT_OF_SCREEN		2



// --- structures ----

typedef struct renderTabEntry {
	int16 depth;
	int16 renderType;
	uint8 *dataPtr;
} renderTabEntry;

typedef struct pointTab {
	int16 X;
	int16 Y;
	int16 Z;
} pointTab;

typedef struct elementEntry {
	int16 firstPoint;		// data1
	int16 numOfPoints;		// data2
	int16 basePoint;		// data3
	int16 baseElement;		// param
	int16 flag;
	int16 rotateZ;
	int16 rotateY;
	int16 rotateX;
	int32 numOfShades;			// field_10
	int32 field_14;
	int32 field_18;
	int32 Y;
	int32 field_20;
	int16 field_24;
} elementEntry;

typedef struct lineCoordinates {
	int32 data;
	int16 x1;
	int16 y1;
	int16 x2;
	int16 y2;
} lineCoordinates;


typedef struct lineData {
	int32 data;
	int16 p1;
	int16 p2;
} lineData;

typedef struct polyHeader {
	uint8 renderType; //FillVertic_AType
	uint8 numOfVertex;
	int16 colorIndex;
} polyHeader;

typedef struct polyVertexHeader {
	int16 shadeEntry;
	int16 dataOffset;
} polyVertexHeader;


typedef struct computedVertex {
	int16 shadeValue;
	int16 x;
	int16 y;
} computedVertex;

typedef struct bodyHeaderStruct {
	int16 bodyFlag;
	int16 unk0;
	int16 unk1;
	int16 unk2;
	int16 unk3;
	int16 unk4;
	int16 unk5;
	int16 offsetToData;
	int8 *ptrToKeyFrame;
	int32 keyFrameTime;
} bodyHeaderStruct;

typedef struct vertexData {
	uint8 param;
	int16 x;
	int16 y;
} vertexData;

typedef union packed16 {
	struct {
		uint8 al;
		uint8 ah;
	} bit;
	uint16 temp;
} packed16;

// ---- variables ----

int32 baseMatrixRotationX;
int32 baseMatrixRotationY;
int32 baseMatrixRotationZ;

int32 baseTransPosX; // setSomething2Var1
int32 baseTransPosY; // setSomething2Var2
int32 baseTransPosZ; // setSomething2Var3

int32 baseRotPosX; // setSomething3Var12
int32 baseRotPosY; // setSomething3Var14
int32 baseRotPosZ; // setSomething3Var16

int32 cameraPosX; // cameraVar1
int32 cameraPosY; // cameraVar2
int32 cameraPosZ; // cameraVar3

// ---

int32 renderAngleX; // _angleX
int32 renderAngleY; // _angleY
int32 renderAngleZ; // _angleZ

int32 renderX; // _X
int32 renderY; // _Y
int32 renderZ; // _Z

// ---

int32 baseMatrix[3*3];

int32 numOfPrimitives;

int32 numOfPoints;
int32 numOfElements;
uint8 *pointsPtr;
uint8 *elementsPtr;
uint8 *elementsPtr2;

uint8 *pri2Ptr2;

int32 matricesTable[271];
uint8 *currentMatrixTableEntry;

int32 *shadePtr;
int32 shadeMatrix[9];
int32 lightX;
int32 lightY;
int32 lightZ;

pointTab computedPoints[800];		// _projectedPointTable
pointTab flattenPoints[800];	// _flattenPointTable
int16 shadeTable[500];

int16 primitiveCounter;
renderTabEntry *renderTabEntryPtr;
renderTabEntry *renderTabEntryPtr2;
renderTabEntry *renderTabSortedPtr;

renderTabEntry renderTab[1000];
renderTabEntry renderTabSorted[1000];
uint8 renderTab7[10000];

uint8 *renderV19;   // RECHECK THIS

// render polygon vars
int16 pRenderV3[96];
int16 *pRenderV2;

int16 vleft;
int16 vtop;
int16 vright;
int16 vbottom;

uint8 oldVertexParam;
uint8 vertexParam1;
uint8 vertexParam2;

int16 polyTab[960];
int16 polyTab2[960];
int32 renderLoop;
// end render polygon vars




int32 projectPositionOnScreen(int32 cX, int32 cY, int32 cZ) {
	if (!isUsingOrhoProjection) {
		cX -= baseRotPosX;
		cY -= baseRotPosY;
		cZ -= baseRotPosZ;

		if (cZ >= 0) {
			int32 posZ = cZ + cameraPosX;

			if (posZ < 0)
				posZ = 0x7FFF;

			projPosX = (cX * cameraPosY) / posZ + orthoProjX;
			projPosY = (-cY * cameraPosZ) / posZ + orthoProjY;
			projPosZ = posZ;
			return -1;
		} else {
			projPosX = 0;
			projPosY = 0;
			projPosZ = 0;
			return 0;
		}
	} else {
		projPosX = ((cX - cZ) * 24) / 512 + orthoProjX;
		projPosY = (((cX + cZ) * 12) - cY * 30) / 512 + orthoProjY;
		projPosZ = cZ - cY - cX;
	}

	return 1;
}

void setCameraPosition(int32 X, int32 Y, int32 cX, int32 cY, int32 cZ) {
	orthoProjX = X;
	orthoProjY = Y;

	cameraPosX = cX;
	cameraPosY = cY;
	cameraPosZ = cZ;

	isUsingOrhoProjection = 0;
}

void setBaseTranslation(int32 X, int32 Y, int32 Z) {
	baseTransPosX = X;
	baseTransPosY = Y;
	baseTransPosZ = Z;
}

void setOrthoProjection(int32 X, int32 Y, int32 Z) {
	orthoProjX = X;
	orthoProjY = Y;
	orthoProjZ = Z;

	isUsingOrhoProjection = 1;
}

void getBaseRotationPosition(int32 X, int32 Y, int32 Z) {
	destX = (baseMatrix[0] * X + baseMatrix[1] * Y + baseMatrix[2] * Z) >> 14;
	destY = (baseMatrix[3] * X + baseMatrix[4] * Y + baseMatrix[5] * Z) >> 14;
	destZ = (baseMatrix[6] * X + baseMatrix[7] * Y + baseMatrix[8] * Z) >> 14;
}

#define PI 3.1415
void setBaseRotation(int32 X, int32 Y, int32 Z) {
	int32 matrixElem;
	double Xradians, Yradians, Zradians;

	shadeAngleTab3 = &shadeAngleTable[384];

	
	baseMatrixRotationX = X & 0x3FF;
	baseMatrixRotationY = Y & 0x3FF;
	baseMatrixRotationZ = Z & 0x3FF;

    Xradians = (double)((256-X) % 1024) * 2*PI / 1024;
    Yradians = (double)((256-Y) % 1024) * 2*PI / 1024;
    Zradians = (double)((256-Z) % 1024) * 2*PI / 1024;
	

	baseMatrix[0] = (int32)(sin(Zradians) * sin(Yradians) * 16384);
	baseMatrix[1] = (int32)(-cos(Zradians) * 16384);
	baseMatrix[2] = (int32)(sin(Zradians) * cos(Yradians) * 16384);
	baseMatrix[3] = (int32)(cos(Zradians) * sin(Xradians) * 16384);
	baseMatrix[4] = (int32)(sin(Zradians) * sin(Xradians) * 16384);
	baseMatrix[6] = (int32)(cos(Zradians) * cos(Xradians) * 16384);
	baseMatrix[7] = (int32)(sin(Zradians) * cos(Xradians) * 16384);

	matrixElem = baseMatrix[3];

	baseMatrix[3] = (int32)(sin(Yradians) * matrixElem + 16384 * cos(Yradians) * cos(Xradians));
	baseMatrix[5] = (int32)(cos(Yradians) * matrixElem - 16384 * sin(Yradians) * cos(Xradians));

	matrixElem = baseMatrix[6];

	baseMatrix[6] = (int32)(sin(Yradians) * matrixElem - 16384 * sin(Xradians) * cos(Yradians));
	baseMatrix[8] = (int32)(cos(Yradians) * matrixElem + 16384 * sin(Xradians) * sin(Yradians));

	getBaseRotationPosition(baseTransPosX, baseTransPosY, baseTransPosZ);

	baseRotPosX = destX;
	baseRotPosY = destY;
	baseRotPosZ = destZ;
}

void getCameraAnglePositions(int32 X, int32 Y, int32 Z) {
	destX = (baseMatrix[0] * X + baseMatrix[3] * Y + baseMatrix[6] * Z) >> 14;
	destY = (baseMatrix[1] * X + baseMatrix[4] * Y + baseMatrix[7] * Z) >> 14;
	destZ = (baseMatrix[2] * X + baseMatrix[5] * Y + baseMatrix[8] * Z) >> 14;
}

void setCameraAngle(int32 transPosX, int32 transPosY, int32 transPosZ, int32 rotPosX, int32 rotPosY, int32 rotPosZ, int32 param6) {
	baseTransPosX = transPosX;
	baseTransPosY = transPosY;
	baseTransPosZ = transPosZ;

	setBaseRotation(rotPosX, rotPosY, rotPosZ);

	baseRotPosZ += param6;

	getCameraAnglePositions(baseRotPosX, baseRotPosY, baseRotPosZ);

	baseTransPosX = destX;
	baseTransPosY = destY;
	baseTransPosZ = destZ;
}

// ------------------------------------------------------------------------------------------------------

void applyRotation(int32 *tempMatrix, int32 *currentMatrix) {
	int32 i;
	int32 angle;
	int32 angleVar1;    // esi
	int32 angleVar2;    // ecx

	int32 matrix1[9];
	int32 matrix2[9];

	if (renderAngleX) {
		angle = renderAngleX;
		angleVar2 = shadeAngleTable[angle & 0x3FF];
		angle += 0x100;
		angleVar1 = shadeAngleTable[angle & 0x3FF];

		matrix1[0] = currentMatrix[0];
		matrix1[3] = currentMatrix[3];
		matrix1[6] = currentMatrix[6];

		matrix1[1] = (currentMatrix[2] * angleVar2 + currentMatrix[1] * angleVar1) >> 14;
		matrix1[2] = (currentMatrix[2] * angleVar1 - currentMatrix[1] * angleVar2) >> 14;
		matrix1[4] = (currentMatrix[5] * angleVar2 + currentMatrix[4] * angleVar1) >> 14;
		matrix1[5] = (currentMatrix[5] * angleVar1 - currentMatrix[4] * angleVar2) >> 14;
		matrix1[7] = (currentMatrix[8] * angleVar2 + currentMatrix[7] * angleVar1) >> 14;
		matrix1[8] = (currentMatrix[8] * angleVar1 - currentMatrix[7] * angleVar2) >> 14;
	} else {
		for (i = 0; i < 9; i++)
			matrix1[i] = currentMatrix[i];
	}

	if (renderAngleZ) {
		angle = renderAngleZ;
		angleVar2 = shadeAngleTable[angle & 0x3FF];
		angle += 0x100;
		angleVar1 = shadeAngleTable[angle & 0x3FF];

		matrix2[2] = matrix1[2];
		matrix2[5] = matrix1[5];
		matrix2[8] = matrix1[8];

		matrix2[0] = (matrix1[1] * angleVar2 + matrix1[0] * angleVar1) >> 14;
		matrix2[1] = (matrix1[1] * angleVar1 - matrix1[0] * angleVar2) >> 14;
		matrix2[3] = (matrix1[4] * angleVar2 + matrix1[3] * angleVar1) >> 14;
		matrix2[4] = (matrix1[4] * angleVar1 - matrix1[3] * angleVar2) >> 14;
		matrix2[6] = (matrix1[7] * angleVar2 + matrix1[6] * angleVar1) >> 14;
		matrix2[7] = (matrix1[7] * angleVar1 - matrix1[6] * angleVar2) >> 14;
	} else {
		for (i = 0; i < 9; i++)
			matrix2[i] = matrix1[i];
	}

	if (renderAngleY) {
		angle = renderAngleY;
		angleVar2 = shadeAngleTable[angle & 0x3FF];	// esi
		angle += 0x100;
		angleVar1 = shadeAngleTable[angle & 0x3FF];	// ecx

		tempMatrix[1] = matrix2[1];
		tempMatrix[4] = matrix2[4];
		tempMatrix[7] = matrix2[7];

		tempMatrix[0] = (matrix2[0] * angleVar1 - matrix2[2] * angleVar2) >> 14;
		tempMatrix[2] = (matrix2[0] * angleVar2 + matrix2[2] * angleVar1) >> 14;
		tempMatrix[3] = (matrix2[3] * angleVar1 - matrix2[5] * angleVar2) >> 14;
		tempMatrix[5] = (matrix2[3] * angleVar2 + matrix2[5] * angleVar1) >> 14;

		tempMatrix[6] = (matrix2[6] * angleVar1 - matrix2[8] * angleVar2) >> 14;
		tempMatrix[8] = (matrix2[6] * angleVar2 + matrix2[8] * angleVar1) >> 14;
	} else {
		for (i = 0; i < 9; i++)
			tempMatrix[i] = matrix2[i];
	}
}

void applyPointsRotation(uint8 *firstPointsPtr, int32 numPoints, pointTab * destPoints, int32 *rotationMatrix) {
	int16 tmpX;
	int16 tmpY;
	int16 tmpZ;

	int16 *tempPtr;

	int32 numOfPoints = numPoints;
	uint8 *pointsPtr;

	do {
		pointsPtr = firstPointsPtr;
		tempPtr = (int16 *)(firstPointsPtr);

		tmpX = tempPtr[0];
		tmpY = tempPtr[1];
		tmpZ = tempPtr[2];

		destPoints->X = ((rotationMatrix[0] * tmpX + rotationMatrix[1] * tmpY + rotationMatrix[2] * tmpZ) >> 14) + destX;
		destPoints->Y = ((rotationMatrix[3] * tmpX + rotationMatrix[4] * tmpY + rotationMatrix[5] * tmpZ) >> 14) + destY;
		destPoints->Z = ((rotationMatrix[6] * tmpX + rotationMatrix[7] * tmpY + rotationMatrix[8] * tmpZ) >> 14) + destZ;

		destPoints++;
		firstPointsPtr = pointsPtr + 6;
	} while (--numOfPoints);
}

void processRotatedElement(int32 rotZ, int32 rotY, int32 rotX, elementEntry *elemPtr) { // unsigned char * elemPtr) // loadPart
	int32 *currentMatrix;
	int16 baseElement;

	int32 firstPoint = elemPtr->firstPoint;
	int32 numOfPoints = elemPtr->numOfPoints;

	renderAngleX = rotX;
	renderAngleY = rotY;
	renderAngleZ = rotZ;

	if (firstPoint % 6) {
		printf("RENDER ERROR: invalid firstPoint in process_rotated_element func\n");
		exit(1);
	}

	//baseElement = *((unsigned short int*)elemPtr+6);
	baseElement = elemPtr->baseElement;

	// if its the first point
	if (baseElement == -1) {
		currentMatrix = baseMatrix;

		destX = 0;
		destY = 0;
		destZ = 0;
	} else {
		int32 pointIdx = (elemPtr->basePoint) / 6;
		currentMatrix = (int32 *)((uint8 *)matricesTable + baseElement);

		destX = computedPoints[pointIdx].X;
		destY = computedPoints[pointIdx].Y;
		destZ = computedPoints[pointIdx].Z;
	}

	applyRotation((int32 *) currentMatrixTableEntry, currentMatrix);

	if (!numOfPoints) {
		printf("RENDER WARNING: No points in this model!\n");
	}

	applyPointsRotation(pointsPtr + firstPoint, numOfPoints, &computedPoints[firstPoint / 6], (int32 *) currentMatrixTableEntry);
}

void applyPointsTranslation(uint8 *firstPointsPtr, int32 numPoints, pointTab * destPoints, int32 *translationMatrix) {
	int16 tmpX;
	int16 tmpY;
	int16 tmpZ;

	int16 *tempPtr;

	int32 numOfPoints = numPoints;
	uint8 *pointsPtr;

	do {
		pointsPtr = firstPointsPtr;
		tempPtr = (int16 *)(firstPointsPtr);

		tmpX = tempPtr[0] + renderAngleZ;
		tmpY = tempPtr[1] + renderAngleY;
		tmpZ = tempPtr[2] + renderAngleX;

		destPoints->X = ((translationMatrix[0] * tmpX + translationMatrix[1] * tmpY + translationMatrix[2] * tmpZ) >> 14) + destX;
		destPoints->Y = ((translationMatrix[3] * tmpX + translationMatrix[4] * tmpY + translationMatrix[5] * tmpZ) >> 14) + destY;
		destPoints->Z = ((translationMatrix[6] * tmpX + translationMatrix[7] * tmpY + translationMatrix[8] * tmpZ) >> 14) + destZ;

		destPoints++;
		firstPointsPtr = pointsPtr + 6;
	} while (--numOfPoints);
}

void processTranslatedElement(int32 rotX, int32 rotY, int32 rotZ, elementEntry *elemPtr) {
	int32 *dest;
	int32 *source;

	renderAngleX = rotX;
	renderAngleY = rotY;
	renderAngleZ = rotZ;

	if (elemPtr->baseElement == -1) { // base point
		int32 i;

		destX = 0;
		destY = 0;
		destZ = 0;

		dest = (int32 *) currentMatrixTableEntry;

		for (i = 0; i < 9; i++)
			dest[i] = baseMatrix[i];
	} else {   // dependent
		int32 i;

		destX = computedPoints[(elemPtr->basePoint) / 6].X;
		destY = computedPoints[(elemPtr->basePoint) / 6].Y;
		destZ = computedPoints[(elemPtr->basePoint) / 6].Z;

		source = (int32 *)((uint8 *)matricesTable + elemPtr->baseElement);
		dest = (int32 *) currentMatrixTableEntry;

		for (i = 0; i < 9; i++)
			dest[i] = source[i];
	}

	applyPointsTranslation(pointsPtr + elemPtr->firstPoint, elemPtr->numOfPoints, &computedPoints[elemPtr->firstPoint / 6], (int *) currentMatrixTableEntry);
}

void translateGroup(int16 ax, int16 bx, int16 cx) {
	int32 ebp;
	int32 ebx;
	int32 ecx;
	int32 eax;
	int32 edi;

	ebp = ax;
	ebx = bx;
	ecx = cx;

	edi = shadeMatrix[0];
	eax = shadeMatrix[1];
	edi *= ebp;
	eax *= ebx;
	edi += eax;
	eax = shadeMatrix[2];
	eax *= ecx;
	eax += edi;
	eax >>= 14;

	destX = eax;

	edi = shadeMatrix[3];
	eax = shadeMatrix[4];
	edi *= ebp;
	eax *= ebx;
	edi += eax;
	eax = shadeMatrix[5];
	eax *= ecx;
	eax += edi;
	eax >>= 14;
	destY = eax;

	ebp *= shadeMatrix[6];
	ebx *= shadeMatrix[7];
	ecx *= shadeMatrix[8];
	ebx += ebp;
	ebx += ecx;
	ebx >>= 14;
	destZ = eax;
}

void setLightVector(int32 angleX, int32 angleY, int32 angleZ) {
	// TODO: RECHECK THIS
	/*_cameraAngleX = angleX;
	_cameraAngleY = angleY;
	_cameraAngleZ = angleZ;*/

	renderAngleX = angleX;
	renderAngleY = angleY;
	renderAngleZ = angleZ;

	applyRotation(shadeMatrix, baseMatrix);
	translateGroup(0, 0, 59);

	lightX = destX;
	lightY = destY;
	lightZ = destZ;
}

// ------------------------------------------------------------------------------------------------------

FORCEINLINE int16 clamp(int16 x, int16 a, int16 b)
{
    return x < a ? a : (x > b ? b : x);
}

int computePolygons() {
	int16 vertexX, vertexY;
	int16 *outPtr;
	int32 i, nVertex;
	int8 direction, up;
	int16 oldVertexX, oldVertexY;
	int16 currentVertexX, currentVertexY;
	int16 vsize, hsize, ypos;
	int16 cvalue, cdelta;
	int64 slope, xpos;
	vertexData *vertices;

	pRenderV1 = vertexCoordinates;
	pRenderV2 = pRenderV3;

	vertices = (vertexData*)vertexCoordinates;

	vleft = vtop = 32767;
	vright = vbottom = -32768;

	for (i = 0; i < numOfVertex; i++) {
		vertices[i].x = clamp(vertices[i].x, 0, SCREEN_WIDTH-1);
		vertexX = vertices[i].x;

		if (vertexX < vleft)
			vleft = vertexX;
		if (vertexX > vright)
			vright = vertexX;

		vertices[i].y = clamp(vertices[i].y, 0, SCREEN_HEIGHT-1);
		vertexY = vertices[i].y;
		if (vertexY < vtop)
			vtop = vertexY;
		if (vertexY > vbottom)
			vbottom = vertexY;
	}
	
	vertexParam1 = vertexParam2 = vertices[numOfVertex-1].param;
	currentVertexX = vertices[numOfVertex-1].x;
	currentVertexY = vertices[numOfVertex-1].y;

	for (nVertex = 0; nVertex < numOfVertex; nVertex++) {			
		oldVertexY = currentVertexY;
		oldVertexX = currentVertexX;
		oldVertexParam = vertexParam1;

		vertexParam1 = vertexParam2 = vertices[nVertex].param;
		currentVertexX = vertices[nVertex].x;
		currentVertexY = vertices[nVertex].y;

		// drawLine(oldVertexX,oldVertexY,currentVertexX,currentVertexY,255);

		if (currentVertexY == oldVertexY) continue;

		up = currentVertexY < oldVertexY;
		direction = up ? -1: 1;

		vsize = abs(currentVertexY - oldVertexY);
		hsize = abs(currentVertexX - oldVertexX);
				
		if (direction*oldVertexX > direction*currentVertexX) { // if we are going up right
			xpos = currentVertexX;
			ypos = currentVertexY;
			cvalue = (vertexParam2 << 8) + ((oldVertexParam - vertexParam2) << 8) % vsize;
			cdelta = ((oldVertexParam - vertexParam2) << 8) / vsize;
			direction = -direction;  // we will draw by going down the tab
		} else {
			xpos = oldVertexX;
			ypos = oldVertexY;
			cvalue = (oldVertexParam << 8) + ((vertexParam2 - oldVertexParam) << 8) % vsize;
			cdelta = ((vertexParam2 - oldVertexParam) << 8) / vsize;
		}
		outPtr = &polyTab[ypos + (up? 480: 0)]; // outPtr is the output ptr in the renderTab

		slope = (int64)hsize/(int64)vsize;
		slope = up ? -slope: slope;

		for (i = 0; i < vsize + 2; i++) {
			if ((outPtr - polyTab) < 960)
			if ((outPtr - polyTab) > 0)
				*(outPtr) = (int16) xpos;
			outPtr += direction;
			xpos += slope;
		}

		if (polyRenderType >= 7) { // we must compute the color progression
			int16* outPtr = &polyTab2[ypos + (up? 480: 0)];

			for (i = 0; i < vsize + 2; i++) {
				if ((outPtr - polyTab2) < 960)
				if ((outPtr - polyTab2) > 0)
					*(outPtr) = cvalue;
				outPtr += direction;
				cvalue += cdelta;
			}
		}
	}

	return (1);
}

void renderPolygons(int32 renderType, int32 color) {
	uint8 *out, *out2;
	int16 *ptr1;
	int16 *ptr2;
	int32 vsize, hsize;
	int32 j;
	int32 currentLine;

	int16 start, stop;

	out = frontVideoBuffer + 640 * vtop;

	ptr1 = &polyTab[vtop];
	ptr2 = &polyTab2[vtop];

	vsize = vbottom - vtop;
	vsize++;

	switch (renderType) {
	case POLYGONTYPE_FLAT: {
		currentLine = vtop;
		do {
			if (currentLine >= 0 && currentLine < 480) {
				stop = ptr1[480];
				start = ptr1[0];

				ptr1++;
				hsize = stop - start;

				if (hsize >= 0) {
					hsize++;
					out2 = start + out;

					for (j = start; j < hsize + start; j++) {
						if (j >= 0 && j < 640)
							out[j] = color;
					}
				}
			}
			out += 640;
			currentLine++;
		} while (--vsize);
		break;

	}
	case POLYGONTYPE_COPPER: {
		currentLine = vtop;
		do {
			if (currentLine >= 0 && currentLine < 480) {
				start = ptr1[0];
				stop = ptr1[480];

				ptr1++;
				hsize = stop - start;

				if (hsize >= 0) {
					uint16 mask = 0x43DB;
					uint16 dx;
					int32 startCopy;

					dx = (uint8)color;
					dx |= 0x300;

					hsize++;
					out2 = start + out;
					startCopy = start;

					for (j = startCopy; j < hsize + startCopy; j++) {
						start += mask;
						start = (start & 0xFF00) | ((start & 0xFF) & (uint8)(dx >> 8)) ;
						start = (start & 0xFF00) | ((start & 0xFF) + (dx & 0xFF));
						if (j >= 0 && j < 640) {
							out[j] = start & 0xFF;
						}
						mask = (mask << 2) | (mask >> 14);
						mask++;
					}
				}

			}
			out += 640;
			currentLine++;
		} while (--vsize);
		break;
	}
	case POLYGONTYPE_BOPPER: { // FIXME: buggy
		currentLine = vtop;
		do {
			if (currentLine >= 0 && currentLine < 480) {
				start = ptr1[0];
				stop = ptr1[480];
				ptr1++;
				hsize = stop - start;

				if (hsize >= 0) {
					hsize++;
					out2 = start + out;
					for (j = start; j < hsize + start; j++) {
						if ((start + (vtop % 1))&1) {
							if (j >= 0 && j < 640) {
								out[j] = color;
							}
						}
						out2++;
					}
				}

			}
			out += 640;
			currentLine++;
		} while (--vsize);
		break;
	}
	case POLYGONTYPE_MARBLE: { // TODO: implement this
		break;
	}
	case POLYGONTYPE_TELE: { // FIXME: buggy
		int ax;
		int bx;
   		unsigned short int dx;
		unsigned short int temp;
		bx = (unsigned short)color << 0x10;
		renderLoop = vsize;
		do {	
			while (1) {
				start = ptr1[0];
				stop = ptr1[480];
				ptr1++;
				hsize = stop - start;
		
				if(hsize)
					break;

				out2 = start + out;
				*(out2) = ((unsigned short)(bx >> 0x18)) & 0x0F;

				color = *(out2 + 1);

				out += 640;

				--renderLoop;
				if (!renderLoop)
					return;
			}

			if(stop >= start)
			{
				hsize++;
				bx = (unsigned short)(color >> 0x10);
				out2 = start + out; 
            
				ax = (bx & 0xF0) << 8;
				bx = bx << 8;
				ax += (bx & 0x0F);
				ax -= bx;
				ax++;
				ax = ax >> 16;
			
				ax = ax / hsize;
				temp = (ax & 0xF0);
				temp = temp >> 8;
				temp += (ax & 0x0F);
				ax = temp;

				dx = ax;

				ax = (ax & 0x0F) + (bx & 0xF0);
				hsize++;

				if (hsize & 1) {
					ax = 0; // not sure about this
				}

				j = hsize >> 1;

				while (1) {
					*(out2++) = ax & 0x0F;
					ax += dx;

					--j;
					if (!j)
						break;

					*(out2++) = ax & 0x0F;
					ax += dx;
				}
     		}
        
			out += 640;
			--renderLoop;

		}while(renderLoop);
		break;
	}
	case POLYGONTYPE_TRAS: { // FIXME: buggy
		do {
			unsigned short int bx;

			start = ptr1[0];
			stop = ptr1[480];

			ptr1++;
			hsize = stop - start;

			if(hsize >= 0)
			{
			  hsize++;
			  out2 = start + out;
          
			  if((hsize >> 1)<0)
			  {
				bx = color &0x0FF;
				bx = bx << 8;
				bx += color &0x0FF;
   				for(j = 0; j< hsize; j++)
				{
				  *(out2) = (*(out2)&0x0F0F) | bx;
				}
			  }
			  else{
				*(out2++) = (*(out2) & 0x0F) | color;
			  }
			}
			out += 640;
		}while(--vsize);
	  break;
	}
	case POLYGONTYPE_TRAME: { // FIXME: buggy
		unsigned char bh = 0;

		currentLine = vtop;
		do {
			if (currentLine >= 0 && currentLine < 480) {
				start = ptr1[0];
				stop = ptr1[480];
				ptr1++;
				hsize = stop - start;

				if (hsize >= 0) {
					hsize++;
					out2 = start + out;

					hsize /= 2;
					if (hsize > 1) {
						uint16 ax;
						bh ^= 1;
						ax = (uint16)(*out2);
						ax &= 1;
						if (ax ^ bh) {
							out2++;
						}

						for (j = 0; j < hsize; j++) {
							*(out2) = (uint8)color;
							out2 += 2;
						}
					}
				}

			}
			out += 640;
			currentLine++;
		} while (--vsize);
		break;
	}
	case POLYGONTYPE_GOURAUD: {
		renderLoop = vsize;
		currentLine = vtop;
		do {
			if (currentLine >= 0 && currentLine < 480) {
				uint16 startColor = ptr2[0];
				uint16 stopColor = ptr2[480];

				int16 colorSize = stopColor - startColor;

				stop = ptr1[480];  // stop
				start = ptr1[0]; // start

				ptr1++;
				out2 = start + out;
				hsize = stop - start;

				//varf2 = ptr2[480];
				//varf3 = ptr2[0];

				ptr2++;

				//varf4 = (int64)((int32)varf2 - (int32)varf3);

				if (hsize == 0) {
					if (start >= 0 && start < 640)
						*out2 = ((startColor + stopColor) / 2) >> 8; // moyenne des 2 couleurs
				} else if (hsize > 0) {
					if (hsize == 1) {
						if (start >= -1 && start < 640 - 1)
							*(out2 + 1) = stopColor >> 8;

						if (start >= 0 && start < 640)
							*(out2) = startColor >> 8;
					} else if (hsize == 2) {
						if (start >= -2 && start < 640 - 2)
							*(out2 + 2) = stopColor >> 8;

						if (start >= -1 && start < 640 - 1)
							*(out2 + 1) = ((startColor + stopColor) / 2) >> 8;

						if (start >= 0 && start < 640)
							*(out2) = startColor >> 8;
					} else {
						int32 currentXPos = start;
						colorSize /= hsize;
						hsize++;

						if (hsize % 2) {
							hsize /= 2;
							if (currentXPos >= 0 && currentXPos < 640)
								*(out2) = startColor >> 8;
							out2++;
							currentXPos++;
							startColor += colorSize;
						} else {
							hsize /= 2;
						}

						do {
							if (currentXPos >= 0 && currentXPos < 640)
								*(out2) = startColor >> 8;

							currentXPos++;
							startColor += colorSize;

							if (currentXPos >= 0 && currentXPos < 640)
								*(out2 + 1) = startColor >> 8;

							currentXPos++;
							out2 += 2;
							startColor += colorSize;
						} while (--hsize);
					}
				}
			}
			out += 640;
			currentLine++;
		} while (--renderLoop);
		break;
	}
	case POLYGONTYPE_DITHER: { // dithering
		renderLoop = vsize;

		currentLine = vtop;
		do {
			if (currentLine >= 0 && currentLine < 480) {
				stop = ptr1[480]; // stop
				start = ptr1[0];  // start
				ptr1++;
				hsize = stop - start;

				if (hsize >= 0) {
					uint16 startColor = ptr2[0];
					uint16 stopColor = ptr2[480];
					int32 currentXPos = start;

					out2 = start + out;
					ptr2++;

					if (hsize == 0) {
						if (currentXPos >= 0 && currentXPos < 640)
							*(out2) = (uint8)(((startColor + stopColor) / 2) >> 8);
					} else {
						int16 colorSize = stopColor - startColor;
						if (hsize == 1) {
							uint16 currentColor = startColor;
							hsize++;
							hsize /= 2;

							currentColor &= 0xFF;
							currentColor += startColor;
							if (currentXPos >= 0 && currentXPos < 640)
								*(out2) = currentColor >> 8;

							currentColor &= 0xFF;
							startColor += colorSize;
							currentColor = ((currentColor & (0xFF00)) | ((((currentColor & 0xFF) << (hsize & 0xFF))) & 0xFF));
							currentColor += startColor;

							currentXPos++;
							if (currentXPos >= 0 && currentXPos < 640)
								*(out2 + 1) = currentColor >> 8;
						} else if (hsize == 2) {
							uint16 currentColor = startColor;
							hsize++;
							hsize /= 2;

							currentColor &= 0xFF;
							colorSize /= 2;
							currentColor = ((currentColor & (0xFF00)) | ((((currentColor & 0xFF) << (hsize & 0xFF))) & 0xFF));
							currentColor += startColor;
							if (currentXPos >= 0 && currentXPos < 640)
								*(out2) = currentColor >> 8;

							out2++;
							currentXPos++;
							startColor += colorSize;

							currentColor &= 0xFF;
							currentColor += startColor;

							if (currentXPos >= 0 && currentXPos < 640)
								*(out2) = currentColor >> 8;

							currentColor &= 0xFF;
							startColor += colorSize;
							currentColor = ((currentColor & (0xFF00)) | ((((currentColor & 0xFF) << (hsize & 0xFF))) & 0xFF));
							currentColor += startColor;

							currentXPos++;
							if (currentXPos >= 0 && currentXPos < 640)
								*(out2 + 1) = currentColor >> 8;
						} else {
							uint16 currentColor = startColor;
							colorSize /= hsize;
							hsize++;


							if (hsize % 2) {
								hsize /= 2;
								currentColor &= 0xFF;
								currentColor = ((currentColor & (0xFF00)) | ((((currentColor & 0xFF) << (hsize & 0xFF))) & 0xFF));
								currentColor += startColor;
								if (currentXPos >= 0 && currentXPos < 640)
									*(out2) = currentColor >> 8;
								out2++;
								currentXPos++;
							} else {
								hsize /= 2;
							}

							do {
								currentColor &= 0xFF;
								currentColor += startColor;
								if (currentXPos >= 0 && currentXPos < 640)
									*(out2) = currentColor >> 8;
								currentXPos++;
								currentColor &= 0xFF;
								startColor += colorSize;
								currentColor = ((currentColor & (0xFF00)) | ((((currentColor & 0xFF) << (hsize & 0xFF))) & 0xFF));
								currentColor += startColor;
								if (currentXPos >= 0 && currentXPos < 640)
									*(out2 + 1) = currentColor >> 8;
								currentXPos++;
								out2 += 2;
								startColor += colorSize;
							} while (--hsize);
						}
					}
				}
			}
			out += 640;
			currentLine++;
		} while (--renderLoop);
		break;
	}
	default: {
#ifdef GAMEMOD
		printf("RENDER WARNING: Unsuported render type %d\n", renderType);
#endif
		break;
	}
	};
}

void circleFill(int32 x, int32 y, int32 radius, int8 color) {
	int32 currentLine;

	radius += 1;

	for (currentLine = -radius; currentLine <= radius; currentLine++) {
		double width;

		if (abs(currentLine) != radius) {
			width = sin(acos((int64)currentLine / (int64)radius));
		} else {
			width = 0;
		}

		width *= radius;

		if (width < 0)
			width = - width;

		drawLine((int32)(x - width), currentLine + y, (int32)(x + width), currentLine + y, color);
	}
}

int32 renderModelElements(uint8 *pointer) {
	uint8 *edi;
	int16 temp;
	int32 eax;
//	int32 ecx;

	int16 counter;
	int16 type;
	int16 color;

	lineData *lineDataPtr;
	lineCoordinates *lineCoordinatesPtr;

	int32 point1;

	int32 point2;

	int32 depth;
	int32 bestDepth;
	int32 currentDepth;
	int16 bestZ;
	int32 j;
	int32 bestPoly = 0;
	int16 shadeEntry;
	int16 shadeValue;

	int16 ax, bx, cx;

	uint8 *destPtr;
	int32 i;

	uint8 *render23;
	uint8 *render24;
	int32 render25;

	polyVertexHeader *currentPolyVertex;
	polyHeader *currentPolyHeader;
	polyHeader *destinationHeader;
	computedVertex *currentComputedVertex;
	pointTab *currentVertex;
	pointTab *destinationVertex;

	// prepare polygons

	edi = renderTab7;			// renderTab7 coordinates buffer
	temp = *((int16*) pointer);  // we read the number of polygons
	pointer += 2;

	if (temp) {
		primitiveCounter = temp;  // the number of primitives = the number of polygons

		do {    // loop that load all the polygons
			render23 = edi;
			currentPolyHeader = (polyHeader *) pointer;
			//ecx = *((int32*) pointer);
			pointer += 2;
			polyRenderType = currentPolyHeader->renderType;

			// TODO: RECHECK coordinates axis
			if (polyRenderType >= 9) {
				destinationHeader = (polyHeader *) edi;

				destinationHeader->renderType = currentPolyHeader->renderType - 2;
				destinationHeader->numOfVertex = currentPolyHeader->numOfVertex;
				destinationHeader->colorIndex = currentPolyHeader->colorIndex;

				pointer += 2;
				edi += 4;

				counter = destinationHeader->numOfVertex;

				bestDepth = -32000;
				renderV19 = edi;

				do {
					currentPolyVertex = (polyVertexHeader *) pointer;

					shadeValue = currentPolyHeader->colorIndex + shadeTable[currentPolyVertex->shadeEntry];

					currentComputedVertex = (computedVertex *) edi;

					currentComputedVertex->shadeValue = shadeValue;

					currentVertex = &flattenPoints[currentPolyVertex->dataOffset / 6];
					destinationVertex = (pointTab *)(edi + 2);

					destinationVertex->X = currentVertex->X;
					destinationVertex->Y = currentVertex->Y;

					edi += 6;
					pointer += 4;

					currentDepth = currentVertex->Z;

					if (currentDepth > bestDepth)
						bestDepth = currentDepth;
				} while (--counter);
			} else if (polyRenderType >= 7) { // only 1 shade value is used
				destinationHeader = (polyHeader *) edi;

				destinationHeader->renderType = currentPolyHeader->renderType - 7;
				destinationHeader->numOfVertex = currentPolyHeader->numOfVertex;

				color = currentPolyHeader->colorIndex;

				shadeEntry = *((int16*)(pointer + 2));

				pointer += 4;

				*((int16*)(edi + 2)) = color + shadeTable[shadeEntry];

				edi += 4;
				renderV19 = edi;
				bestDepth = -32000;
				counter = destinationHeader->numOfVertex;

				do {
					eax = *((int16*) pointer);
					pointer += 2;

					currentVertex = &flattenPoints[eax / 6];

					destinationVertex = (pointTab *)(edi + 2);

					destinationVertex->X = currentVertex->X;
					destinationVertex->Y = currentVertex->Y;

					edi += 6;

					currentDepth = currentVertex->Z;

					if (currentDepth > bestDepth)
						bestDepth = currentDepth;
				} while (--counter);
			} else { // no shade is used
				destinationHeader = (polyHeader *) edi;

				destinationHeader->renderType = currentPolyHeader->renderType;
				destinationHeader->numOfVertex = currentPolyHeader->numOfVertex;
				destinationHeader->colorIndex = currentPolyHeader->colorIndex;

				pointer += 2;
				edi += 4;

				bestDepth = -32000;
				renderV19 = edi;
				eax = 0;
				counter = currentPolyHeader->numOfVertex;

				do {
					eax = *((int16*) pointer);
					pointer += 2;

					currentVertex = &flattenPoints[eax / 6];

					destinationVertex = (pointTab *)(edi + 2);

					destinationVertex->X = currentVertex->X;
					destinationVertex->Y = currentVertex->Y;

					edi += 6;

					currentDepth = currentVertex->Z;

					if (currentDepth > bestDepth)
						bestDepth = currentDepth;
				} while (--(counter));
			}

			render24 = edi;
			edi = renderV19;

			render25 = bestDepth;

			ax = *((int16*)(edi + 4));
			bx = *((int16*)(edi + 8));

			ax -= *((int16*)(edi + 16));
			bx -= *((int16*)(edi + 2));

			ax *= bx;

			bestDepth = ax;
			bx = currentDepth;

			ax = *((int16*)(edi + 2));
			cx = *((int16*)(edi + 10));

			ax -= *((int16*)(edi + 14));
			cx -= *((int16*)(edi + 4));

			ax *= cx;

			ax -= bestDepth;
			currentDepth -= (bx) - 1; // peut-etre une erreur la

			if (currentDepth < 0) {
				edi = render23;
			} else {
				numOfPrimitives++;

				renderTabEntryPtr->depth = render25;
				renderTabEntryPtr->renderType = 1;
				renderTabEntryPtr->dataPtr = render23;
				renderTabEntryPtr++;

				edi = render24;
			}
		} while (--primitiveCounter);
	}

	// prepare lines

	temp = *((int16*) pointer);
	pointer += 2;
	if (temp) {
		numOfPrimitives += temp;
		do {
			int32 param;
			lineDataPtr = (lineData *) pointer;
			lineCoordinatesPtr = (lineCoordinates *) edi;

			if (*((int16*)&lineDataPtr->p1) % 6 != 0 || *((int16*)&lineDataPtr->p2) % 6 != 0) {
				printf("RENDER ERROR: lineDataPtr reference is malformed !\n");
				exit(1);
			}

			point1 = *((int16*) & lineDataPtr->p1) / 6;
			point2 = *((int16*) & lineDataPtr->p2) / 6;
			param = *((int32*) & lineDataPtr->data);
			*((int32*)&lineCoordinatesPtr->data) = param;
			*((int16*)&lineCoordinatesPtr->x1) = flattenPoints[point1].X;
			*((int16*)&lineCoordinatesPtr->y1) = flattenPoints[point1].Y;
			*((int16*)&lineCoordinatesPtr->x2) = flattenPoints[point2].X;
			*((int16*)&lineCoordinatesPtr->y2) = flattenPoints[point2].Y;
			bestDepth = flattenPoints[point1].Z;
			depth = flattenPoints[point2].Z;

			if (depth >= bestDepth)
				bestDepth = depth;

			renderTabEntryPtr->depth = bestDepth;
			renderTabEntryPtr->renderType = 0;
			renderTabEntryPtr->dataPtr = edi;
			renderTabEntryPtr++;

			pointer += 8;
			edi += 12;
		} while (--temp);
	}

	// prepare spheres

	temp = *((int16*) pointer);
	pointer += 2;
	if (temp) {
		numOfPrimitives += temp;
		do {
			uint8 color = *(pointer + 1);
			int16 center = *((uint16*)(pointer + 6));
			int16 size = *((uint16*)(pointer + 4));

			*(uint8*)edi = color;
			*((int16*)(edi + 1)) = flattenPoints[center/6].X;
			*((int16*)(edi + 3)) = flattenPoints[center/6].Y;
			*((int16*)(edi + 5)) = size;

			renderTabEntryPtr->depth = flattenPoints[center/6].Z;
			renderTabEntryPtr->renderType = 2;
			renderTabEntryPtr->dataPtr = edi;
			renderTabEntryPtr++;

			pointer += 8;
			edi += 7;
		} while (--temp);
	}

	renderTabEntryPtr2 = renderTab;

	renderTabSortedPtr = renderTabSorted;
	for (i = 0; i < numOfPrimitives; i++) { // then we sort the polygones | WARNING: very slow | TODO: improve this
		renderTabEntryPtr2 = renderTab;
		bestZ = -0x7FFF;
		for (j = 0; j < numOfPrimitives; j++) {
			if (renderTabEntryPtr2->depth > bestZ) {
				bestZ = renderTabEntryPtr2->depth;
				bestPoly = j;
			}
			renderTabEntryPtr2++;
		}
		renderTabSortedPtr->depth = renderTab[bestPoly].depth;
		renderTabSortedPtr->renderType = renderTab[bestPoly].renderType;
		renderTabSortedPtr->dataPtr = renderTab[bestPoly].dataPtr;
		renderTabSortedPtr++;
		renderTab[bestPoly].depth = -0x7FFF;
	}
	renderTabEntryPtr2 = renderTabSorted;

	// prepare to render elements

	if (numOfPrimitives) {
		primitiveCounter = numOfPrimitives;
		renderV19 = pointer;

		do {
			type = renderTabEntryPtr2->renderType;
			pointer = renderTabEntryPtr2->dataPtr;
			renderV19 += 8;

			switch (type) {
			case RENDERTYPE_DRAWLINE: { // draw a line
				int32 x1;
				int32 y1;
				int32 x2;
				int32 y2;

				lineCoordinatesPtr = (lineCoordinates *) pointer;
				color = (*((int32*) &lineCoordinatesPtr->data) & 0xFF00) >> 8;

				x1 = *((int16*) &lineCoordinatesPtr->x1);
				y1 = *((int16*) &lineCoordinatesPtr->y1);
				x2 = *((int16*) &lineCoordinatesPtr->x2);
				y2 = *((int16*) &lineCoordinatesPtr->y2);

				drawLine(x1, y1, x2, y2, color);
				break;
			}
			case RENDERTYPE_DRAWPOLYGON: { // draw a polygon
				eax = *((int*) pointer);
				pointer += 4;

				polyRenderType = eax & 0xFF;
				numOfVertex = (eax & 0xFF00) >> 8;
				color = (eax & 0xFF0000) >> 16;

				destPtr = (uint8 *) vertexCoordinates;

				for (i = 0; i < (numOfVertex * 3); i++) {
					*((int16*)destPtr) = *((int16*) pointer);
					destPtr += 2;
					pointer += 2;
				}

				if (computePolygons() != ERROR_OUT_OF_SCREEN) {
					renderPolygons(polyRenderType, color);
				}

				break;
			}
			case RENDERTYPE_DRAWSPHERE: { // draw a sphere
				int32 circleParam1;
				//int32 circleParam2;
				int32 circleParam3;
				int32 circleParam4;
				int32 circleParam5;

				eax = *(int*) pointer;

				circleParam1 = *(uint8*) pointer;
				circleParam4 = *((int16*)(pointer + 1));
				circleParam5 = *((int16*)(pointer + 3));
				circleParam3 = *((int16*)(pointer + 5));

				if (!isUsingOrhoProjection) {
					circleParam3 = (circleParam3 * cameraPosY) / (cameraPosX + *(int16*) pointer);
				} else {
					circleParam3 = (circleParam3 * 34) >> 9;
				}

				circleParam3 += 3;

				if (circleParam4 + circleParam3 > renderRight)
					renderRight = circleParam4 + circleParam3;

				if (circleParam4 - circleParam3 < renderLeft)
					renderLeft = circleParam4 - circleParam3;

				if (circleParam5 + circleParam3 > renderBottom)
					renderBottom = circleParam5 + circleParam3;

				if (circleParam5 - circleParam3 < renderTop)
					renderTop = circleParam5 - circleParam3;

				circleParam3 -= 3;

				circleFill(circleParam4, circleParam5, circleParam3, circleParam1);
			}
			default: {
				break;
			}
			}

			pointer = renderV19;
			renderTabEntryPtr2++;
		} while (--primitiveCounter);
	} else {
		renderRight = -1;
		renderBottom = -1;
		renderLeft = -1;
		renderTop = -1;
		return (-1);
	}

	return (0);
}

int32 renderAnimatedModel(uint8 *bodyPtr) {
	elementEntry *elemEntryPtr;
	pointTab *pointPtr;
	pointTab *pointPtrDest;
	int32 coX;
	int32 coY;
	int32 coZ;
	uint8 *tmpElemPtr;
//	int32 *tmpLightMatrix;
	uint8 *tmpShadePtr;
	int32 numOfShades;

	numOfPoints = *((uint16*)bodyPtr);
	bodyPtr += 2;
	pointsPtr = bodyPtr;

	bodyPtr += numOfPoints * 6;

	numOfElements = *((uint16*)bodyPtr);
	bodyPtr += 2;
	elementsPtr = elementsPtr2 = bodyPtr;

	currentMatrixTableEntry = (uint8 *) matricesTable;

	processRotatedElement(renderAngleX, renderAngleY, renderAngleZ, (elementEntry *) elementsPtr);

	elementsPtr += 38;

	elemEntryPtr = (elementEntry *) elementsPtr;

	if (numOfElements - 1 != 0) {
		numOfPrimitives = numOfElements - 1;
		currentMatrixTableEntry = (uint8 *) &matricesTable[9];

		do {
			int16 boneType = elemEntryPtr->flag;

			if (boneType == 0) {
				processRotatedElement(elemEntryPtr->rotateX, elemEntryPtr->rotateY, elemEntryPtr->rotateZ, elemEntryPtr);  // rotation
			} else if (boneType == 1) {
				processTranslatedElement(elemEntryPtr->rotateX, elemEntryPtr->rotateY, elemEntryPtr->rotateZ, elemEntryPtr); // translation
			}

			currentMatrixTableEntry += 36;
			elementsPtr += 38;
			elemEntryPtr = (elementEntry *) elementsPtr;

		} while (--numOfPrimitives);
	}

	numOfPrimitives = numOfPoints;

	pointPtr = (pointTab *) computedPoints;
	pointPtrDest = (pointTab *) flattenPoints;

	if (isUsingOrhoProjection != 0) { // use standard projection
		do {
			coX = pointPtr->X + renderX;
			coY = pointPtr->Y + renderY;
			coZ = -(pointPtr->Z + renderZ);

			pointPtrDest->X = (coX + coZ) * 24 / 512 + orthoProjX;
			pointPtrDest->Y = (((coX - coZ) * 12) - coY * 30) / 512 + orthoProjY;
			pointPtrDest->Z = coZ - coX - coY;

			if (pointPtrDest->X < renderLeft)
				renderLeft = pointPtrDest->X;
			if (pointPtrDest->X > renderRight)
				renderRight = pointPtrDest->X;

			if (pointPtrDest->Y < renderTop)
				renderTop = pointPtrDest->Y;
			if (pointPtrDest->Y > renderBottom)
				renderBottom = pointPtrDest->Y;

			pointPtr++;
			pointPtrDest++;
		} while (--numOfPrimitives);
	} else {
		do {
			coX = pointPtr->X + renderX;
			coY = pointPtr->Y + renderY;
			coZ = -(pointPtr->Z + renderZ);

			coZ += cameraPosX;

			if (coZ <= 0)
				coZ = 0x7FFFFFFF;

			// X projection
			{
				coX = orthoProjX + ((coX * cameraPosY) / coZ);

				if (coX > 0xFFFF)
					coX = 0x7FFF;

				pointPtrDest->X = coX;

				if (pointPtrDest->X < renderLeft)
					renderLeft = pointPtrDest->X;

				if (pointPtrDest->X > renderRight)
					renderRight = pointPtrDest->X;
			}

			// Y projection
			{
				coY = orthoProjY + ((-coY * cameraPosZ) / coZ);

				if (coY > 0xFFFF)
					coY = 0x7FFF;

				pointPtrDest->Y = coY;

				if (pointPtrDest->Y < renderTop)
					renderTop = pointPtrDest->Y;
				if (pointPtrDest->Y > renderBottom)
					renderBottom = pointPtrDest->Y;
			}

			// Z projection
			{
				if (coZ > 0xFFFF)
					coZ = 0x7FFF;

				pointPtrDest->Z = coZ;
			}

			pointPtr++;
			pointPtrDest++;

		} while (--numOfPrimitives);
	}

	shadePtr = (int32 *) elementsPtr;

	numOfShades = *((uint16*)shadePtr);

	shadePtr = (int32 *)(((uint8 *) shadePtr) + 2);

	if (numOfShades) {   // process normal data
		int32 color;
		int32 shade;

		uint8 *currentShadeDestination = (uint8 *) shadeTable;
		int32 *lightMatrix = matricesTable;
		uint8 *pri2Ptr2;

		numOfPrimitives = numOfElements;

		tmpElemPtr = pri2Ptr2 = elementsPtr2 + 18;

		//assert(frontVideoBufferbis == frontVideoBuffer);

		do { // for each element
			numOfShades = *((uint16*)tmpElemPtr);

			if (numOfShades) {
				int32 numShades = numOfShades;

				shadeMatrix[0] = (*lightMatrix) * lightX;
				shadeMatrix[1] = (*(lightMatrix + 1)) * lightX;
				shadeMatrix[2] = (*(lightMatrix + 2)) * lightX;

				shadeMatrix[3] = (*(lightMatrix + 3)) * lightY;
				shadeMatrix[4] = (*(lightMatrix + 4)) * lightY;
				shadeMatrix[5] = (*(lightMatrix + 5)) * lightY;

				shadeMatrix[6] = (*(lightMatrix + 6)) * lightZ;
				shadeMatrix[7] = (*(lightMatrix + 7)) * lightZ;
				shadeMatrix[8] = (*(lightMatrix + 8)) * lightZ;

				do { // for each normal
					int16 col1;
					int16 col2;
					int16 col3;

					int16 *colPtr;

					colPtr = (int16 *) shadePtr;

					col1 = *((int16*)colPtr++);
					col2 = *((int16*)colPtr++);
					col3 = *((int16*)colPtr++);

					color =  shadeMatrix[0] * col1 + shadeMatrix[1] * col2 + shadeMatrix[2] * col3;
					color += shadeMatrix[3] * col1 + shadeMatrix[4] * col2 + shadeMatrix[5] * col3;
					color += shadeMatrix[6] * col1 + shadeMatrix[7] * col2 + shadeMatrix[8] * col3;

					shade = 0;

					if (color > 0) {
						color >>= 14;
						tmpShadePtr = (uint8 *) shadePtr;
						color /= *((uint16*)(tmpShadePtr + 6));
						shade = (uint16) color;
					}

					*((uint16*)currentShadeDestination) = shade;
					currentShadeDestination += 2;
					shadePtr += 2;

				} while (--numShades);
			}

			tmpElemPtr = pri2Ptr2 = pri2Ptr2 + 38; // next element

			/*tmpLightMatrix =*/ lightMatrix = lightMatrix + 9;
		} while (--numOfPrimitives);
	}

	return renderModelElements((uint8 *) shadePtr);
}

void prepareIsoModel(uint8 *bodyPtr) { // loadGfxSub
	bodyHeaderStruct *bodyHeader;
	int16 offsetToData;
	uint8 *bodyDataPtr;
	int16 numOfElement1;
	int16 numOfPoint;
	uint8 *ptrToKeyData;
	int32 i;
	int32 bp = 36;
	int32 bx = 38;
	uint8 *ptr2;

	bodyHeader = (bodyHeaderStruct *)bodyPtr;

	// This function should only be called ONCE, otherwise it corrupts the model data.
	// The following code implements an unused flag to indicate that a model was already processed.
	if (!(bodyHeader->bodyFlag & 0x80))	{
		bodyHeader->bodyFlag |= 0x80;
	}
	else {
		return;
	}

	if (!(bodyHeader->bodyFlag & 2)) {	// no animation applicable
		return;
	}

	offsetToData = bodyHeader->offsetToData;

	bodyDataPtr = bodyPtr + offsetToData + 16;

	numOfElement1 = *((int16*)bodyDataPtr);
	ptr2 = bodyDataPtr + 2 + numOfElement1 * 6;

	numOfPoint = *((int16*)ptr2);

	ptrToKeyData = ptr2 + 2;

	for (i = 0; i < numOfPoint; i++) {
		ptrToKeyData += 38;
		*((int16*)(ptrToKeyData + 6)) = (*((int16*)(ptrToKeyData + 6)) * bp) / bx;
	}
}

int renderIsoModel(int32 X, int32 Y, int32 Z, int32 angleX, int32 angleY, int32 angleZ, uint8 *bodyPtr) { // AffObjetIso
	uint8 *ptr;
	int16 bodyHeader;

	renderAngleX = angleX;
	renderAngleY = angleY;
	renderAngleZ = angleZ;

	// model render size reset
	renderLeft = 32767;
	renderTop = 32767;
	renderRight = -32767;
	renderBottom = -32767;

	if (isUsingOrhoProjection == 0) {
		getBaseRotationPosition(X, Y, Z);

		renderX = destX - baseRotPosX;
		renderY = destY - baseRotPosY; // RECHECK
		renderZ = destZ - baseRotPosZ;
	} else {
		renderX = X;
		renderY = Y;
		renderZ = Z;
	}

	// reset the number of primitives in the model
	numOfPrimitives = 0;

	// restart at the beginning of the renderTable
	renderTabEntryPtr = renderTab;

	bodyHeader = *((uint16*)bodyPtr);

	// jump after the header
	ptr = bodyPtr + 16 + *((uint16*)(bodyPtr + 14));

	if (bodyHeader & 2) { // if animated
		// the mostly used renderer code
		return (renderAnimatedModel(ptr));
	} else {
		printf("Unsupported unanimated model render!\n");
		exit(1);
	}

	return (0);
}

void copyActorInternAnim(uint8 *bodyPtrSrc, uint8 *bodyPtrDest) {
	int16 cx;
	int16 ax;
	int32 i;

	// check if both characters allow animation
	if (!(*((int16*)bodyPtrSrc)&2))
		return;

	if (!(*((int16*)bodyPtrDest)&2))
		return;

	// skip header
	bodyPtrSrc += 16;
	bodyPtrDest += 16;

	*((uint32*)bodyPtrDest) = *((uint32*)bodyPtrSrc);
	*((uint32*)(bodyPtrDest + 4)) = *((uint32*)(bodyPtrSrc + 4));

	bodyPtrSrc = bodyPtrSrc + *((int16*)(bodyPtrSrc - 2));
	bodyPtrSrc = bodyPtrSrc + (*((int16*)bodyPtrSrc)) * 6 + 2;
	cx = *((int16*)bodyPtrSrc);

	bodyPtrDest = bodyPtrDest + *((int16*)(bodyPtrDest - 2));
	bodyPtrDest = bodyPtrDest + (*((int16*)bodyPtrDest)) * 6 + 2;
	ax = *((int16*)bodyPtrDest);

	if (cx > ax)
		cx = ax;

	bodyPtrSrc += 10;
	bodyPtrDest += 10;

	for (i = 0; i < cx; i++) {
		*((uint32*)bodyPtrDest) = *((uint32*)bodyPtrSrc);
		*((uint32*)(bodyPtrDest + 4)) = *((uint32*)(bodyPtrSrc + 4));

		bodyPtrDest += 30;
		bodyPtrSrc += 30;
	}
}

void renderBehaviourModel(int32 boxLeft, int32 boxTop, int32 boxRight, int32 boxBottom, int32 Y, int32 angle, uint8 *entityPtr) {
	int tmpBoxRight;
    int x;
    int y;
    short int newAngle;

    tmpBoxRight = boxRight;

    y = boxBottom + boxTop;
    y >>= 1;

    x = boxRight + boxLeft;
    x >>= 1;

    setOrthoProjection(x, y, 0);
	setClip(boxLeft, boxTop, tmpBoxRight, boxBottom);

	if (angle == -1) {
		newAngle = getRealAngle(&moveMenu);
		if (moveMenu.numOfStep == 0) {
			setActorAngleSafe(newAngle, newAngle - 256, 50, &moveMenu);
		}
		renderIsoModel(0, Y, 0, 0, newAngle, 0, entityPtr);
	}
	else {
		renderIsoModel(0, Y, 0, 0, angle, 0, entityPtr);
	}
}

void renderInventoryItem(int32 X, int32 Y, uint8* itemBodyPtr, int32 angle, int32 param) { // Draw3DObject
	setCameraPosition(X, Y, 128, 200, 200);
	setCameraAngle(0, 0, 0, 60, 0, 0, param);

	renderIsoModel(0, 0, 0, 0, angle, 0, itemBodyPtr);
}
/** @file renderer.h
	@brief
	This file contains 3d models render routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef RENDERER_H
#define RENDERER_H

#include "sys.h"

int32 isUsingOrhoProjection;

int16 projPosXScreen; // fullRedrawVar1
int16 projPosYScreen; // fullRedrawVar2
int16 projPosZScreen; // fullRedrawVar3
int16 projPosX;
int16 projPosY;
int16 projPosZ;

int32 orthoProjX; // setSomethingVar1
int32 orthoProjY; // setSomethingVar2
int32 orthoProjZ; // setSomethingVar2

int32 destX;
int32 destY;
int32 destZ;

int16 *shadeAngleTab3; // tab3


int16 polyRenderType; //FillVertic_AType;
int32 numOfVertex;
int16 vertexCoordinates[193];
int16 *pRenderV1;

void setLightVector(int32 angleX, int32 angleY, int32 angleZ);

int32 computePolygons();
void renderPolygons(int32 ecx, int32 edi);

void prepareIsoModel(uint8 *bodyPtr); // loadGfxSub

int32 projectPositionOnScreen(int32 cX, int32 cY, int32 cZ);
void setCameraPosition(int32 X, int32 Y, int32 cX, int32 cY, int32 cZ);
void setCameraAngle(int32 transPosX, int32 transPosY, int32 transPosZ, int32 rotPosX, int32 rotPosY, int32 rotPosZ, int32 param6);
void setBaseTranslation(int32 X, int32 Y, int32 Z);
void setBaseRotation(int32 X, int32 Y, int32 Z);
void setOrthoProjection(int32 X, int32 Y, int32 Z);

int32 renderIsoModel(int32 X, int32 Y, int32 Z, int32 angleX, int32 angleY, int32 angleZ, uint8 *bodyPtr);

void copyActorInternAnim(uint8 *bodyPtrSrc, uint8 *bodyPtrDest);

void renderBehaviourModel(int32 boxLeft, int32 boxTop, int32 boxRight, int32 boxBottom, int32 Y, int32 angle, uint8 *entityPtr);

void renderInventoryItem(int32 X, int32 Y, uint8* itemBodyPtr, int32 angle, int32 param);

#endif
BCÀŞ!  ‚!  ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q  ;  f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØPÂÿÿÿÿ€P;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å lˆáÿÿÿÿ‚Êaæ¡àAÊaÒaÊ¡ÌÚ!È0‡p`‡y(€p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th€ä¡ÊÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú¡ÜáÜ¡Ø¡ÂÁ ÂŞ¡ÒÁÌaÚÀà¡Ú!è sv˜‡r wx‡6p‡pp‡yhs€‡6h‡p t Ì!ØaÊ æÂaÖ¡àAŞÊaèáä¡Ä¡ÌÁÊAÚ`ÒAÊÀ€¨w˜‡p0‡rhs€‡6h‡p t Ì!ØaÊ êaÊ¡æáÌÚÀØáÂ sv˜‡r 6ÌñÿÿÿÿìPó0m òPãóPm`ğĞá@€9„;ÌC9 „;¼C˜ƒ<„C;”CÀÃ;¤ƒ;ĞC9ÈC”;¤C; ô õPÀàïĞæ áĞåĞğğéàôPòĞåÀéĞmàïàmÀåæ îğmî`óĞæ mĞá@è ˜C8°Ã<”@¸Ã;´;„ƒ;ÌC˜<´A;„= `áÀóP 1ôã°m òğôPã@ï m õ`æPòĞóúP  D=¸Ã<„ƒ9”C˜<´A;„= `áÀóP QóPm0ï`ôĞæÀïô ˜C8°Ã<”°( Û@€m À6 `ˆ„ °†òÿÿÿÿ Ôbùÿÿÿÿˆ  I     ‚`B L†	1(Œ#˜P …q„$˜@Æ1L”	Á2a(ŒcÆ1!H  ‰   Ë   2"
 d…$¤„$ã„¡LŒ„MÜÄ”€ 0G 4@ ™0@T0G€¤P)ä£À 1Ü#M%Lşã ÍÔ   ÔÀ("R%&28 €*€.ø €2Ò)6’~ €:®’¦ˆ&?"šˆZ ğš)ÂĞ  A’4	$’èDBi’@'gISD	“¯	“™NE°SD	"   (%‘"h%‘¨%	 è%¡(æ0iŠ(aòÑŠˆ +ib§ˆ&t       ¤ÂÑ$ @Ùä  á¤@ÂaÒQÂä³0!Â· †ÄN%L(Ğ¹Lš"J˜ük ¾0$vŠ(aBÎ9ÒQÂäÏoê Í„ €c¤)¢„ÉŸßÍ¹ĞĞÓÓsš4E”0ùZƒ0-ÂQL ;E”0!!bà$iŠ(aò5ar"vŠ(aBv°Ã300001100000000000000000000011000000000000000à“òC@Tˆ(FÑÀÀÀÀ ¢h``€† Š ¤DK) ¦2Ğ9”¢(b Š€¤n’¦ˆ&ŸX†h&¯™"9         DUŠ¢*²ªÂ@a¡h€´
Q  @\% ¯B    XH¬EDVŠ¢2+Â@¡¡(‚Ô
2000000Ale(Šˆ ·‚D\)ŠH®*DWŠ"   ²+FÑÀ@ÄÀ áÌS ¤DQT5@€ISD	“_ÑD\0hH   A¼Gš"J˜üiˆ˜ 4  P!%M%Lş‚4ç8Ñ€4ÀDH¨     DJ¼Kš"J˜üÇY°—ˆ&â
	` "$  Ğ"1^$M%Lşã,XH ¡!!€éñ*iŠ(aò‡y¨‰^"šˆ   I’wISD	“8À@DìQÂ„       €ˆ¢¤J °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD 
¨HÓÀI`8	L'ià$0œ¦“À4pJÓÀI`8Hei $0œ¦“À4p˜ÎƒÔÀI`8	L'iàD@œ¦“À4p˜NÓÀI`8	Lß¡,Áj$  ÀÖÀ	Ñ(%\ß¡PÁk$  @	×Ày8	L'ià$0œ°5pbÄJÔÀY@(Hei , ”¦3¢40F”ÆˆÒÀ¨!(H¥†l ”pœ¦“c60J	×ÀéA(!Z%ià©|‡2m$  À’ÛÀR8KngHmà$0œ¦“À4p˜NÓÀI`8%\§„kà$0œ¦“À4pšœ¾CAƒ 7’  €  Jnà, ”¤²€4PJ¸NİÀé²8	L'ià$0œ¥±€4PÊÒ@Y@(H¥„kà”pœ®SÂ5pJ¸ÎÒ@Y@(Hei , ”0¼’À4pÊÒ@Y@(Hei , ”¦“À4pÊÒ@)á8%\§LoàTÉœ¦“À4p˜NÓÀI`8H%ià, ”¤’À4p˜NÓÀI`8k|%ià$0œ¦“À4p˜NÓÀI`8	L'ià$0œ7¿1<PÊÒ@Y@(Hei 
œ¤²€4PJÓÀ)áø…      `Èr
      0dI      ²¤      YR €     †,©  @     CV @    €!+      À%      `Èâ
      0d      ²Ì      Yn €     †,¹ À     C–] €    €!Ë,      Àå      `ÈÒ      0dI      ²ü      YÂ     †,ã €     C–r       €!Ë9  p    À…€     `Èr
@     0dI      ²¤      YÖ €     †,í  @     C–w       €!K<      Àe€     `ÈR@     0d¹      ²ä      d    å  2˜ LŒ	&GÆC „  ‚ * ƒ 
 RÃMdæ~v	´ÈåÚ/ƒºt4ğ×@|SÔ:pñ@ŞÛòPèI!DrNWXcÁ¥…øh]¸{A~~sÕlĞyPíaÍ‡–Ü€E".	%æ•˜]‚	š&è› u‚î‰,æ±Í"N˜-Ü·`åb­‹/Ì½ ı"4vÓ¸Scf÷5VÙ8kCÄ^7ğŞÁƒÓ<ÀôÈ×cv5>HúàíƒÎ–?ÆÿĞC$&‘óDú™Y}‘>Fd9odÏ—GÄ©Ã%İLØ4ñ×äu0Nâ9	í$ÆpOŞ>ñÿ„TÎS©S%d×UtX)g®•ıVJ]yy÷•0\Ôq‘ËE?—P]Pvyİ¥†]^~z!ïÍv_Ş~‘ÿ…{dğ’ÉO&O™|eò–Á_Æzfäšyo†ÍtgÆù}&›YlZ²1Íæ?›;mÜµ)Û†wnP¹éç&®›ònp¼YõÆß¸oÂ¿‘AGxtÂÒyM§?5upÕ!YnİuLØc'—‘vÖÚ™mG¿0wNİiwGæ»wtßéQ|Èñ)É§,ŸÒ|ÈóÑ'LŸ?}võÁ×gfŸ·}R÷ß‡Ÿ~Úø)å‡—y~Púéé'®ŸÒ~pûYï§¿ŸÀüóÔŸWzıY÷ßŸ’bşáùçìŸ¸öş!ı‡õÚvÿ	ÿçüöâÿ©ÿÿŸıúÿùÿ!„@úÿ§ÿŸığÿ©ÿ'şöÎÿ	ÿg÷ÚXÿ!ıgïŸ¸Îşáù'æŸ’ğıY÷§×ŸW@ıóÌŸúûYï·ŸÒ~âúéé¥y~xù)å§Ÿ~ø÷ß'uŸ·}föÁ×gWŸ?}ÂôÑ‡<ŸÒ|Êò)É‡Q|ÀğéG÷»wdŞiwçÔ0wôÛ™mg­‘vrÙcÇ„İuàÖ!YW5uúÓyM',xtDÑ‘A'ü¸oü½YõÇ›ònâºéç•nx·)ÛÆ]›;mş³1Í¦%›Ylr°ù}fìtgØœyoF®zfì˜Á_&o™|eò”ÉO/{dè‘ÿåív_Ğ|!ïå§]^jxyİe—P]ôs‘ËE—0\p_yy¥Ô•ıVàZ)gE‡×UBV©Så<TXQñÿäípOb<	í$0N^7ñ×„MİLP2©ÃDü—Gö9oD¦‘>FĞ™Y¤O‘óDbÑCdü–?èüàíƒ¤5>f÷È×LÓ<ØñÁï^7DÜ8kc•÷5fÖ¸Sc74ÂĞ ıÂÜ‹/Öº`åÂ}˜-â´Íb‹,è u‚¾	š&è˜˜]b^	%â’€EÂı‡–Ö|PíÈvÕá7~tp¸{Ö…ø\ZXcátrBTèI!Ûä=pñ@­SÄ7ğ×@Gƒºb1h?”#3ĞÚ¥û‘7Ir vşîüdûÜùRøÊö@õxóğñfğŞŞVİÌÛDÚ|ØôÖlÕäÓ\ÒÔĞN¿Æ½ş»xºò¸j·äµ^´Ø²R±ÌŸHÂœşšx™ô—p–ì”j“æ‘dà~^}Ü{ZzÚxXwØuXtØrXqÚ_Z^Ü\^[àYdXèVjUîStRøP~?D>Ê<R;Ú9b8ê6r5ü3Æ2P1ÜhôÀNÚjøÈXèzLÿŞırüFûÚùpøF÷ÜõrôJóäñ|ğVßğİÌÜhÛDÚâØÀ×^ÖşÔŞÓÀÒbÑDĞè¾Ì½r¼V»ş¹ä¸Ì·v¶`µJ´ö²â±Ğ°~Ÿl\Lœşšğ™â˜Ö—Ì–Â•x”p“h’b‘\XT~P}N|N{NzNyPxTwXv\ubthsprzqÂpÎ_Ú^æ]ô\B\R[dZvYÈXÜWğVFV^UvTĞSêRDR`Q~PÜ?ü>^>~=â<F<j;Ğ:ø9`9Ê8ô7`7Î6ü5j5Ú4L4~3ò2f2Ü1T1Ì0F0Àüxövöxú~BÊPÚbîzHÖföÈ\ğÆ^öĞjFâÀ`@âÆjPöŞÈr^JøèØÊ~rh^VPJFB@@@BFJPV^hr~ÊØèøJ^rÈŞöPjÆâ@`ÀâFjĞö^Æğ\ÈöfÖHzîbÚPÊB~úxövöxüÀF0Ì0T1Ü1f2ò2~3L4Ú4j5ü5Î6`7ô7Ê8`9ø9Ğ:j;F<â<~=^>ü>Ü?~P`QDRêRĞSvT^UFVğVÜWÈXvYdZR[B\ô\æ]Ú^Î_Âpzqprhsbt\uXvTwPxNyNzN{N|P}T~X\b‘h’p“x”Â•Ì–Ö—â˜ğ™şšLœ\l~ŸĞ°â±ö²J´`µv¶Ì·ä¸ş¹V»r¼Ì½è¾DĞbÑÀÒŞÓşÔ^ÖÀ×âØDÚhÛÌÜğİVß|ğäñJórôÜõF÷pøÚùFûrüŞıLÿzèXÈøjÚNÀôhÜP1Æ2ü3r5ê6b8Ú9R;Ê<D>~?øPtRîSjUèVdXàY^[Ü\Z^Ú_XqØrXtØuXwÚxZzÜ{^}à~dæ‘j“ì”p–ô—x™şšÂœHÌŸR±Ø²^´äµj·ò¸xºş»Æ½N¿ÔĞ\ÒäÓlÕôÖ|ØDÚÌÛVİŞŞfğğñxó@õÊöRøÜùdûîüvşHACAZt‹RPQ*}Ju ´Ûf§É sZ>§Cßi7”vƒàò÷¸<Ÿåoz˜^&Ëìr»ì¦ƒÌu÷XA# ô0@# 4¡i -:‰E)è”:“Î£ä|ƒàï´›>¥İ ::=µßä2;¤ Š º Œ Ú   iÑI,JAE©ô)ÕØiw™¦‡¡t9H^6—åe÷¸JÏAí0Ûü–·ËdPHA$# t¢ePuÏëpø[N/“AuwØn‡ée2¨ı&—Ù yÙM.ËC
J • j — Š š ² œ 
    y     C}HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   V  6pÄ´±:0!N“:2!Nc„/M‘¥Q9Zƒ0âp¥+Ú¢©Æ‘…0NE˜DC™c 4×#ÍàX›3Mc!Éã Í$¥Sd¡’DL m4ÒLˆÓØİTDN3½È@8UD ’,NED€•ˆ4™”óDN’:’Ì
A4vVDähÂˆÃ¥àê±¬øzf÷XN¤¼È@8UDdzÎâ8O’D$ÙĞÍ@D+b“‘M9^3!–®h‹¦Gšg òDˆN‘m ‘DLÀ:2!NcÁ‘DLš09‘ÖÁa4Èã,X¶	,mÆJ`Y@…H®„4N9	!LˆÓ˜m€" ‘°²,&°€D¬Î”:RlK HÄêL©#ÉF°€D¬Î”:Òl¯Ø9!Im4ÒLÄà-C4“Í8³`+ÑDÔba;M± ÓD4©ƒ4“d7JD4µ@°›_³8Î£	“±ñØÚ&PQD4SêHÈ„8ØlÎ€¥SÔí<OD<@Dˆ’c:±˜f€óDD…8”¤	“Å6 	Tƒ+1D€µ9—q8ODTˆCIš09Ñl›ÎâP’&LN$[…#À@h±-Ü&ğóP‘:f8dlKàL“Ã”D1ÅÖ¶Î49LI“lnKàL“Ã”D1ÍVµHO„LDa· 8’±UàL“Ãp cÓJ ‹Öa:Št ÑÁBØ_5 ,+DÑ¬„@4™d€$PQdÕ×´QEADVÄDD3ÑæL“ÃØIò¬D3Ñ[›Å aS„\«3â4±]L &0EÈµ:0!N#Æ aS„\«3â4³µÄ…L†àHÄÄZc,„¥$ÏJ4½¶¡$ÏJ4½·aÒ%›Ìñ8Ö©-9Zƒ0âpYÖ!ÀàX³]Ò›u‘ã52a®ËŠ¯gÔD\Œ4ƒcmÎ49T„=ÑDÔëD1Xe€r‘£	â4	T™DCµÄ5‰Í@\¦´ÁÍ$¥SdZ“t ƒcqÎ² â4-öF—,D1™%†€`•HCX_´8Î#6ÑLN„‰ÁØiÀe0Dh±©#!â4’Ù(ÑDT:ÎcNˆt ‘N‘ÍK ´CXYt‘£5#×‰®¦VšËÒPZ¼D4—,¡	“Ù”óDN’:ÒÌ
A4¦BT“óØ$DÎ³9Óä0¬Dc‘@E‘I4TK\Ó4Š±O„4Sa“	2ŒÖa‹ÒD\Œ4ƒc•D1±@E˜a@PA°ì!!6q™‡#8ÌCMÄ:H3I6&DäxÍ„LX'²Üêµu40Eˆ@H-,„½0MÄ•ÀØÆÕ ÔähFDHRÃTD4W
D SU!Ÿ³8ÎÃQQD4I`Ö0M@d“&LNÔ!Ò4a™Ï9!Iš09Q:Eæ`Ï³`©ƒ4“ÔF@#-À„8<Ò„ÖÑÁBXj@<Ï‚­ÎLˆÓHáKST›OáKSdÛSáKStÛÑÒPZ¤ÒL’!5Å …·ÑL’I!M±M!M²Q!M³•Ò‘Í@D%QLÖ0MÄ5ÁH38ÖŠÇÄahÓADÖ Œ8\Èr«×zFDä˜NEÖU=Q!%…DälÄTˆCEÆó4ƒi„0È„T„d^ÑâPRHDÖaFID4µÎc8Ğ!2!Á9T3‘‰,Ò„	Lrl€3E@#-ÀD€‘C=fõHO„L‹dDaLD4i±±m0ÑD¤5ÆBÈ¦ÁDD3‘Ö1òDN’:RlÈ9IêH²1 Oä$©#Í dÃ°BD)8qM0ÒUÅdŠ 0D¤›" ©#É–  CD@êH³ùPÑD´P!™Î@,ö“DD3Q¶ÕDälÄTˆCE¦0ED3‘Ö 0ƒéÄb„NC1h±CX›sYb@4×#ÍàX­ó°@EXC,C4“”N‘mQÎ9IêH1+DÑØgÀõDNBSêHÈ„8Ú°BDE( &0EÈe-F!Æ1™h€$M‡“FNBâ4FğHÄ´±:0!NcKGD4ÅÆtDD3‘l5P9Íô"álTQ‘5ÑD4Ûj@õD@HÒêLÀDŞB0D3o€Í@D¢ä˜Î@,&$ED3Q¬MÄN‘å$ÑDôÖ½áE’DS:B=-,„ı1qòXoÀ$8¦	“‰ÍDDÖ ŒbSl$Æ‚Ç$[‰± Æ1Ív 8Ñt8iä$±)(N4N9‰lŠM‡“FN2ÛJQ-D1Ù[29ÏŠÇ\29ÏŠÇ$[\29ÏŠÇ4b@3×#ÍàX­óØe@óD@H’&LN$f@óD@H’&LN4›e@óD@H’&LNmÀ ’íYODTˆCI¥ã<iDH1faÒAD×LÈ„imXz­ÈY!Æ1™%ÖĞ€D´ĞH©#ÅæĞ€D´ĞH©#ÉöĞ€D´ĞH©#ÍVàDD3Qê,˜á4’	LÑD$6ÑLN„‰ÁXOÍ@D-xÍaé™iÀ 8’™M9Zƒ0âpimXz­ÈYŞ²8Îc:‘N‘ÍÂ0Å8Î2¼D4W
D c¹SD4™Î@,ŞB0D3I `‰0D´9—IÑDÔ×L–N‘m—@EÑL&0EÈÕÁBxÍa¦0Ï³`©ƒ4“´:0!Nc`ĞAD×LÈ„èjj¥Å81•ˆqL/!LNd&QEDqqHL„dŒÏD\Œ4ƒc­ˆqL&‡@2 C    a   i   I,      4PˆPşÿ5P0…Q< 3Ä@ÃL1Ç0Aä1ÌDy3Ä@Ã`ñÀ`ÄàÀ`„Ğ ½ÇnØ fŒ  øt„F$Á |J†B#–` ˆ>-Ã!ƒM0 ÔŒá†àÎ`–A(zåÇ0! Á`D Ec¸!à4˜eˆ`0bâ`–€ kP5Jˆ@d˜€à Œ‘@ ¨f
AhD†	è%D&2L@p F H  Dã ŒH‘@ #ÔÀ `– ŒhY€Á‘ŒHY€Á5€ ˜%@(¡Á0!p ‚
è€hF†	. €Áˆ	€â`Xp" :àlBPÁíÈ0! Á 0Ñ# âƒaBúƒaB‚ `0BL˜%8#FA `– ¡Q „     ±‰‚lã‚0Û{ ñ8Ò       a   &   A,      4P 3Ä`ÃL1˜Ç0Aæ1ÌDƒy3Ä`Ã`D±À`¡À`ÄÀ`„€À`Dp c0Â<‚ bFG0 TŒÁõ€Š1¡Á P1#Ğ#€Áø`ƒÀp       Ä&È6 ±‘‚lå‚0     a      A,      4P 3Ä@ÃL1Ç0Aä1FÇ FÆ FÅ Ğ0#x# Æ`o@ÃŒà` 0     Ä&È6Ì        a      A,      4P 3Ä@ÃL1Ç0Aä1FÇ FÆ FÅ Ğ0#Ä# Æ`x@ÃŒØ` #Ôã    Ä&È6Ì        a   E   A,      4PÅQeP¥PåPD0”qDCi¥1”qDCiä1”qDCiæ1”qDCiç1”qDCiè1”qDCié1”qDCiê1”qDCië1”qDCiì   3Ä@ÃL1Ç0Aä1FØ F× FÖ 3ˆ&" g1LD`D Š%Ã„@F ¨àËÁˆù€ªAĞ0!]ƒ¤aB #6¨&"0" Akƒş yƒ¸aB ƒAŞ0!h…Á0!*¸ƒŒH‘` 0   Ä&È6Ì        a   á   A,   *   4PåÿP€Q€EP…PåP
ACG4”Æ CG4”ÆÀCG4”ÆPCG4”Æ@CG4”ÆCG4”Æ°CG4”ÆĞCG4”ÆàCG4”ÆğT0”! CièAJc ‚ ‚ H‡Ä‚ ‚ ‚ 1FğÎ¤‰‚k¦"HŒ€ ‚ ‚ c ‚ ‚ ‚ 3Ä@ÃL1Ç0Aä1ÌDy3ı01Ñy3ı01q”Á Fd0 ƒÅÀ`D|4@Ç¨@t0B>‚ dT@:1Á P2*0Œ ` ¨vA*8»@É*¨¤‚J*¨h0
€¦an„ 7°”¬N*à¤#¬€ (VA*¨»@É*©`¤‚1 Á.  âÈˆ‘ ıĞGFˆø‡ †@*`¹`€#ì  2b@$ÀHÅATrÁ FèA0 „dÄ€H€”hÈˆ‘ *ÔHx Ğ`(@o@Fˆx‰€æ€Œ	 ATğrÁ F¬B0 ddÄ€H€›HÈˆ‘ 9ÔH¦ Ğ`D+@}@Fˆè‰€BŒ	ğATĞ
rÁ FàB0 D
dÄ€H€²Èˆ‘ fÔH´ Ğ`„.@à0#^! j2b@$@[ã%«!’2b@$@\å-"è"¨!:¸`€#Ü! Ò2b@$@^äã%«!ú2b@$À_µĞ8"B#¨!:‚¸`€#è! Ò‡1¡Á :"P# v(Y;"Z#¨|„àŒ	ğAÔÄ4Á P="h# |(YĞ>"t#(“„úŒ	ĞAÔÀ4áÁ P¾Ê—Aù2F 0Aè^Æ`Ê@÷2#P& º—12Á `8   Ä&È6Ì&( 0À!—·Œ
 rĞH6(€Ä0 @#Y¡ 2GÀ€      a   E   A,      4PÅQÅPåP¥PD0”qDCi¥1”qDCiæ1”qDCiç1”qDCiä1”qDCiè1”qDCié1”qDCiê1”qDCië1”qDCiì   3Ä@ÃL1Ç0Aä1FØ F× FÖ 3ˆ&" g1LD`D Š%Ã„@F ¨àËÁˆù€ªAĞ0!]ƒ¤aB #6¨&"0" Akƒş yƒ¸aB ƒAŞ0!h…Á0!*¸ƒŒH‘` 0   Ä&È6Ì        a   A   A,      4P 3Ä€ÃL1 Ç0Aè1ÌDz3Ä€ÃL1 Ç0Aè1FÏ FÎ FÍ FÌ FË FÊ FÉ Ğ1#È# :Æ`y@ÇŒ ` èt:Æˆ ²0ƒæcX €`0¢>‚ ûtƒîcŒ PƒzŒÁø€ÔcFÀG0 ¤c0>‚Àp       VpDÎ”:’læGäL©#ÍLĞH©#Å&LĞH©#É6LĞH©#Ív`<@0º‘‘3¥    a   š  V,      4PÅQÅP¥PQåÿP€%  3f0ŒÇ0aÃx3Ä0ÃL1ŒÇ0Aã1ÌDÃx3Ç0ÃLÄ1ŒÇ0X0qT@¾1†‚9ƒY†@<Æ` !£‚GÇøã
Ä2±@Í°`Á`Ä =£KÇFÄ
Ä21@ÖOD‚1Ş@‘)FÂ 6Æ3 `Œ7`¨€ƒ0 äñ„ (ã+¬Á`D  ‰ÁOØ€‚Aa0LD@g0Æ‚: `Ğ˜€ ‚<Èñ†4È…=Œ„ 7ã	AP0è†	ˆÆxB 
šƒaB 3‚T`
9Ş`æ@
ƒ0 Äc<!(
íÁ0!…ÂOR‚A¡0LD`F ‚
f!ÇFa^a0"€RaŒ'²@Á T&" Wã	-P0¨†	ÌBP8äx,€D/FÂ -Œñ„ (TÃ„@´c<!
íÂ0!*h‡oè…–8‡Áˆ@ ‡1¨ƒÆa˜ˆ€ĞaŒ'î@Á s&"0#Aúãê õ00KpF¼ÃNÀ,Á@ï0†‚y@ƒYÂ(ÍÃO
ÕÃo±#‚a f	
º‡aI€`0"‚˜%f	‚•1Ü˜EÌ2 I@²2#ö! Ú‡QHèxÃ»¨E@¸`@#ü! ‰aI€`0B$‚ ‘¤„7ØK\ˆd0Â$‚o 	º	
ÆxCIØMFÂ Œ7œÄ]Ğc¼%òÂ&#a ÆTB/j‚‚1Ş°|qƒ0 ã-Ñ?AÁ ˜&"oˆ‰Ğ
ÕÄ0!*8‹o°‰Ó8Áˆ@€ñœ@µ `OŒ7ğk°ƒ~b˜ˆÀŠ ÈE7„…lĞÅ`D ÀxÃXÌÆ[P0È,†	ÆÎâ6î‚‚Ak1LD`E ‚
ú"ÇØ¢7úb0"`¼Á-|C/($Ã„@ãr!¢AÁ º&"°"A¨‘ãw¤10Şé1â‹aB ‚ñ†¾hÖ `PhX€ ‚ÙÈñÑ˜ÙŒ„o úp
¡Æ0!ÁxjàÇmP0h5†	¬BPoäxCkønFÂ Ì8ƒ³ñ0K ĞlŒá†à6Ğ`–aiª1Ş "P07Æxm”H00KÀnÒƒ¼À,2KàÜŒá† EÂ`–á¢›1áÁ oŒ
ÊCÇd§E
Ä2Á ĞxÒƒå •Ç¨€=t¼!wh$ @\0 ƒéÀxƒyÜH~P0è=ÆxBÀƒÁ0 ãê±#÷AÁ ùã	~FÃ Œ7¸ÇäƒîcŒ'ü10Ş c2&ºaB ‚ñû8“¡`~X„ ‚I‘1¸É`D0Àxƒ¼É›P0HD†	ÆDdNb„‚A'2LD`E ‚
r$éEÆxB€#ƒÁ0 ã*²';BÁ &"op‘?á
ÉÈ0!A*(“¤ã	™FÃ Œ7ØÈ©œ	ƒtd˜ˆ`¼AGVM(ô#Ã„@V ¨ N’ÎdŒ'o20Ş &³"':“aB ‚ñ3¹9¡`šX„ ‚>Iš“1ôÉ`D0Àxƒ›üŠŸP0HN†	Æäd\ü„‚Aw2LD`E ‚
R%éOÆxBP*ƒÁ0 ³Õ`ÄŸ¬Ë ÌDô'c¸!4˜e¨€BeŒ7ô‰»"•A§2Æa0" `–`¢SØ
#R%€Y‚h– Âp    6 ±/ÕF ±/ÙVp0À!WmòĞaâ@EÑL&0EÈeñböLrÙ Ló˜À!        a   “   D,      4PEPÅP…P
åP5    3ÒPÃL1”Ç0áCy3f0”Ç0Qå!ÌDCy3ÅPÂL2”Ç0Aå1ÌDHCyƒ
6 ƒÉ5 ƒˆ5 ƒG5 ”ŒÁˆ!€Y‚€–11@Ì¸ `#` èã	AP #š@ Hã	GŒx fŒ'b0"
€¨1ˆƒ,qÁ€Øˆ€´1 ƒ6qÁ€ØˆÀ c<!p
…¸`@lD`G ‚
æ )E†	.  jƒ1Şè‚.Fƒ Œñ„ (â‚±!ÑÁOú€‚Au .Ø€€ö`Œ'£@Á =ˆì@PA+$‰É0! Á @§0Æz …Áˆ` B…1ÌƒTA\0 6" Wã	A-P0èÄbC ;P-Œñ„`(Tâ‚±!*8‡¤=& ¸  (ÆxCàí0@ã0ÆxŒ(‡` ÈÆxBğƒéÀ,@á0,XFŒC0 ÃAM„Á,C0    v°4ƒ©ƒ4“døÉã Í$¥SdäNäLÀ„8	LrÙ| 11OlôÄÄ<²…8ISê Í$¥SdõÄÄ<³‰$Å¤ÒL’(!M©ƒ4“döÇD0O:E       a   ‹   H,      4PÅPePD0”qDCi¥AC7”ÆP¶C¥1”    3ÄPÃL1”Ç0Aå1ÌDüÃPÃL„å1ÌDCy3ÄPÃL1”Ç0Aå1F$Ö F Õ FÔ FÓ 1Æ‚9˜
Ä2q@Êoîà¢@\0 ƒJ0 ôŒÁˆó€¢1aÁ Ğ4#Ğ# rF7³Œ Úˆ¡ ¹JÕoDá£@FX %.á†@À`–a ‚ÁM`0B?Na #òã`0?Na f	
ÚÆxC€
f@¸`@*PŒØ‚ O\0 ã	g\@°ƒc }c¼?b!odA(È`Š@d0ÆúÃ‚ñ†àî€qÁ€F°H0 ”c¼ADv!oxA(È`Œ0KPP‰Œ–è`Œ àB@r0†‚qƒY†ÃF è>˜%8(EİÁOÂƒAz0*Ho‘uHFÆ;bp @JÆ`8     f€<ÒLâp}€R ‘4¥ÒLV°4ƒ©ƒ4“dóK H„·ÑL&ĞTÍdS„\FpÁ¤SdãDäL±‰‘3É@DÎ4    a      D,      4PEPÅP…P
åP5    3ÒPÃL1”Ç0áCy3f0”Ç0Qå!ÌDCy3ÅPÂL2”Ç0Aå1ÌDHCyƒ
6 ƒÉ5 ƒˆ5 ƒG5 ”ŒÁˆ!€Y‚€–11@Ì¸ `#` èã	AP .:aB ‚ `0"
€œ1€â‚¡ö& ¸  #®@ ¨ã	P .²aB ‚ `0¢€À`Œ'®@Á 1ˆÈÆxB@:qÁ€ØˆÀ Ôc<!Ğ
µ¸`@lD`G ‚
ş ©F†	.  Êƒ1Ş˜ƒ9Fƒ Œñ„€(Äâ‚±!ÂOR‚A¡ .Ø€€NaŒ'¯@Á Sˆì@PA.$¹É0! Á @³0Æ ‡Áˆ` ¢…1üƒlA\0 6" ]ã	A8P0hÄbC ;P8Œñ„à(â‚±!*˜‡¤S& ¸  ¨ÆxC ù0@ï0Æ~Œˆ‡` HÆxB°ƒõÀ,@í0,¸F¼C0 ÃAX„Á,C0     v°4ƒ©ƒ4“døÉã Í$¥SdäÑ´ â4&0EÈeóÄÄ<±ÑóÈàH$M©ƒ4“”N‘ÕóÌ&4“:H3I6 „4¥ÒL’ÙÁ<é    a   ‘   L,      4PEPeP5@¶ 3ÄPÃL1”Ç0Aå1ÌDüÃPÃL„å1ÌD˜ÁPÃL1”Ç0Aå1F Ó FÒ FÑ FĞ 2#x# BÆ`Än@ÈŒè` ãÁ@ˆd¸!ˆÀ`–!0‚Áõ¸ƒŒH;€Áô¸ƒ Şì`„À`“0K 3†f†" gŒ7ÀŠQc<!#b f	¢†b ‚Á+€Ya–`¡lŒ7¤0ˆ¤‚2 ñ†÷@…`¼!H…T @\0 ƒÿ ‰ÁoZ(Hn@ãøÁxC r@¸`@#N$ Zƒ1ŞØBP .
î€ÆBD‚ñ†`ô€qÁ€F¼H0 Dc¼!ø> @\0 ã	|\@°ƒx ©È¸€`#ö €Á<0‡˜%8ÆpC0
h0Ë€(éÁ >ã	@Á ?$
c<!#b f	
…a,€`0b‚˜%8f	ª‘A¨0Æ‚y˜
Ä2PÔ
c¼!À\ @\0 c¼!à~ @\0 ô7œ	Ht&ã‚18 @'šd0    @„4Y|€!9T$FpÁ¤SdòbóR[x 9SlâDäL²‘3Í      a   Œ   A,      4PÅQeP¥PåPD0”qˆÁPCieb0”Æ@C‡¥1˜ÇPÆ!Ciç1”qˆÁPzeb0”ÆC‡¥1¨ÇPÆ!Cië1”qˆÁP{ 3Å@ÂLD1‡0Qä!ÌDy3Ä@ÃL1Ç0Aä1ÌDyƒH' ƒ' ƒÆ& „ˆd0â€qÁ€F Á ".Áˆ$ ºÆ` ]c0B	€šAÊ°@Á` =ƒœa ‚Á( ‚AÃƒR0 c0‚
€ªAÕ°@Á`Ä Yƒ°a ‚Á- ÒFrƒ\0 ÄÁˆ	€Ò`FtÁ PŒÁˆ/ ƒAß°@Á`D@d0h†‚#Ê  *ƒAe0,@0qÁ ŒÁˆ4€Ô`F°A0 ´ƒÚ`X €`0â‚ 7œBFÄA0 c0bG‚ =dÃAƒx õÁ <"ŒĞƒ` èéÁ°@Á`@~0È†#@! úƒA¡0,@01
Á Ğ(Œ
r!#J! …1Á&Á `8    ¶0Âeı1 –0Ácáp™x€\6 —ñp™~À@      a   +   A,      Pv4PD0”qˆÁPCieÑPCi    3ÄPÃL1”Ç0Aå1FÊ FÉ FÈ Ğ0#f# Æ`„l@ÃŒ ` F
 (ä10ÀÖ`â1ÁÁ oŒÁÖ€xcF°F0    &` ±²@c,ÄláĞ    a   Á  k     PşÿHPş	å{@%PQÀ–2ø`©ASå@C–¥1”ÆP†Ci¥A€c ‚ (Ğ ­…	  3ÅPÂLD1”‡0å1ÌDCy3ÄPÃLD4”G0åÌDCy3ÅPÂLD1”‡0Qå!ÌDCy3ÅPÂLD1”‡0Qå!ÌDCy3!1”Ç0Cy3$1”Ç0å1Fü6 ƒ½qÀ`„PÀ`o” FìFÀ`„n FäÀ`D
0KP4(7Æpƒ Á,ƒÀD2ÆxB Œ7§pˆƒv!X…5 m3Æa¼!h…6Œ
 o4Æa¼!ˆ…8 @F˜A  dâ‚¡÷ÈpÃ Á,Ã@´b0b>˜% ˆÄBó!.á†!0ƒY†Â(Ä`Ä}0K`Ğ
ƒ1ã8„bÄÀ` {Ì¡¨ÁO„ñ† Na0"(€ò`ĞŒñ„@oØa(ƒ  ‚¸`@hEÄ2Ü0h0Ëp •‚Œx‘@ f	2qÁ€Ğ‹ˆd¸aÌ`–!QZ11# Ì(³©Â°`@0Á
Á Ì4#Ã‚^ıÁO„ñ† $@‚‚0#A FÜH ”#Ã‚q•ÂO„ñ†À$Ì1! ĞÒ!´
c<!Æ–X
Ä`Ä-0Ñ.1 ³õÂ 3ÃB€³¤b0¢ ^ƒ¿ ¡IŒ@“  hÙÂO„ñ†à&n‚‚0ñ&A F¸I „ƒvaŒ'ÂxCÀü@Œ@‡@ ¨ÃO„ñ† ,@‚1Á ;ˆ„àA\0 ÃC ³Ì¤Åƒ¸`@¨Ä2Ü0hpÁ@\ ƒü ñC¸`@†‚¸ƒé†•‰à‚Œ‰  ¨ÄB!!.‚Œ	 Á 01 PIˆ„RB\0 6!1  6‚ `0"% ˜Á„¸`@lD@5.š	qÁ€Øˆ`¸ÁÌ`–!’º	q FÄD0 „b0Â& s	Dpqt.á‚ u	„A*°‹£°H™€à Œ‹@ H^ÂAö.‚TGl!.º  #Ø" ²‹pÁ€˜z!¸ #ô"€Y‚‰ğB\ hƒp å…Œ¨‹@ hdÂQÁk¡L¸` eÂaC‚
jã4ÄRC`¦ ¸  #D# š™pÁ@ĞÌ„Â† €ÇÑjˆ¤†€. €ÁˆÕ`–`¢ÖÙF¸`@†‚	ƒé†ô`‘ÀŠ ãaã"Á`x@¶!. 4Êq ÕĞ`Äm@á.á†ÀFÂ`–ªÒQíÄ,E¼1f	¬
 (¡Œğ` #ÖcG`–à¢õDâ‚± ?@0Ü@h0Ë€yÅÇ¸` +ğ°@D(0ÜüÌ2d\@ö1.È
F$,8
7ib³Ú{Œ ˆúcF‚ Ìl³íG¸`@DÆxB FˆH0 DƒècT À`„}0KĞ‰jƒ&À,ÁE¨#.á† FÎ`–áCƒ€şC\0 „"á‚nú$¦vÄO+Œ7Ä¨ƒ!À`DŒ„Ê Ì€ÅÈ ˆc‚á"@ƒY†08ƒ€Ld\0ˆIX€&nÊfÄ Z‘qÁ@Vp&aA›P`¸!x3˜e2¨FÅÈŒ˜% ƒY‚2 0	ÑÈO„Á	€tD\0 Ô#â‚±` Á 0& Ì˜±É° O@0á&Á Ì€Á,Ì¤µÉ°àO@0ñ&Á Ì4	*á@   +   (`°P„İ$Â„8ù‡„d„	
Òâ<„áÔc„HED"’Õˆ
×ãHö@`#™}ÀÑ¼D4—
Â@,`ô†CMéY@QIHFX~€â,ÃKDqÅ¦ 8ËğÑD\²ÉMÄÛ|ÀQÑD\²í8ED3½D4Wlü@EÑL/MÄ%[¡ÀáPS:E5        a     ¬     P¶%@%Pş¨PEPÀ5P€üåQ >Pş	eP¥PåP€ÅQ0åÉSÅŸ    3ÄPÃL1”Ç0!å1ÌDHCy3ÈPÃL2”Ç0Aå1ÌDCy3ÄPÃL1”Ç0Qå!ÌDCy3ÅPÂLD1”‡0Aå1ÌDCy3ÄPÃLD1”‡0Qå!ÌDCy3ÑPÁLD1”‡0Qå!ÌDCy3ÅPÂL1”Ç0Qå!ÌDCy3ÄPÃLD1”‡0Qå!ÌDCy3ÅPÂ`DğÁ F€Á ¡Ç úˆåA ‚ñ"Œ ƒ` ?Ä2Ş ¿F”A0 ´â‚o˜q#Î  âqÁ€ˆˆÄ† ƒk ­Á° @0ÑÁ ĞŒaª!PÒÊ#J0ˆ9:˜S Y¨r@› È`D0K PŒá†ÀÎ`–apzƒ1Ü¬Ì2N@v0Æ‚V @FÈA  ”c<!¨
Ä`„@|0Æ\Œğƒ` èÄBz .‚F€B0 
c¸!ø‡3˜e(š€DaX Œ …` (ÄB«0Æa0‚‚ RÈ`D*0K`P*Z…A© .7Ì2L@¯0†‚—8ƒYD	(ÆpCğh0Ë(éÂ¸ ¨ñÂO„Áˆ€€Ye–`!\à#t!€Yc– ™%pÆxB€ƒâ íÂ°€@0ÑÁ Ì<Ã| Á`„80ÜüDÌ2P0K°´'â‚Œ‡` f	$‡1ÜŒÅÌ2L^@ä0†@ƒYÊhÆxBpˆÁt€ÜaŒ'%AŒP‡@ (ÆxBĞƒó ±ƒ¸`@èÄbC‚Áˆz€êa7tq³UFÈÃM õÃ¸ . ˆÁz€èA\0¤Ä^  ƒø ùÃ° '@0Á P?ˆ„NbŒ'Â`J@!!.Áˆ€şaF˜D0 ³™Ä ”$Ã„ ÃD€³ĞIˆ‚VB\0  ¸  #^" z	qÁ€T°J2!.
èBI&ÄQA]ä	pÁ@”h)Á^  ƒ= õ„¸`@*È%°H¢¡â‚¨ 4Ôˆ …{ F¤E  ´c¸!X3˜eÀ´€Úb7«³™P[ˆ¤‚×Ğ€æb^Œñ„@Œˆ ˜%ĞH.ÄQÁlÕ…¸` *@,"Ø `0B/ ½üFğE  ³Æ° <@0!Á ÌX³İ,G¨1ÆğŒP` h4†ä‚ÁˆÒ`–à#Ô€#T#€á†àDÂ`–Aƒ`–`5hlÄ2¡Á Ìˆ©ÆnVäfÆ b1Ü Ì24c<!x
Ä`l@¶1Æ‚ö @FÈF  ”c<!¨Áˆİ€hC\0 tâ‚±!Á`Do@½1†9ƒY†2xƒ€~cXà Œ` È7ÄBè1Æa0"=‚ ñÈ`„y0K`dƒĞcyˆÄ† ÃE€³gà©‡¸`@uÄRÁ‹˜*ˆnä$fĞ€¢1ÜĞÉÌ2¤Ádc¸! 4˜ePƒ5è?Æ	@ú1(DÆxB FD Ì¬Á,ˆŒñ„ G#H$€Y‚6 ÿü#B$€Y3˜%xƒY8 ã	ÁF¤H0 $"Ã‚1Á`‰0Kt"Ã‚Á`DŠ0Ü˜JÌ2ˆ³«1K°ô"ã ¸` *“Œ ‘` ÈEÆ`Äî0KP³v@12Æ‚V¡@F¸H  D#c<!X
Ä`Œ@72Æ‚9ŒÈ‘` HFÄB5".‚FìH0 ´#c¸!Ğ•0˜e¸<f	ö€tD\0 D&c<!#Ê$ Â‘QA›ä pÁ@T°'zAĞšŒÁˆ@ b“1œ
á‚Œ“` (NÆxB*ƒs íÏ°àT@0Ñ?Á PÿŒá†à]Â`–Aò ˜%XY; 7Å‰¸`@††àfø`º“a­€`0"O‚ ?¼J^  Ä`@z"."•1ƒ¥ áÉ¨ÀV´_¹Á>	€ödT .7Ñ'Á PŸŒ
zE	T†#D% 
•A£2,B0Q*Á P©Øƒ§ Ê¨ \r0"U‚ T$+£„€#X% b•QAºè 0Á* «ˆ¢zÉ `0V YÈ‹’¬ˆÂ‚ À`„­@¶".ˆÁˆ]	€ve\  ƒ» õÊ¨€_”|eTÀ/jC ‚Áq	€ÔeX2 Œ`—` ˆ]F+£ÃÛ„Á,CøA0q.m3 ³~@ï2*p™Œ€—` f	ş€ÒeT€2zA¾Œñ„`f#ô%€Áa bqÁ@¼FÈK0 ”/Ã‚™Á`Ä¾@û2†‚½	ƒY†P …`–@È^F5£$ •ÌOÀf0âd‚Œ†  |õË°@ Á`Ä¿0Kğ³£@,3Æ²Œp™` È–†b‚Á\
`–€—ÆpC :a0ËP¥Ì¬Æ,Á)ÌŒñ„€u(ƒ- ÍÌOÔ†1ñ2 ÍŒñ„@n#p& ŠqÁ€ÍˆÄ† ƒ: éÌnrçfPâ™aÁŞ€`0Âg‚ •ÍO„Á³	€ÄfT:9ÜˆÌ2¤‚+´6£‚ÑÑ `0‚g D¥s À`Ø@r3*P%±„. €Á³	`0"nàg f	TâfĞÜŒá!@ƒY†Uh…€òfP.ˆ
DG©mÄQC°$ …ÎŒ„ ˜%`ê›aAï€`0âo‚˜%P…Y‚W Ò„¢‚ÜQRQB°$ ­ÎOÌg0¢u‚Œ† ˜%x…YX ×ã	ùFÀN0 ³±@¬3, F¸N0 ÃÁ
…Á,Ã)ÈB0K°ƒ¡ÓB@g%.Á×	`–€ÈuÆpCğBg0ËPáìŒá†€}Ğ`–ÁÂ! Ûã	ÁQ #h' Ò1Äb0Âv Şã	AşFüN0 „;â‚¡İˆA#Â' 
Ÿ1Ü€ÑÌ2Ü84>ÃÁ`Dù@â#.bŸ1ƒí ¥Ï¨€„h0b}‚ õÃ
™Á,.üB@à.ˆ
Zˆ/H€Áò	€êgP. ˆÁó	€ÌG\0Ğ^  ƒê ©¸` ¨}ÂQCÀÃÁ…Á,C.èB@"4Æ‚Œ ¡` f	ta0âüh f	vşgPá!@ƒY^ğ…€Rh\ ”Bc0"€ThŒ'a4ÁBÁ ÌôĞ°àŒ@0‘BÁ ÌìÂ,Á/Ì€Ã,A8Ğñ„àŒ#b( R¡aÁ`0‚…‚˜%z¡aÁ`0"†‚n\)fha‚Y‚Õ ƒ¿ ­—¸`@#d(€Y‚r ÃÁ,Á,ƒ9ĞD@44†8BƒY†s ‰€thŒ'·DŒ`¡@ ¨‡ÆxBPGˆÁ
€\H\0Câ‚°!Á 01C Ğñ„À(ƒc ©ÑOÌ‰1qF Pñ„ •#Ş( J#qÁ€Ğñ„@Œ £` ˆÄBo$.‚FÔQ0 tGc<! ¥Áˆ<
€îh7ö³èÀÙ‘¸`@†‚|:ƒY†tX‡€òH\0 Ã.¡Á,ƒ:¬C@p$.Š#qÁ@Ø€ _¢
À)/H Z¥10K°³3A¨4†‚“2ƒY†v‰€Ti7é³îP¥’¸`@†s:ƒY†wˆ‡€XI\0 Ã9¡Á,<ÄC@¢$.ˆ
Ş)/H Ò¥1ÔÓ`D0À,A<P-‰d¸!À©3˜ez—Ä2ÜäÌ2Ì=ôJâ‚¨`Ÿò‚ sƒ ³ô0K4Nc¸!ğ'0˜e°HœÄ2ÜÀÓÌ2ÜC>TNâ‚nä	fğ!Ú%qÁ@T€RyAĞ<ñ„@¥#‚! f	òÜI\0 ÃÁJÁ,ƒ>ğC@ñ$.á† ¥Ğ`–aø! t¥“¸` l@PMQ8•$ ÔO|j0"`–€ÈŸÄ2Ü„ÖÌ2ôÃ?Râ‚nÄ
füáÂ'qÁ@T@VyAĞKÁˆ@€Y‚˜%€	J)qÁ€FğS0 äRƒüI\0 t FˆT  4SÃ¹Á`DM@55*€+nj+fB¢$Â©QÁ\Ñ`„N@(5†‚Ü:ƒY‘ ‰€Tj7y…³#A½”¸` *Ø«¼ È¬Æ`D À,IĞYñ„@´#Ò* š©ai`0¢¦‚ ›é”¸` ,@p FøT  ³&Am5*@-Œx«` f	Lb–à$¨§ÆpCà^g0Ë€*ĞOá†ÀµĞ`–!%T" ²D°•$ íÕŒ„ ˜%P	2«aÁm`0­‚ ´µ•¸` ,@p FÄU  äVc¸!ø¯3˜eX‰–®ÆpCğ[h0ËÀ-P]‰¢‚ğÊ€XkŒ'ç50KĞ„WÃ‚ôÁ`„^@°5Æ‚óŒ­` ¨¯ÄB¡%.\  ƒ¥À,KmÚƒ¶ÀpC@ca0Ëp/ÌÀÄ,ALÌÈÄ,ÁLÌĞñÖOèk0Â·‚ Ûà#r+€Y‚š ´Ğ#Ô.€á†`ÇÂ`–¡l"˜%Xú­1ÁvÁ Ş‰d0â·‚˜%À	ú­1Ü€ÙÌ2äÄi^c¸!è/4˜eĞ‰Ó½ÆxBğ_ˆÁò
€ÖkŒ'gFŒ@¯@ È½ÆxB bƒğ ¥—¸`@ˆ½ÄbC‚Áù
€äk7qv³;aÙ×OæŒ1A^ P~ñ„ Æ(ƒæ İ—¸`@#Î+ Ê/qÁ€Ğˆñ„@Œ ±` HÄÆxBğcƒ$ ‰ØnBfx,z¯1ÜŒÚÌ2ôÄO_c¸!34˜eğ‰Ÿ¨¾ÄAö%.TpfTAšå	@46#! f	~b– 4¨¿ÄA &.‚\  ƒ! İØnìfÂ-2111b òƒ< ñØ¨àÎh0ÂÇ‚ D}¦ À`ÄŠ@/&.j1qÁ@X0€à Œˆ±@ hÆÆpCpng0Ë dPá†àÔĞ`–a,È" D©–$ ÑÙŒ„ ˜% Ò1qÁ@T kz FøX  ôcâ‚!2„. €Á4€ÈL\0ĞšÒ™‰¢‚^S
µQÁ¯iÁUnZH° À`œ@t&.’3qÁ@X0€à Œ°³@ Ï†ì‚Á=€ôl7.w³eqñÙnÜfÌâ,â3qÁ@T oyAĞ®ñ„ÀŞ#‚! f	Îb–€4(×ÆpC@o`0Ësª‰ÁR€xmX°o Œğµ` È×FùFƒà ¡š¸` *ø7½  #X- r5qÁ€T rt FÈZ  kâ‚¨ ä”fM\0¨œ’»
XNk®—ÓB‚½  #x- 
7qÁ@¯‰Â‚ À`„¸@å6†‚¼;ƒYµ`‹€Îm79‡³kÁ™›¸` *Ø¹¼ ÈäÆ`D À,[ĞÉñ„@ì#R. ‚·aÙ`0BŞ‚ xÙ›¸` ,@p Fè[  Toâ‚¨€íô ŒÈ·@ ÈßÄAû&.\  ƒÿ ‰ÜnlïfÚâ-"¹1ÜØÌ2¸Å[4râ‚¨ ïò‚ ±ƒ ³oA('.ˆ
şN/ €Á–€\N\0 4sâ‚°` Á 0qs Ì‰¢‚ÑSª9qÁ@TÀzJp7*p=­!¸
`O	ö Œğ¹@ hìÄA`'.\  ƒd İ°`÷@0‘vÁ PÚá† ÿÎ`–.ä" µÃAï¡Á,C\ÈE@j'.ˆ
~//H R½1”ß`D0À,\ÌŒÕŒ€»@ (õÑ¸`@*è ŒÀ»@ Èõ†í‚ÁØ€`oT°~6ÜÀ`³tÍŞ¨Àıh0¢ö‚ ¾Dô§ À`è@ '.ˆ
äOiôÄQÁş)ıŞ¨ ÿ´†à*ø?-$Ø `0‚õ Ù¹¸` ,@p FÈ^  d{c¸!PÃàfêâ.Â½1Ü¨`€³vqÙ¸` *`Á /H º¿10Kp„c<!˜Á`0Bÿ‚ ğÔ` ‚Áˆñ`– /ÿF3Ğ`„ş0K³zAá'.ˆ
r0Ğ `0¢ü õŸ¸` ,@p F¬_  ô~c¸!Åàfö¢/Š¿1ÜŒa€³|Ñ½Ÿ¸` *(Ã /H ‚Á`FB Ìôáß°€Fè_0 dâ‚¨À½  #ô/ ê?qÁ€â‚°` Á 0a‚A  ‚¸` *Ã@iqÁ@T°‡Ò£‚>´†à*øÃ@	ö Œ`Á  ’Á@\0ä‚¸` ,@p FÈ` Ù`0†uÎ`–Á/@# ÆpC ŠÌ2ühdƒ¸` *`Å /H ºÃ`Œ'²FC Ì€a0, Å ƒb@{Œñ„@ƒÁˆ>‚ 1ÄBhˆÂ‚ À` Ì„ıa0,ÀÅ ƒ¡0Üüc³z!Á,ÁhÌÆ,AiÌ˜Æ,ÁiĞ)c<!øÅ`0"ƒ` HƒaÁ8 Œ Å €YÔ †¿€`0¢Fƒ` †“Â`–'R#˜%XY‚ÕÀp   D   f)°HMœ³8náJD4µØCØ @qHHFØ¤@"MÎÃ9‹Ù¡ !MÎc€Ä3Eµ
ÏÙ) ‡=
Áe[£À0\µU
,ED3Å©#Y¤À \·	
•„d„e
(‚³8‹dÄnÄD0i
0ED3qÎâDÆ( —Q
$‚³8‹d„%
Ãe—Š49ç,N”›x@!8‹¦ #PQD4Sœ:’nŠ‰4ÑÄ9fÿ„CM¶
‰
,ED3•HC¢ Á ’b†…4Ñd’Š4ÑÄ9‹™ÀàP“-
Àe›@EÑLœ³8oœ@EÑLœ³8Q       a   Y   J,      4P¤40F ‚ ‚ ‚ ˆ  3ÄPÃL1”Ç0Aå1ÌDDCy3ÄPÃLD?åAFÍ FÌ FË FJ 1,P@0a@Æ06B0a0K1(ÃB³BP2Fˆ…€š1Ü a0Ë05ã@£h\ h5t	€
Áˆ‘ »FPÌƒÔF ³]ã%#‹T È` ad¸! b–Á8ÒH…Aƒ\@ ³…Á¸@ÉÈ#%qÁ ‘2ƒaB Jƒq’‘¸`€H¹Á0! ¹A¸`@F g1†`– ¡7Ü#â €Y‚ Ã    ÖPXÈ0\&`6`DÀ€P’±,ED3•HCy@!8‹      a   —  ´     Põÿ?PE@%PÅPeP5PôåPR
ÈPÅQå?P€€øEDCÜ¥1”ÆPÆøÁPCiØZ˜ÈPFüÁPCie”A(¥1” 3Ä`ÃL„4˜Ç0!æ1ÌDƒy3Ä`ÃLD1˜‡0Qæ!ÌDƒy3'1˜Ç0¡ƒy3Ä`ÃL1˜Ç0Aæ1ÌDƒy3Ä`ÃLD1˜‡0Aæ1ÌDƒy3Å`ÂLD1˜‡0Qæ!ÌDƒy3Å`ÂL„4˜Ç0Aæ1ÌDHƒy3Ò`ÃL1˜Ç0Ñƒy301˜Ç0ƒy331˜Ç0áƒy3ş0˜Ç0Aæ1ÌDDƒy3Å`ÂLD1˜‡0Aæ1ÌDƒy3Ä`ÃL1˜Ç0Aæ1ÌDƒy3Ä`ÃL1˜Ç0Ñ«0 ƒİ9À`ÌÁ PŒ
–1á Œñ„ #ä  ‚1Ü¼CÌ2]@r #ø#€Yè`FxÁ Œw0‚€ğ`Œ'±0¡Á 7Æ‚z¨
Â 1¡" Šˆd¸!€…3˜e’€@a\ğ¸ƒf ÁoüÁ(„¿‚€Ø`Œ7$AƒÁ ôc¼!0‰r  PŒñ† %Ğa0"€è`Œ7+‘²ƒ1Ş¸;Fƒ P-Œñ„À#n! ²…1¸Ã`.@|0Æš˜
Â 1‘ FÄÂ; ñÂŒ “` f	ò…qãF”B0 D
c¼!Ø‰| @\0 ”
c¼!ø‰Ÿ @\0 ãm"â‚1$ Á 0± ;Œ$w0"‚ ^$c¼!X‹µŒ [ãA[°â‚© %h¼aOâ"ŒÈ…` èÆxBDí`Ä.@¼0Æ»°
ùÂoò"/#‚A (ÆxC°:A qã_ôÄ`D0 ‘ÄOzb0Â$‚ “ã	OF¤D0 ¤c¼! ± @\0 ƒ  Ä ‘ÃB`³…ĞHŒÁˆ’`–À˜%8¨%Doƒ/ÀpCğa0Ë@ Á,ÁEà".á†à,Î`–A²‰qÁãFğC0 Ôc¼! Ú  \0¸E.H ‰1Şè†nFC PIŒñ†€7ö‚‚@'1Æ‚ßğ‹Áˆ` R‰1Ş„Ç_P #Æ" J‹1ˆÆKŒà‰@ ¨-ÆxB@ƒo ¥…¸`@,Ä2Ş€/íP .3\  tc<!ˆ
v0" €ôbŒ'²1ÁÁ _ŒÁ’	`0B.`c (,ÆxC¸AA¸  #ü"€Y‚…Dc\P°ˆd0b4‚ Óã	ÁoF F0 T£ğ ñ—!‘`0‚-‚ Õã	y\µƒn ½ÅoR$E(c¼!`Œ ºã‹´‚ìbŒ71ƒÁ  tc<!€ÁˆÜ€öbŒ752ˆd0"6‚ Ø4c¸AÌ`–i¢1aÁ Ì4³ù†¨ D`0<nÀ$f–'˜%°ˆ<Æ;¡Á ĞjŒñ†@LÄ„‚@­1Æ‚2)“Áˆ` ‚1Şœ‰‰PH6ÆxC &)2@µ1Æ6Q
İÆoŞ¤E#‚A È>ÆxBğ"ƒø İÇO^d0"?‚Œp Ê1:Á FàG ıÆoì¤F( Ä`Ä~0KÑŒ
–qÁ€F€H0 4"c<!à‘Áˆ	€DdTĞ#4Ş°:¡F¤G0 t"c<!“¢v0b=‚ öã©˜
‚ÜcŒ7©’*ƒÁ  c¼!X5¡@Ğ|Œñ†ÀUÚd0"€hdŒ'm2a#Á ~Œñ†@Và„qÁ€F¸H0 ä"ƒ`d7Ì2HS@12#f$€Y‚i–€¢ô	FôH  ÃA¯„Á,CT³Ö,ÁEa2#T$ JŸ11&Á ŒÁˆ	€ÈdŒ'|rAÁR #l$ B“1øÉKŒÈ‘@ ˆMÆxBĞ',â‚¡ˆC. €Áˆ1	€êdŒ'¯rAÁR .:qÁ€X0„à ŒX“@ hMÄBn".\  ƒr É‰¸`@#ö$ Ò“q FÔI  „*c<!—
–1¡' «Œñ„@W.(X
Ä`Ÿ@°2Æ‚^¹ `)Š¸`@,Bp FœJ  ”+c<!ˆ—
–qÁ€ªˆÄ‚! À`„«@®".’qÁ€X0ˆà Œ°•@ ¨WİŠ¸`@,Bp FìJ  ¤+â‚± eB@ä2,B0a.Á ¹Œá†ÀmĞ`–Ëê•1Q/Á Ìh”GÃ˜Á`Ä@¾2.  â£1ŞÔMİFƒ ñ†ànlf0"È sJc¼!ĞœŒ† Qã	ÁÎF”R0 ¤.c0bd‚˜%Ğf	6Z%QØÀ`D+0ÜˆNÌ2\0KĞÑÉŒ
–12 ÊŒñ„`l#X& R1Ü¤NÌ2xgËˆ„fiX €`0¢–‚˜%øHfÆ†;Ñ2Á ĞÌŒw0Âe‚ —ãAìÀâ‚© nl¸!¨0˜e0¨fÆxCp;uC¸`@*¸nv'fÂ@‚ êçlF¨¾Qâ™1ŞøNßP .
ü†#~& 
›1ŞŒOèP .
F‡#Æ& 2›1Ş úP0#^& z™Ai3ÆöaŸÁˆ` R›1Ş€OîŒ7ïó>z›1ŞÈOìFƒ ÜŒñ¢Ÿ`¼!¨Ú¡@PİŒñ† lg0"€êfŒ7”şãÁşì‚öfŒ7ş“;ƒÁ  ´7c¼A¥@(oB|(:c¼! !ğŒ Ñã0eBÁxCpBåC¸`@#H' 21ŞPS+Œ7,¤>ˆd0Bu‚ Õ¤:c¸AÎ`–aÈ  Öƒ­À,PëŒ €zjŒ76dCƒÁ  ôSc¼!À¡ûŒvH Èw‰Õov(#‚a ˆ¬ÆxBÀ?ƒf ‘ÏOòg0Â|‚ òã	AüFœO0 ³e@æ#*0!Œ@Ÿ@ †3
ƒY†Ï‚Y‚3 õ,b0‚} ÷ã	Á	FÀO0 ä>b¸!h£0˜e@6~ÄBw5,@0‘WÁ Ì¤ÙÏO`ˆ‚0q;A PşŒñ„ †.(X
Ä`„î@ı3Æº `)ƒ½ ıN ƒ >â‚©€‡h¼Aµ@)oB)”(„Bc<!£
v0" €ÒG\0 ”7ÌV*ã*¥‚bhŒ'htAÁF„ Püª¡1”Ñ;@ö#.
äˆÆÀË–‚ñ†à–êˆAá5Æ]Ò¥Áˆ` ¯1ŞğÒF}$ $FƒÌkŒ7¿ÔGƒÁ0 „^c<! ¥Áõ
€ĞhŒ'}4¡FÁ Pñ„€#Ö(€Y5 5¨F°Q  Ã:…Á,C¬A0KÀƒî%G0Á^q4 ƒ8”N0KĞ„Cƒæk7Ì2¸ƒñUG0AF®$ ƒcÄN0Kğ4Fƒìk7Ì2ÀD_c¼!€'x¢@\0 ´Fâ‚n3˜eˆ9h¿ÆxCpO÷DŒˆ£@ Æ`0K ô_c<!Ğ¥Áˆ`–`h†¼‚Áˆ:
`–àˆÆxC‰ıS0Ş€HQ ¨ÄÆxC0R#5@z4ÆV¬¤‚ñ†À¤Ê‰A+6Æ‚”B§Áˆ` ¥1Şc+Œ7,¥NŠ±1Ş¼T;FÃ ĞŒñ„ #j, B¥1Şc3Œ74ESƒÁ=	À,A)ê	ƒ¦À,AFğØ/ Ùnp*fî ³q F Y  Nc0Í‚˜%À
³1Şô?Q #À) "³1Ş€•?Q0#Ğ) r³1ôÓ`œ@å$.a’!h…ÒÈóĞƒób§qAâF˜S0 dNc¼!H«´¢`TàOZIå 0áN ;ñ†à­\ŠqÁ€FÌR0 Oc¼!˜«˜¢@\0 ƒ¶ ÑÓoîJ¦(È`D.@ø4Æ‚½º)
Ä2ÁKÁ Ğ/ú¥A¿4è—‰”¸`@F ˆ-£ †`–ÀH¥ÆKÁŒP©` ¨¥ÆxB@Vƒ/ ±Ô¨ §ô Œğµ@ è¥F`¥ UF˜[0 $S£ŸÒ
Ì*/ €Áˆ™
`0b¤zj #Dj¶`–`H¤­Û° ®D0Ü0h0ËÀ~PO
–A*5.(ØÁˆ` b©1ìÕ`„K@d5Æ‚¾Œ0«` f	ú€^jX Z Œˆ©` f	ö`Ä` €únB+fş ²7qÁ€Y‰dÄ   ü‚YP˜%pr«qÁR0#Ü* Š«AA¸` #V* ¢«1¸ÖK¸`@#\* Ê«1¼ÖK¸`@#d* ò«1´ÖK¸`@#r* 
½1ÜøWÌ2Œ‚(´Sƒşn˜ˆ€DoPj
–qÁ€X€ €#Ê*€YR ²Ü–*¯Œ@«` f	HĞjX€^ ŒP«` (­­Õ0! ÍÜn3˜e(SÈ­ÁÕ0! Á`Î0K`
Wƒæj˜„€tn7Ì2œ*dWƒğj˜„`0âç‚˜%@Â«A{5L@@a7†„ÀfRAê«A 5L@0avÁ Ì¨Ö Ñ&! ´ÃB€³«À
•Ö Ô&!Œh»` f	XTkX b!Œ`­` hµ­Ö ×[ã‚18€Ô
bf	Za–À(ôÆ`@{7ÆŒè»` f	^JOTÀc0qz 7|³x Á,,FôÀ`ÄŞÑØ FğÀ`„ŞÑØ FˆÀ,Á,FˆØÀ,Á,ˆÂ g   6(pÕLDdáÇã ÍDDF(@LØCX§@%PQD4ç05ÃKDq™§@#PQD4ÓKDqÙ¥ Í@Döm•Ç@HS:E†)€DD3‘[¦ Í@DvnŸÑ@HÒ â4/MÄe¢†@4Ù©€€ÙV* `µm
DED3¥Î‚…0‘
Œ¡
0	‘ÀÔ(@LóXª # ‘°)ÌmŒŒ@EÑLñL‡
,Ò0éÙ¤€\6*@HHF˜ª # ‘°)n‚\V(PÎâD) H0/°P„-
$!MñL‡i
DED3¥Î‚½D4—­
0	‘ÀäÖ(P„4Íf) æ($Æ)„4!0!NÀ@DF* \µ™
—m¡†à,NT À@ˆ=
 !M©³`¦(PÄ3) H0^3E˜
HÒœãDÒ !¥Sd’p¥€ \†(`<ÒLµ%
ƒ4“      a   ©  x  +   4PEP5P¥PL…Pşÿåÿ?PˆPQHSÅSşÿÿÿERD0”qˆÁPCieb0”Æ C‡¥1ŒÇPÆ!Ciî1”qˆÁPCzeb0”ÆpC‡¥1ÇPÆ!Ciæ1”qˆÁPÃ{e4İP{e4İPCiP„mC‡- €­‡Ee@ŞPCie@{0”ÆP    3Ò ÃLÄ?â1ÌDøÃ ÃL„?â1ÌDƒx3Ä ÃL1ˆÇ0!â1ÌDHƒx3Ä ÃLD1ˆ‡0Aâ1ÌDƒx3Ò ÃL„â1ÌDHƒx3Ä ÃLD1ˆ‡0Qâ!ÌDƒx3È Ã`Dµ@Õ¸ `)Ä`Dn@ÙOü`0b€¶1!"Á o@Aäñ„@Œ ƒ` ÆK¸` #Æ# "ƒ1¤Â`„@f0#Ê#€Áò`0âEØ` ¨FÑÈ tã‚ª18  %
b(=ÆxBÀ
ƒë ­Ç¸ j#Ş  za-„`¸! ‡0˜e”€äcX!Œ ‘` #z$`–@ :ã>Ğb0Â 7ÈpCÀ`0Ë0éÁoü¡(ùÁoDb(‰ÂoL‚(™Â18 €,Cf	òqÁ€7ï ³…*Œñ†À%ÚqÁ€+Œñ†@&æqÁ€,Œñ†À&èqÁ€-Œƒ àB1„`–À˜%8TÆxB ƒ¢ İÈOôa0"G‚ Tí`D/0K€PšBƒkÀpC a0Ë $Á,Ba2#Ú$€Áp ‡Œø…q B—1Ü”EÌ2,W0KÀ8Œñ†à,Î‚qÁ€™F˜C0 „c¼!h˜ @\0 ”&Ã„ ƒë ¹Ãoæ¢&(¹É0! áE‚Áˆx€æa<X "¨ &ˆøe˜€à  ~ãhˆÆ`D0 õÃ ~&!° 'D@ 1,Ğ	Ø„ ± 2™aB ‚ €RbŒ7¯!ƒÁ  „ƒVb˜„€Xb˜„à  ˜ãÁmäÅ`D0 ÍÄor#7(õÊn4˜ehœ€rbŒ7¿ñˆd0b\‚˜%p¨'ÆxC0ãA¸`@]Æpƒ˜Á,Ã4c¼!Hô @\0 ƒîÀ,Dg1Æ‚ö€
ÄBï2†„ f") ¶ãÁ|Øâ‚Œ¨—` f	$Š‹1ŞÜ‡nP .Ò—1Ü f0Ë0QİÅoú<(È`È0K@_Œñ„€<#ü" ê‹1˜Ç`Ä_0KPQËÊƒ/ÀpC`"a0ËÀXÁ,ÁÌ`4c¼!@¡@\0 T2Ã„ ƒ§ ¥Æo\$>(©Ì0! Á`k@¯1Æ±
ÄB/3L@`9„`0B6‚ İ4Ãƒµ ÕÆn|$f2-Œ¸ø€YzgnŸaB ÚQB@f Œ ` <ÆpC "f0Ë°qÁ`„xˆÈ Ìp$ã  òãÁš¬É`D0 ÇoÚ¤M(ÅÍn4˜eè¼€ÚcŒ7s2'ˆd0ân‚˜%ğ(>ÆxCp'wB¸`@ˆoÆpƒ˜Á,ÃİÇoú¤O(È`„è0K ´?ƒôc˜¨! ÿ&" ş%dG ‚Áˆ	€Bd7db³a Á`ÄˆÉ ÌˆÈ¸  èDÆxCĞ*p2@)2Æ‚W‘
ÄB±3†„ fÆ€z‘1ŞÔ
P .ÁˆÛ	`–€hFÆxC+|B¸`@ˆwÆpƒ˜Á,C˜A@92Æ‚_
Ä2!>Á Ì˜éÈnüÄfÎ ‚Áñ“˜%@â‘q P˜Œñ†à\Re0"€ÈdŒ'¬2a&Á P™Œñ„ÀU#Î$€Y‚4 ú´
#î'€á†À]Â`–Sƒ`–`H}Æ;>Á úŒ
–qÁ@F¨I0 Ä>ã‚ˆOrå‚Œ€Ÿ` ÈMÆpC /a0ËÀwF°	ŸÀ`ÄšüÉ şŒÁˆ
€ğgŒ'­2Ñ&Á FÔI0 ³m@u2.(X
Ä1q'Á ĞŒá†`dÂ`–Áè  <ƒs ÕÉ `PFÜJ0 ”'c<!h
¹Ñ0!Á`Ä®@~2Æ‚x¡`ĞFüJ0 4*c<!X
İÑ0!Á`Ä¸@¨2Æ‚z¡`FœK0 Ô*c<!à
…Ò0!Á`Äº@²2Æ’¡`P)F¼K0 t+c<!8
©Ò0!Á`Ä¼@¼2Æ‚‘¡`Ğ+FÜK0 ³o@h4.(ØÁˆ^	€zeŒ'73ñ+Á  #Æ% —1èÌ`„¸@‚Œ(—@ h\ÆxBĞ3ƒå 	b0â\ •¤.â‚±!µÌ vˆ¬@@13(^ÄbC +FôK0 T3ƒğE\0 6" œ´/â‚±!ˆgı‹¸`@lD`E Z™a ‚Áˆ–	€ÄfÊˆÄ†@T6ƒVF\0 6"°" ¥Í —ˆ¬@@;3,@0Ñ3Á FğŒú õÌnÖÇfà ú™Qßä`DØ@å4.ˆØÁ³	€ÌfŒ'²sAÁR .B›Q@ƒj ©Í¸  .ˆÁ¶	`– ˆmÆ @m3.(ØÁˆ` z›1„Ï`DÜ@÷4Æ‚ñŒÈ§` f	ä€àfX0> Œ›` †
ƒY†7˜ƒ`–€ˆnÆxB0>ƒvÀ`„ß@w3Æ‚ğŒÈ›` f	ê€djX > Œ ©` †‚
ƒY†6°ƒ`–àh¤Æ;b@ €„1   –(€<ÒLéYxÀ8–N‘M
Ò„E
 Ó-öf)€<b§SdÛ¥@ÒP{ !™£€21·L:E¶(0Nlˆ±Œ×L–N‘5
‚3£À 8²=
,ó°0é™¢ ó8H3¥SÔÒd™„à,¶a
‚³ÔV)°,ˆqL&0EÈe”—@EÑLìDGHÒ â4¶)`Î’N‘i
‚³Ü)°4ƒì„d’…à,N      a   €   J,      4PEPÅT€…T 3Ò ÃL„Mâ1ÌDƒx3Ò ÃLD1ˆ‡0Qâ!ÌDHƒx3Ä ÃL1ˆÇ0Aâ1ÌDHƒxƒ5 ƒƒ3 ƒ4 ´Œ*w0‚	€˜1ŞÌÁP .
*nî f„  iŒ7yˆ¤‚m/ €Áˆ"€Y‚a– !lŒ7ğˆ¤2Ğá†`Â`–¡ ‚Y‚„¼1Ş”‚P #À  ƒAa .ñ„!OÎ`0‚‚ 2,b0Â 3ã	ˆÄ:ÁxF˜A0 dã‚‚¥@F¸A  ”c<!ØƒÁˆ7`0Âta f	rƒAq .á†!@ƒY†#	hÆxBğƒu ÕÁODá‚‚¥@\0 „Ã„@”£„€.  úƒ1°Â;0K€P(bƒ£À,á@      æĞ4ƒŞB0D3Õ& …3`é{ ã…DL­Ó`ëJàXH } ñL‘mñbóBp| óLQëÖ`íKàXL@:Eö 4ƒ©ƒ4     a   r   F,   
   4Påÿ?PÿÿRE@Chğ
Ci¥A CeğCi¥   3Ä€ÃL1 Ç0Aè1ÌDz3Ä€ÃL1 Ç0!è1ÌDHz3Å€Â`D‚À`rÀ`ÄaÀ`„QÀ`DAÀ`1À`Ä  c0"<‚ cF€G0 dŒÁñ`0/¦Œ°‹i #òB€Áˆ»€öc7x ³3ÈäŒ |azA 2LB0‘Á P|‘aB‚Áˆ½€æc‰‚FôE0 ³ic04‚ mF€F0 ¤ÁĞ`–`ŒˆT€ÁØğ€®qAÁR #°@ Hã	7Æ‚3¸ `)Äx‚F„A0 â‚© t¸!°…0˜e Š€Ê`Œ 0A# ÈŒ
 w á@      V` ±²™@c,ÄlçGàX:Ev0<SdøJàXH Yx@›x@ Ûx@0y€4ÆBÄ        a   ‡   K,      4PEPRÅPÅ  3Ò0ÃL„4ŒÇ0Qã!ÌDÃx3Ä0Ã`DñÀ`á ã‚‚¥@\0 @:ÜÀAÌ2A0K 2.(X
ÄR¥Ã„Á,1³
Ec<!¸#¦` Hã	A6A@Õ¸€`)tv0"€´1„ÁKÁ nŒ'epÁFÄ Pƒ1œÁK¸`@ÆŒ`0‚ 4”ã‚‚¥@\0 ÀÆŒ`<!°ƒÁ8€à`\P°ˆÁˆ8€ä`ĞŒñ„ .(X
Ä2`ƒy åÁ =,â‚±@D0`ã	*F„B0 
ã‚‚¥@FˆB  4
â‚!RÈpÃ˜Á,Cat
b0"˜%0hÆxBà
ƒ­ ±ÂO`a0Â‚ŒX…z€Y‚ƒVa+ˆd¸aĞ`–Qš…qÁR0¨Æ;@¸0Æ‚_¸€`)´c<!‡v0" €|aŒ'á0Á P8Œñ„`#Æ!€Y‚„~aXÀ Œ‡` f	   
   &°Î€¥SÔÒdîpÙ{@€X{€ \ Î€¥SÄF        a   l   F,      Pd4P5PH@Cj Cië 3ÄÃL1¤Ç0Aé1ÌDCz3ÄÃL1¤Ç0!é1ÌDCz3ÄÃL1¤Ç0Qé!F,Ø F(× F$Ö F Õ FÔ FÓ FÒ P2#Š` (ÄFÁ 1*¨r0	€AÒ0! Á` 1£-#œ` ÈäŒ ÈAB°AØ i6F XbºÆpC`0ËÁˆ ¬À À`„ …¸`@†‚U ƒYa(¤‰Ä4Á 0bp,@-˜Æ,Á@d0è•Á1P Àj¨…Zj!˜%((¥Á 4#
 ˆC.¹B.³†   †€4„¥5ÆB˜}@pÙy@B42aéYxÀ8WI“ s­ˆqLfP ±VÈv`V°LÌ³9×ŠÇdâFà\­óy@8×æL“Ã       a   ,   A,      4P9P€…  3Ä`ÃL1˜Ç0!æ1ÌDƒy3Ä`Ã`DáÀ`ÑÀ`ÄÀÀ`„°À`D  ƒŠ1b€ @,A¢(4Œ T¡Ú ’6hƒ€ŠAÇ1P  ŞàŞà„70   	   VP<@06° ÁlÎ€¥SdäĞaáAlâ          /** @file resources.c
	@brief
	This file contains the definitions of most used game resources.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "resources.h"
#include "text.h"
#include "scene.h"
#include "animations.h"
#include "screens.h"
#include "sdlengine.h"
#include "sound.h"

int8 * HQR_RESS_FILE			= "/ress.hqr";
int8 * HQR_TEXT_FILE			= "/text.hqr";
int8 * HQR_FLASAMP_FILE			= "/flasamp.hqr";
int8 * HQR_MIDI_MI_DOS_FILE		= "/midi_mi.hqr";
int8 * HQR_MIDI_MI_WIN_FILE		= "/midi_mi_win.hqr";
int8 * HQR_MIDI_MI_WIN_MP3_FILE = "/midi_mi_win_mp3.hqr";
int8 * HQR_MIDI_MI_WIN_OGG_FILE = "/midi_mi_win_ogg.hqr";
int8 * HQR_SAMPLES_FILE			= "/samples.hqr";
int8 * HQR_LBA_GRI_FILE			= "/lba_gri.hqr";
int8 * HQR_LBA_BLL_FILE			= "/lba_bll.hqr";
int8 * HQR_LBA_BRK_FILE			= "/lba_brk.hqr";
int8 * HQR_SCENE_FILE			= "/scene.hqr";
int8 * HQR_SPRITES_FILE			= "/sprites.hqr";
int8 * HQR_FILE3D_FILE			= "/file3d.hqr";
int8 * HQR_BODY_FILE			= "/body.hqr";
int8 * HQR_ANIM_FILE			= "/anim.hqr";
int8 * HQR_INVOBJ_FILE			= "/invobj.hqr";

/** Init palettes */
void initPalettes() {
	// Init standard palette
	hqrGetallocEntry(&mainPalette, HQR_RESS_FILE, RESSHQR_MAINPAL);
	convertPalToRGBA(mainPalette, mainPaletteRGBA);
	
	memcpy(palette, mainPalette, NUMOFCOLORS * 3);

	convertPalToRGBA(palette, paletteRGBA);
	setPalette(paletteRGBA);

	// We use it now
	palCustom = 0;
}

/** Preload all sprites */
void preloadSprites() {
	int32 i;
	int32 numEntries = hqrNumEntries(HQR_SPRITES_FILE) - 1;

	for (i = 0; i < numEntries; i++) {
		spriteSizeTable[i] = hqrGetallocEntry(&spriteTable[i], HQR_SPRITES_FILE, i);
	}
}

/** Preload all animations */
void preloadAnimations() {
	int32 i;
	int32 numEntries = hqrNumEntries(HQR_ANIM_FILE) - 1;

	for (i = 0; i < numEntries; i++) {
		animSizeTable[i] = hqrGetallocEntry(&animTable[i], HQR_ANIM_FILE, i);
	}
}

/** Preload all animations */
void preloadSamples() {
	int32 i;
	int32 numEntries = hqrNumEntries(HQR_SAMPLES_FILE) - 1;

	for (i = 0; i < numEntries; i++) {
		samplesSizeTable[i] = hqrGetallocEntry(&samplesTable[i], HQR_SAMPLES_FILE, i);
	}
}

/** Preload all animations */
void preloadInventoryItems() {
	int32 i;
	int32 numEntries = hqrNumEntries(HQR_INVOBJ_FILE) - 1;

	for (i = 0; i < numEntries; i++) {
		inventorySizeTable[i] = hqrGetallocEntry(&inventoryTable[i], HQR_INVOBJ_FILE, i);
	}
}

/** Initialize resource pointers */
void initResources() {
	// Menu and in-game palette
	initPalettes();

	// load LBA font
	hqrGetallocEntry(&fontPtr, HQR_RESS_FILE, RESSHQR_LBAFONT);

	setFontParameters(2, 8);
	setFontColor(14);
	setTextCrossColor(136, 143, 2);

	hqrGetallocEntry(&spriteShadowPtr, HQR_RESS_FILE, RESSHQR_SPRITESHADOW);

	// load sprite actors bounding box data
	hqrGetallocEntry(&spriteBoundingBoxPtr, HQR_RESS_FILE, RESSHQR_SPRITEBOXDATA);

	preloadSprites();
	preloadAnimations();
	//preloadSamples();
	preloadInventoryItems();
}
/** @file resources.h
	@brief
	This file contains the definitions of most used game resources.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef RESOURCES_H
#define RESOURCES_H

#include "sys.h"
#include "hqrdepack.h"
#include "gamestate.h"

/** RESS.HQR FILE */
#define RESSHQR_MAINPAL 0
#define RESSHQR_LBAFONT 1
#define RESSHQR_BLANK 2
#define RESSHQR_SPRITEBOXDATA 3
#define RESSHQR_SPRITESHADOW 4
#define RESSHQR_HOLOPAL 5
#define RESSHQR_HOLOSURFACE 6
#define RESSHQR_HOLOIMG 7
#define RESSHQR_HOLOARROWINFO 8
#define RESSHQR_HOLOTWINMDL 9
#define RESSHQR_HOLOARROWMDL 10
#define RESSHQR_HOLOTWINARROWMDL 11
#define RESSHQR_RELLENTIMG 12
#define RESSHQR_RELLENTPAL 13
#define RESSHQR_MENUIMG 14
#define RESSHQR_INTROSCREEN1IMG 15
#define RESSHQR_INTROSCREEN1PAL 16
#define RESSHQR_INTROSCREEN2IMG 17
#define RESSHQR_INTROSCREEN2PAL 18
#define RESSHQR_INTROSCREEN3IMG 19
#define RESSHQR_INTROSCREEN3PAL 20
#define RESSHQR_GAMEOVERMDL 21

#define RESSHQR_ALARMREDPAL 22
#define RESSHQR_DARKPAL		24

#define RESSHQR_ADELINEIMG 27
#define RESSHQR_ADELINEPAL 28

#define RESSHQR_LBAIMG 49
#define RESSHQR_LBAPAL 50
#define RESSHQR_PLASMAEFFECT 51
#define RESSHQR_EAIMG 52
#define RESSHQR_EAPAL 53

#define FLA_DRAGON3 "dragon3"
#define FLA_INTROD  "introd"
#define FLA_THEEND  "the_end"

#define FILE3DHQR_HERONORMAL 0
#define FILE3DHQR_HEROATHLETIC 1
#define FILE3DHQR_HEROAGGRESSIVE 2
#define FILE3DHQR_HERODISCRETE 3
#define FILE3DHQR_HEROPROTOPACK 4

/** Behaviour menu sprite values */
#define SPRITEHQR_KASHES			3
#define SPRITEHQR_LIFEPOINTS		4
#define SPRITEHQR_MAGICPOINTS		5
#define SPRITEHQR_KEY				6
#define SPRITEHQR_CLOVERLEAF		7
#define SPRITEHQR_CLOVERLEAFBOX		41

#define SPRITEHQR_MAGICBALL_GREEN			42
#define SPRITEHQR_MAGICBALL_RED				43
#define SPRITEHQR_MAGICBALL_YELLOW_TRANS	44  
#define SPRITEHQR_MAGICBALL_GREEN_TRANS		109 
#define SPRITEHQR_MAGICBALL_RED_TRANS		110 

#define SPRITEHQR_DIAG_BUBBLE_RIGHT		90
#define SPRITEHQR_DIAG_BUBBLE_LEFT		91

extern int8 * HQR_RESS_FILE;
extern int8 * HQR_TEXT_FILE;
extern int8 * HQR_FLASAMP_FILE;
extern int8 * HQR_MIDI_MI_DOS_FILE;
extern int8 * HQR_MIDI_MI_WIN_FILE;
extern int8 * HQR_MIDI_MI_WIN_MP3_FILE;
extern int8 * HQR_MIDI_MI_WIN_OGG_FILE;
extern int8 * HQR_SAMPLES_FILE;
extern int8 * HQR_LBA_GRI_FILE;
extern int8 * HQR_LBA_BLL_FILE;
extern int8 * HQR_LBA_BRK_FILE;
extern int8 * HQR_SCENE_FILE;
extern int8 * HQR_SPRITES_FILE;
extern int8 * HQR_FILE3D_FILE;
extern int8 * HQR_BODY_FILE;
extern int8 * HQR_ANIM_FILE;
extern int8 * HQR_INVOBJ_FILE;

/** Table with all loaded samples */
uint8* inventoryTable[NUM_INVENTORY_ITEMS];
/** Table with all loaded samples sizes */
uint32 inventorySizeTable[NUM_INVENTORY_ITEMS];

/** Initialize resource pointers */
void initResources();

#endif
BCÀŞ!  t  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q     f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l † X6„ ,@µ(şÿÿÿ $  I     ‚`B L¢   ‰   w   2"È	 d…“#¤„“#ã„¡LŒ„äL”Ã’
 
€Ù  BF è Jä€É  F" è‘€ ŠÌ@4Iä€UæÀ ‘.„Il‚i›àBœœ'ç.J‰’ãB¤ )9 „JË  ©Ò@¬T¸‹.)1¡X‚Mh–ª¥ à0iŠ(aòÙ	˜á[ Cb§ˆ&Ü.“¦ˆ&¿Ã€A„o‰"J˜Pp;Gš"J˜üùM¤™0™#M%LşünÎ…Nw–4E”0ùš09‘éT;E”0!b2™\N“¦ˆ&_k¦E"ê€	`§ˆ&$.'ISD	“¯	“±SD	²\îr¹\.ƒËàr¹\.—Ëår¹\.—Ëår¹\.—Áep¹\.—Ëår¹\.—Ëå²ãõ’ÌG?òQğ"iŠ(aòYhˆÔAš	“ÉäiŠ(aòÆi1™L&§Pâ4>Ğ8
ˆISD	“?;ÁN%L¨'ÅI’é˜ÈCJ&€–	r¡æ@	-Ä…0¸´ÏÁ€¨sA1ƒÁåb¥kÊá2 m—u‹ğ¼Ğ·ÏËåBá€)   °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD€ŠğG   $Ğx‡"ú‘   	vŞ¡Áz$  @Ş€w(FÀI  @  7à
ÈG   $ğx‡¢ó‘   	~Ş¡(}$  @ğ€w(FĞI  @  <àŠ¸G   $x‡bï‘   	ÆŞ¡|$  @ò€w(LPI  @  <àŠÄG   $0x‡âö‘   	ÎŞ¡Ám$  @ô€w(B€I  @  =àŠÜG   $P˜¹?0JäFüÀHa(-ögFàÜğœÿóDp†„ÎÁY2"8	r'Anà$Èœ'$‚‘Â6PRØJ
Û@Ia()l%…m ¤°”¶’Â6PRØJ
Û@Ia(SJãŠ‰`l9Œ/(‚¦6pÊ¤J˜ÚÀ	S8aj'Anà„©œ0µ¦6pÂÔN˜ÚÀ	S8aj'Lmà„©œ0µ¦6pÂÔN˜ÚÀ	S8ajç	‰`<!Œ¹“ 7pÂÔN˜ÚÀ	S8aj'Lmà„©œ0µ“ 7pÂÔN˜ÚÀ	S8aj'Lmà„©œ4*‚¦6pÂÔN˜ÚÀyB"aj'Lmà„©œ0µs€60RØJ
Û@Ia()l%…m $Èœ¹“ 7päN‚ÜÀIa()l%…m ¤°”¶ÒfEPÂÔN
Û@Ia()l%…m ¤°”¶¦6pÂÔN˜ÚÀ	S8aj'Lmà„©œ6+‚ÒfEPÚ¬J
Û@Ia()l%…m ¤°”¶’Â6PRØJ
Û@Ia()l%…m ¤°”¶’Â6PÂÔN Á)Ô"8)l%…m ¤°”¶’Â6PÂÔN$A	S8•^%…m ¤°”L0‚‘Â6PRØJ
Û@Ia()l%…m $Èœ¹“ 7päN‚ÜÀI8!ğ#…m ¤°”¶Ò)Fp:Å>d‰      ²Ì     Yj     †,¸ À     C] @    €!K,      À…€     `È      0d‰      ²Ä      Yb €     †,¾ €     Cp @    €!‹8      @  t   2˜$LŒ	&GÆCŒ Ğe€&# Ğä%~“ó.t\®É+ìN·]è¸œ# CpÑÆEC‚pÑÆECqÑÆEC†qÑÆECrÑÆECŠrÑÆEC
sÑÆEC†sÑÆECtÑÆEC†tÑÆECuÑÆECŒuÑÆECvÑÆECvÑÆECwÑÆEC‚wÑÆEC\´qÑ”y™Ùáy¸w¡ãre^í49ım§]è¸\™×<Ü†³Ës:.WæÅ‡¿gyÚ…Ë•y±Åá¯˜Ív¡ãre^lqø+–¯]è¸\™×.OÓËs:.§ƒB¯všœş¶Óß{ÚíBÇå”PêÕN“Óßvú{O»¿møÌ…Ë•zµÓäô·şŞÓîïû|v¡ãrZ¨òšËî²—SC——9Í.ÏÈ.t\®Ë+í¶¿Åj:.§Ç EF ( É‹^ÆÓ]è¸œ*# Ğä%/Ïç.t\N˜ ÒŒ g€<#  Ñ ‘F È4@¨ R k€\#  Ù ÕF è7@Á : Pr€–# Ô    y     C„qHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   ©  @øÒ™` u‘£5#Wº¢-šji)	Ğ Lal‘@EQ‡ KK\“×Lf>
%!ÁADXªë_nÚ¿­äÿ‰¥gN¨®?Ëy§÷bé™s@õDÄâ ƒØTD39&N#YÏƒ4ÑLN„’1DOD,0hÂ â4’I9,-qM›sµÎcÇà4M)°´Î
nš9E,-qMìä<œ³8‘T9Zƒ0âpi ¸z,+¾Q,À<±:T3PEmYD@¶M@¡ºşå¦ı[YşŸXzVàH ó,„‰4± ˜©HED3±B„<Ó,a¥‹$¡	“IÖ7DäxÍ„LXº¢-šji“Œ0ÏB¬ÄC “=ED3µÄ5m@£ØR3 ÀÂ@Ä>€@…áKSTÓfaøÒÕµa¾4Eµm†/MQ}‡áKSTãæaøÒÕ¹}4¡ºşÚ)šÿ'–¾4EµnUÑ€ KK\Óæ\)LmÊÎ‹ì!!™…4ÑLN„S@!mÎePÒ€ KK\ÓF±HFXÉò 1MÄ
nšµ8HSÍäDXa¢ÏAD¼…°,f°´Ä5mÎ•ÀØÆC!ME4“a&` Bê Í$Y#"Z#YDdgNå\!2D#6qÙe #Ì³é`Ä`\Î!ÍÔ×Ä¿@T[—óDH3µÄ5ñ/Ùæå<ÒL-qMüD·9O„4SK\ÿQnaÎ!ÍÔ×Ä¿@¤Û˜óDH3µÄ5ñ/ñ†-KÅøÁæ?4Âûğ>rÛ I ó,„ÆÑD‹0„¹HHSÍäD‹dDa¨–@EÑLö9ËâXÄ 	“ÙÒ0ÄD¸•-a C¼@”Ûp€#Ì³Rº ÒF°	TÍ”:2!N#6›3`éµ@`µš@EÑL–F@H1hÂäDâpÙs@ƒ4È´’CE!Ù×ÔzqûsTÍTÓDD±‰M­·?GEÑL%1MD$[c ôDD…8”Ä
DCˆÃe™Š$‘›f€"	DC„DäÈ¶ HÑ!9³½,’@4D‚"YaÀ8Óä0%QL±,3MSÅ$ÛaÀ8Óä0%QL³ı8HSÍäDØ· †dn’@EÑL¯sm@£|ÈBU4 ÀÒ×´9×æL“ÃØÉ"=2-,„Ñ0` Â,‹8\ödNC„DäÄdNC„DäÈdNC„DäÌf P°,à5S„f€"	DC˜”„– 	TÍ¤	“‰Íì4„ÍTOä„$­ÎLˆÓl˜Ö Œ,9Zƒ0âpÙu‘ã52a®ËŠ¯g¦‰$‘cp‡t ƒcÅwH08–lr‡t ƒcÍĞ„êú¯ËşŸXzFàHÑ'ÅhÂäD’@¡ºş_©±š™şŸXz67I08ç,"!NÓbaÅÒ S
,Ä4’½IÒáX,AaŒ@EÑL¬@4„8\æDähÂˆÃu¢«©•fÆ€"Ã@4¯s™Lb ñ-€!$DÎ³9Óä0¬DcMÒ€ KK\;ÑÄ9‹YªëoŠø›â‹çÿ‰¥g$Ç,Ä46ò0 Ò¤ÀBL±‚›fZÎ!ÍÔ×Ä§ST›d€#Ì³ @#¦°° 1YÑXoÀ4³QEAD¶m9O„4SK\ŸN‘m¼Ğ ÌFÕIÄô9Í”ÀIÆI ó,„Ä"ÑÁBXpÀ²8‚’1M„á@HSÍäDØI1$I& HÑß’58OD,0° ó,„dP¨®?«™ié±ÿ'–ñI9^3!Ö‰,·z­g3‹0w ÏDDV× ÔähFDHR–€	TÍ¤	“iÂx×é™o@!Ñd Á"KLÒ’é,
}ÀéYÔ3 ÀÒ×´9WI“‰,€4)°ÓD˜@áKSTAáKSd›AáKStBáKS„›BáKS”CáKS¤›CáKS´DáKSÄ›DáKSÔ›Ğb Á"’ÙH` Â,‹F]›C5aSĞ€ KK\Óæ\+b“¹8’@4ÄI1mŠdÀÊ,+!1X`Àt‘£5#W'²ÜêµÅPÒ!±9T3 ±9W:E6Ğ„êú·^ÜşŸXz–Ö ÃP"±E ÄfW=Q!%…DälÄTˆCEò„êú‹ç‹nãÿ‰¥gwÑâPRHDÖa¶Œ@EÑLìD<±İ0ED3±ñÈ…êú—›öƒ«øbéÊ#=2,’-,„á0ED3±ñÌÖ HÑ³Ó’15,-qMœ³8‘í< M$}ÀéÌ#=2ì•N‘Ñ59q âP‘PÀ<!¥€!¡	“IäH@E¤€Ñ	0„­0À<!µ@°¶ÀLÀ¢ ¡	“Ùo@ô 1MÄ
nGI“ÃØN„4ÑLN„S@!YªëoŠø›â‹ç‚àÿ‰¥g´Ø9!I% M«3â4Zc,„¡=O„4SK\SM¿@T[lÀ#@c«ã0/Õµ-<AÜ4Á
DCXªëÏ¦«Øzìÿ‰¥gËÍE'ÅxÍ!„dOĞ€ KK\;‹d„Á<Â4±:óQM›e@$Ì³&ÒtÄ`k3X3 ÀÒ×Ä"a7ˆP±ˆÃeWÎ!ÍÔ×ôQ}›ZñL¼„Ûh t‘“:2!NÓba”@EÑL ÀhED¬@4„©4@ƒ0,’-,„!$“ó¬ˆqL±%$“ó¬ˆqL²)$“ó¬ˆqL³)Åp‡ƒ„dI@L@‰Çd§C@Š4…4âp™t‘ã52aZ–^+rörN3¥Sd¬$qRÌì4„dmQC\S‡ KK\“×LfœHCX!9±u a…DäÈæ€4„‘3Û$PQÔ!ÀÒ×Ä"aX¨®¿)vâoŠ?,¿™Şÿ'–åHHSÍäDØI1$ „d
°<P"Æ1ÙÆªëÿ‰¥wwÿ'–E01}N3qÎâDÄÎâ0Àó-€!Ùßt‘£5#—Ö†¥×ŠœP¡ºş¦Ø‰¿)şÊşŸXzV#1€°,'ÅlÕ„­mO„4SK\ŸFÄDÄF½@dÒ#PQÔ!ÀÒ×”N‘åA9^3!v¢«©•ÖÑ„êúoh'ÿŸXzf’<ÀÂQÒä0&IÄÔ×ÄE$qÎâD– HÄ”1M„	L”DhËDD0)°ÓD  a      A,   
   d K	 †2 1¸hã¢¡¨.Ú¸hc(C"ƒ‹6.Ú    d#cÄÀ  Y°€è>ÆˆA ³„cÄ €Y($QF
  …Â1  @ŒÁˆú0@ a   $   E,      t) 3ppÅÈ0WŒ´cÄ€  U,(B0A0QŒÂ ÌT*Æpƒ Á,ƒ@„Œñú8…€FdĞ2F À…A¨ãøÁ
Á`D0À,Á@Ï° Á`DÀ,A€á@    &) 6) 4ã5S„     a   $   E,      t) 3ppÅÈ0WŒTcÄ€  U,(B0A0QŒÂ ÌT*Æpƒ Á,ƒ@„Œñù8…€úcĞ2F À…A¨ãöÁ
Á`D0À,Á@Ï° Á`DÀ,A€á@    &) 6) 4ã5S„     a   $   E,      t) 3ppÅÈ0WŒT"cÄ€  U,(B0A0QŒÂ ÌT*Æpƒ Á,ƒ@„Œñø8…€ZdĞ2F À…A¨ãôÁ
Á`D0À,Á@Ï° Á`DÀ,A€á@    &) 6) 4ã5S„     a   $   E,      t) 3ppÅÈ0WŒ4cÄ€  U,(B0A0QŒÂ ÌT*Æpƒ Á,ƒ@„Œñ÷8…€öcĞ2F À…A¨ãòÁ
Á`D0À,Á@Ï° Á`DÀ,A€á@    &) 6) 4ã5S„     a      A,      t)‚(ˆâ(Hò(„2 # ĞáÈ10 €Ö#@F
 X1  @ RÁ(Ò‘1b` €-°GPŒ p¡=cÄ` €Z1 `F ˆ    /** @file scene.c
	@brief
	This file contains main scenario routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "scene.h"
#include "actor.h"
#include "grid.h"
#include "main.h"
#include "lbaengine.h"
#include "text.h"
#include "resources.h"
#include "music.h"
#include "renderer.h"
#include "gamestate.h"
#include "redraw.h"
#include "movements.h"
#include "sound.h"
#include "animations.h"
#include "extra.h"
#include "screens.h"

uint8* currentScene;


void setActorStaticFlags(int32 actorIdx, uint16 staticFlags) {
	if (staticFlags & 0x1) {
		sceneActors[actorIdx].staticFlags.bComputeCollisionWithObj = 1;
	}
	if (staticFlags & 0x2) {
		sceneActors[actorIdx].staticFlags.bComputeCollisionWithBricks = 1;
	}
	if (staticFlags & 0x4) {
		sceneActors[actorIdx].staticFlags.bIsZonable = 1;
	}
	if (staticFlags & 0x8) {
		sceneActors[actorIdx].staticFlags.bUsesClipping = 1;
	}
	if (staticFlags & 0x10) {
		sceneActors[actorIdx].staticFlags.bCanBePushed = 1;
	}
	if (staticFlags & 0x20) {
		sceneActors[actorIdx].staticFlags.bComputeLowCollision = 1;
	}
	if (staticFlags & 0x40) {
		sceneActors[actorIdx].staticFlags.bCanDrown = 1;
	}
	if (staticFlags & 0x80) {
		sceneActors[actorIdx].staticFlags.bUnk80 = 1;
	}

	if (staticFlags & 0x100) {
		sceneActors[actorIdx].staticFlags.bUnk0100 = 1;
	}
	if (staticFlags & 0x200) {
		sceneActors[actorIdx].staticFlags.bIsHidden = 1;
	}
	if (staticFlags & 0x400) {
		sceneActors[actorIdx].staticFlags.bIsSpriteActor = 1;
	}
	if (staticFlags & 0x800) {
		sceneActors[actorIdx].staticFlags.bCanFall = 1;
	}
	if (staticFlags & 0x1000) {
		sceneActors[actorIdx].staticFlags.bDoesntCastShadow = 1;
	}
	if (staticFlags & 0x2000) {
		//sceneActors[actorIdx].staticFlags.bIsBackgrounded = 1;
	}
	if (staticFlags & 0x4000) {
		sceneActors[actorIdx].staticFlags.bIsCarrierActor = 1;
	}
	if (staticFlags & 0x8000) {
		sceneActors[actorIdx].staticFlags.bUseMiniZv = 1;
	}
}

void loadScene() {
	int32 i;
	int32 scriptSize = 0;
	uint8* localScene = currentScene;

	// load scene ambience properties
	currentTextBank = *(localScene++);
	currentGameOverScene = *(localScene++);
	localScene += 4;

	alphaLight = *((uint16*)localScene);
	localScene += 2;
	betaLight = *((uint16*)localScene);
	localScene += 2;

	// FIXME: Workaround to fix lighting issue - not using proper dark light
	alphaLight = 896;
	betaLight = 950;

	sampleAmbiance[0] = *((uint16*)localScene);
	localScene += 2;
	sampleRepeat[0] = *((uint16*)localScene);
	localScene += 2;
	sampleRound[0] = *((uint16*)localScene);
	localScene += 2;

	sampleAmbiance[1] = *((uint16*)localScene);
	localScene += 2;
	sampleRepeat[1] = *((uint16*)localScene);
	localScene += 2;
	sampleRound[1] = *((uint16*)localScene);
	localScene += 2;

	sampleAmbiance[2] = *((uint16*)localScene);
	localScene += 2;
	sampleRepeat[2] = *((uint16*)localScene);
	localScene += 2;
	sampleRound[2] = *((uint16*)localScene);
	localScene += 2;

	sampleAmbiance[3] = *((uint16*)localScene);
	localScene += 2;
	sampleRepeat[3] = *((uint16*)localScene);
	localScene += 2;
	sampleRound[3] = *((uint16*)localScene);
	localScene += 2;

	sampleMinDelay = *((uint16*)localScene);
	localScene += 2;
	sampleMinDelayRnd = *((uint16*)localScene);
	localScene += 2;

	sceneMusic = *(localScene++);

	// load hero properties
	sceneHeroX = *((uint16*)localScene);
	localScene += 2;
	sceneHeroY = *((uint16*)localScene);
	localScene += 2;
	sceneHeroZ = *((uint16*)localScene);
	localScene += 2;

	scriptSize = *((uint16*)localScene);
	localScene += 2;
	sceneHero->moveScript = localScene;
	localScene += scriptSize;

	scriptSize = *((uint16*)localScene);
	localScene += 2;
	sceneHero->lifeScript = localScene;
	localScene += scriptSize;

	sceneNumActors = *((uint16*)localScene);
	localScene += 2;

	for (i = 1; i < sceneNumActors; i++) {
		uint16 staticFlags;
		
		resetActor(i);

		staticFlags = *((uint16*)localScene);
		localScene += 2;
		setActorStaticFlags(i, staticFlags);

		sceneActors[i].entity = *((uint16*)localScene);
		localScene += 2;

		if (!sceneActors[i].staticFlags.bIsSpriteActor) {
			hqrGetallocEntry(&sceneActors[i].entityDataPtr, HQR_FILE3D_FILE, sceneActors[i].entity);
		}

		sceneActors[i].body = *(localScene++);
		sceneActors[i].anim = *(localScene++);
		sceneActors[i].sprite = *((uint16*)localScene);
		localScene += 2;
		sceneActors[i].X = *((uint16*)localScene);
		sceneActors[i].collisionX = sceneActors[i].X;
		localScene += 2;
		sceneActors[i].Y = *((uint16*)localScene);
		sceneActors[i].collisionY = sceneActors[i].Y;
		localScene += 2;
		sceneActors[i].Z = *((uint16*)localScene);
		sceneActors[i].collisionZ = sceneActors[i].Z;
		localScene += 2;
		sceneActors[i].strengthOfHit = *(localScene++);
		sceneActors[i].bonusParameter = *((uint16*)localScene);
		localScene += 2;
		sceneActors[i].bonusParameter &= 0xFE;
		sceneActors[i].angle = *((uint16*)localScene);
		localScene += 2;
		sceneActors[i].speed = *((uint16*)localScene);
		localScene += 2;
		sceneActors[i].controlMode = *((uint16*)localScene);
		localScene += 2;
		sceneActors[i].info0 = *((int16*)localScene);
		localScene += 2;
		sceneActors[i].info1 = *((int16*)localScene);
		localScene += 2;
		sceneActors[i].info2 = *((int16*)localScene);
		localScene += 2;
		sceneActors[i].info3 = *((int16*)localScene);
		localScene += 2;
		sceneActors[i].followedActor = sceneActors[i].info3;
		sceneActors[i].bonusAmount = *(localScene++);
		sceneActors[i].talkColor = *(localScene++);
		sceneActors[i].armor = *(localScene++);
		sceneActors[i].life = *(localScene++);

		scriptSize = *((uint16*)localScene);
		localScene += 2;
		sceneActors[i].moveScript = localScene;
		localScene += scriptSize;

		scriptSize = *((uint16*)localScene);
		localScene += 2;
		sceneActors[i].lifeScript = localScene;
		localScene += scriptSize;
	}

	sceneNumZones = *((uint16*)localScene);
	localScene += 2;

	for (i = 0; i < sceneNumZones; i++) {
		sceneZones[i].bottomLeft.X = *((uint16*)localScene);
		localScene += 2;
		sceneZones[i].bottomLeft.Y = *((uint16*)localScene);
		localScene += 2;
		sceneZones[i].bottomLeft.Z = *((uint16*)localScene);
		localScene += 2;

		sceneZones[i].topRight.X = *((uint16*)localScene);
		localScene += 2;
		sceneZones[i].topRight.Y = *((uint16*)localScene);
		localScene += 2;
		sceneZones[i].topRight.Z = *((uint16*)localScene);
		localScene += 2;

		sceneZones[i].type = *((uint16*)localScene);
		localScene += 2;

		sceneZones[i].infoData.generic.info0 = *((uint16*)localScene);
		localScene += 2;
		sceneZones[i].infoData.generic.info1 = *((uint16*)localScene);
		localScene += 2;
		sceneZones[i].infoData.generic.info2 = *((uint16*)localScene);
		localScene += 2;
		sceneZones[i].infoData.generic.info3 = *((uint16*)localScene);
		localScene += 2;

		sceneZones[i].snap = *((uint16*)localScene);
		localScene += 2;
	}

	sceneNumTracks = *((uint16*)localScene);
	localScene += 2;

	for (i = 0; i < sceneNumTracks; i++) {
		sceneTracks[i].X = *((uint16*)localScene);
		localScene += 2;
		sceneTracks[i].Y = *((uint16*)localScene);
		localScene += 2;
		sceneTracks[i].Z = *((uint16*)localScene);
		localScene += 2;
	}
}

/** Initialize new scene */
int32 initScene(int32 index) {
	// load scene from file
	hqrGetallocEntry(&currentScene, HQR_SCENE_FILE, index);

	loadScene();

	return 1;
}


/** Reset scene */
void resetScene() {
	int32 i;

	resetExtras();

	for (i = 0; i < NUM_SCENES_FLAGS; i++) {
		sceneFlags[i] = 0;
	}

	for (i = 0; i < OVERLAY_MAX_ENTRIES; i++) {
		overlayList[i].info0 = -1;
	}

	currentPositionInBodyPtrTab = 0;
	useAlternatePalette = 0;
}

/** Change to another scene */
void changeScene() {
	int32 a;
	
	// change twinsen house destroyed hard-coded
	if (needChangeScene == 4 && gameFlags[30] != 0)
		needChangeScene = 118;

	// local backup previous scene
	previousSceneIdx = currentSceneIdx;
	currentSceneIdx = needChangeScene;

	stopSamples();

	resetScene();
	loadHeroEntities();

	sceneHero->controlMode = 1;
	sceneHero->zone = -1;
	sceneHero->positionInLifeScript = 0;
	sceneHero->positionInMoveScript = -1;
	sceneHero->labelIdx = -1;

	initScene(needChangeScene);

	//TODO: treat holomap trajectories

	if (needChangeScene == 116 || needChangeScene == 117)
		currentTextBank = 10;

	initTextBank(currentTextBank + 3);
	initGrid(needChangeScene);

	if (heroPositionType == kZone) {
		newHeroX = zoneHeroX;
		newHeroY = zoneHeroY;
		newHeroZ = zoneHeroZ;
	}

	if (heroPositionType == kScene || heroPositionType == kNoPosition) {
		newHeroX = sceneHeroX;
		newHeroY = sceneHeroY;
		newHeroZ = sceneHeroZ;
	}

	sceneHero->X = newHeroX;
	sceneHero->Y = heroYBeforeFall = newHeroY;
	sceneHero->Z = newHeroZ;

	setLightVector(alphaLight, betaLight, 0);

	if (previousSceneIdx != needChangeScene) {
		previousHeroBehaviour = heroBehaviour;
		previousHeroAngle = sceneHero->angle;
		saveGame();
	}

	restartHeroScene();

	for (a = 1; a < sceneNumActors; a++) {
		initActor(a);
	}

	inventoryNumKeys = 0;
	disableScreenRecenter = 0;
	heroPositionType = kNoPosition;
	sampleAmbienceTime = 0;

	newCameraX = sceneActors[currentlyFollowedActor].X >> 9;
	newCameraY = sceneActors[currentlyFollowedActor].Y >> 8;
	newCameraZ = sceneActors[currentlyFollowedActor].Z >> 9;

	magicBallIdx = -1;
	heroMoved = 1;
	useCellingGrid = -1;
	cellingGridIdx = -1;
	reqBgRedraw = 1;
	lockPalette = 0;

	needChangeScene = -1;
	changeRoomVar10 = 1;
	changeRoomVar11 = 14;

	setLightVector(alphaLight, betaLight, 0);

	if (sceneMusic != -1) {
		playMidiMusic(sceneMusic, 0); // TODO this should play midi or cd tracks
	}
}

/** Process scene environment sound */
void processEnvironmentSound() {
	int16 s, currentAmb, decal, repeat;
	int16 sampleIdx = -1;

	if (lbaTime >= sampleAmbienceTime) {
		currentAmb = Rnd(4); // random ambiance

		for(s = 0; s < 4; s++) {
			if(!(samplePlayed & (1 << currentAmb))) { // if not already played
				samplePlayed |= (1 << currentAmb); // make sample played

				if(samplePlayed == 15) { // reset if all samples played
					samplePlayed = 0;
				}

				sampleIdx = sampleAmbiance[currentAmb];
				if(sampleIdx != -1) {
					decal = sampleRound[currentAmb];
					repeat = sampleRepeat[currentAmb];

					playSample(sampleIdx, (0x1000+Rnd(decal)-(decal/2)), repeat, 110, -1, 110, -1);
					break ;
				}
			}

			currentAmb++;    // try next ambiance
			currentAmb &= 3; // loop in all 4 ambiances
		}

		// compute next ambiance timer
		sampleAmbienceTime = lbaTime + (Rnd(sampleMinDelayRnd) + sampleMinDelay) * 50;
	}
}

/** Process zone extra bonus */
void processZoneExtraBonus(ZoneStruct *zone) {
	int32 a, numBonus;
	int8 bonusTable[8], currentBonus;

	numBonus = 0;

	// bonus not used yet
	if (!zone->infoData.generic.info3) {
		for (a = 0; a < 5; a++) {
			if (zone->infoData.generic.info1 & (1 << (a + 4))) {
				bonusTable[numBonus++] = a;
			}
		}

		if (numBonus) {
			int32 angle, index;
			currentBonus = bonusTable[Rnd(numBonus)];

			// if bonus is magic an no magic level yet, then give life points
			if (!magicLevelIdx && currentBonus == 2) {
				currentBonus = 1;
			}

			angle = getAngleAndSetTargetActorDistance(Abs(zone->topRight.X + zone->bottomLeft.X)/2, Abs(zone->topRight.Z + zone->bottomLeft.Z)/2, sceneHero->X, sceneHero->Z);
			index = addExtraBonus(Abs(zone->topRight.X + zone->bottomLeft.X)/2, zone->topRight.Y, Abs(zone->topRight.Z + zone->bottomLeft.Z)/2, 180, angle, currentBonus + 3, zone->infoData.generic.info2);
			
			if (index != -1) {
				extraList[index].type |= 0x400;
				zone->infoData.generic.info3 = 1; // set as used
			}
		}
	}
}


/** Process actor zones
	@param actorIdx Process actor index */
void processActorZones(int32 actorIdx) {
	int32 currentX, currentY, currentZ, z, tmpCellingGrid;
	ActorStruct *actor;

	actor = &sceneActors[actorIdx];

	currentX = actor->X;
	currentY = actor->Y;
	currentZ = actor->Z;

	actor->zone = -1;
	tmpCellingGrid = 0;

	if (!actorIdx) {
		currentActorInZone = actorIdx;
	}

	for (z = 0; z < sceneNumZones; z++) {
		ZoneStruct *zone = &sceneZones[z];

		// check if actor is in zone
		if ((currentX >= zone->bottomLeft.X && currentX <= zone->topRight.X) &&
			(currentY >= zone->bottomLeft.Y && currentY <= zone->topRight.Y) &&
			(currentZ >= zone->bottomLeft.Z && currentZ <= zone->topRight.Z)) {
			switch (zone->type) {
			case kCube:
				if (!actorIdx && actor->life > 0) {
					needChangeScene = zone->infoData.ChangeScene.newSceneIdx;
					zoneHeroX = actor->X - zone->bottomLeft.X + zone->infoData.ChangeScene.X;
					zoneHeroY = actor->Y - zone->bottomLeft.Y + zone->infoData.ChangeScene.Y;
					zoneHeroZ = actor->Z - zone->bottomLeft.Z + zone->infoData.ChangeScene.Z;
					heroPositionType = kZone;
				}
				break;
			case kCamera:
				if (currentlyFollowedActor == actorIdx) {
					disableScreenRecenter = 1;
					if (newCameraX != zone->infoData.CameraView.X || newCameraY != zone->infoData.CameraView.Y || newCameraZ != zone->infoData.CameraView.Z) {
						newCameraX = zone->infoData.CameraView.X;
						newCameraY = zone->infoData.CameraView.Y;
						newCameraZ = zone->infoData.CameraView.Z;
						reqBgRedraw = 1;
					}
				}
				break;
			case kSceneric:
				actor->zone = zone->infoData.Sceneric.zoneIdx;
				break;
			case kGrid:
				if (currentlyFollowedActor == actorIdx) {
					tmpCellingGrid = 1;
					if (useCellingGrid != zone->infoData.CeillingGrid.newGrid) {
						if (zone->infoData.CeillingGrid.newGrid != -1) {
							createGridMap();
						}

						useCellingGrid = zone->infoData.CeillingGrid.newGrid;
						cellingGridIdx = z;
						freezeTime();
						initCellingGrid(useCellingGrid);
						unfreezeTime();
					}
				}
				break;
			case kObject:
				if (!actorIdx && heroAction != 0) {
					initAnim(kAction, 1, 0, 0);
					processZoneExtraBonus(zone);
				}
				break;
			case kText:
				if (!actorIdx && heroAction != 0) {
					freezeTime();
					setFontCrossColor(zone->infoData.DisplayText.textColor);
					talkingActor = actorIdx;
					drawTextFullscreen(zone->infoData.DisplayText.textIdx);
					unfreezeTime();
					redrawEngineActions(1);
				}
				break;
			case kLadder:
				if (!actorIdx && heroBehaviour != kProtoPack && (actor->anim == kForward || actor->anim == kTopLadder || actor->anim == kClimbLadder)) {
					rotateActor(actor->boudingBox.X.bottomLeft, actor->boudingBox.Z.bottomLeft, actor->angle + 0x580);
					destX += processActorX;
					destZ += processActorZ;

					if (destX >= 0 && destZ >= 0 && destX <= 0x7E00 && destZ <= 0x7E00) {
						if (getBrickShape(destX, actor->Y + 0x100, destZ)) {
							currentActorInZone = 1;
							if (actor->Y >= Abs(zone->bottomLeft.Y + zone->topRight.Y) / 2) {
								initAnim(kTopLadder, 2, 0, actorIdx); // reached end of ladder
							} else {
								initAnim(kClimbLadder, 0, 255, actorIdx); // go up in ladder
							}
						}
					}
				}
				break;
			}
		}
	}

	if (!tmpCellingGrid && actorIdx == currentlyFollowedActor && useCellingGrid != -1) {
		useCellingGrid = -1;
		cellingGridIdx = -1;
		createGridMap();
		reqBgRedraw = 1;
	}
}
/** @file scene.h
	@brief
	This file contains main scenario routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef SCENE_H
#define SCENE_H

#include "sys.h"
#include "actor.h"

#define NUM_SCENES_FLAGS	80

#define NUM_SCENES_ENTRIES	120
#define NUM_SCENES	NUM_SCENES_ENTRIES-1

#define NUM_MAX_ACTORS		100
#define NUM_MAX_ZONES		100
#define NUM_MAX_TRACKS		200

enum ScenePositionType {
	kNoPosition	= 0,
	kZone		= 1,
	kScene		= 2,
	kReborn		= 3
};


int32 needChangeScene;
int32 currentSceneIdx;
int32 previousSceneIdx;

uint8 *spriteShadowPtr;
uint8 *spriteBoundingBoxPtr;

int32 currentGameOverScene;
int32 alphaLight;
int32 betaLight;

/** Timer for the next sample ambience in scene */
int32 sampleAmbienceTime;

int16 sampleAmbiance[4];
int16 sampleRepeat[4];
int16 sampleRound[4];
int16 sampleMinDelay;
int16 sampleMinDelayRnd;

int16 samplePlayed;

int16 sceneMusic;

int16 sceneHeroX; // newTwinsenXByScene
int16 sceneHeroY; // newTwinsenYByScene
int16 sceneHeroZ; // newTwinsenZByScene

int16 newHeroX; // newTwinsenX
int16 newHeroY; // newTwinsenY
int16 newHeroZ; // newTwinsenZ

int16 zoneHeroX; // newTwinsenXByZone
int16 zoneHeroY; // newTwinsenYByZone
int16 zoneHeroZ; // newTwinsenZByZone

/** Hero Y coordinate before fall */
int16 heroYBeforeFall;

/** Hero type of position in scene */
int16 heroPositionType; // twinsenPositionModeInNewCube

// ACTORS
int32 sceneNumActors;
ActorStruct sceneActors[NUM_MAX_ACTORS];
ActorStruct *sceneHero;

/** Meca pinguin actor index */
int16 mecaPinguinIdx; // currentPingouin

/** Current followed actor in scene */
int16 currentlyFollowedActor;
/** Current actor in zone */
int16 currentActorInZone; // currentActorInZoneProcess
/** Current actor manipulated in scripts */
int16 currentScriptValue; // manipActorResult

int16 talkingActor;

// ZONES

typedef struct ScenePoint {
	int16 X;
	int16 Y;
	int16 Z;
} ScenePoint;

typedef struct ZoneStruct {
	ScenePoint bottomLeft;
	ScenePoint topRight;
	int16 type;
	union {
		struct {
			int16 newSceneIdx;
			int16 X;
			int16 Y;
			int16 Z;
		} ChangeScene;
		struct {
			int16 dummy;
			int16 X;
			int16 Y;
			int16 Z;
		} CameraView;
		struct {
			int16 zoneIdx;
		} Sceneric;
		struct {
			int16 newGrid;
		} CeillingGrid;
		struct {
			int16 textIdx;
			int16 textColor;
		} DisplayText;
		struct {
			int16 info0;
			int16 info1;
			int16 info2;
			int16 info3;
		} generic;
	} infoData;
	int16 snap;
} ZoneStruct;

int32 sceneNumZones;
ZoneStruct sceneZones[NUM_MAX_ZONES];

enum ZoneType {
	kCube		= 0, // Change to another scene
	kCamera		= 1, // Binds camera view
	kSceneric	= 2, // For use in Life Script
	kGrid		= 3, // Set disappearing Grid fragment
	kObject		= 4, // Give bonus
	kText		= 5, // Displays text message
	kLadder		= 6  // Hero can climb on it
};


// TRACKS

int32 sceneNumTracks;
ScenePoint sceneTracks[NUM_MAX_TRACKS];

// TODO: check what is this
int16 changeRoomVar10;
int16 changeRoomVar11;

uint8 sceneFlags[80]; // cubeFlags

/** Change to another scene */
void changeScene();

/** Process scene environment sound */
void processEnvironmentSound();

/** Process actor zones
	@param actorIdx Process actor index */
void processActorZones(int32 actorIdx);

#endif
BCÀŞ!  ë  ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q  ì   ˆ@ Ä`Ãlÿÿÿÿ? Áå0óĞğ å0é0åĞæ íä ˜C8°Ã<”@¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´@òPå îğm`òíPm ïî@å mPìíĞîğîĞìPá` áïĞéàæ0m`ğĞíô€€9„;ÌC9 „;¼C¸C8¸Ã<´9ÀC´C8Ğ: æì0å ó@á0ëĞğ ï@å0ôğòĞâPæ`å m0é å à@Ôƒ;ÌC8˜C9´9ÀC´C8Ğ: æì0å õ0åĞóğæ@m`ìğá@€9„;ÌC9 ˆ! °±Aüÿÿÿÿ@°C9ÌÃ<´<ÈC9ŒC:ÌC9´9ÀC;„9 æì0å îğm`òíPm ïî@å mPìí Ğƒ<ÔC9 ƒ;¼C˜ƒ<„C;”CÀÃ;¤ƒ;ĞC9ÈC”;¤C;´;¼ƒ;´;”C8˜@¸Ã;´A:¸ƒ9ÌC˜<´A;„= `áÀóP áïĞîî0m`ğĞíô€€9„;ÌC9 Ä<ĞC8ŒÃ:´<ÈÃ;ĞC9Œ=¼ƒ<´8Ôƒ9˜C9ÈCÌC:èC9 x õàóæPm`ğĞíô€€9„;ÌC9 D=ÌC9´Á<¼ƒ9ĞC˜;¼C8Ğ`áÀóPÀ†Ú(şÿÿÿ $€"Ø¡æaÚ ä¡Æ!æ¡ÚÀà¡Â sv˜‡r wx‡60y‡v(‡6€‡wHw ‡r‡6(vH‡v èAê¡€ÁŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ÚÀŞÁÚ€Ê!Ì ÜáÚ ÜÁæ¡ÌÚ ÂĞ0‡p`‡y(€p‡whww˜‡60xhƒvz@ÀÂæ¡ bè!ÆaÚ äáè¡ÆŞAÚ@êÁÌ¡ä¡æ!ô¡ < ˆzp‡ys(‡60xhƒvz@ÀÂæ¡ ¢æ¡Ú`ŞÁè¡ÌŞ!è0‡p`‡y(`a ¶8@6Èÿÿÿÿ€P  I     „@˜„˜‚bÂ`Ä„`˜d‚`  ‰   ±   2"
 d…$¤„$ã„¡LŒ„M¤Ä’ ‡ISD	“ÏNÀ„ß;E”0¡ à2iŠ(aò;¬DøÀØ)¢„	s`@ sĞ9ÒQÂäÏoê Í„ƒc¤)¢„ÉŸßÍ¹Ğpppp–4E”0ùš09‘éT;E”0!ÂÀÀ€à4iŠ(aòµaZ„!¢˜ vŠ(aBBÁIÒQÂäkÂäDìQÂ„ì@`€€€€€ € €€€€€€€€€€€€€€€€€€€€€€ € €€€€€€€€€€€€€€€€ !A!Éˆ
ˆ 	‚h&.’¦ˆ&Ÿˆ†H¤™Ğ```p‹4E”0ù@ã4ˆ00008…j§ñÆiP`q‘4E”0ù³ÓìQÂ„ŠŠ
ƒƒ$Ã ŒD¨ „ Ã¤)¢„ÉG+"Z ¬D¤‰"J˜Ğa``````
’€ $r–4E”0ùŞ5E@‰H;E”0¡ÈÀÀÀÀÀÀ ÁÀÀÀÀ€ÀÀÀ eH¨$‘
è$‘(%¡h…Ì€\’€`Ò2 €dÒ€hR€lRÂ€p’£€t’ƒ€xH"ƒè'ç
((çh(A¨(±	
è(±	() h) ¨i OU‚'’*Â“Q‚À¡€€¬Š@@@X5x"­"<W!È«OV+È‘FÌè¬”VZ+ µ‚€€€€Şæ‚)  
º¸Fš"J˜| qG„İÑ™% í	Y\#M%L>Ğ8O#ÂÀÀÀ€ş®‘¦ˆ&hœÆ¯Q`@×HSD	“4NãÛ(0 Ák¤)¢„É§ño$P!!Ğ  °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD 6ÄN‡ÁùĞ"8ZçC‹à|hœ2‚2BFPFÈJ	A)á"(%\¥„‹ ”p”.‚’‚Fp>´N àC‹àÔ¨”-‚“ÃFP:  =nc |hœ.‚ò¡EpäÆ‡ÁùĞ"8%\¥„‹ ”p”.‚RÂEPJ¸J	A)á"(%\¥„‹ ”p”.‚RÂEP>´N	AùĞ"8ZçC‹à”p”.‚RÂEPJ¸J	A)á"(%\¥„‹ |hœ.‚RÂEPšèN	A)á"(%\¥„‹ |hœ.‚ò¡Ep¢ìNÁùĞ"8ZçC‹à,`Œ.‚RÂEP:¼N‡Áéğ"8^§Ã‹à”p”.‚RÂEPJ¸J	A!#(%\¥„‹ ”p”.‚RÂEPJ¸J‡Áéğ"8%\¥„‹ |hœ-‚ó¡Ep:¼N‡ÁùĞ"8%\¥„‹ txœ/‚ÓáEp²ôÎÁùĞ"8ZçC‹à|hœ-‚ó¡Ep>´N‡Áéğ"8ZçC‹à|hœ-‚ó¡Ep>´Î‡ÁùĞ"8ZçC‹à|hœ-‚ó¡Ep>´Î‡Á9’#Gr£Ã‹àtxœ-‚ó¡Ep>´Î‡ÁùĞ"8ZçC‹àtxœ-‚ó¡Ep>´Î‡ÁùĞ"8Zç‹ |hœ-‚ó¡EpäÆ‡Á)á"(%\¥„‹ ”p”.‚RÂEPJ¸J	A)á"(c~ã˜`¬	Œ7b‚ó¡EpæŒ	Ê‡Á¹C&8{ÊçC‹à|hœ.‚RÂEPJ¸J	A)á"(%\åC‹à|hœ-‚ó¡EpúÌN	AùĞ"8Ì¥ÏŒà|hœ-‚ó¡Ep>´N	AùĞ"8ZçC‹à|hœ.‚’‚FpJ¸J	A)á"(Z§Ğ™à$BœFi‚Ó(Mp"©	N¥5Á)á"(%\¥„‹ ”p”.‚RÂEP:¼N‡Áéğ"8^§Ã‹àdbŒNm‚Ñ©M0J¸J	Aéğ"8Ú²Ä      Yf      †,µ À     C–[ €    €!K.       Àe      `È²@     0d™      ²ì     Yv     †,½      C–\ €    €!Ë/ @    Àe€      `È²@     0d©      ²„     Yf      †,ã      C–r €    €!:       ÀE€      `È’@     0da      ²ô      Yv     †,»      C–\ €    €!Ë. @    ÀÅ€ 0    `ÈÒ@     0dé      ²ô     Y~     †,ğ      Y    "   2˜$LŒ	&GÆC ‚ 2 ‚ J † ‚ ‰ š Œ Ú   ‘ * “ J • r ˜ ’ š ² œ Ò  ú    ¢ : ¤ Z ¦   y     C„xHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   ^  VEDähÂˆÃ•®h‹¦Gšf@$PQÔ!ÀÒ×ä5S„u@4ÓÁB˜i€BIHc°@fá„êú³œwzÿ'–­MEä4Ó‹„³QEAD"YiÀƒ4ÑLN„’8,-qM›sµÎc‹SÑ`%"MÆ°´Ä5±“ópÎâD6à<‘“¤$³BD
DOä„$iÂäD³Ó’MU9Zƒ0âpi ¸z,+¾!,À<±:T3˜a PEm‡D@¶Í8”DpÄ² FÈ`iåDÊ‹„³QEAD–àH ó,„‰4± ˜IED3±B„<Ó,a…Ò “Ö Œ,’@4„&LN$™›³8Î“F„$I`5DäxÍ„LXº¢-šjiÂKD4­ˆqLvÀH ó,ÄJ<0™À#PQD4SK\Ó4Šå5,ÜDì„D,-qM›s¥@0µD,-qM›s¥@0¶‘PHSÍäD˜	ˆ:H3I&°<ÀBL±‚›f¢ÒTD39vRLI …´9—
0TSD‘-Âö°Ğ+a~Ò€ KK\ÓF±HFXÍĞf¬Ä–¹8HSÍäDXa±"¹Òht8iä$„0!Nc&ÏAD¼…°,æ°D„DLŞ5E€d­Œp8ˆ@hd‘é0À<‘. FVàTÎ"Ã@4b3—)8O„4SK\ÿQm,’0ÏBhL€@´C˜~ Í`ŒÎ!ÍÔ×Ä¿@t›c€óDH3µÄ5ñ/åöà<ÒL-qMüDº‘-ÁâÊF™¡@$Óç49’Ä9‹Yd€óDH3µÄ5ñ/ñ&×,óhÂäDìD<Öà<Î‚­D3Q‹=„½HHSÍäD‹dDa‹Î!ÍÔ×Ä¿@dÛ~€ò, ÆÌ³Öb	TÍ´`Ÿ³,Eš09‘I,a C¼@„ÛdÀÒ0ÄD¹I8À<!¥€!a›@EÑL©#!â4b³9–NQÆà<Q!%iÂäD±5L­·?GEÑL%1MD›ôDD…8”Ä
DCˆÃeŒ@EÑL¬@4„HE'Å ÅJ`mÎeSëÅíÏQQD4SILÉÆ HÑ!9±5(’@4DHDlŠ$‘3[Å"	DC´ (’
<HƒL±,Hc€2ØÕ8Óä0%QL±a-3MSÅ$[Ö8Óä0%QL³qHED3½Îµò!a‚Ñ€ KK\Óæ\›3Mc§ÒTD39ö-€!Ñ"=2-,„ñ8Ò„ÖÑÁm1ˆ°Ë"—$™Ó!9±‰$™Ó!9²‘$™Ó!9³‰À @õD@HÒì4„wM°9%YØ! ±­@Ä,‹#xÍa6v CDÀlØš@EÑL–F@H1hÂäDâp™‹Ò0DÄ¶RˆÁ
A4+!ÍDDv 2iÂäD£4„Å³-(’@4„IIˆ`=’@EÑLš09‘ØÌNCØ‹Ò0DÈÖà<Q!%iÂäD²98ODTˆCIš09ÑlÄLD4mÎ49Œ$ÏJ4½µY-9Zƒ0âp™u@õD@HÒêLÀ„8Í†iÂ˜u‘ã52a®ËŠ¯g‰$‘cêJDHÄ¤	“™Ñ!ÀàX±Ò%Ò!ÀàX³A8’@4ÄI1š09‘d>ÊAD&LˆÓXÒ$ÀàXœ³,ˆ„8M‹=„%QL¦CI„u<ED3±ÑâpYg€$Õ!Àâ±QA°-óˆME4“aâD0†Ğ<€™È€˜”„°H“ó° ó,„d9Ç -ÂDähÂˆÃu¢«©•æ°4ƒ/MÄe”ÌH!2Dó:—!,¡	“Gb ñ-€!m€óDN’:ÒÌ
A4FãÄ² FÈ —-ABä<›3MÃ
A4¶'°´Ä5±Mœ³8‘…°ÓD4 ÀÂ>€@lÄdDcˆÎ!ÍÔ×Ä§ST›#Ì³ @#–à<ÒL-qM|:E¶,@ƒ0UDdÛwÀ4³QEADµÙ,‹#()°ÓDXt $Ì³‹dDa*ÒTD39vRI`’](’@4Ä· †dÉQ@ÁB°O„L„ØÄeOÒAD×LÈ„u"Ë­^ëÙyÀÃ H“1MÄ
nšy,ÀÜ<™RP“£!IHEw &PQD4“&LN¤5ã]S¤Sde…0tHdpÎâ8GEÑL$kÀd Á"KLÒ’u,
}ÀéÙsÀ4‘ALš09Q‡HĞ„-<Oä„$iÂäDé™ €RD‘-Âö÷°´Ä5mÎUÅdæ M
,Ä4¦° Cp‡ƒ„döPDHM!9¬@4„Q8’@4ÄI1mŠdĞ€ KK\Óæ\+b“!M±É$9¦Sƒ!M³QM9Zƒ0âpu"Ë­^ë¢ÀCX^c ¡	â4’yQÒ!±9T3 ±9W:EvĞ ÃP"±E Ä¶P„4É†R=Q!%…DälÄTˆCE DD3QI“¥DODTˆCI!9Zc,„$ÑDÔ:ı4À0x×›ÓP’H` Â,‹F]›C5aÙŒ@EÑLìD<±i0ED3±ñÈ¶ÀTÍÄNÄ3[Ñ#=2,’-,„M(’@4Äì4„dzÍ€ KK\ç,NdŞÏHI`_0D:EÀTÍdR"Øœ’9Ã
A4v( `µÄ5}Ô²HBDÙ Oä$©#ÉV€<‘“¤[} "a·È9IêH³•(°¬„DLÄ`'ÍADÎF@…8Td]ôDÈD°08V:E6@I ó,„”. †4†&LN$Ùq€ÓPZ¬ÄÖæ\–àH@E¤€Ñ	0„A0À<!µ@°öÃLÀ¢ ¡	“™l€óDN’:RÌ
A46=ÀBL±‚›ÆQÒä0–(°DÎL„&LNd£ÒTD39vRLI …d×Ø9!I% M«3â4Zc,„İ<Â4±:óQMÎ#@c«ã0/Õµm<AÜ4Á
DC˜eÀóDH3µÄ5ÕôDµõA,-qMìD<,’¦I ó,„‰4± ØÚ6€ 22˜TDN3½È@8UDdŠAL[„
{ al‘$DÑ”£POaéÉâ +añĞâ CHD×LÈ„’İ1,-qM,’¶Ó0€%Q‹8\Và<ÒL-qM/Õ·ñ$Ä5E@‰H“å(N4N9‰l¸ŠM‡“FNf@ñL¼„›n€âDÓá¤‘“ÌöDä¤„LˆÓ´ØCØ %PQD40Z+aÕĞ ‹dDaZÉä<+bSl[Éä<+b“l\Éä<+bÓl«JC1Üá !PóD@H’&LN[@Ä¤5ÆBhÍÀSD1iÂäD"M@#&Ô<‘#’¤	“ÍVÄ”ˆqLöå0„ ¤HcPH#—ù@ Ù›õDD…8”T:Î“F„$I`Ö$DäxÍ„L˜Ö†¥×Šœ)4Oä„$iÂäD²±$HƒL¬@4„¡)b“éPa$qRÌì4„dvGá4S:E¶5Ä5u°´Ä5yÍa‚4„‘[{€1±ÑV‚4„‘3ÛÒVHDlòÒ SK\Ó4ŠÑAE,-qM,’†0IÄ¤	“±0!Â· †d¡ÒTD39vR	H!,Ï”ˆqLñ„êúbéİİÿ‰¥g¨Ìá,<ß’IM9Zƒ0âpimXz­ÈYÛ²8Îc:‘N‘}H` Â,ËI1›C5a™Û!ÍÔ×Ä§ñ ±QEAD/ÙV `‰0D´9—Õ=E,-qMét‘ã52a'ºšZiôDL%bÓK“Y @#D0`„&ğØo@TÑD\œãDÒ !y@ò GI“Ã˜ÆDI„¶LDÔ ‘1M„™!…L À–p=‘#’ä59C4ëPÍ  a   ó   a     DPEPQ T€(P€ˆP€R€@P€€H@UPuPµP5Q5R 5T@5P€5(P€5HP€5ˆP€5Q€5R€ 5T€@5(P€€åÿ?P€ 3ñ&ÃL„D¼‰0!ÈÁ Fq  ˆ¢9Ğá†ÀÂ`–!2Æx¹àB0ŞäB.\ ±ˆ
Ò@+HƒŒ ˜%ˆD| ÃA8„Á,Ã@ñ†w‡`¼! r¸@b)ÈV ;A0K@Ğ%. ˆ
LA‡vƒY†ÂˆãúâÁxCğïpÄR *Ø­`v0‚`–À 1D° ÃÁ=„Á,Ãtc¼¡dò!oôA.X
D¤ ÂF Ì Ôâ‚¨@t¸!‰0˜eH”€ä`Œ7ÀIãAI”ÄK¨ ´‚VØÁ"€Y…ğ@\@ƒ7-³PŒñ†y‰`¼!€	˜¸@b)Ø‚V`;A0KÀĞ(ˆ¢wĞá† 'Â`–¡qB…1Ş`6:Œ7;±H,¢‚_Ğ
~a#ˆ@ f	rqAT€:ÜŒEÌ2<P@³0Æâ¦,‚ñ†À,Ìâ‰¥@T€Z:ì`À,D¹ . ˆ
DB‡·ƒY†H
ÈÆxßÀE0ŞÄE\\ ±ˆ
âA+ˆ‡Œ ˜%ˆÄQKèpCa0Ë0Q¥Ão8½Æ¾à‹$–Q>hú°ƒD  ³½ƒ¸€ *°	nH#f*+ zã²cÁxCp§qÄR *	­`$v0‚`–À"}D`¡ÃÁk„Á,Ã…ôc¼¡wb#odC6.X
D,¡°ÄF Ì`Tâ‚¨@-t¸!Ğ0˜eÈ´€TbŒ7 oãAoôÆK¨ &´‚šØÁ"€Y`B\@Ğ…7å³ÌpDâ‚¨à.t¸!H0˜eè¼€rbŒ7ÜÏzã{°ÇK¨@,´±ØÁ"€Y~B\@„†7ô³Dc¼A„ì#oîã>.X
Dk¡¬ÅF Ì€†    æ*°H0!Â· †d­ LN$       a   ö  O,   '   DP%P…P@ETeQåQ,èPì%Q…S:ÅSÅ?P %R$eR(¥R.S2ES6dP%@C‘A°Á"CÑA°Á"CB°Á"C‘A°á&CÑA°á&CB°á&C‘A°Ñ&CÑA°Ñ&CB°Ñ&C‘A°ñ&CÑA°ñ&CB°ñ&   3á&ÃLÄC¸É0án2ÌDH„›ƒƒ, õÊŒ‚ aŒ'r0Q@B¸€ #Â% :ÆxB`ƒI0 $„b0‚\‚ eŒ'x0Ñ@Í¸@b)Ä`Dº@ÑOBa0b
€¦qÄR . ˆÁw	€®1œÂ`DÀ`D¼ôÁ FÀ eã‰¥@F¨A  Äñ„€#¼` ÈH,b0Â 0ã	A,FŒA0 4ã‰¥@FÈA  dc<!°…Á4€Ğ`\ ±ˆÁ;€Ö`Œ'»0ÑÁ PŒ$–1¡ Œñ„ #ä  ’ƒqÄR #ü  ªƒ1”Ã`Ä@w0.X
Ä`„(@z0ÆuŒàƒ` ˆÆKŒ0…@ èÆxBğƒ¡ …Â¸@b)ƒª ‘ÂOèa0Â‚ SH,b0Â Tã	A>F¬B0 ´
ã‰¥@FÈB  ä
c<!ğ‡ÁX€`a\ ±ˆÁ[€faŒ'#1QÁ P-Œ$–1±6 .Œñ„ %#t! Ò…qÄR #Ş& ê…1´Ä`Ä/@¿0Æ—Œ‡` HÄ`İ@ã0.X
Ä`„İ@æ0Æ›Œ@‡` ÆKŒĞ›@ hÆxB°ƒí µÃ¸@b)ƒ~ ÁÃOÀb0B‚ yH,â‚Œ¸‡` ÈÆxB`ƒø áÃ Óãj”Å`D0 ñÃ ~ã	0áÁ ?Œ$–qAFŒD0 $c<!‹Á’€HbìŒñ†À6àb0"€PbJŒñ„@ŒP‰` H%ÆK¸€ #t' r‰1øÅ`L0!~1 ³ÉÄ ŞÃB€³‚PMŒ`Ä€8€	¨&ÆKŒ¸‰@ 'ÆxB€ƒ: ñÄ #ÀˆOŒ$–qAXŒñ†ş‰`¼!ØŒˆ ±ã	ÁlF”E0 tc¼A„ì#oîã>.X
Dzè…7û³ÄĞ[Œñò`¼!øØ ı4c¼Á…D$oFD<(# ˜‰Q³ÙÅOÊc0/‚ !\@Äc¼á†V$oX$=#b ¨/ÆxBÀƒ 	á‚ Ñã>$#ÁxC0#ï1@¤1.X
ÄAª1ÆÊ(G‚ñ†@GÖc0" €VcŒ'û1ÑÁ PkŒ$–qAĞlŒñ7“`¼!şŒˆ ÛãqT&ÁxC`&ÿAÁ İãu”&ÁxC &ú1@»1Æ‚Œè` ¨7ÆK¸€ h<ÆxƒÉI0ŞÌÉŠFÄ yŒñ†Pª“`¼!°¡`zŒñ†RÊ“`¼!Ğ“Œˆ õã	ÁF´G0 Ôã‰¥@\@4c¼Á•D%oFEG#b È>ÆxC,•J0Ş˜JP0H?ÆxC-¥J0Ş¨
FÄ Ğ~Œñ„`M#ú# ê1°É`Ä@B¸€ hDÆxƒ/ÉJ0ŞÌ
˜FÄ ‰Œ$–qAŠŒñ†rÊ•`¼!Ğ8Œˆ ã	ÁF´H0 ô"c¼A|%o~¥N(´‰FÁ ŒŒ$–qAŒñ†y:—`¼!@—9Œˆ ã	AªFìH0 ´#ã‰¥@\@&c¼Ÿà%oâeO#b HLÆxB +ƒd ‘É¸@b)©Éo(©|	Æ}•Áˆ€ Z“1ìÊ`D›@m2.X
ÄBs2Æ\Jd‚ñ†`dVe0" €èdŒ'ä2a'Á Œ$–qŸŒñ†›Z™`¼!`™YŒˆ >ã	A»FüI0 ô'ã‰¥@\@ T*c¼¬h&ojfW#b ÈTÆxB`/ƒ¨ ¡Ê¸@b)¹ÊoH«	ÆŸ™—Áˆ€ z•1üË`D¬@³2ÆÜJl‚ñ†`lğ…‚A·2ÆäÊl‚ñ†àlØe0" €peŒ''3¡+Á . ò•1ŞWmŒ7n#/ƒ1 ô+c<!p™Áˆp	€„pAP¹ŒñĞ¢›`¼!¨|Œˆ sã	AÍF K0 $„‚ØeŒ7œÖŞãßøË`D@ µËOxf0â]‚ !\@4/c¼ÁµD'oF‡d#b ˆ^ÆK¸€ #ò% Â—1 Í`„¾@ú2¨_Æxn±N0Ş´ÚFÄ Ğ¿ú—1ƒ! …Ì¸@b)Ä`„É@%3Æ‚ºŒ8™` èd©Ìo(¯Ü	Æİ¡›Áˆ€ b™A,3Æa0Âe‚˜%(f†}‚Á™	`–  ˜H,â‚Œğ­` ˆfÆxB@:ƒ6À`Î˜Ï Ì„3ƒÂk7Ì2 J@93.X
ùÌo0¯ö	Æ÷qŸñ†à}Şg0"(€ÀfŒ'°3!6Á ØŒ$–Ag3ÆŞË~‚ñ†à~îg¼!ÀÛŒ
 ´ã	AîF¬M0 ´6ã‰¥@ÜŒñüúŸ`¼! !oB|#‚B HnÆxB >ƒt ÑÍ¸@b)”7c¼!ÄP(oRè|ÆR¡Áˆ  Ú›1¬Ï`Dß@}3.X
‰ÎoP±
Æ‚Ÿñ†`†âg0"(€HgŒ'ô3a:Á éŒ$–A«3ÆfL‡‚ñ†`‡òg¼!à¡ıŒ
 Öã	AÿF¼N0 ô:ã‰¥@íŒñ£`¼! £Œ Úã	A	FÜN0 t;ã‰¥@ïŒñ2[£`¼!`£º oÇ7r£ÁˆÀ ú1¼Ğ`Dø@á3.X
™Ïop³:
Æ;š¡ğv¼!À#Œ ôã	AF¬O0 ´>ã‰¥@üŒñ<û£`¼! ¥º oÇQ
£ÁˆÀ šŸ1ŒÑ`Dı@õ3.X
éÏoµT
ÆU:£ğv¼!`¥4Œ şã	AFüO0 ô?ã‰¥@	ñV›¥`¼! %8Œ ã	AFœP0 ³	¥Ğ°À@0±BÁ Ì”Bã‰¥@\@ƒµ µĞOúh0â…‚Œˆ¡_€Y‚…bh®á!@ƒYÆ	H†ÆK ã½fNÁxCpNç4@84ÆTŒĞ¡` H‡ÆK ãåæNÁxCğN­4@`4ÆXŒ£` HŒÆK 3ãífOÁxCpO¶4@h4Æ\ŒP£` f	b£aA.`0Â‚˜%X0
   ¶- HB„<‹d„u,ÒLˆğ-€!™¶@€·€²8°°Ñ       a      A,      DP 3á&Ã`D0 éÈ aŒ p
q"# ¨Bá@      Ö*P Í@\     a   +   I,      DPPdP4e»å 3Ñ&ÃˆÁ  Â`Dp0KP0†f" aŒ7üˆƒÀ,Á@Å°`Á`ÄÀ,A0q´Á ÌtŒá†`AƒY	(ãdÁxCĞ`DàÀ,ÁAÌ°@Á`„À,A1q&t0 ƒf2€á@   &+         a   Ë   T,      DP5PeQ%QÅSìERR%T>eTè¥PEP AÅQ%@CcÀ,BĞ	MÙnÁØnÅØnÕØnÙ    3Ñ&½Én00˜e†€pA7¢³ÂFĞ‰6 ³ÉÉŒ“` ¨NÆ`0b0  3b0  9Œ °¨Œñ†À¸ÁˆÀ€HeŒ7¨ĞFg0 d*c¼!Po0"X… Tã+|ƒÁ ©Êo\#‚6 •1b@  <$*c¸!0˜e(ˆ€He7d ³…FüŠÀ,A¿2,(Œ ¡Ê1   2q7z ³ªˆÁT	€NEFœJ  d*b0ÂT˜%@ˆUÄ2Ü¼Ì2(I@¯". á†€À`–AY*1+ P¹ˆÁX	€ÊEF¼J  ³ÍŠ¸€@è\ÆxC°¨0@µ"#f%€„ÖeŒ7ï°
ƒÁ0 t+â¡wãÁ<¸Â`D0 ñË ~# ¸„Ø‘Ë tÃB³L¯ˆÁ_	€îeŒ7û€
Œ`0"\1 `f	šƒ Da0"za f	
…Aû2†„ f( RÀˆq 8Ì@d
Ã‚q Á`*0KàFœIÀ`„¹„ FÈIÀ`D¹”Ä ¹ˆd¼afN"oP¢(CF¤K0 ¤.âoÈ™–Æ—P
F¼ƒî Á‹¸€@Æ~f&‚ñ†€&Ş‚Q<ä`Ä¼0!/á  ƒñ0/á  ƒï0á.à  ƒíb02õ0 ƒì0±.â  ô3ƒ~fŒ B¤3ânò!f¤) ÈˆA røÄ,Á„á@     –,         a   t   M,      DP5PÅPTePddP5   3Ñ&ÂL„D´‰0!m"ÌDHD›3Ñ&Â`D` ‘È$ÃBp³Œ `
HvF( F,v  ³-ân,4˜e–€XD\@ ôˆ¤ºàŠt¸! …0˜eHˆ€(q”G6". 
†½À #t$ Òq7e ³…Fôˆ*À,A¸€@Æf¥
Ä`Ä }ânŞ f$ 2Èx®ĞB@Œ@ƒ@ (Ä2ŞĞ+¸P #Ö  RqŒ àôâ©!0Óƒ 4â©€Èˆ dâ1P  ˜!…R…R˜%Xf	ÒQÀ`@| . 
FA/0€ÁP`–@¡PFŒB  ³‰Ê1 @$h^ÄRC`t/â±! ® KFäJ0 ³†
   ¶+`DÄC “á
’å
(ED3iL`¼‰0ÏBˆÃeºÅ@À    a   ¼   P,      PDPEP¥PEQ….PeQ€dP  3ú@¼É0ño2ÌD<Ä›3ü@¼I0QoÌD<Ä›3ñ&Ã`ÄQÀ`Da@Çoî@º oÇ‚< (Ã„Á,ÃƒÀ,@Ìn.4˜e€1ŞüvŞ7¡àQ . ¢†j‚+"Ğá† Â`–(ÊÆ @Ú° @0Á0Ş°µ‚00KPÌäØ ƒ`À,@ßnb!f'1 €HF	7ŒA-„Á2€ĞD7·³K„d¸!¸0˜eP–`0"ô  f	jƒ1Şô‚Œ7¾àˆ„ä`Œ7â ãÁ8Œâ1# Áˆ‘ õT@
Dz0Æu8…ñ†`NqĞŒñ†àŞa¼!€V @\@ f 1 @$‚
bh^ÆxCp¯@Á {ã>ÄcÄà €• "ŒH…` ÈÆxCà»0ŞüÃ?P . š…1ŞŒÄHŒ7$AˆÄŒ #DØDPA9íÂoVÆ–H
ÄBà0Æ˜h‡ñ† &ÚqP9Œñ† &jb¼!°	y @\@ f 1  -‚
î©C¸€@,ĞP<Œñ† ,øá¼oÆâ(Èˆ sÑa?(G0!Á <Œá† Â`–i¢‡1Ş /jŒ7kñˆ¤‚Ø`0¢€BbŒ7qÁàíxC0.1˜„ Ì4³Î,Áƒá@      Æ+ Ö+€4³9%°@4ÆBX°@4qÙ¯ #PQD4Óæ4”d­Dæ4„ù
(ÓPR       a   ë       PDPePeQ…QEQR¥Qfˆ?P
ÅP6R€H@%PE@S¶[¶[‚¶[„ 3ñ&ÃLÄC¼É0ño2ÌD<Ä›3ñ&ÃLÄC¼É0Ao2ÌDèñ&Ã`"@Èo€R#ˆ` ˆã)pŒÁ& :ÆxC
c@ÁŒp‚ eŒ7¬@ŒÁ( jÆxCğ
d0œÁ F@°0 Tá† Â`–AºÆ01& Ìƒ-À,Á@Õ WÃB€³„„ñ†XÁ…`0â
€ºAØovaÆ^à
Ä2Ü`g0ËPàA@d0èã8üÁxC0ã@¸€@†Œ f<H™ÁoÒ!Æu8
Ä2Ü`g0ËpàA@q0¨ÆxC ­0ŞÄƒ+P . á#HƒYºƒAt0Æ‚{¸‡ñ† fq7ÁÌ2$xÚƒ1ŞøÃ.Œ7ÿ ˆd¸ÁÒ`–AÁƒ€BaŒ7$ñˆd˜ˆî€E–7yâÄ‚“kN¼=>1b…1Ü DÌ28L@¨0Æ•È
ÆpCÀf0ËĞ8­Âo\B.ğÛñ† &`‚qFL0 $c¼! 	u `-Œñ†à&nb¼!À	œ @\@ f! ]ãAOäÃ~;Şü?P . ;\` ƒ0 ÃoÊâ(Tc¼!@´oÒÂ$(ˆAhÆxCà*qß7p±ˆÄ À`ÄÏ@ô0Æ»p	
ÙÃoò"/Æ½¨	
ÄbFâ‡1ŞüÅN\à·ãAhôâ±# Á0á6 FÌMLÀ,3KpT6â¡–ÃB ³PF¬MM ¡Í ”ãk Å€;Ş¸ÆZP . á†#ƒY†)
èmÅÄoh.. Üñ†À6â‚q7AÌ2LR@v3('ÆxCÀxqà7¾¡ˆd¸áÂ`–a¢‹1ŞŒÇ_\ ¸ãAyˆâŒ0` È,ÆxC¥qà7ëaˆd0bu‚ ¶ãÁ{¬Æ€;ŞÄGkP . ÁØ	`0buşB f	¨Y‚j–àH.ÆxCP±qà7÷qˆ„òbŒ7ûƒÁ0 ³w@»#. 1Ü `0Ë€uÁ`hôÆ Pîˆ„@cŒ7#òîxCP"%B¸€@† f2. ÓãŠ˜Ç„;Ş°‹P . á†À<Â`–AÛ‚ƒ pc–`#×ãAŒ´Ç„;ŞÌÈŒP #Ü' ²qF¼O  # øÁ¸€@F “`Ä`  ğ˜%àf	ºY‚; ßÃÁ„Á,C|©¸€@†	ƒY0ƒ`ÄàP 3Éõ “!ß# ÄI0K³w@æ1†1	ƒY†2ƒ€âG\@ ÃA™„Á,”A0b0 @{yŒñ†àLFäÃoÒÄD(Èˆ rP|Œ`0b öãÁ›¬È†;ŞÄIœP .  ò$1 @?F À“™%(ƒY‚; üÃA„Á,ƒœA@;$. á† FÂ`–ì  üãÌc¸!È0˜eXƒ4ˆ?ÆxCà'7BÁnhfÖ@‘1ŞˆÊP0†ƒY†5°ƒ€HdŒ7¦’#ãÁ©œÊxC€*¨B¸€@HEÆxCÀ*?2Ş´
šŒ7®â*ˆ„`dŒ7²&Â# àÊRFâ!1 Œ £` hŒÄBd4,@0aFÁ á†ÀWÎ`–ê  4Ã¸œÁ,CÔA@l4†:IƒY7¨ƒ€Øh7v’³oPÁÑ 2ãÁ¹„
Ã‚:ÍÑ10  ]!nØ%fà€‚Á>Â 6ã» 
ƒÜdŒ7ñ/ã¼¼
â¡9ã½ÌÊxCp/´B¸€@Ì@0b@$@ÊÜ
78ÁÌ2Ä4*cÄàP “™T™`–`¨TÆˆÁ¡ (“+ ó+Á,ÁÌĞÁ,AÌØÁ,ÁÌàÁ,AĞ¨Àƒ¥À,Á@¤2†‚’	ƒY?Øƒ€Ve9‰d¸aÀ`–ü  qÈpC0.a0ËĞ~F˜Ó­À`D9İŠ Œ P+ƒä„+0Kà   Æ,àLÌÃË‚4!ƒ5€09‘-™! ED3Å–,€TÍ$›² "PQD4Ól­ LN$—9™Ó            /** @file images.c
	@brief
	This file contains image processing.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "screens.h"
#include "resources.h"
#include "main.h"
#include "sdlengine.h"
#include "music.h"
#include "hqrdepack.h"
#include "lbaengine.h"


/** Load and display Adeline Logo */
void adelineLogo() {
	playMidiMusic(31, 0);

	loadImage(RESSHQR_ADELINEIMG, 1);
	delaySkip(7000);
	fadeOut(paletteRGBACustom);
	palCustom = 1;
}

/** Load and display Main Menu image */
void loadMenuImage(int16 fade_in) {
	hqrGetEntry(workVideoBuffer, HQR_RESS_FILE, RESSHQR_MENUIMG);
	copyScreen(workVideoBuffer, frontVideoBuffer);
	if (fade_in) {
		fadeToPal(paletteRGBA);
	} else {
		setPalette(paletteRGBA);
	}

	palCustom = 0;
}

/** Load a custom palette */
void loadCustomPalette(int32 index) {
	hqrGetEntry(palette, HQR_RESS_FILE, index);
	convertPalToRGBA(palette, paletteRGBACustom);
}

/** Load and display a particulary image on \a RESS.HQR file with cross fade effect
	@param index \a RESS.HQR entry index (starting from 0) */
void loadImage(int32 index, int16 fade_in) {
	hqrGetEntry(workVideoBuffer, HQR_RESS_FILE, index);
	copyScreen(workVideoBuffer, frontVideoBuffer);
	loadCustomPalette(index + 1);
	if (fade_in) {
		fadeToPal(paletteRGBACustom);
	} else {
		setPalette(paletteRGBACustom);
	}

	palCustom = 1;
}

/** Load and display a particulary image on \a RESS.HQR file with cross fade effect and delay
	@param index \a RESS.HQR entry index (starting from 0)
	@param time number of seconds to delay */
void loadImageDelay(int32 index, int32 time) {
	loadImage(index, 1);
	delaySkip(1000*time);
	fadeOut(paletteRGBACustom);
}

/** Converts in-game palette to SDL palette
	@param palSource palette source with RGB
	@param palDest palette destination with RGBA */
void convertPalToRGBA(uint8 * palSource, uint8 * palDest) {
	int i;

	for (i = 0; i < NUMOFCOLORS; i++) {
		palDest[0] = palSource[0];
		palDest[1] = palSource[1];
		palDest[2] = palSource[2];
		palDest += 4;
		palSource += 3;
	}
}

/** Fade image in
	@param palette current palette to fade in */
void fadeIn(uint8 * palette) {
	if (cfgfile.CrossFade)
		crossFade(frontVideoBuffer, palette);
	else
		fadeToPal(palette);

	setPalette(palette);
}

/** Fade image out
	@param palette current palette to fade out */
void fadeOut(uint8 * palette) {
	/*if(cfgfile.CrossFade)
		crossFade(frontVideoBuffer, palette);
	else
		fadeToBlack(palette);*/
	if (!cfgfile.CrossFade)
		fadeToBlack(palette);
}

/** Calculate a new color component according with an intensity
	@param modifier color compenent
	@param color color value
	@param param unknown
	@param intensity intensity value to adjust
	@return new color component*/
int32 crossDot(int32 modifier, int32 color, int32 param, int32 intensity) {
	if (!param)
		return (color);
	return (((color - modifier) * intensity) / param) + modifier;
}

/** Adjust palette intensity
	@param R red component of color
	@param G green component of color
	@param B blue component of color
	@param palette palette to adjust
	@param intensity intensity value to adjust */
void adjustPalette(uint8 R, uint8 G, uint8 B, uint8 * palette, int32 intensity) {
	uint8 localPalette[NUMOFCOLORS*4];
	uint8 *newR;
	uint8 *newG;
	uint8 *newB;
	uint8 *newA;

	int32 local;
	int32 counter = 0;
	int32 i;

	local = intensity;

	newR = &localPalette[0];
	newG = &localPalette[1];
	newB = &localPalette[2];
	newA = &localPalette[3];

	for (i = 0; i < NUMOFCOLORS; i++) {
		*newR = crossDot(R, palette[counter], 100, local);
		*newG = crossDot(G, palette[counter + 1], 100, local);
		*newB = crossDot(B, palette[counter + 2], 100, local);
		*newA = 0;

		newR += 4;
		newG += 4;
		newB += 4;
		newA += 4;

		counter += 4;
	}

	setPalette(localPalette);
}

/** Adjust between two palettes
	@param pal1 palette from adjust
	@param pal2 palette to adjust */
void adjustCrossPalette(uint8 * pal1, uint8 * pal2) {
	uint8 localPalette[NUMOFCOLORS*4];

	uint8 *newR;
	uint8 *newG;
	uint8 *newB;
	uint8 *newA;

	int32 i;
	int32 counter = 0;
	int32 intensity = 0;

	do
	{
		counter = 0;

		newR = &localPalette[counter];
		newG = &localPalette[counter + 1];
		newB = &localPalette[counter + 2];
		newA = &localPalette[counter + 3];	

		for (i = 0; i < NUMOFCOLORS; i++) {
			*newR = crossDot(pal1[counter], pal2[counter], 100, intensity);
			*newG = crossDot(pal1[counter + 1], pal2[counter + 1], 100, intensity);
			*newB = crossDot(pal1[counter + 2], pal2[counter + 2], 100, intensity);
			*newA = 0;

			newR += 4;
			newG += 4;
			newB += 4;
			newA += 4;

			counter += 4;
		}

		setPalette(localPalette);
		fpsCycles(50);

		intensity++;
	} while(intensity <= 100);
}

/** Fade image to black
	@param palette current palette to fade */
void fadeToBlack(uint8 *palette) {
	int32 i = 0;

	if (palReseted == 0) {
		for (i = 100; i >= 0; i -= 3) {
			adjustPalette(0, 0, 0, (uint8 *) palette, i);
			fpsCycles(50);
		}
	}

	palReseted = 1;
}

/** Fade image with another palette source
	@param palette current palette to fade */
void fadeToPal(uint8 *palette) {
	int32 i = 100;

	for (i = 0; i <= 100; i += 3) {
		adjustPalette(0, 0, 0, (uint8 *) palette, i);
		fpsCycles(50);
	}

	setPalette((uint8*)palette);

	palReseted = 0;
}

/** Fade black palette to with palette */
void blackToWhite() {
	uint8 palette[NUMOFCOLORS*4];
	int32 i;

	i = 256;
	for (i = 0; i < NUMOFCOLORS; i += 3) {
		memset(palette, i, 1024);

		setPalette(palette);
	}
}

/** Resets both in-game and sdl palettes */
void setBackPal() {
	memset(palette, 0, NUMOFCOLORS*3);
	memset(paletteRGBA, 0, NUMOFCOLORS*4);

	setPalette(paletteRGBA);

	palReseted = 1;
}

/** Fade palette to red palette
	@param palette current palette to fade */
void fadePalRed(uint8 *palette) {
	int32 i = 100;

	for (i = 100; i >= 0; i -= 2) {
		adjustPalette(0xFF, 0, 0, (uint8 *) palette, i);
		fpsCycles(50);
	}
}


/** Fade red to palette
	@param palette current palette to fade */
void fadeRedPal(uint8 *palette) {
	int32 i = 0;

	for (i = 0; i <= 100; i += 2) {
		adjustPalette(0xFF, 0, 0, (uint8 *) palette, i);
		fpsCycles(50);
	}
}

/** Copy a determinate screen buffer to another
	@param source screen buffer
	@param destination screen buffer */
void copyScreen(uint8 * source, uint8 * destination) {
	int32 w, h;

	if (SCALE == 1)
		memcpy(destination, source, SCREEN_WIDTH*SCREEN_HEIGHT);
	else if (SCALE == 2)
		for (h = 0; h < SCREEN_HEIGHT / SCALE; h++) {
			for (w = 0; w < SCREEN_WIDTH / SCALE; w++) {
				*destination++ = *source;
				*destination++ = *source++;
			}
			memcpy(destination, destination - SCREEN_WIDTH, SCREEN_WIDTH);
			destination += SCREEN_WIDTH;
		}

}

/** Clear front buffer screen */
void clearScreen() {
	memset(frontVideoBuffer, 0, SCREEN_WIDTH*SCREEN_HEIGHT);
}
/** @file images.h
	@brief
	This file contains image processing.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef SCREENS_H
#define SCREENS_H

#include "sys.h"
#include "main.h"

/** In-game palette (should not be used, except in special case. otherwise use other images functions instead) */
uint8 palette[NUMOFCOLORS * 3];

/** SDL converted in-game palette */
uint8 paletteRGBA[NUMOFCOLORS * 4];

/** SDL converted custom palette */
uint8 paletteRGBACustom[NUMOFCOLORS * 4];

/** flag to check if a custom palette is in use */
int16 palCustom;

/** flag to check in the game palette was changed */
int16 palReseted;

/** flag to check if the main flag is locked */
int16 lockPalette;

/** flag to check if we are using a different palette than the main one */
int16 useAlternatePalette;

/** main game palette */
uint8* mainPalette;

/** SDL converted in-game palette */
uint8 mainPaletteRGBA[NUMOFCOLORS * 4];

/** Load and display Adeline Logo */
void adelineLogo();

/** Load a custom palette
	@param index \a RESS.HQR entry index (starting from 0) */
void loadCustomPalette(int32 index);

/** Load and display Main Menu image */
void loadMenuImage(int16 fade_in);

/** Load and display a particulary image on \a RESS.HQR file with cross fade effect
	@param index \a RESS.HQR entry index (starting from 0)
	@param fade_in if we fade in before using the palette */
void loadImage(int32 index, int16 fade_in);

/** Load and display a particulary image on \a RESS.HQR file with cross fade effect and delay
	@param index \a RESS.HQR entry index (starting from 0)
	@param time number of seconds to delay */
void loadImageDelay(int32 index, int32 time);

/** Converts in-game palette to SDL palette
	@param palSource palette source with RGB
	@param palDest palette destination with RGBA */
void convertPalToRGBA(uint8 * palSource, uint8 * palDest);

/** Fade image in
	@param palette current palette to fade in */
void fadeIn(uint8 * palette);

/** Fade image out
	@param palette current palette to fade out */
void fadeOut(uint8 * palette);

/** Calculate a new color component according with an intensity
	@param modifier color compenent
	@param color color value
	@param param unknown
	@param intensity intensity value to adjust
	@return new color component*/
int32 crossDot(int32 modifier, int32 color, int32 param, int32 intensity);

/** Adjust palette intensity
	@param R red component of color
	@param G green component of color
	@param B blue component of color
	@param palette palette to adjust
	@param intensity intensity value to adjust */
void adjustPalette(uint8 R, uint8 G, uint8 B, uint8 * palette, int32 intensity);

/** Adjust between two palettes
	@param pal1 palette from adjust
	@param pal2 palette to adjust */
void adjustCrossPalette(uint8 * pal1, uint8 * pal2);

/** Fade image to black
	@param palette current palette to fade */
void fadeToBlack(uint8 *palette);

/** Fade image with another palette source
	@param palette current palette to fade */
void fadeToPal(uint8 *palette);

/** Fade black palette to white palette */
void blackToWhite();

/** Resets both in-game and sdl palettes */
void setBackPal();

/** Fade palette to red palette
	@param palette current palette to fade */
void fadePalRed(uint8 *palette);

/** Fade red to palette
	@param palette current palette to fade */
void fadeRedPal(uint8 *palette);

/** Copy a determinate screen buffer to another
	@param source screen buffer
	@param destination screen buffer */
void copyScreen(uint8 * source, uint8 * destination);

/** Clear front buffer screen */
void clearScreen();

/** Init palettes */
void initPalettes();

#endif
BCÀŞ!  }  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  ¤   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l À6D `ˆ" Ä`a€l ƒ Ë"ùÿÿÿÿ6Š ,@   I     ‚`B L†`‚@ˆÂ8‚	’L%™†Â8 ‰   A   2"È	 d…“#¤„“#ã„¡LŒ„äL”Â’€ 
Ì@4  Ğ @‡T Ì€A .’¦ˆ&Ÿsš1>d!Ğ—H(ÅBP(
…B¡P(
…B¡P(
…‚	(  Gr ’– ’¤€(©  )Rb@™ä(Ğ&9ÔIä€}9@A¡$Ğ(¡T:Kš"J˜|M˜œÈt*‚"J˜1t(AŠTeH)Ä*CJ1 WR
‚!U YR¢BQ((ÈV†T¡@¸R(
…‚tÅH €‚‚xsA1R€Bá£_1R…‚Bá£à@À    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD 
â#ÁPŞ§ hxœ‚xÀˆ€Œ  ÁPŞ'ÁPÜ¥áp
âãC0Ü%ÁPÜ%ÁPÜ%ÁPÜ%ÁPÜ%ÁPÜ%ÁPFæã„0VêãÅpbÚ§æPbÚ'pzò'¦p‚ô§hpbÚ'¦pbÚg0Ü%ÁPÜ%ÁPÜ¥ápŞ§ápŞ§ápÜ%ÁPÜ%ÁPÜ%‰PbÚ'ÁPÜ%ÁPÜ%ÁPÜ%¦pbÚ'ÁPÜ¥ápšú'ÊpbÚ'¦pbÚ'¦pbÚ'ÁPbÚ²¬      YÚ      †,o  À     C–8 @    €!Ë      À¥       `Èr@     0dÉ      ²Ì      Yæ      †,q  @     C–<       €!K      Àe      `È’@     0d™      ²ì      Yú  €    †,y  @     C–8 @    €!Ë      À€ 0    `È²      0d™      ²Ì      YD€    †,k  @     Y       2˜LŒ	&GÆCŒ b€# T Ã F È1@ ’Œ e€,# ” Í uF è3@¡  Pi€N#  y     C„QHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   K  &„@2 CØÃb ÁÀ3‘±4 59š’„T„‰IÀPÒÄE$¥ÀBLa	…0tHdj‹°@Ä
A42 Cp‡ƒ„ÄÓ„4†d9ÔADÖ Œ8\éŠ¶hªq¤%Å#q˜°’U5‹&ÑP"„y%BäHÒ„-9‹ã<ED3‘f
%!ÁADÃÂ H“1M„y,ÀÜá !YÆƒ4ÑLN„’MEä4Ó‹„³QEAD"Ù$8MEDS
,­³‚›feÔ²TŒÏŒDLşC#¼Ü¶M%± « IH` Â,‹F]›C5aTGJM† <À²1ƒ¡)0+1¤Àb8ÓADÖ Œ8\Èr«×zvSDähÂˆÃ¥àê±¬øz†•À@´N
,ÖR=Q!%…DälÄTˆCEÆå,0ˆ`± ˜¹DODTˆCI!9Zc,„	<–)/2ÎFY’³8Î“F„$I`fòHO„L‹dDaWŠà<+DÑÍt‘ã52aéŠ¶hªq¤‘0ED3™”„ö¤dÃ°BDiE‹%M“1M„,°ÓD¬à¦…4ÑLN„™€©ƒ4“d‡P²†‘#I3™…4ÑLN„S@!mÎe+ÍADÎF@…8Td"ÒTD39ÖÁBX#"Z#YDdTDº  C˜T²8À 2€A@ô 1MÄ
nGI“ÃX—Q !6v!ME4“a'Å”PH––-KÅøÁæ?4Âûğ>rÛÖÔ,óhÂäDìD<6"!ME4“a,’-,„@Eä4Ó‹„³QEADvIBDMé8
õ´@°¶³	TÍ”:2!N#6›3`éµ@`<KàL“Ã”D1ÅÖ³Î49LI“lfŠDL ()°Ø†ƒ4ÑLN„}`Hæ³Î49LIÓlˆP±ˆÃe%‹ôDÈD´@°Á0€°,âpÙO29ÏŠÇP29ÏŠÇ$[P29ÏŠÇ4›S5 ,+DÑ¬„@4Ù‡ÒPw8ˆ@HöµÀ@´Î¶ ‚bJÖâPRé8O’D$™Îr‘£5#—ÅH9^3!¦µaéµ"g2ÔAD×LÈ„i ¸z,+¾ÒÊ!ÀàX²¥Ò5ÔÄ‚4Dé4¡ºş«Ç²ÿ'–)b“éPa*“t ƒcqÎ² â4-öF”,D1™%Æ-óˆME4“aâD0Õ<€™È€˜”„V!!ME4“a'Å€t’q0‡³8ğ|`H6t,Ğ"adL° ‚Ò:ğL„ÕD9Zƒ0âpèjj¥ÙL9Zƒ0âpimXz­È™Cb ñ-€!Ù™R ‘ËJ!1€°,'ÅlÕ„½@Bä<›3MÃ
A4†´,ó˜NE¤SdÇ,Ä4Öğ0 Ò¤ÀBL±‚›f0ĞAD×LÈ„èjj¥),‹#()°ÓDX@ò GI“ÃXX	%M)°ÓD„4ÑLN„C˜dYŠDL)°ÓD˜Õr@HL^3E˜ÍH9^3!Ö‰,·z­g%Ú2QLD
,Ä4 a      A,      4(Rl[ù”†2@a… # ÈÁpB1b@  # ¼A0!…    a   &   D,      4(R” †2@a… 3˜ÃL¡„„0!0@#1h$cÄÀ  9„€NbIŒƒ è@, 1  `JÄpCa0ËÁˆ wĞÌ# ØA3K0F¸Ä#    öwÀ@üHc~ÒÄ      a      C,      ¤(B!ÌPFs(ì €  3†òÃ`DP 	c¸!ÀÂ`–AÆˆ gÌ   æw<ÀBL    a      D,      ¤( ÂP†P(ì °  3„Â`DP …Ä # ¼DƒFbŒ B@†n¸0˜e„`Ä€  9Hf	† â ™%#R¢     æwÀ@üH    a      A,      ¤(.!ß   3†ÃL„¡€Ä0) 1ÌD`
HƒD2 ƒ2 4*Æˆ ` Hr`8      ægH	„ı-!MHLˆÓXa@`™a@p       a   #   E,      ¤(B(²2    3†òÃL¦üÃ0!00d0KP0†#f" b1F@Ïó„`Ä€  3@f	*†#` f	BÆˆ sFÄ'       F æw<ÀBL    a      A,      ¤(*e€Â
;e †Â
;    3˜òÃ`DP Ä aŒ ğ„Œ °…á@      æW Í@\      a   1   E,      ¤("(@‚B(  3†ÃL„¡€Ä0) 1FÊ FÉ FÜ ÌŒá†à@ƒY¨ã	ÁGA cŒ'b0@ÊO 
1c<!˜#‚! èã	EA hŒ'×`D0 Mc<!¸#ª` Èã	60K05,ğ@00K`8    v öw<ÀÒÒd~É,¬CE       a      A,      4(RôC	Pa(C vPØ  3˜"ÃL¦ˆÄ0! 0@Â1( ‚ƒ„aG ‚ ì 1      æW Í@\öGLC     a      D,      ¤(B!ÌPFs(ì €  3†òÃ`DP 	c¸!ÀÂ`–!
‰AÄ1(  „`–` bŒ  Á,Á@Æ1       æw<ÀBL    a   %   G,      4(R”@!Y 3†ÃL¦€Ä0! 0h@ş .PÈpCÀÁ,C`ƒ2 ³c¸!ğÎ`–a(:cÄ I 61!1  @–Y‚aÁ‚Á%€Ya–ÀŒ8	H 0   V æw<ÀBL    a   )   D,      ¤( 3˜"ÃL¦ˆÄ0)"1ÌD`ŠH3˜"Ã`¡À`ÄÀ`„€À`Dp 	c¸!èÂ`–A*Æ` À,Á@Æ d˜„€aB RF	‘3L@0 0K0P2      öWÎâDP<@0 ÍD42aæ‡0Î€    a   „   E,      ¤(B(ä€"(ƒ$    3…2ÁLD¡ŒD0Q(#ÌDÊH3˜2ÃL„ ŒD0a(#1ÌDÊH3†2ÃL„¡ŒÄ0)#1ÌD`ÊH3˜2Ã`DƒÀ`sÀ`ÄbÀ`„RÀ`DBÀ`„ @ÉŒ ‚oHÖ`#’` Æ6¨#’` Æ–6˜#’` Æ7˜#’` #Œ7€Y‚€Œ1ÜPh0Ë QáEĞ2ˆã	@A¸@ƒ JáÀ ¸  „Áˆ@ òÂŠ kX€  0ã	@A¸@Ôƒ bØ ¸  4c0"€Ò \ ƒaA€€Ø`Œ'áEPŒƒ zğ ¸  äc0"€Ü`F¶ $c<!ğƒÁ:€æ`Œ' 0QÁ Œñ„@#ì  ªƒ1Â`Ä@u0,0FÜA0 ³ÙÁ° @0Á Ìãá0b@ @=    FpÕLDd€Áfh‚	ÒLD#!f•b’DCXšEam6P, ,p<ÀBLaDCX ù«90‹# K
,Ä4ö@4„µ      a      H,      ¤(B(ä€"(ƒ$(2  3†ÃL„¡€Ä0!( ÌD
H3†ÃL„¡€Ä0a( 1ÌD`
H3˜ÃL¦€Ä0¡L0‘H0!”Á Fe0 ³Á`„P@ÂoHÌ ŒH‚ bX@`¼Iƒ`0b	€a‚ñ†‡‚Áˆ& R†Æ¤7#` #8€Yœ1Ü`h0Ë0=ƒ°1„AÔ nŒ'áE6F H…C8ƒà PŒÁˆ@ ê†m :ƒ1„Ac0,˜Œñ„@  \ Bƒ1bp @. Â €à`FB Pô tc<!((‚æ`X 
  >ã	@A¸@„cÄà €t@„S.  ıÁŒ„  ?ƒ8 ÂOZa0¢‚ Rã	Á+F˜B0 T
c<!ˆ…ÁˆS€LaŒ'³0
Á )jƒ¨À,A©0,ÀF¬B0 ³Âx,´C;Œ Áˆ ÷@¤
Ã‚] Á`+0K`+Œá†`Ò`–!8   öpÕLDd‹DCX A$H3„L˜9ˆ%0‹# K
,Ä4Ö@4„¥™b ÑÖjŒDCX›ù°ÔöG<Àb     a   "   E,      ¤($(@ˆ2 ß    3‚âÁL¦øÃ00d0KP0†‚f"8¢°DŒ 0b€ @Â ã‡ç  Á,Á@Ç°`Á`DÀ,A€á@      F 6p<ÀBL       a      A,      4(ò ¢ !J  ¨0”
;(ì0”!
;(ì # € „1b€  ZA# °A0Ñ‡      a      E,      ¨R”@!Y 3†ÃL¦€Ä0! 000KP0†‚íf" b1FHƒåû„`Ä€ €3@f	*†H#` f	    V æw<ÀBL    a      E,      ¨R”@!Y 3†ÃL¦€Ä0! 0h0h0KP0†#f" b1FHƒåû„`Ä€ €3@f	*†#` f	    V æw<ÀBL    a   
   A,      ¤(@à’ ß   ÔcÄ €.¸ˆA@        /** @file script.life.c
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <string.h>

#include "script.life.h"
#include "scene.h"
#include "actor.h"
#include "movements.h"
#include "animations.h"
#include "scene.h"
#include "renderer.h"
#include "sound.h"
#include "redraw.h"
#include "lbaengine.h"
#include "gamestate.h"
#include "grid.h"
#include "music.h"
#include "flamovies.h"
#include "resources.h"
#include "collision.h"
#include "text.h"
#include "screens.h"
#include "sdlengine.h"
#include "keyboard.h"
#include "interface.h"
#include "holomap.h"


uint8 *scriptPtr; // local script pointer
uint8 *opcodePtr; // local opcode script pointer

int32 drawVar1;
int8 textStr[256]; // string

/** Returns:
	   -1 - Need implementation
		0 - Completed
		1 - Break script */
typedef int32 ScriptLifeFunc(int32 actorIdx, ActorStruct *actor);

typedef struct ScriptLifeFunction {
	const uint8 *name;
	ScriptLifeFunc *function;
} ScriptLifeFunction;

#define MAPFUNC(name, func) {(uint8*)name, func}

/** Script condition operators */
enum LifeScriptOperators {
	/*==*/ kEqualTo = 0,
	/*> */ kGreaterThan = 1,
	/*< */ kLessThan = 2,
	/*>=*/ kGreaterThanOrEqualTo = 3,
	/*<=*/ kLessThanOrEqualTo = 4,
	/*!=*/ kNotEqualTo = 5
};

/** Script condition command opcodes */
enum LifeScriptConditions {
	/*0x00*/ kcCOL = 0,
	/*0x01*/ kcCOL_OBJ = 1,
	/*0x02*/ kcDISTANCE = 2,
	/*0x03*/ kcZONE = 3,
	/*0x04*/ kcZONE_OBJ = 4,
	/*0x05*/ kcBODY = 5,
	/*0x06*/ kcBODY_OBJ = 6,
	/*0x07*/ kcANIM = 7,
	/*0x08*/ kcANIM_OBJ = 8,
	/*0x09*/ kcL_TRACK = 9,
	/*0x0A*/ kcL_TRACK_OBJ = 10,
	/*0x0B*/ kcFLAG_CUBE = 11,
	/*0x0C*/ kcCONE_VIEW = 12,
	/*0x0D*/ kcHIT_BY = 13,
	/*0x0E*/ kcACTION = 14,
	/*0x0F*/ kcFLAG_GAME = 15,
	/*0x10*/ kcLIFE_POINT = 16,
	/*0x11*/ kcLIFE_POINT_OBJ = 17,
	/*0x12*/ kcNUM_LITTLE_KEYS = 18,
	/*0x13*/ kcNUM_GOLD_PIECES = 19,
	/*0x14*/ kcBEHAVIOUR = 20,
	/*0x15*/ kcCHAPTER = 21,
	/*0x16*/ kcDISTANCE_3D = 22,
	/*0x17 - 23 unused */
	/*0x18 - 24 unused */
	/*0x19*/ kcUSE_INVENTORY = 25,
	/*0x1A*/ kcCHOICE= 26,
	/*0x1B*/ kcFUEL = 27,
	/*0x1C*/ kcCARRIED_BY = 28,
	/*0x1D*/ kcCDROM = 29
};



/** Returns:
	   -1 - Need implementation
		1 - Condition value size (1 byte)
		2 - Condition value size (2 byes) */
int32 processLifeConditions(ActorStruct *actor) {
	int32 conditionOpcode, conditionValueSize;

	conditionValueSize = 1;
	conditionOpcode = *(scriptPtr++);

	switch(conditionOpcode) {
	case kcCOL: 
		if (actor->life <= 0) {
			currentScriptValue = -1;
		} else {
			currentScriptValue = actor->collision;
		}
		break;
	case kcCOL_OBJ: {
		int32 actorIdx = *(scriptPtr++);
		if (sceneActors[actorIdx].life <= 0) {
			currentScriptValue = -1;
		} else {
			currentScriptValue = sceneActors[actorIdx].collision;
		}
	}
		break;
	case kcDISTANCE: {
		ActorStruct *otherActor;
		int32 actorIdx = *(scriptPtr++);
		conditionValueSize = 2;
		otherActor = &sceneActors[actorIdx];
		if (!otherActor->dynamicFlags.bIsDead) {
			if (Abs(actor->Y - otherActor->Y) >= 1500) {
				currentScriptValue = MAX_TARGET_ACTOR_DISTANCE;	
			} else {
				// Returns int32, so we check for integer overflow
				int32 distance = getDistance2D(actor->X, actor->Z, otherActor->X, otherActor->Z);
				if (Abs(distance) > MAX_TARGET_ACTOR_DISTANCE) {
					currentScriptValue = MAX_TARGET_ACTOR_DISTANCE;
				}
				else {
					currentScriptValue = distance;
				}
			}
		} else {
			currentScriptValue = MAX_TARGET_ACTOR_DISTANCE;
		}
	}
		break;
	case kcZONE:
		currentScriptValue = actor->zone;
		break;
	case kcZONE_OBJ: {
		int32 actorIdx = *(scriptPtr++);
		currentScriptValue = sceneActors[actorIdx].zone;
	}
		break;
	case kcBODY:
		currentScriptValue = actor->body;
		break;
	case kcBODY_OBJ: {
		int32 actorIdx = *(scriptPtr++);
		currentScriptValue = sceneActors[actorIdx].body;
	}
		break;
	case kcANIM:
		currentScriptValue = actor->anim;
		break;
	case kcANIM_OBJ: {
		int32 actorIdx = *(scriptPtr++);
		currentScriptValue = sceneActors[actorIdx].anim;
	}
		break;
	case kcL_TRACK:
		currentScriptValue = actor->labelIdx;
		break;
	case kcL_TRACK_OBJ: {
		int32 actorIdx = *(scriptPtr++);
		currentScriptValue = sceneActors[actorIdx].labelIdx;
	}
		break;
	case kcFLAG_CUBE: {
		int32 flagIdx = *(scriptPtr++);
		currentScriptValue = sceneFlags[flagIdx];
	}
		break;
	case kcCONE_VIEW: {
		int32 newAngle;
		int32 targetActorIdx;
		ActorStruct *targetActor;

		newAngle = 0;
		targetActorIdx = *(scriptPtr++);
		targetActor = &sceneActors[targetActorIdx];

		conditionValueSize = 2;

		if (!targetActor->dynamicFlags.bIsDead) {
			if (Abs(targetActor->Y - actor->Y) < 1500) {
				newAngle = getAngleAndSetTargetActorDistance(actor->X, actor->Z, targetActor->X, targetActor->Z);
				if (Abs(targetActorDistance) > MAX_TARGET_ACTOR_DISTANCE) {
					targetActorDistance = MAX_TARGET_ACTOR_DISTANCE;
				}
			} else {
				targetActorDistance = MAX_TARGET_ACTOR_DISTANCE;
			}

			if (!targetActorIdx) {
				int32 heroAngle;

				heroAngle = actor->angle + 0x480 - newAngle + 0x400;
				heroAngle &= 0x3FF;

				if (Abs(heroAngle) > 0x100) {
					currentScriptValue = MAX_TARGET_ACTOR_DISTANCE;
				} else {
					currentScriptValue = targetActorDistance;
				}
			} else {
				if (heroBehaviour == kDiscrete) {
					int32 heroAngle;

					heroAngle = actor->angle + 0x480 - newAngle + 0x400;
					heroAngle &= 0x3FF;

					if (Abs(heroAngle) > 0x100) {
						currentScriptValue = MAX_TARGET_ACTOR_DISTANCE;
					} else {
						currentScriptValue = targetActorDistance;
					}
				} else {
					currentScriptValue = targetActorDistance;
				}
			}
		} else {
			currentScriptValue = MAX_TARGET_ACTOR_DISTANCE;
		}
	}
		break;
	case kcHIT_BY:
		currentScriptValue = actor->hitBy;
		break;
	case kcACTION:
		currentScriptValue = heroAction;
		break;
	case kcFLAG_GAME: {
		int32 flagIdx = *(scriptPtr++);
		if (!gameFlags[GAMEFLAG_INVENTORY_DISABLED] ||
			(gameFlags[GAMEFLAG_INVENTORY_DISABLED] && flagIdx >= 28)) {
			currentScriptValue = gameFlags[flagIdx];
		} else {
			if (flagIdx == GAMEFLAG_INVENTORY_DISABLED) {
				currentScriptValue = gameFlags[flagIdx];
			} else {
				currentScriptValue = 0;
			}
		}
	}
		break;
	case kcLIFE_POINT:
		currentScriptValue = actor->life;
		break;
	case kcLIFE_POINT_OBJ: {
		int32 actorIdx = *(scriptPtr++);
		currentScriptValue = sceneActors[actorIdx].life;
	}
		break;
	case kcNUM_LITTLE_KEYS:
		currentScriptValue = inventoryNumKeys;
		break;
	case kcNUM_GOLD_PIECES:
		conditionValueSize = 2;
		currentScriptValue = inventoryNumKashes;
		break;
	case kcBEHAVIOUR:
		currentScriptValue = heroBehaviour;
		break;
	case kcCHAPTER:
		currentScriptValue = gameChapter;
		break;
	case kcDISTANCE_3D: {
		int32 targetActorIdx;
		ActorStruct *targetActor;

		targetActorIdx = *(scriptPtr++);
		targetActor = &sceneActors[targetActorIdx];

		conditionValueSize = 2;

		if (!targetActor->dynamicFlags.bIsDead) {
			// Returns int32, so we check for integer overflow
			int32 distance = getDistance3D(actor->X, actor->Y, actor->Z, targetActor->X, targetActor->Y, targetActor->Z);	
			if (Abs(distance) > MAX_TARGET_ACTOR_DISTANCE) {
				currentScriptValue = MAX_TARGET_ACTOR_DISTANCE;
			}
			else {
				currentScriptValue = distance;
			}
		} else {
			currentScriptValue = MAX_TARGET_ACTOR_DISTANCE;
		}
	}
		break;
	case 23: // unused
	case 24:
		break;
	case kcUSE_INVENTORY: {
		int32 item = *(scriptPtr++);

		if (!gameFlags[GAMEFLAG_INVENTORY_DISABLED]) {
			if (item == loopInventoryItem) {
				currentScriptValue = 1;
			} else {
				if (inventoryFlags[item] == 1 && gameFlags[item] == 1) {
					currentScriptValue = 1;
				} else {
					currentScriptValue = 0;
				}
			}

			if (currentScriptValue == 1) {
				addOverlay(koInventoryItem, item, 0, 0, 0, koNormal, 3);
			}
		} else {
			currentScriptValue = 0;
		}
	}
		break;
	case kcCHOICE:
		conditionValueSize = 2;
		currentScriptValue = choiceAnswer;
		break;
	case kcFUEL:
		currentScriptValue = inventoryNumGas;
		break;
	case kcCARRIED_BY:
		currentScriptValue = actor->standOn;
		break;
	case kcCDROM:
		currentScriptValue = 1;
		break;
	default:
		printf("ERROR: Actor condition opcode %d\n", conditionOpcode);
		break;
	}

	return conditionValueSize;
}

/** Returns:
	   -1 - Need implementation
		0 - Condition false
		1 - Condition true */
int32 processLifeOperators(int32 valueSize) {
	int32 operatorCode, conditionValue;

	operatorCode = *(scriptPtr++);

	if (valueSize == 1) {
		conditionValue = *(scriptPtr++);
	} else if(valueSize == 2) {
		conditionValue = *((int16 *)scriptPtr);
		scriptPtr += 2;
	} else {
		printf("ERROR: Unknown operator value size %d\n", valueSize);
		return 0;
	}

	switch(operatorCode) {
	case kEqualTo:
		if (currentScriptValue == conditionValue) {
			return 1;
		}
		break;
	case kGreaterThan:
		if (currentScriptValue > conditionValue) {
			return 1;
		}
		break;
	case kLessThan:
		if (currentScriptValue < conditionValue) {
			return 1;
		}
		break;
	case kGreaterThanOrEqualTo:
		if (currentScriptValue >= conditionValue) {
			return 1;
		}
		break;
	case kLessThanOrEqualTo:
		if (currentScriptValue <= conditionValue) {
			return 1;
		}
		break;
	case kNotEqualTo:
		if (currentScriptValue != conditionValue) {
			return 1;
		}
		break;
	default:
		printf("ERROR: Actor operator opcode %d\n", operatorCode);
		break;
	}

	return 0;
}

/** Life script command definitions */

/* For unused opcodes */
int32 lEMPTY(int32 actorIdx, ActorStruct *actor) {
	return 0;
}

/*0x00*/
int32 lEND(int32 actorIdx, ActorStruct *actor) {
	actor->positionInLifeScript = -1;
	return 1; // break script
}

/*0x01*/
int32 lNOP(int32 actorIdx, ActorStruct *actor) {
	scriptPtr++;
	return 0;
}

/*0x02*/
int32 lSNIF(int32 actorIdx, ActorStruct *actor) {
	int32 valueSize = processLifeConditions(actor);
	if (!processLifeOperators(valueSize)) {
		*opcodePtr = 13; // SWIF
	}
	scriptPtr = actor->lifeScript + *((int16 *)scriptPtr); // condition offset
	return 0;
}

/*0x03*/
int32 lOFFSET(int32 actorIdx, ActorStruct *actor) {
	scriptPtr = actor->lifeScript + *((int16 *)scriptPtr); // offset
	return 0;
}

/*0x04*/
int32 lNEVERIF(int32 actorIdx, ActorStruct *actor) {
	int32 valueSize = processLifeConditions(actor);
	processLifeOperators(valueSize);	
	scriptPtr = actor->lifeScript + *((int16 *)scriptPtr); // condition offset
	return 0;
}

/*0x06*/
int32 lNO_IF(int32 actorIdx, ActorStruct *actor) {
	return 0;
}

/*0x0A*/
int32 lLABEL(int32 actorIdx, ActorStruct *actor) {
	scriptPtr++;
	return 0;
}

/*0x0B*/
int32 lRETURN(int32 actorIdx, ActorStruct *actor) {
	return 1; // break script
}

/*0x0C*/
int32 lIF(int32 actorIdx, ActorStruct *actor) {
	int32 valueSize = processLifeConditions(actor);
	if (!processLifeOperators(valueSize)) {
		scriptPtr = actor->lifeScript + *((int16 *)scriptPtr); // condition offset
	} else {
		scriptPtr += 2;
	}
	
	return 0;
}

/*0x0D*/
int32 lSWIF(int32 actorIdx, ActorStruct *actor) {
	int32 valueSize = processLifeConditions(actor);
	if (!processLifeOperators(valueSize)) {
		scriptPtr = actor->lifeScript + *((int16 *)scriptPtr); // condition offset
	} else {
		scriptPtr += 2;
		*opcodePtr = 2; // SNIF
	}
	
	return 0;
}

/*0x0E*/
int32 lONEIF(int32 actorIdx, ActorStruct *actor) {
	int32 valueSize = processLifeConditions(actor);
	if (!processLifeOperators(valueSize)) {
		scriptPtr = actor->lifeScript + *((int16 *)scriptPtr); // condition offset
	} else {
		scriptPtr += 2;
		*opcodePtr = 4; // NEVERIF
	}
	
	return 0;
}

/*0x0F*/
int32 lELSE(int32 actorIdx, ActorStruct *actor) {
	scriptPtr = actor->lifeScript + *((int16 *)scriptPtr); // offset
	return 0;
}

/*0x11*/
int32 lBODY(int32 actorIdx, ActorStruct *actor) {
	int32 bodyIdx = *(scriptPtr);
	initModelActor(bodyIdx, actorIdx);
	scriptPtr++;
	return 0;
}

/*0x12*/
int32 lBODY_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	int32 otherBodyIdx = *(scriptPtr++);
	initModelActor(otherBodyIdx, otherActorIdx);
	return 0;
}

/*0x13*/
int32 lANIM(int32 actorIdx, ActorStruct *actor) {
	int32 animIdx = *(scriptPtr++);
	initAnim(animIdx, 0, 0, actorIdx);
	return 0;
}

/*0x14*/
int32 lANIM_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	int32 otherAnimIdx = *(scriptPtr++);
	initAnim(otherAnimIdx, 0, 0, otherActorIdx);
	return 0;
}

/*0x15*/
int32 lSET_LIFE(int32 actorIdx, ActorStruct *actor) {
	actor->positionInLifeScript = *((int16 *)scriptPtr); // offset
	scriptPtr += 2;
	return 0;
}

/*0x16*/
int32 lSET_LIFE_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	sceneActors[otherActorIdx].positionInLifeScript = *((int16 *)scriptPtr); // offset
	scriptPtr += 2;
	return 0;
}

/*0x17*/
int32 lSET_TRACK(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript = *((int16 *)scriptPtr); // offset
	scriptPtr += 2;
	return 0;
}

/*0x18*/
int32 lSET_TRACK_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	sceneActors[otherActorIdx].positionInMoveScript = *((int16 *)scriptPtr); // offset
	scriptPtr += 2;
	return 0;
}

/*0x19*/
int32 lMESSAGE(int32 actorIdx, ActorStruct *actor) {
	int32 textIdx = *((int16 *)scriptPtr);
	scriptPtr += 2;

	freezeTime();
	if (showDialogueBubble) {
		drawBubble(actorIdx);
	}
	setFontCrossColor(actor->talkColor);
	talkingActor = actorIdx;
	drawTextFullscreen(textIdx);
	unfreezeTime();
	redrawEngineActions(1);

	return 0;
}

/*0x1A*/
int32 lFALLABLE(int32 actorIdx, ActorStruct *actor) {
	int32 flag = *(scriptPtr++);
	actor->staticFlags.bCanFall = flag & 1;
	return 0;
}

/*0x1B*/
int32 lSET_DIRMODE(int32 actorIdx, ActorStruct *actor) {
	int32 controlMode = *(scriptPtr++);

	actor->controlMode = controlMode;
	if (controlMode == kFollow) {
		actor->followedActor = *(scriptPtr++);
	}

	return 0;
}

/*0x1C*/
int32 lSET_DIRMODE_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	int32 controlMode = *(scriptPtr++);

	sceneActors[otherActorIdx].controlMode = controlMode;
	if (controlMode == kFollow) {
		sceneActors[otherActorIdx].followedActor = *(scriptPtr++);
	}

	return 0;
}

/*0x1D*/
int32 lCAM_FOLLOW(int32 actorIdx, ActorStruct *actor) {
	int32 followedActorIdx;
	followedActorIdx = *(scriptPtr++);

	if (currentlyFollowedActor != followedActorIdx) {
		newCameraX = sceneActors[followedActorIdx].X >> 9;
		newCameraY = sceneActors[followedActorIdx].Y >> 8;
		newCameraZ = sceneActors[followedActorIdx].Z >> 9;

		currentlyFollowedActor = followedActorIdx;
		reqBgRedraw = 1;
	}

	return 0;
}

/*0x1E*/
int32 lSET_BEHAVIOUR(int32 actorIdx, ActorStruct *actor) {
	int32 behavior = *(scriptPtr++);

	initAnim(kStanding, 0, 255, 0);
	setBehaviour(behavior);

	return 0;
}

/*0x1F*/
int32 lSET_FLAG_CUBE(int32 actorIdx, ActorStruct *actor) {
	int32 flagIdx = *(scriptPtr++);
	int32 flagValue = *(scriptPtr++);

	sceneFlags[flagIdx] = flagValue;
	
	return 0;
}

/*0x20*/
int32 lCOMPORTEMENT(int32 actorIdx, ActorStruct *actor) {
	scriptPtr++;
	return 0;
}

/*0x21*/
int32 lSET_COMPORTEMENT(int32 actorIdx, ActorStruct *actor) {
	actor->positionInLifeScript = *((int16 *)scriptPtr);
	scriptPtr += 2;
	return 0;
}

/*0x22*/
int32 lSET_COMPORTEMENT_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);

	sceneActors[otherActorIdx].positionInLifeScript = *((int16 *)scriptPtr);
	scriptPtr += 2;

	return 0;
}

/*0x23*/
int32 lEND_COMPORTEMENT(int32 actorIdx, ActorStruct *actor) {
	return 1; // break
}

/*0x24*/
int32 lSET_FLAG_GAME(int32 actorIdx, ActorStruct *actor) {
	int32 flagIdx = *(scriptPtr++);
	int32 flagValue = *(scriptPtr++);

	gameFlags[flagIdx] = flagValue;
	
	return 0;
}

/*0x25*/
int32 lKILL_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);

	processActorCarrier(otherActorIdx);
	sceneActors[otherActorIdx].dynamicFlags.bIsDead = 1;
	sceneActors[otherActorIdx].entity = -1;
	sceneActors[otherActorIdx].zone = -1;
	sceneActors[otherActorIdx].life = 0;

	return 0;
}

/*0x26*/
int32 lSUICIDE(int32 actorIdx, ActorStruct *actor) {
	processActorCarrier(actorIdx);
	actor->dynamicFlags.bIsDead = 1;
	actor->entity = -1;
	actor->zone = -1;
	actor->life = 0;

	return 0;
}

/*0x27*/
int32 lUSE_ONE_LITTLE_KEY(int32 actorIdx, ActorStruct *actor) {
	inventoryNumKeys--;

	if (inventoryNumKeys < 0) {
		inventoryNumKeys = 0;
	}

	addOverlay(koSprite, SPRITEHQR_KEY, 0, 0, 0, koFollowActor, 1);
	
	return 0;
}

/*0x28*/
int32 lGIVE_GOLD_PIECES(int32 actorIdx, ActorStruct *actor) {
	int16 kashes, i, hideRange;
	int16 oldNumKashes = inventoryNumKashes;

	hideRange = 0;

	kashes = *((int16 *)scriptPtr);
	scriptPtr += 2;

	inventoryNumKashes -= kashes;
	if (inventoryNumKashes < 0) {
		inventoryNumKashes = 0;
	}

	addOverlay(koSprite, SPRITEHQR_KASHES, 10, 15, 0, koNormal, 3);

	for (i = 0; i < OVERLAY_MAX_ENTRIES; i++) {
		OverlayListStruct *overlay = &overlayList[i];
		if (overlay->info0 != -1 && overlay->type == koNumberRange) {
			overlay->info0 = getAverageValue(overlay->info1, overlay->info0, 100, overlay->lifeTime - lbaTime - 50);
			overlay->info1 = inventoryNumKashes;
			overlay->lifeTime = lbaTime + 150;
			hideRange = 1;
			break;
		}
	}

	if (!hideRange) {
		addOverlay(koNumberRange, oldNumKashes, 50, 20, inventoryNumKashes, koNormal, 3);
	}

	return 0;
}

/*0x29*/
int32 lEND_LIFE(int32 actorIdx, ActorStruct *actor) {
	actor->positionInLifeScript = -1;
	return 1; // break;
}

/*0x2A*/
int32 lSTOP_L_TRACK(int32 actorIdx, ActorStruct *actor) {
	actor->pausedTrackPtr = actor->currentLabelPtr;
	actor->positionInMoveScript = -1;
	return 0;
}

/*0x2B*/
int32 lRESTORE_L_TRACK(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript = actor->pausedTrackPtr;
	return 0;
}

/*0x2C*/
int32 lMESSAGE_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	int32 textIdx = *((int16 *)scriptPtr);
	scriptPtr += 2;

	freezeTime();
	if (showDialogueBubble) {
		drawBubble(otherActorIdx);
	}
	setFontCrossColor(sceneActors[otherActorIdx].talkColor);
	talkingActor = otherActorIdx;
	drawTextFullscreen(textIdx);
	unfreezeTime();
	redrawEngineActions(1);

	return 0;
}

/*0x2D*/
int32 lINC_CHAPTER(int32 actorIdx, ActorStruct *actor) {
	gameChapter++;
	return 0;
}

/*0x2E*/
int32 lFOUND_OBJECT(int32 actorIdx, ActorStruct *actor) {
	int32 item = *(scriptPtr++);
	
	freezeTime();
	processFoundItem(item);
	unfreezeTime();
	redrawEngineActions(1);

	return 0;
}

/*0x2F*/
int32 lSET_DOOR_LEFT(int32 actorIdx, ActorStruct *actor) {
	int32 distance = *((int16 *)scriptPtr);
	scriptPtr += 2;
	
	actor->angle = 0x300;
	actor->X = actor->lastX - distance;
	actor->dynamicFlags.bIsSpriteMoving = 0;
	actor->speed = 0;

	return 0;
}

/*0x30*/
int32 lSET_DOOR_RIGHT(int32 actorIdx, ActorStruct *actor) {
	int32 distance = *((int16 *)scriptPtr);
	scriptPtr += 2;

	actor->angle = 0x100;
	actor->X = actor->lastX + distance;
	actor->dynamicFlags.bIsSpriteMoving = 0;
	actor->speed = 0;

	return 0;
}

/*0x31*/
int32 lSET_DOOR_UP(int32 actorIdx, ActorStruct *actor) {
	int32 distance = *((int16 *)scriptPtr);
	scriptPtr += 2;

	actor->angle = 0x200;
	actor->Z = actor->lastZ - distance;
	actor->dynamicFlags.bIsSpriteMoving = 0;
	actor->speed = 0;

	return 0;
}

/*0x32*/
int32 lSET_DOOR_DOWN(int32 actorIdx, ActorStruct *actor) {
	int32 distance = *((int16 *)scriptPtr);
	scriptPtr += 2;

	actor->angle = 0;
	actor->Z = actor->lastZ + distance;
	actor->dynamicFlags.bIsSpriteMoving = 0;
	actor->speed = 0;

	return 0;
}

/*0x33*/
int32 lGIVE_BONUS(int32 actorIdx, ActorStruct *actor) {
	int32 flag = *(scriptPtr++);

	if (actor->bonusParameter & 0x1F0) {
		processActorExtraBonus(actorIdx);
	}

	if (flag != 0) {
		actor->bonusParameter |= 1;
	}

	return 0;
}

/*0x34*/
int32 lCHANGE_CUBE(int32 actorIdx, ActorStruct *actor) {
	int32 sceneIdx = *(scriptPtr++);
	needChangeScene = sceneIdx;
	heroPositionType = kScene;
	return 0;
}

/*0x35*/
int32 lOBJ_COL(int32 actorIdx, ActorStruct *actor) {
	int32 collision = *(scriptPtr++);
	if (collision != 0) {
		actor->staticFlags.bComputeCollisionWithObj = 1;
	} else {
		actor->staticFlags.bComputeCollisionWithObj = 0;
	}
	return 0;
}

/*0x36*/
int32 lBRICK_COL(int32 actorIdx, ActorStruct *actor) {
	int32 collision = *(scriptPtr++);
	
	actor->staticFlags.bComputeCollisionWithBricks = 0;
	actor->staticFlags.bComputeLowCollision = 0;
	
	if (collision == 1) {
		actor->staticFlags.bComputeCollisionWithBricks = 1;
	} else if (collision == 2) {
		actor->staticFlags.bComputeCollisionWithBricks = 1;
		actor->staticFlags.bComputeLowCollision = 1;
	}
	return 0;
}

/*0x37*/
int32 lOR_IF(int32 actorIdx, ActorStruct *actor) {
	int32 valueSize = processLifeConditions(actor);
	if (processLifeOperators(valueSize)) {
		scriptPtr = actor->lifeScript + *((int16 *)scriptPtr); // condition offset
	} else {
		scriptPtr += 2;
	}
	
	return 0;
}

/*0x38*/
int32 lINVISIBLE(int32 actorIdx, ActorStruct *actor) {
	actor->staticFlags.bIsHidden = *(scriptPtr++);
	return 0;
}

/*0x39*/
int32 lZOOM(int32 actorIdx, ActorStruct *actor) {
	zoomScreen = *(scriptPtr++);
	
    if (zoomScreen && !drawInGameTransBox && cfgfile.SceZoom) {
        fadeToBlack(mainPaletteRGBA);
        initMCGA();
        setBackPal();
        lockPalette = 1;
    } else if (!zoomScreen && drawInGameTransBox) {
        fadeToBlack(mainPaletteRGBA);
        initSVGA();
        setBackPal();
        lockPalette = 1;
        reqBgRedraw = 1;
    }
    
    return 0;
}

/*0x3A*/
int32 lPOS_POINT(int32 actorIdx, ActorStruct *actor) {
	int32 trackIdx = *(scriptPtr++);

	destX = sceneTracks[trackIdx].X;
	destY = sceneTracks[trackIdx].Y;
	destZ = sceneTracks[trackIdx].Z;

	actor->X = destX;
	actor->Y = destY;
	actor->Z = destZ;

	return 0;
}

/*0x3B*/
int32 lSET_MAGIC_LEVEL(int32 actorIdx, ActorStruct *actor) {
	magicLevelIdx = *(scriptPtr++);
	inventoryMagicPoints = magicLevelIdx * 20;
	return 0;
}

/*0x3C*/
int32 lSUB_MAGIC_POINT(int32 actorIdx, ActorStruct *actor) {
	inventoryMagicPoints = *(scriptPtr++);
	if (inventoryMagicPoints < 0) {
		inventoryMagicPoints = 0;
	}
	return 0;
}

/*0x3D*/
int32 lSET_LIFE_POINT_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	int32 lifeValue = *(scriptPtr++);

	sceneActors[otherActorIdx].life = lifeValue;
	
	return 0;
}

/*0x3E*/
int32 lSUB_LIFE_POINT_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	int32 lifeValue = *(scriptPtr++);

	sceneActors[otherActorIdx].life -= lifeValue;

	if (sceneActors[otherActorIdx].life < 0) {
		sceneActors[otherActorIdx].life = 0;
	}
	
	return 0;
}

/*0x3F*/
int32 lHIT_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	int32 strengthOfHit = *(scriptPtr++);
	hitActor(actorIdx, otherActorIdx, strengthOfHit, sceneActors[otherActorIdx].angle);
	return 0;
}

/*0x40*/
int32 lPLAY_FLA(int32 actorIdx, ActorStruct *actor) {
	int8 *movie = (int8 *)scriptPtr;
	int32 nameSize = strlen(movie);
	scriptPtr += nameSize + 1;

	playFlaMovie(movie);
	setPalette(paletteRGBA);
	clearScreen();
	flip();
	
	return 0;
}

/*0x41*/
int32 lPLAY_MIDI(int32 actorIdx, ActorStruct *actor) {
	int32 midiIdx = *(scriptPtr++);
	playMidiMusic(midiIdx, 0); // TODO: improve this
	return 0;
}

/*0x42*/
int32 lINC_CLOVER_BOX(int32 actorIdx, ActorStruct *actor) {
	if (inventoryNumLeafsBox < 10 ) {
		inventoryNumLeafsBox++;
	}
	return 0;
}

/*0x43*/
int32 lSET_USED_INVENTORY(int32 actorIdx, ActorStruct *actor) {
	int32 item = *(scriptPtr++);
	if (item < 24) {
		inventoryFlags[item] = 1;
	}
	return 0;
}

/*0x44*/
int32 lADD_CHOICE(int32 actorIdx, ActorStruct *actor) {
	int32 choiceIdx = *((int16 *)scriptPtr);
	scriptPtr += 2;
	gameChoices[numChoices++] = choiceIdx;
	return 0;
}

/*0x45*/
int32 lASK_CHOICE(int32 actorIdx, ActorStruct *actor) {
	int32 choiceIdx = *((int16 *)scriptPtr);
	scriptPtr += 2;

	freezeTime();
	if (showDialogueBubble) {
		drawBubble(actorIdx);
	}
	setFontCrossColor(actor->talkColor);
	processGameChoices(choiceIdx);
	numChoices = 0;
	unfreezeTime();
	redrawEngineActions(1);

	return 0;
}

/*0x46*/
int32 lBIG_MESSAGE(int32 actorIdx, ActorStruct *actor) {
	int32 textIdx = *((int16 *)scriptPtr);
	scriptPtr += 2;

	freezeTime();
	textClipFull();
	if (showDialogueBubble) {
		drawBubble(actorIdx);
	}
	setFontCrossColor(actor->talkColor);
	talkingActor = actorIdx;
	drawTextFullscreen(textIdx);
	textClipSmall();
	unfreezeTime();
	redrawEngineActions(1);

	return 0;
}

/*0x47*/
int32 lINIT_PINGOUIN(int32 actorIdx, ActorStruct *actor) {
	int32 pingouinActor = *(scriptPtr++);
	sceneActors[pingouinActor].dynamicFlags.bIsDead = 1;
	mecaPinguinIdx = pingouinActor;
	sceneActors[pingouinActor].entity = -1;
	sceneActors[pingouinActor].zone = -1;
	return 0;
}

/*0x48*/
int32 lSET_HOLO_POS(int32 actorIdx, ActorStruct *actor) {
	int32 location = *(scriptPtr++);
	
	setHolomapPosition(location);
	if (gameFlags[GAMEFLAG_HAS_HOLOMAP]) {
		addOverlay(koInventoryItem, 0, 0, 0, 0, koNormal, 3);
	}

	return 0;
}

/*0x49*/
int32 lCLR_HOLO_POS(int32 actorIdx, ActorStruct *actor) {
	int32 location = *(scriptPtr++);
	clearHolomapPosition(location);
	return 0;
}

/*0x4A*/
int32 lADD_FUEL(int32 actorIdx, ActorStruct *actor) {
	inventoryNumGas += *(scriptPtr++);
	if (inventoryNumGas > 100) {
		inventoryNumGas = 100;
	}
	return 0;
}

/*0x4B*/
int32 lSUB_FUEL(int32 actorIdx, ActorStruct *actor) {
	inventoryNumGas -= *(scriptPtr++);
	if (inventoryNumGas < 0) {
		inventoryNumGas = 0;
	}
	return 0;
}

/*0x4C*/
int32 lSET_GRM(int32 actorIdx, ActorStruct *actor) {
	cellingGridIdx = *(scriptPtr++);
	initCellingGrid(cellingGridIdx);
	return 0;
}

/*0x4D*/
int32 lSAY_MESSAGE(int32 actorIdx, ActorStruct *actor) {
	int16 textEntry = *((int16 *)scriptPtr);
	scriptPtr += 2;

	addOverlay(koText, textEntry, 0, 0, actorIdx, koFollowActor, 2);

	freezeTime();
	initVoxToPlay(textEntry);
	unfreezeTime();

	return 0;
}

/*04E*/
int32 lSAY_MESSAGE_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	int16 textEntry = *((int16 *)scriptPtr);
	scriptPtr += 2;

	addOverlay(koText, textEntry, 0, 0, otherActorIdx, koFollowActor, 2);

	freezeTime();
	initVoxToPlay(textEntry);
	unfreezeTime();

	return 0;
}

/*0x4F*/
int32 lFULL_POINT(int32 actorIdx, ActorStruct *actor) {
	sceneHero->life = 50;
	inventoryMagicPoints = magicLevelIdx * 20;
	return 0;
}

/*0x50*/
int32 lBETA(int32 actorIdx, ActorStruct *actor) {
	int32 newAngle = *((int16 *)scriptPtr);
	scriptPtr += 2;
	actor->angle = newAngle;
	clearRealAngle(actor);
	return 0;
}

/*0x51*/
int32 lGRM_OFF(int32 actorIdx, ActorStruct *actor) {
	if (cellingGridIdx != -1) {
		useCellingGrid = -1;
		cellingGridIdx = -1;
		createGridMap();
		redrawEngineActions(1);
	}
	
	return 0;
}

/*0x52*/
int32 lFADE_PAL_RED(int32 actorIdx, ActorStruct *actor) {
	freezeTime();
	fadePalRed(mainPaletteRGBA);
	useAlternatePalette = 0;
	unfreezeTime();
	return 0;
}

/*0x53*/
int32 lFADE_ALARM_RED(int32 actorIdx, ActorStruct *actor) {
	freezeTime();
	hqrGetEntry(palette, HQR_RESS_FILE, RESSHQR_ALARMREDPAL);
	convertPalToRGBA(palette, paletteRGBA);
	fadePalRed(paletteRGBA);
	useAlternatePalette = 1;
	unfreezeTime();
	return 0;
}

/*0x54*/
int32 lFADE_ALARM_PAL(int32 actorIdx, ActorStruct *actor) {
	freezeTime();
	hqrGetEntry(palette, HQR_RESS_FILE, RESSHQR_ALARMREDPAL);
	convertPalToRGBA(palette, paletteRGBA);
	adjustCrossPalette(paletteRGBA, mainPaletteRGBA);
	useAlternatePalette = 0;
	unfreezeTime();
	return 0;
}

/*0x55*/
int32 lFADE_RED_PAL(int32 actorIdx, ActorStruct *actor) {
	freezeTime();
	fadeRedPal(mainPaletteRGBA);
	useAlternatePalette = 0;
	unfreezeTime();
	return 0;
}

/*0x56*/
int32 lFADE_RED_ALARM(int32 actorIdx, ActorStruct *actor) {
	freezeTime();
	hqrGetEntry(palette, HQR_RESS_FILE, RESSHQR_ALARMREDPAL);
	convertPalToRGBA(palette, paletteRGBA);
	fadeRedPal(paletteRGBA);
	useAlternatePalette = 1;
	unfreezeTime();
	return 0;
}

/*0x57*/
int32 lFADE_PAL_ALARM(int32 actorIdx, ActorStruct *actor) {
	freezeTime();
	hqrGetEntry(palette, HQR_RESS_FILE, RESSHQR_ALARMREDPAL);
	convertPalToRGBA(palette, paletteRGBA);
	adjustCrossPalette(mainPaletteRGBA, paletteRGBA);
	useAlternatePalette = 1;
	unfreezeTime();
	return 0;
}

/*0x58*/
int32 lEXPLODE_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	ActorStruct *otherActor = &sceneActors[otherActorIdx];

	addExtraExplode(otherActor->X, otherActor->Y, otherActor->Z); // RECHECK this

	return 0;
}

/*0x59*/
int32 lBUBBLE_ON(int32 actorIdx, ActorStruct *actor) {
	showDialogueBubble = 1;
	return 0;
}

/*0x5A*/
int32 lBUBBLE_OFF(int32 actorIdx, ActorStruct *actor) {
	showDialogueBubble = 1;
	return 0;
}

/*0x5B*/
int32 lASK_CHOICE_OBJ(int32 actorIdx, ActorStruct *actor) {
	int32 otherActorIdx = *(scriptPtr++);
	int32 choiceIdx = *((int16 *)scriptPtr);
	scriptPtr += 2;

	freezeTime();
	if (showDialogueBubble) {
		drawBubble(otherActorIdx);
	}
	setFontCrossColor(sceneActors[otherActorIdx].talkColor);
	processGameChoices(choiceIdx);
	numChoices = 0;
	unfreezeTime();
	redrawEngineActions(1);

	return 0;
}

/*0x5C*/
int32 lSET_DARK_PAL(int32 actorIdx, ActorStruct *actor) {
	freezeTime();
	hqrGetEntry(palette, HQR_RESS_FILE, RESSHQR_DARKPAL);
	if (!lockPalette) {
		convertPalToRGBA(palette, paletteRGBA);
		setPalette(paletteRGBA);
	}
	useAlternatePalette = 1;
	unfreezeTime();
	return 0;
}

/*0x5D*/
int32 lSET_NORMAL_PAL(int32 actorIdx, ActorStruct *actor) {
	useAlternatePalette = 0;
	if (!lockPalette) {
		setPalette(mainPaletteRGBA);
	}
	return 0;
}

/*0x5E*/
int32 lMESSAGE_SENDELL(int32 actorIdx, ActorStruct *actor) {
	int32 tmpFlagDisplayText;

	freezeTime();
	fadeToBlack(paletteRGBA);
	loadImage(25, 1);
	textClipFull();
	setFontCrossColor(15);
	newGameVar4 = 0;
	tmpFlagDisplayText = cfgfile.FlagDisplayText;
	cfgfile.FlagDisplayText = 1;
	drawTextFullscreen(6);
	newGameVar4 = 1;
	textClipSmall();
	fadeToBlack(paletteRGBACustom);
	clearScreen();
	setPalette(paletteRGBA);
	cfgfile.FlagDisplayText = tmpFlagDisplayText;

	do {
		readKeys();
	} while (skipIntro || skippedKey);

	unfreezeTime();
	
	return 0;
}

/*0x5F*/
int32 lANIM_SET(int32 actorIdx, ActorStruct *actor) {
	int32 animIdx = *(scriptPtr++);

	actor->anim = -1;
	actor->previousAnimIdx = -1;
	initAnim(animIdx, 0, 0, actorIdx);

	return 0;
}

/*0x60*/
int32 lHOLOMAP_TRAJ(int32 actorIdx, ActorStruct *actor) {
	scriptPtr++; // TODO
	return -1;
}

/*0x61*/
int32 lGAME_OVER(int32 actorIdx, ActorStruct *actor) {
	sceneHero->dynamicFlags.bAnimEnded = 1;
	sceneHero->life = 0;
	inventoryNumLeafs = 0;
	return 1; // break
}

/*0x62*/
int32 lTHE_END(int32 actorIdx, ActorStruct *actor) {
	quitGame = 1;
	inventoryNumLeafs = 0;
	sceneHero->life = 50;
	inventoryMagicPoints = 80;
	currentSceneIdx = 113;
	heroBehaviour = previousHeroBehaviour;
	newHeroX = -1;
	sceneHero->angle = previousHeroAngle;
	saveGame();
	return 1; // break;
}

/*0x63*/
int32 lMIDI_OFF(int32 actorIdx, ActorStruct *actor) {
	stopMidiMusic();
	return 0;
}

/*0x64*/
int32 lPLAY_CD_TRACK(int32 actorIdx, ActorStruct *actor) {
	int32 track = *(scriptPtr++);
	playTrackMusic(track);
	return 0;
}

/*0x65*/
int32 lPROJ_ISO(int32 actorIdx, ActorStruct *actor) {
	setOrthoProjection(311, 240, 512);
	setBaseTranslation(0, 0, 0);
	setBaseRotation(0, 0, 0);
	setLightVector(alphaLight, betaLight, 0);
	return 0;
}

/*0x66*/
int32 lPROJ_3D(int32 actorIdx, ActorStruct *actor) {
	copyScreen(frontVideoBuffer, workVideoBuffer);
	flip();
	changeRoomVar10 = 0;

	setCameraPosition(320, 240, 128, 1024, 1024);
	setCameraAngle(0, 1500, 0, 25, -128, 0, 13000);
	setLightVector(896, 950, 0);

	initTextBank(1);

	return 0;
}

/*0x67*/
int32 lTEXT(int32 actorIdx, ActorStruct *actor) {
	int32 textSize, textBoxRight;
	int32 textIdx = *((int16 *)scriptPtr);
	scriptPtr += 2;

	if (drawVar1 < 440) {
		if (cfgfile.Version == USA_VERSION) {
			if (!textIdx) {
				textIdx = 16;
			}
		}

		getMenuText(textIdx, textStr);
		textSize = textBoxRight = getTextSize(textStr);
		setFontColor(15);
		drawText(0, drawVar1, textStr);
		if (textSize > 639) {
			textBoxRight = 639;
		}
		
		drawVar1 += 40;
		copyBlockPhys(0, drawVar1, textBoxRight, drawVar1);
	}

	return 0;
}

/*0x68*/
int32 lCLEAR_TEXT(int32 actorIdx, ActorStruct *actor) {
	drawVar1 = 0;
	drawSplittedBox(0, 0, 639, 240, 0);
	copyBlockPhys(0, 0, 639, 240);
	return 0;
}

/*0x69*/
int32 lBRUTAL_EXIT(int32 actorIdx, ActorStruct *actor) {
	quitGame = 0;
	return 1; // break
}

static const ScriptLifeFunction function_map[] = {
	/*0x00*/ MAPFUNC("END", lEND),
	/*0x01*/ MAPFUNC("NOP", lNOP),
	/*0x02*/ MAPFUNC("SNIF", lSNIF),
	/*0x03*/ MAPFUNC("OFFSET", lOFFSET),
	/*0x04*/ MAPFUNC("NEVERIF", lNEVERIF),
	/*0x05*/ MAPFUNC("", lEMPTY), // unused
	/*0x06*/ MAPFUNC("NO_IF", lNO_IF),
	/*0x07*/ MAPFUNC("", lEMPTY), // unused
	/*0x08*/ MAPFUNC("", lEMPTY), // unused
	/*0x09*/ MAPFUNC("", lEMPTY), // unused
	/*0x0A*/ MAPFUNC("LABEL", lLABEL),
	/*0x0B*/ MAPFUNC("RETURN", lRETURN),
	/*0x0C*/ MAPFUNC("IF", lIF),
	/*0x0D*/ MAPFUNC("SWIF", lSWIF),
	/*0x0E*/ MAPFUNC("ONEIF", lONEIF),
	/*0x0F*/ MAPFUNC("ELSE", lELSE),
	/*0x10*/ MAPFUNC("ENDIF", lEMPTY), // unused
	/*0x11*/ MAPFUNC("BODY", lBODY),
	/*0x12*/ MAPFUNC("BODY_OBJ", lBODY_OBJ),
	/*0x13*/ MAPFUNC("ANIM", lANIM),
	/*0x14*/ MAPFUNC("ANIM_OBJ", lANIM_OBJ),
	/*0x15*/ MAPFUNC("SET_LIFE", lSET_LIFE),
	/*0x16*/ MAPFUNC("SET_LIFE_OBJ", lSET_LIFE_OBJ),
	/*0x17*/ MAPFUNC("SET_TRACK", lSET_TRACK),
	/*0x18*/ MAPFUNC("SET_TRACK_OBJ", lSET_TRACK_OBJ),
	/*0x19*/ MAPFUNC("MESSAGE", lMESSAGE),
	/*0x1A*/ MAPFUNC("FALLABLE", lFALLABLE),
	/*0x1B*/ MAPFUNC("SET_DIRMODE", lSET_DIRMODE),
	/*0x1C*/ MAPFUNC("SET_DIRMODE_OBJ", lSET_DIRMODE_OBJ),
	/*0x1D*/ MAPFUNC("CAM_FOLLOW", lCAM_FOLLOW),
	/*0x1E*/ MAPFUNC("SET_BEHAVIOUR", lSET_BEHAVIOUR),
	/*0x1F*/ MAPFUNC("SET_FLAG_CUBE", lSET_FLAG_CUBE),
	/*0x20*/ MAPFUNC("COMPORTEMENT", lCOMPORTEMENT),
	/*0x21*/ MAPFUNC("SET_COMPORTEMENT", lSET_COMPORTEMENT),
	/*0x22*/ MAPFUNC("SET_COMPORTEMENT_OBJ", lSET_COMPORTEMENT_OBJ),
	/*0x23*/ MAPFUNC("END_COMPORTEMENT", lEND_COMPORTEMENT),
	/*0x24*/ MAPFUNC("SET_FLAG_GAME", lSET_FLAG_GAME),
	/*0x25*/ MAPFUNC("KILL_OBJ", lKILL_OBJ),
	/*0x26*/ MAPFUNC("SUICIDE", lSUICIDE),
	/*0x27*/ MAPFUNC("USE_ONE_LITTLE_KEY", lUSE_ONE_LITTLE_KEY),
	/*0x28*/ MAPFUNC("GIVE_GOLD_PIECES", lGIVE_GOLD_PIECES),
	/*0x29*/ MAPFUNC("END_LIFE", lEND_LIFE),
	/*0x2A*/ MAPFUNC("STOP_L_TRACK", lSTOP_L_TRACK),
	/*0x2B*/ MAPFUNC("RESTORE_L_TRACK", lRESTORE_L_TRACK),
	/*0x2C*/ MAPFUNC("MESSAGE_OBJ", lMESSAGE_OBJ),
	/*0x2D*/ MAPFUNC("INC_CHAPTER", lINC_CHAPTER),
	/*0x2E*/ MAPFUNC("FOUND_OBJECT", lFOUND_OBJECT),
	/*0x2F*/ MAPFUNC("SET_DOOR_LEFT", lSET_DOOR_LEFT),
	/*0x30*/ MAPFUNC("SET_DOOR_RIGHT", lSET_DOOR_RIGHT),
	/*0x31*/ MAPFUNC("SET_DOOR_UP", lSET_DOOR_UP),
	/*0x32*/ MAPFUNC("SET_DOOR_DOWN", lSET_DOOR_DOWN),
	/*0x33*/ MAPFUNC("GIVE_BONUS", lGIVE_BONUS),
	/*0x34*/ MAPFUNC("CHANGE_CUBE", lCHANGE_CUBE),
	/*0x35*/ MAPFUNC("OBJ_COL", lOBJ_COL),
	/*0x36*/ MAPFUNC("BRICK_COL", lBRICK_COL),
	/*0x37*/ MAPFUNC("OR_IF", lOR_IF),
	/*0x38*/ MAPFUNC("INVISIBLE", lINVISIBLE),
	/*0x39*/ MAPFUNC("ZOOM", lZOOM),
	/*0x3A*/ MAPFUNC("POS_POINT", lPOS_POINT),
	/*0x3B*/ MAPFUNC("SET_MAGIC_LEVEL", lSET_MAGIC_LEVEL),
	/*0x3C*/ MAPFUNC("SUB_MAGIC_POINT", lSUB_MAGIC_POINT),
	/*0x3D*/ MAPFUNC("SET_LIFE_POINT_OBJ", lSET_LIFE_POINT_OBJ),
	/*0x3E*/ MAPFUNC("SUB_LIFE_POINT_OBJ", lSUB_LIFE_POINT_OBJ),
	/*0x3F*/ MAPFUNC("HIT_OBJ", lHIT_OBJ),
	/*0x40*/ MAPFUNC("PLAY_FLA", lPLAY_FLA),
	/*0x41*/ MAPFUNC("PLAY_MIDI", lPLAY_MIDI),
	/*0x42*/ MAPFUNC("INC_CLOVER_BOX", lINC_CLOVER_BOX),
	/*0x43*/ MAPFUNC("SET_USED_INVENTORY", lSET_USED_INVENTORY),
	/*0x44*/ MAPFUNC("ADD_CHOICE", lADD_CHOICE),
	/*0x45*/ MAPFUNC("ASK_CHOICE", lASK_CHOICE),
	/*0x46*/ MAPFUNC("BIG_MESSAGE", lBIG_MESSAGE),
	/*0x47*/ MAPFUNC("INIT_PINGOUIN", lINIT_PINGOUIN),
	/*0x48*/ MAPFUNC("SET_HOLO_POS", lSET_HOLO_POS),
	/*0x49*/ MAPFUNC("CLR_HOLO_POS", lCLR_HOLO_POS),
	/*0x4A*/ MAPFUNC("ADD_FUEL", lADD_FUEL),
	/*0x4B*/ MAPFUNC("SUB_FUEL", lSUB_FUEL),
	/*0x4C*/ MAPFUNC("SET_GRM", lSET_GRM),
	/*0x4D*/ MAPFUNC("SAY_MESSAGE", lSAY_MESSAGE),
	/*0x4E*/ MAPFUNC("SAY_MESSAGE_OBJ", lSAY_MESSAGE_OBJ),
	/*0x4F*/ MAPFUNC("FULL_POINT", lFULL_POINT),
	/*0x50*/ MAPFUNC("BETA", lBETA),
	/*0x51*/ MAPFUNC("GRM_OFF", lGRM_OFF),
	/*0x52*/ MAPFUNC("FADE_PAL_RED", lFADE_PAL_RED),
	/*0x53*/ MAPFUNC("FADE_ALARM_RED", lFADE_ALARM_RED),
	/*0x54*/ MAPFUNC("FADE_ALARM_PAL", lFADE_ALARM_PAL),
	/*0x55*/ MAPFUNC("FADE_RED_PAL", lFADE_RED_PAL),
	/*0x56*/ MAPFUNC("FADE_RED_ALARM", lFADE_RED_ALARM),
	/*0x57*/ MAPFUNC("FADE_PAL_ALARM", lFADE_PAL_ALARM),
	/*0x58*/ MAPFUNC("EXPLODE_OBJ", lEXPLODE_OBJ),
	/*0x59*/ MAPFUNC("BUBBLE_ON", lBUBBLE_ON),
	/*0x5A*/ MAPFUNC("BUBBLE_OFF", lBUBBLE_OFF),
	/*0x5B*/ MAPFUNC("ASK_CHOICE_OBJ", lASK_CHOICE_OBJ),
	/*0x5C*/ MAPFUNC("SET_DARK_PAL", lSET_DARK_PAL),
	/*0x5D*/ MAPFUNC("SET_NORMAL_PAL", lSET_NORMAL_PAL),
	/*0x5E*/ MAPFUNC("MESSAGE_SENDELL", lMESSAGE_SENDELL),
	/*0x5F*/ MAPFUNC("ANIM_SET", lANIM_SET),
	/*0x60*/ MAPFUNC("HOLOMAP_TRAJ", lHOLOMAP_TRAJ),
	/*0x61*/ MAPFUNC("GAME_OVER", lGAME_OVER),
	/*0x62*/ MAPFUNC("THE_END", lTHE_END),
	/*0x63*/ MAPFUNC("MIDI_OFF", lMIDI_OFF),
	/*0x64*/ MAPFUNC("PLAY_CD_TRACK", lPLAY_CD_TRACK),
	/*0x65*/ MAPFUNC("PROJ_ISO", lPROJ_ISO),
	/*0x66*/ MAPFUNC("PROJ_3D", lPROJ_3D),
	/*0x67*/ MAPFUNC("TEXT", lTEXT),
	/*0x68*/ MAPFUNC("CLEAR_TEXT", lCLEAR_TEXT),
	/*0x69*/ MAPFUNC("BRUTAL_EXIT", lBRUTAL_EXIT)
};

/** Process actor move script
	@param actorIdx Current processed actor index */
void processLifeScript(int32 actorIdx) {
	int32 end, scriptOpcode;
	ActorStruct *actor;

	actor = &sceneActors[actorIdx];
	scriptPtr = actor->lifeScript + actor->positionInLifeScript;

	end = -2;

	do {
		opcodePtr	   = scriptPtr;
		scriptOpcode   = *(scriptPtr++);

		if (scriptOpcode <= 105) {
			end = function_map[scriptOpcode].function(actorIdx, actor);
		} else {
			printf("ERROR: Actor %d with wrong offset/opcode - Offset: %d\n", actorIdx, actor->positionInLifeScript);
		}

		if (end < 0) { // show error message
			printf("Actor %d Life script [%s] not implemented\n", actorIdx, function_map[scriptOpcode].name);
		}

	} while(end != 1);
}
/** @file script.life.h
	@brief
	This file contains life-related routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef SCRIPTLIFE_H
#define SCRIPTLIFE_H

#include "sys.h"

#define MAX_TARGET_ACTOR_DISTANCE 0x7D00

/** Process actor life script
	@param actorIdx Current processed actor index */
void processLifeScript(int32 actorIdx);

#endif
BCÀŞ!  ]"  ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q  ò   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØPÂÿÿÿÿ€P;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å lˆáÿÿÿÿ‚Êaæ¡àAÊaÒaÊ¡ÌÚ!È0‡p`‡y(€p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th€ä¡ÊÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú¡ÜáÜ¡Ø¡ÂÁ ÂŞ¡ÒÁÌaÚÀà¡Ú!è sv˜‡r wx‡6p‡pp‡yhs€‡6h‡p t Ì!ØaÊ æÂaÖ¡àAŞÊaèáä¡Ä¡ÌÁÊAÚ`ÒAÊÀ€¨w˜‡p0‡rhs€‡6h‡p t Ì!ØaÊ êaÊ¡æáÌÚÀØáÂ sv˜‡r 6D `ˆB °„1 Øâ  l ¶H Û@(€m –ƒS b°Áhşÿÿÿ $€ I     ‚`B L†	Q’(Ã¡&Å2L˜aBĞL8ˆÂ8D™„b™0   ‰   Ø   2"
 d…$¤„$ã„¡LŒ„MŒÆB 0G Ñ@
 &M%L>;"|`HìQÂ„‚‚Ë¤)¢„Éï°`á[ Cb§ˆ&Ì€Á9ÒQÂäÏoê Í„„c¤)¢„ÉŸßÍ¹Ğp–4E”0ùš09‘éT;E”0!b`` á4iŠ(aòµaZ„!¢˜ vŠ(aBB ÂIÒQÂäkÂäDìQÂ„ìÀà ! ! ! ! Aa!ÉÈ!¡ ‚P €&’€*R€.ò€22€6“¦ˆ&­ˆh°‘&vŠ(aBÇÀÀÀÀÀÀ@*tG* ä ÀEÒQÂäsNS Æ‡,ú@@BB H$ ˆä"iŠ(aòYhˆÔAš	‰`B'©€@)Ô@+	h @-e@@X¡—Ë¤)¢„Ég…y¦)ˆj„	q$À¤ZÉä Ñä
 Ù$r@ á$r é$Á ñÜ"M%L>Ğ8"N¡Äi| qø\$M%Lşì4;E”0¡ÂÄdàg É€((±	h(±	¨ˆ28`€r> €”r> ˜œú h!- h*= ¨*%è*é (+9h+9¨ë,iŠ(aò½kŠ€‘&vŠ(aBÑÀÀÀÀÀÀÀÂÀÀÀÀ ÂÀÀ@Ê|X‚X Y Y Z" Z [ …d Åe ÍH: ]2 ^B ^. _F _V `N `> aVÈ°„X
R,1 Äq``````€«€@‘epD ÉR    Peé²”YÇ Ú,…#u!€>Ëàˆ€@¡Ep\¡ÑB  Piè´”ZGZ-†#µÄ^Ëàˆ@±…pD@ Ùb8"    Pí@ÀÀA@%p¤]2 ò%Š!    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:I #DD 
 )œvå“Âá¤0JĞ!œv%BI¥0Ø!”v%B)A‡pZH)Œt'Bw(X RI  @ ìP´`¥’  € Ø¡pK%  @$…S‚á$°C(	ìJ	:„S‚á” C8	ìÊ-…R‚á” C8	ìJ	:„“À¡ ,aS	ìJ7…R‚á” C8%èN;„’À¡,aS	ìJ	:„SNá$°C(	ìJ9…“À¡$°C(]èF @	:„³„Ma$°C(	ìJ;„R‚á” C8	ìJ;„’À¡” C8%èN$…S Iá$°C(%èN
(…q¦ˆÍ;”:F,	  €Ê$–   s”Î&†S‚á” C8%èÎ 9„‘À¡$°C(N$…S Iá@R8N;„’À¡$°C(	ìJ;„²Ç‰¡” C8	ìJ;„’À¡$°C(	ìJ;„R‚á@R8N	:„S‚áìqb({œÊ'†’À¡$°C(	ìJ;„’À¡$°C(	ìJ;„’À¡$°C(	ìJ;„’À¡” C8	ìJ	:„SŠ¡” C8	ìJ;„’À¡$°C(	ìJ9…“À¡$°C(	ìJ")†ÓˆŠá$°C(	ìJ;„’À¡$°C(	ìJ$…S Iá@R8N$…S‚á$°C(	ìJ;„’À¡$°C(	ìJ	:„S‚á” C8ŒN;„R‚áL²b(ŒÎ%,†³I‹á|âb8Ÿ¸N	:„S‚á” C8%èN	:„S‚á” C8%èN;„’À¡@R8£¼N)%…S‚á” C8%èN	:„“À¡$°C(	ìJ;„’À¡¤c­ÄF,2†R‚á” C8%èN$…S‚á@R8µÌF.4†ÓKácc8%èN	:„S‚á” C8%èN	:„S‚á” C8%èN$…S Iá” C8%èN	:„S‚á” C8%èN	:„S‚á” C8%èN	:„S‚á” C8%èN	:„“Ja¤€RN$…S‚á” C8%èN	:„S‚á” C8%èN$…S‚á” C8%èN	:„S‚ásc(%èN	:„S‚á¤€R	ìJ;„R Iá$°C(	ìJ;„R‚á” C8%èN	:„S‚á” C8%èN	:„S‚á” Cø¥K  `‡RA%  °C9‡@Ç’  € Ø¡¤C fI  @ ìPÖ! ³$    v(í´Y   ;”wÜ,	  €Ê;o–  À%‚1K  `‡AM%  °C9‡`Ç’  € Ø¡¼C gI  @ ìPÎ!à±$    v(ïÄY   ;”sz,	  €Š<s–  ÀåK  `‡"%  °C‘‡ Î’  € Ø¡ĞCğgI  @ ìPê!p©$    v(÷¤Z   ;”uÊ,	  €Š<v–  À%‚XK  `‡²®%  °Cé‡ Ü’  € Ø¡ÜC jI  @ ìPî!Xµ$    v(ô€Z   ;”Î-	  €JHê–  ÀåtK  `‡r«%  °C‘‡àÎ’  € Ø¡¬C`fI  @ ìPF"X·$    v(ÿ¤[   ;yğ,	  €
=¡–  Àe‚]K  `‡’¬%  °CÉ‡`Ö’  € Ø¡ĞC jI  @ ìPî!hµ$    v(%¼[   ;”|h-	  €Ê=®–  À¥‚pK  `‡’A­%  °CY‡àÌ’  € Ø¡ÔCğRI  @ ìPŞ!³$    v(õÀT   ;”s~,	  €J=1•  Àe^K  `‡²A¯%  °C‰€İ’  € Ø¡ŒDĞnI  @ ìPÖ!@³$    v(òäY   ;”zd*	  €JIğ–  Àe$wK  `‡Ò¸%  °Cé‡`Ü’  € Ø¡äC`kI  @ ìPî!xµ$    v(ôŒZ   ;zH-	  €Š<z–  ÀE‚=K  `‡²Aš%  °CÉ‡àÖ’  € Ø¡ìCàkI  @ ìPú! ·$    v(ç€Y   ;”uÔ,	  €
=¥–  À¥$‚xK  `‡R¼%  °C¡‡ÀÔ’  € Ø¡”D0oI  @ ìPJ" ·$    v(ùàZ   ;”zf*	  €J?å–  À¥$‚zK  `‡BÁ©%  °C)‰ÀŞ’  € Ø¡ìCğkI  @ ìPä!à³$    v(ô Z   ;”zh*	  €Ê:k–  ÀE‚>K  `‡r¬%  °C‘‡ÀÏ’  € Ø¡¬CÀfI  @ ìPÎ!³$    v(ı˜[   ;”|r-	  €!ËI      À%%€     `È²@     0dY	      ²´     Y`     †,2À     C–”       €!      À      `È      0d      ²À      Yà  €     †,p  @     C8       €!      À      `È      0d      ²À      Yà  €     †,4@    C8       €!      ÀÅ&€ 0    `È      0d      ²À      Yà  €     †,p  @     C8       €!N 0    ÀE'€     `È¢@     0dÑ	      ²à     Yt€    †,p  @     C8       €!      À      `È      0dÑ	      ²À      Yà  €     †,p  @     C8       €!      À      `È      0dÑ	      ²À      Yà  €     †,p  @     C–• `    €!      À      `È      0d      ²À      Yà  €     †,:À     C8       €!      À      `È      0d      ²è     Yà  €     †,p  @     C8       €!      À      `È      0dá	      ²à     Yp€    †,8À     C8       €!      À      `È      0d      ²À      Y|€    †,p  @     C° `    €!O 0    À…'€     `È‚@     0dÁ	      ²À      YÄ€    †,p  @     C8       €!      À      `È¢@     0d      ²à     Yp€    †,p  @     C8       €!‹N 0    À      `È¢@     0d      ²À      Yà  €     †,)À     C8       €!KJ 0    À      `È      0d      ²     Yà  €     †,8À     C8       €!O 0    À      `Èb@     0dA      ²À      YĞ€    †,p  @     C `    €!      À      `È      0dQ      ²À      Yà  €     †,p  @     C8       €!      À      `ÈB@     0dÁ	      ²À      Yà  €     †,p  @     C8       €!N 0    À      `È‚@     0d      ²è     Yà  €     †,lÀ     C¶ `    €![ 0    À…-€     `È      0dA      ²¸     Yà€    †,:À     C8       €!‹\ 0    À,€     `È¢@     0d¡      ²ø     Yà  €     †,vÀ    C8       €!‹N      @   ´  2˜(LŒ	&GÆC „  €¡ŒrH$‡Ê8ArÉ¡¡ŒtX$‡ÊXArÉ¡¡Œvh$‡ÊxArÉ¡¡Œwx$‡ÊHArÉ¡¡xˆ$‡Ê8ArÉ¡¡Œw˜$‡Ê8ArÉ¡¡Œw¨$‡Ê8ArÉ¡¡y¸$‡Ê8ArÉ¡¡yÈ$‡ÊArÉ¡¡zØ$‡Ê¨ArÉ¡¡Œ{è$‡ÊXArÉ¡¡yø$‡ÊÈ0ArÉ¡¡Œ}$‡Êè1ArÉ¡¡Œ{$‡Ê¸2ArÉ¡¡z($‡Êø3ArÉ¡¡Œ8$‡Êø4ArÉ¡¡Œ{H$‡Ê5ArÉ¡¡ŒuX$‡Ê	6ArÉ¡¡Œh$‡Ê7ArÉ¡¡zx$‡ÊØ8ArÉ¡¡Œ|ˆ$‡ÊÈ9ArÉ¡¡z˜$‡Ê¸:ArÉ¡¡Œ’¨$‡ÊÈ;ArÉ¡¡Œ{¸$‡Êè<ArÉ¡¡Œ|È$‡ÊX=ArÉ¡¡ŒzØ$‡Êx>ArÉ¡¡Œzè$‡Ê8?ArÉ¡¡Œzø$‡ÊØPArÉ¡¡Œ}$‡Ê	QArÉ¡¡Œ‘$‡ÊXRArÉ¡¡y($‡Ê¨SArÉ¡¡Œ’8$‡Ê	TArÉ¡¡Œ~H$‡ÊèUArÉ¡¡Œ|X$‡Ê¸VArÉ¡¡zh$‡Ê WArÉ¡¡yx$‡ÊXArÉ¡¡Œuˆ$‡ÊÈYArÉ¡¡Œ}˜$‡ÊèZArÉ¡¡Œs¨$‡ÊX[ArÉ¡¡z¸$‡Ê(	\ArÉ¡¡Œ’È$‡Ê ]ArÉ¡¡Œ’Ø$‡Ê(	^ArÉ¡¡Œ|è$‡Ê¨_ArÉ¡¡Œ~ø$‡Ê(	pArÉ¡¡z$‡Ê(	qArÉ¡¡Œ}$‡ÊrArÉ¡¡z($‡Ê¨sArÉ¡¡Œu8$‡ÊtArÉ¡¡Œ{H$‡ÊuArÉ¡¡ŒuX$‡Ê8vArÉ¡¡Œ~h$‡ÊÈwArÉ¡¡Œr@$‡"‚ 
 … r ˆ š Š ºĞ0(J¥O©ÓßrĞøí&§éé·ô†ßä2¨DVP†šAQ*}Ju ª{í~ßİ 7¼,Óßr=Ì®—Aó´¾*‘´¡`P”JŸR(8¦¿å 7¼,ÓßrĞ>~“Ë YA# ²	ëµ»j¹É¶Šùsh¹‰x¾"+n¥·IŠ²ŠŠg»IZjòoŠ¸Éæn[éıè¹	¨™Ş¾ŞJ!+ˆ‘Œ ĞÉ ¥Œ ĞÊ µŒ P
Ş…B x¡°a^(p¨
î…‚‡|¡ b_(„è
"ş…Âˆ€¡@b`(”(
&†Â‰w¡€"a(¤h
*†ÂŠ‰¡À¢b(´¸
.2†Â‹¡ £c(ÄX
2Z†ÂŒ—¡@#f(Ô˜
6n†Âœ¡€cg(äè
:~†Â ¡Àch(ô8
>’†Â¥¡ äi(‰
B¦†Âª¡@äj(É
Fº†Â‘¯¡€$l($
JÊ†Â’´¡Àdm(4i
NŞ†Â“¸¡ en(Dé
Rş†Â”À¡@ep(T)
V‡Â•Å¡€år(dÙ
Z:‡Â–Ï¡À%t(t)
^V‡Â—Ö¡ &v(„©
bn‡Â˜Ü¡@¦w(”	
f†‡Â™â¡€&y(¤i
j¢‡Âšë¡Àf{(´ù
nÂ‡Â›ñ¡ ç|(ÄI
rÖ‡Âœö¡@ç}(Ô‰
vî‡Âü¡€g(äé
zˆÂ¢À'(ô™ 
~:ˆÂŸ¢ ¨…$ƒê°)§zú©¦ jª©¦¡Š:*©¥šz*ª©ªº*«­ºú*¬±Ê:+­µÚz+®¹êº+¯½úú+°Á
;,±Å{,²É*»,³Í:û,´ÑJ;-µÕZ{-¶Ùj»-·İzû-¸áŠ;.¹åš{.ºéª».»íºû.¼ñÊ;/½õÚ{/¾ùê»/¿ıúû/ÀD£vP”JŸR(8¦¿å tOÓÑ »üí>ƒŞfó¼L½áã7¹jfó¼L×JdÙ¨Çô·T"ƒ˜is4ËÓp:h[šwAî7”nÃÙåvÙM/“„3@:# Ä3@A# 44@E# „4@J# Ä4@N# 5@S# T5@W# ”5@[# Ô5@`# $6@d;xg·Ã‰¦d¶{Šß,,~Kx%ë-±¡¼„vŠæ3ŠšKl^«-ÑzqKhk ßÇzí«×ºëIj{œŞë­â·‡é±¬z{°®È‰·º?‡–{„bû£Û¸ëµ?¸š{€«ù£ß·Gz¿wv{¤+:şwGl# ä¶Å‰şâ·E©m^¹zzâ·…wvâ·ºşâGq‹lh'ÿè6.¢¢ù£Û¸ëµ)~Ş"ŸV–ÚVz‹bYşè6.âİ_ŠŸ·HZjòÿ•Ú"Z×ıŸë•‹°îö®W.¢¢ù³^»ˆ)vâ~ß"éŠ¿È¢4·ëµ)~Şnã2j¦èÚz¦w¶Ë°-šşåß®G.ó¡îÙıè6z\»ëµˆ–èŸ¢ì2\¹ş!Z¢Š²Ë|Zçı©Vş«×-ói÷¯^÷§Z¹ëµ§­äŸjå2!Z¢¦–şíªd·ëµ»jù£Û¸ëµÿæ…Ú+¢îºëµÿWjàÏ¹›·ëµÿWjàj¦·ëµ‡¢ë_z_»ëµ‡¢ëß¡ğ¹xŠíŸŠ'ˆºâ¹MZjòÏu»jIx»°^ûwâj¢·‹é±¬z?º»ˆ'÷s¡–¶Şºëµ‡¢ëï¦»p¡v‚ŞÏ¹›·Ë&‚¿é±¬z»°šü›Ëj ·‹§%Úy?º»l«ÛjåïÅbKzû°^ûwâj¢÷£Û¸Ïê±-ºzù·«Æ‘û°^û›(ré½^¹ën¿©"÷§¨x¶û°šü›Ëj ÷£Û¸é±¬z?ëW–Ä·
§™ÿ‡–%
¯Š¯÷oèé²«h]÷s!*rŞ*Kş\ˆŠœ·Êç–åŸ¢âÙ®²¹ÛVz?ú}«p¥§­ëÅ-ù-ÄzíÏ¡fŠ®­gzg»wv?‡š)º¶éíB øz?ˆ–İŸŠç±¸ëµ?‡š)º¶éín#	®ä²ŞŞ_Šm[z?éÉ+±^û—âçı)*ínãJ¬»ı¥øyŠŠgû£Û¸ëµ¿Ëzİ/¯w¶è*á:¬×şŠ®ÿ*‚a»xr?W¢¯·ş¯ói÷k¥¶šÿêuë|ZçıZ©­æŸjå:ŸÖyÿêu¿Vj«¹Î§uŞŸjå¯•Új®£±äÏ…¨Èy?ºë°^ûŸèjjåŸj%   y     C„»HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q     &>P,›×jH,¦Ø‰?ú}¦<@òØ¿À±¬^ë®§$@ƒ0-,„eQ9Zƒ0âp¥+Ú¢©Æ‘–: -«Ç¶èêıåß®GZ}@$PQÔ!ÀÒ×ä5S„™!$ÓHD´ â4= =‘#’Á"’½LEä4Ó‹„³QEAD"™Ãƒ4ÑLN„’q ëµ?¸š¦±8- V"Òdêà4M)°´Î
nšm$ënÿçz¥Á<Ë§uŞŸjå¯•Újv@4 ÀÒ×ÄNÎÃ9‹ù ²€«ù£ßgâD@µUØ&I€`µÄ5Y€$PQD4+DÈ3½ÀB¦æH ó,„‰4± ˜	,’@4„&LN$Õt‘ã52aéŠ¶hªq¤=,‹Öu?¢"ç™iÀÍ@D+b“=<ED3µÄ5m@£Xu@3 ÀÂ@Ä>€@XÊò 1MÄ
nšePÂB Qè,<©#!â4:,¤X–?º6>àD+,Zc,„iH,-qMUDÄ"aKD@›±CXVà ME4“a-,„Ù=9òFND|À²X#"Z#YDdlŒ0ÏB¤€ƒÁ8•s…È0ØÄe³Ö9!Iš09‘wM°9%™y€óDH3µÄ5ñ/Õf&I ó,„ÆÑD‹0„8O„4SK\ÿ‘mèÎ!ÍÔ×Ä¿@t›z€óDH3µÄ5ñ/å¶à<ÒL-qMüDºµ8O„4SK\ÿo‚Æ‚øYå@²|ZYj[éÙh€#Ì³Rº Ò– 	TÍ´`iä„$ƒ&LN$—¥L­·?GEÑL%1MDí ³p¡v‚ŞÏ¹›g‡Å¢¢ibĞâP+!—,’@4D‚"g€#À@h±-ÜÖ=ğ 2qÄ² FÈ`\KàL“Ã”D1ÅF8P,ÚÉÆà ME4“aß’İºşâg^KàL“Ã”D1ÍÖµÎ49LI“lñAL"M@#vgıÊj¦÷£¯·Ú\’9‘[]’9‘3{ÀÔzqûsTÍTÓDD²Ñ%™Ó!9²õ
è€³°^û¥ş fzf¡4„Å±](aq CD€lJCXÀ0Ûê ³ˆ'÷s¡–¶Şjx’@EÑLš09‘ØÌNCØ}€$PQD4Óë\Ğ(²6:€,¬+rbç™ı@³°^ûwÚJş©Vj Í@D›3McZËADÖ Œ8\vP=‘#’´:0!N³aZƒ0&EDäxÍ„L˜‚«Ç²âë##0Dh±¦=,Z×ıŸë•fPˆÁ
A4+!ÍDD6/ĞÄÔ!Ò4qw†/@,ŞÙYí ² Ûøshi“à<Ø¶8‚’˜dw$qRŒ&LN$™¿€±”Úæ•V?ğ,Kş\ˆŠœ÷£Ûh­ÉB“éPa®ÎÂzíß¡èú—Ş×šÎ#PQD4+!—-D‹ã<bSÍäD˜8ŒMHÒáX,AaÌÍ³ ˜‰ˆIIˆ`™ÎÂzí¿y¡öŠ¨»ÚÆ±@‹0„y,Å ÅKDqÙAb ñ-€!™‹#Ë‚4!ƒ8\ö	‘ólÎ49+DÑ˜ê ³˜Ëj ÷£ÛhÄI± UDdĞ ÌFÕ° ÂlTQ‘mÔĞ€ û ±“E
HqM0ÒUÅÄa"ËâJ
,Ä4öH°ÄdÕ×d˜@EÑLš09‘Ö ŒwMN‘İ<ëµÿ‰®¦Vş©VZúÀr@HL^3E˜±HÀPÒÄE$¥ÀBLaÔÍD\· Ë ËbœÍÂ¡fŠ®­gzgk½“0w8ˆ@H,1MHcH6Hà<€µ (&%!‚<Oä„$iÂäDé!A²¤+:ş"‹Ú%AôD@HR‰+DÈ3àÀ°ˆŸñ Ëé½Ş*~Æ:Ğ,êİn£Çµ¶>ğ,ŸÖy¿Vj«ù§Zi{$qRL‚"™ï€²¤(û§¨x¶FR„4ÅVR„4ÉfR„4Í†5DähÂˆÃÕ‰,·z­g”SD`y4„&LˆÓH&Ğ ÃP"±E ÄÖ—Dä˜NE– 1€°,umÕ„Í(Ëæn[éıèiİĞ€ KK\Óæ\+b“)0ED3±ñÄ¶ÀTÍÄNÄ#c #PQD4;ÏlIôDÈD°HF´@°¦H Îƒ±BDé)’@4Äì4„dÖÍ€ KK\ç,NdÂŒ@EÑL&%!‚y(™ã0¬Dc’ÒVK\ÓG-‹$DÑØe òDN’:’l–È9IêH±ı P À†€<‘“¤4› €3×#ÍàX%QLö; -¬×ş¦ŠÜ_z¯WZAs‘³P!i %Ì³Rº Òš09‘d¡Œ0ÏBH-,„ı<9iDH1f[ @4×#ÍàX­ó°@E3‹‚4†&LNd“Î9IêH1+DÑXMô 1MÄ
nGI“Ãb öD@HR	HÓêLÀ„8ÖañÏ!ÍÔ×TÓ/Õ=°,Kş\ˆŠœgÙĞ€ KK\;‹d„Q,WzÚú·^Üšô ³l"ø›Ëj gÇÌ³ Ø· ¦S!„i01mÄTˆCEV<,i©ÉÿWj6À°´Ä5±HFX"²¤+:şwg'ˆP±ˆÃe¢Ó9!Iš09DBDv×%"M6P</á8P,,,~ÖDä¤„LˆÓ´ØC˜a@4Ã"ÑÁB @3×#ÍàX­ó˜¼@Ä¤5ÆBhÍÀSD1iÂäD"M@#ö“Ä”ˆqLÖâ0„ ¤HcPH#—Á@ Ù")ÈóI`I°ÄÔ×Ä"a®J„Çd:”D˜tÀQ8Í”N‘ñ a…DäÄ‡4„‘#›ÒVHDÎlöQC\S‡ KK\“×Lf—ĞÂzíß‰«‰vŞn£50HƒL-qMĞ( 	Tu°´Ä5±HF˜ş À@˜d»Ìá,<ß’ù(Àò@‰Çd‘ŒDLŸÓLœ³8‘1Õâ4?<f5DähÂˆÃ¥µaéµ"g¸ˆ°ËrRÌæP@Xâ@²h§hşè6ì ³°^ûw(ºşnjÎÓÂzíï²^÷‹çë-ºÊ†HàHÄT"Æ1½„09‘	Lën)~ŞŸ¢âÙşè6Úg@TÑD\œãDÒ !¡À3×#ÍàX+b“å …L ÀF<€È¤	“™üÀƒwMà]Ïâ„í(ODH1fÈŠà,"!N[r€"8Ë‚HˆÓÈ¦ Î² â4³=¾4Eö=Ğ 2½ÎÕ:é`F/  Ã€VD´ ˜ñ4Kˆ–¨©¥»j£a,§™ÿ‡–%
›¡ 4×#ÍàX›3Mcº
%!ÁADXé@´€âëı Zv*zœÇw€3 ÀÒ×´9Wë<†>ğ,ŸÖy¿Vj«ù¯^g6‰¤ ØL‘cşÈÒ†ŞïQ8Oä$©#É¬DcîJÄJ)°ØUu‘£5#—‚«Ç²âëYÚ"Ì³«C5ƒÁ8”DpÄ² FÈ`AåDÊ‹„³QEAD†8€ 2iÂ˜l€³8Î“F„$I`†ÆH ó,ÄJ<0Y£€áKSTÓæ(`øÒÕµ-D1q CD@êHÈ„8 K(¶?º†B!ME4“a&` Bê Í$Ùw@4 ÀÒ×´9W
D Sx@4 ÀÒ×´9W
D céÀ´¸¬÷£§÷—bÛ–ŞOz²BaÈB¤€áKSTß¦B!ME4“a'Å”PH›sÙä C5EDÑ"a†/MQm›%³l«ÛjåïÅbk‘†/MQ›d@…H®„4N9	!LˆÓØ¤€áKSTëF)`øÒÕ»U
¾4E5o–†/MQİ›¤€áKSTç–?,0ˆ`Ö;€ 2±/¨Yg€ó8¶Í@D-öV=à,â)¶* êŠ§]
¾4E6m˜†/M‘][pÀ, lTQ‘ED1}N3q‘#Iœ³8‘i
¾4Eöm™†/M‘m[m@³8Î£	“±ñØ¦€áKSdãf !ME4“a,’-,„µ4Ë§uŞ¿zİŸj¥y
¾4Eön†É²¡ü£Ûh†/M‘­Û§€áKSdóÆ)`øÒÙ¹
¾4Evo–@EÑLö9ËâXÄ 	“™ìÀ²€âëızº¬Ñ,a C¼@„[ì€³°^ûw(ºş
Ÿæ°4„ñQn[›@EÑL©#!â4b³9–NQHB„<S:E&*`øÒİµ…
¾4E7mÕÂzíÏ¡fŠ®­gzgû£Ûh‚ÎâP’&LNÛ`€óDD…8”¤	“ÉFà<Q!%iÂäD³¥HE'Å ÅJ`mÎe¤†/MÑ}››"	DC„DäÄö¦HÑ!9²Á)’@4DHDÎl¨†/MÑ½[©€áKStãf*`øÒİ¹
¾4E·n£†/MÑm[ª€áKStóæ°´Ä5mÎµ9Óä0†´HO„LDa·ˆ°Ë"—ıÀ pÀ! ³-(KZjòoŠhÎÂzíß®Gşè6šoÀ! ±©
¾4Ewo«†/MN«€áKS„×Ö*`øÒá¶¹
¾4EømmŠ$aR"˜Dâ<‚3é¬€áKS„çö*`øÒá¸É
¾4Eøn¶Ê²­"GşZ­€áKS„÷6+`øÒá¼)$ëµ)~á@‹é±¬z?ëW–<+ÑDôÖ+`øÒáº½$’@4DHD)ÒÛÒ!ÀàX²1Ò5Û¡ 5×#ÍàX›3MÃa3M¨®ÿê±ìÿ‰¥gáËò¹eù§¨x¶f DähÂ„8ñ(ED3‘f¶†/MQ^Ûæ€³°^û¥şœ»y†+`øÒå·á(‹x¾"+n¥gµ†/MQN[®€áKS”ãÖ4I08ç,"!NÓbaƒÅâ•¬g¼†/MQ¾›®€áKS”çf<`HS´Y4ëµˆ–èŸ¢¬ù
¾4Eyo»†/MQ®Û­€áKS”ÛÖ+`øÒå¼UE9Zƒ0âpèjj¥­,¡	“Ù{ s RˆÑ¼Îe•Î9IêH3+DÑØù€R ‘ËJ6„`½@TÛu€4 ÀÒ×ÄN@4qÎâDö+`øÒé´¾4Ezm2Ç,Ä4ò0 Ò¤ÀBL±‚›f×’DL¡³8ğ¤„LˆÓıÀ²lî¶•Ş~ŸÕO„4SaäÎ!ÍÔ×Ä§STÛ™#Ì³ @#&,`øÒé·õË‰şâg¢0ÏBH,’-,„¾4EºmÒTD39vRI`’(’@4Ä· †d¬Q@ÁB°O„L„ØÄeÅ†/M‘®Û”t‘ã52aÈr«×zv,`øÒé¼U<CXì³ ÓD›s™Âb ÁÀ3‘95 59š’„T„¾4EúnÈ†/M‘Şm€³8ÎÃQQD4I`–<°D¬Dc¯ÏÂzíß¡èú¯"¶6PC‡Dæ°(öE C¤SdÓD1iÂäD"M@#6,`øÒé¸•8O„4SK\ŸN‘mÉ†/MÑNÛã€RD‘-Â¶8Ğ,¬×ş¥øy?º†:Ğ,l‹¦ù·«Æ‘¶ğ°´Ä5mÎUÅd¹Å2£¨iú M
,Ä4F,`øÒé¹1¾4Eûm…/MQm…/M‘mÊÖFÁB˜éÀc“V`/°P„	8KZjòÏu»jiF…/MÑmG…/MnŸÑâİÏ¡fŠ®­gzgk‰…/M‘nŠ…/MÑn§Éâİ_ŠŸgËÑ9!Iœ³,ˆ„8MlÌÑ9!Iœ³,ˆ„8lÍÑ9!Iœ³,ˆ„8Ílˆ…/MQn,‹0w8ˆ@Hæ,`øÒí¹å(°¬„DLÄ`…ÓD\Œ4ƒc­ˆqL,PV DD3QI“‘QÒ!±9T3 ±9W:E¶(PøÒñÆ(PøÒõ¶S=Q!%…DälÄTˆCE-`øÒí»õDODTˆCI!9Zc,„íú}¬×Úi@Í@D­óØ´€áKSÄÓÖ,`øÒí¸@«É¿é±¬z?ºö,`øÒíºåË‰¦-`øÒí¼I¾4E{oÊ†/MÑ^Û²€áKS´Ûöğ,€4‘öE C¤SdÔ†/M_[µ€áKSÄÛf-`øÒñ·]¾4E<nØ†/MŸ[¶€áKSÄë¦-`øÒñ»m¾4E<oÜ†/MßÛî ‚4Èdr fØÍÂ•ë¢%ú§(kİ†/MQO›·€áKSÔ×ö-`øÒõ¶=Ò!ÁÀàXé™j€ÓPZ¬ÄÖæ\.`øÒõ¸¾4Eımã†/MQ¯[óÀ³ˆ'÷s%úzë¿¡±•¾4E=oä†/MQ¿Û½€±xfÚÊ¦/P,ì)~¶?,Ú)š?ëµÆàH@E¤€Ñ	0„‰¾4E}næ†/MQßN„4ÑLN„S@!™s $ ”DhÂäDÀ aBp A¬Ã¼@TÓÆ÷ĞÄê8ÌDumOCw A°ÑæHP,­·f>Ğ,ŸÖyª•ÿêuVH IÄ„FÓá¤‘“Â„8<1m€D¬ÎLˆÓØ¹ÀáKSTÓ´­EÀ<a"MG, ¶6ƒAEä4Ó‹„³QEADf9À,¬×ş¸šhçºÀáKSTÓµ¥¾4E5m[á€ƒ4Èd:±hÂäD¶.pøÒÕ4nì‡/MQMç¦.pøÒÕôm°‘$DÑ”£POaí‡/MQMëæ.pøÒÕôn­Ğ9!IŸC5ƒ8Œù89iDH1fÈbz,«ñ(1m€ ¤ÀböÔ9!I%RèCDÀäD’e(N4N9IlšŠM‡“FN"Ûf€âDÓá¤‘“Ìö>ğ,ŸÖyÿêu¿Vj«iáÎ!ÍÔ×ôQ}[%PQD40Z+a_Éä<+bSl`Éä<+b“laÉä<+bÓl+JC1Üá !™îÀR Ñ:ÛŠı5Oä„$iÂäD²4Oä„$iÂäD³ù5Oä„$iÂäD±uDëµ?‡š)º¶é­ÍXODTˆCI¥ã<iDH1fQÒAD×LÈ„imXz­ÈYğÀ´°^û—âçı)*ín£4Òä<&2 &%!‚1(ëµ»jiy$qRÌì4„dñÌâÅi‰vŞn£%HHSÍäDØI1$ „dŞÌÂjòoz,«qMìÙô 3×Ä-ÈóQËb±Ëâ8éTD:EF°=ÒL-qM|UDô‘mÒ–Ø€ C´ĞH›sYtÀ#PQÔ!ÀÒ×”N‘AA9^3!v¢«©•V>ĞL!ƒ	<ö.P=‘#’T"Á9Í€LˆÓH†< HÄ”1M„ÅL”DhËDD0)°ÓD~@ò GI“Ãğ ´°îö›(rŠŠga     ½     „PP¥CH?P¥Pe@%PeQEP6H?P…P ÅQ8ÅT¸%UF(Q€åÿP€ÅP
ÅPQ¥Q%R$eR(¥R,åR0%S40”=H!94”AH!23l€øÛ0!!ş6ÌDHˆ¿3âoÃL ş6ÌDHˆ¿3âoÃL„„øÛ0!!ş6ÌDHˆ¿3âoÃL„„øÛ0!!ş6ÌDHˆ¿3l€øÛ0!!ş6ÌDHˆ¿3âoÃL„„øÛ0!!ş6ÌD°âoÃL„„øÛ0!!ş6F\§0 ƒÕ õİO@a0âï‚ !\€ƒZ0 ¤aş 	v!‡+D.)¹Éä¨™«hÎª¹Ëæ°›ËşM¹-ä8œ‹”“ƒœ›ƒ“ãëƒóûƒŸ…Ÿ°K…°K±S…±»…‘Ã…”Ë|ÓâÆxC 6 @ÁnØ&f„!Œ(=U€Y‚À`Œ7nÓŒ`0"õ˜% f	xToŒ'­0ÁzÁ .@ˆÁˆ2€Ê`Œ7´İãÁİ´c¸!È›4˜e0`0BönA f	Rƒ1Ş {{Œ7|³
Œ`0âö˜%@f	xpoŒ'»0¡{Á .@ˆÁˆ8`0‚ta (ÆxÃî‘N0AÁ Œñ†ÀtÂá‚¥@TpXA:èpC :a0Ë)ıÁoZÇ(äc¼!€t `„`Ä€@ ~
†q8ƒY†…	#Ú¯`– "TãíÀƒVaŒ7¹R…1Şğ=P0¨ÆxCğ;÷@Á18  ¥”ƒ#^! z…1b@  KÃA>˜Á,CãƒıW0Kğ,Œ`0âÿ˜%xf	 Yi0âÿNB f	¤Y^ ]ãúÔã‚ŒÁ €Y^ ÆxBpƒ&@B¸ !#v! Ú…1Şp‚üãAüøã‚Œ`Á €Y^ sãAı¤ã‚Œ€Á €Y^ ÆxB@ƒ3@B¸ !#Î! :‡1Ş@ƒAÿãÿÈã‚ŒÈÁ €Y^ zãÕã‚ŒèÁ €Y^ ÆxBƒ`@B¸ !#æ! š‡1Ş†
ãÁ
ùã‚Œ0Ã €Y^ ãÁíã‚ŒPÃ €Y^ 5ÆxBàƒm@B¸ !#ş! ú‡1Şà†Áã‘ã‚Œ˜Ã €Y^ :ÆxBpƒv@B¸ !#N" :‰1Ş`‡„b0bƒ@ f	xa0B%Æh ˆƒ1üÅ`„Á .@ˆÁˆ–€ZbŒ7üa€FÁ`„K0¡ 1 äc¼!P£Ò¸€`)¬VĞ:Ü¸QÌ2¼APMŒñ† Tƒ‚Af1Æ:j
†AF ¯`¸!04˜eğÂ  ¶ãÑƒŞbŒ7}T"‹1Ş€’nP0è,ÆxC0J»AÁ18 €½”ƒ#Ú" ÚÅ`Œ _ÁpCĞf0ËğA0á‹oÀ,ÌˆÁ`„/¾1 ³b@o1†U
ƒY†3ƒ€übŒ7¬ärdÃ„ ì#ì" ²‹Qoè`^@x1Fğ¯`¸!ğ3˜e ƒ2#Ş1¸˜%0bÇ`\0 ƒñ0K`³n@íˆd¸!x0˜e@6è5ÆxCĞKïAÁ°@=@@§1LB`{€`0Â4‚ Ó´‡F F0 „cÄ€@€†‚÷0ƒY†4Pƒ`0$€Y‚5 ~Æ0!’A  ³k0KĞôÁ¸` #H2`– f	Ü`– #H2`˜%€ƒY^ ßãA;ùã‚Œ@É €Y^ ‘Ä`DJ Ìğ©d0Æ‚Œ`É  Â1qÁ Pz„á†àÂ`–ì  õ ÄpCOa0ËPwoŒá†`EÎ`–Áî  ßã/ôS@A¸` #p2`–`H<ÆpC€"`0Ë€yyŒñ†šF*  \0ƒ>0K ƒ>”” ÌèÁ,ÁÌğåÇoNªG(À`„X Ìğe0Æ3Œ(Ë  Â1ñÁ Ğ{Œñ³^*o`ÊL(À`ÄZ Ìğ‘e #Ø2`–€#JdM€È2ƒm0KÀ”–ŒpË €Y^ ²Ä`Ä[ ÌğÁe0Æ‚9ŒË  Â1±Á Ğ~Œñ†¹x*Œà` #\„N€øcŒ7>•',¢‚?Á
BE‡±
ƒY†S…€ndŒ7eõ'Ò‘1Ş U¨P0¨GÆxC°V£BÁ ã[¡
ƒ^dŒ7q¥*’‘1ŞĞ«P0F à5¨Q"Œ¨‘` ¨FÆˆ á7®b³¤P
Á`„lº" ³¦@82.€ÁÚ˜%0…YTŒ Í€W`– f	xa–€¨6ƒ1àÊ`ÄmÁ .@ˆÁˆ	€è$7¢³µ°
ıÈ ØÆpƒ€Á,+´B0Ñ›¹À,,˜Œñ†ÙL+  \€Ã¹€Á,ƒ+ÀB@g2Æz3X­€‚pB7é³¯ Á`Äyî" ³±0qk	À,A,ÌÈg .@á†€]À`–ah! 7Àˆ’ ù/ÁlÍÖlÍ¼ÌĞÂ,-F°g0[0K`³¼0Q*ë2 Á¸` #Ü3`–€(<1ñA  ³¼@ª2ÆÜÒ
Æ01ŸA  ³¼01Ÿ¾À,/P«Œƒ @.V‚Y^ W„ >   †z 	N3 â4/°P‹d„<‚ÓÈ„8úÎ@˜îA3‘ALš09QMíÁ2‘ALš09‘å<Ä¤	“‰ÃÕÛì3‘ALš09‘8\Æz€ˆ4@˜ír‘£5ÆBè¶{ ˆ4@Ôµ­$€09‘8\µµ$€09‘8\¶¹$€09‘8\·½$€09‘8\¸Á$€09‘8\¹É ai±V{Däh±v{€`ˆÃµîA“‰ÃÅ›½A“™êâLiÂäDÆ{@ ÁXê“‰Ãe±G± †8\       a   r   \,      „P
…PEP0”ÁEH!94”¡AH!9 3’oÃL„„äÛ0!!ù6ÌDHH¾ƒ3 $rc<!P#H. Â1a@Çn0˜e„€PnŒ'Ğ`„Ê@B¸ !#–` f	jÆpC0Á,Ã@ärã‚¥@\€ ƒQ0 $sc<!È#h.€Y‚‚ª1bP  aÁ`Ö/ 0K°Ída$ÈrèÈ7Eßš}ƒğmº7‹lN\€ „á! ƒY$	#:1 €Y‚m–@# qc¸AÌ`–aa‚Áˆ00 ˜%Øf	4ò9q‚Œá!@ƒYç	#Ê@ `–`›%ĞHìÄBd0†„àf")ŒH7 €Y‚m–@#³ ¡Án‚4˜e ª`0¢ä  f	¶YÔN\€ Äc¸AÂ`–áÂ‚Áˆ8° ˜%Øf	4zƒ1bP ÀÑA0K FÌÎ À,ÁFs 2
   xàN3 â4/°P„0ÎCDÀäDœ3foTÀB,’        a      A,      „P 3‚oÃL ø6FÅ FÄ ¤¸„    voP ÂäDfo€ ÂäDâp       a      A,      „P%T  3‚oÃL ø6FÇ FÆ P0Æ‚r)#‚b ò     voP ÂäDfo€ ÂäDâp       a      A,      „P 3‚oÃL ø6FÅ FÄ Ğ¾ñ„€Œè·` ’\Â     voP ÂäDfo€ ÂäDâp       a   (   C,      P„PE3’oÃL ù6ÌDHH¾ƒ2 ƒÂ1 $Œ `(Œ‚ aŒ °BÁpC.a0Ë ÅÛŒ˜ ˜%ã»,:¹qÁR .@ñ„"Œ`¹` r^Â     ÖoTÀB,’voP ÂäDfo€ ÂäDâp     a      A,      „PE   3‚oÃL ø6FÆ FÅ P0Ær!(ôoã‚¥@\€ ã	E0ArÁ äº„    voP ÂäDfo€ ÂäDâp       a   #   A,      „PE   3‚oÃL ø6ÌDH¾ƒÃ1 ƒ‚1 $Œ ^(Œ‚ aŒ  Bc¼!H—„‚A$7. X
Ä2Pƒ)@ÂK8     ÆoTÀB,’voP ÂäDfo€ ÂäDâp     a      A,      „P 3‚oÃL ø6FÅ FÄ ¤¸„    voP ÂäDfo€ ÂäDâp       a      A,      „P 3‚oÃL ø6FÅ FÄ Ğ¾ñ„€Œè·` ’\Â     voP ÂäDfo€ ÂäDâp       a      A,      „P 3‚oÃL ø6FÅ FÄ ä     voP ÂäDfo€ ÂäDâp       a   *   D,      „PET  3‚oÃL ø6ÌDH¾ƒ2 ƒÂ1 $Œ `(Œ‚ aŒ °BÁpC.a0Ë c¼!X—…‚A&7. X
Ä2Pƒ+À,Á@+7Æi0¢å‚˜%’^Â      ÖoTÀB,’voP ÂäDfo€ ÂäDâp     a   -   D,      P„PET   3’oÃL ù6ÌDHH¾ƒC2 ƒ2 $Œ b(Œ‚ aŒ ÀBÁpC .a0Ë c¼!`—…‚A'7. X
Ä2Pƒ,À,Á@,7Æi0Âå‚ ~ƒÁ ³CÚK8      æoTÀB,’voP ÂäDfo€ ÂäDâp     a   -   D,      P„PET   3’oÃL ù6ÌDHH¾ƒC2 ƒ2 $Œ b(Œ‚ aŒ ÀBÁpC .a0Ë c¼!`—…‚A'7. X
Ä2Pƒ,À,Á@,7Æi0Âå‚ ~ƒÁ ³CÚK8      æoTÀB,’voP ÂäDfo€ ÂäDâp     a      A,      „PE   3‚oÃL ø6FÆ FÅ P0Ær!(ôoã‚¥@\€ ã	E0ArÁ äº„    voP ÂäDfo€ ÂäDâp       a      A,      „P 3‚oÃL ø6ÌDH¾ƒƒ1 ƒB1 Äoƒ‚pBFÁ 1èÀˆA¡ ı3$rc<!X#H.€\—p      ¶opÎ€‰Ãe÷ LNdö LN$       a   )   A,      „P 3‚oÃL ø6ÌDH¾3‚oÃ`qÀ`Ä` õÛOŒÁˆ€„pBFÁ PÈñ„@Œ¹` H Ä`D %ƒ–qÁ Œ
0BCï    ¶oĞ8ÓADš09‘8\ÆoÀ8ÓAD›3`âpÙ½A“™½“‰Ã      a      A,      „P 3‚oÃL ø6ÌDH¾ƒƒ1 ƒB1 Äoc<!(#ü- Â1Q@Å dŒ ?º¨Kê   voP ÂäD¶op ÂˆÃeö LN$       a   )   A,      „P 3‚oÃL ø6ÌDH¾3‚oÃ`qÀ`Ä` õÛOŒÁˆ€„pBFÁ PÈñ„@Œ¹` H Ä`D %ƒ–1bp,Àÿíò.A¾K8    ¶oĞ8ÓADš09‘8\voP ÂäDÆoÀ8ÓADZƒ0âp™½“‰Ã      a      A,      „P%T  3‚oÃL ø6FÇ FÆ P¿–q‚P1Æ‚tI#‚a häÆxB F”\0 É.á@   voP ÂäDfo€ ÂäDâp       a   '   A,      „P%T  3‚oÃL ø6ÌDH¾ƒ2 ƒÂ1 äoc<!8#@. Â1Q@"7. X
ÄBÉo(9w	Æ‚wy#b (åÆxB F¬\0 )/á@      ÖoĞ8ÓADš09‘8\voP ÂäDfo€ ÂäDâp      a      A,      „PåS  3‚oÃL ø6FÇ FÆ P¿–q‚P1Æ‚tI#‚a häÆxB F”\0 É.á@   voP ÂäDfo€ ÂäDâp       a   '   A,      „PåS  3‚oÃL ø6ÌDH¾ƒ2 ƒÂ1 äoc<!8#@. Â1Q@"7. X
ÄBÉo(9w	Æ‚wy#b (åÆxB F¬\0 )/á@      ÖoĞ8ÓADš09‘8\voP ÂäDfo€ ÂäDâp      a   2   C,      „PEP2Äk‹ù8`‹99 3‚oÃL ø6ÌDH¾ƒƒ2 ƒB2 rã‚¥@\€ ƒE0 Drc<!`#L.€ƒ š·1Ü¸KÌ2B@Ë1   ‚Y–1ŞÄDÁ1  `zÆ0¡o Ğ3F èŸ`Ä` €iÄ€ €ı¹Ò^Â      voP ÂäDöopLÄ5‰Ãeö LN$       a   $   A,      4PeQƒ „P  3²oÃL û6ÌDHÈ¾ƒC2 ƒ2 ôoc<!(#B. Â1Q@Å¨ Ñ€’1Ş¸‹»\@°ˆ*$­@º$­@ØÁ#€¬—p    voP ÂäDæo@`˜½“‰Ã     a   +   C,      „PERå3‚oÃL ø6ÌDH¾ƒC2 ƒ2 ôoc<!@#B. Â1Q@Å cŒ7ìÂFÃ 2†‚f! ”ã	A4¡rÁ .@zÆxC@/Ò`D0À,õ     æo°N3EÎb:a÷ LNdö LN$        a   8   C,      „PERå3‚oÃL ø6ÌDH¾3‚oÃ`¡À`Ä ÜO’Á‘€„pBFÁ Éñ„ Œ0¹` H Ä`D %ƒ–1Ş€rñŒ7ò"FÄ P3†‚	f! —ã	Á5sÁ .@¢ÆxCÌéK0ŞìK60K $¿„      æoĞ8ÓADš09‘8\öo°N3EÎb:a÷ LNdö LN$       a   9   C,      4P„P%QeQ…  3’oÃL ù6ÌDHH¾ƒ3 ƒÂ2 $rc<!P#H. Â1Q@ñ&.@:Æpƒ„Á,C ”Œñ†”“—`¼!˜—ˆ‚Q•ƒù 9c¼Áåî%oğ¥¢`T`å`D¿@Óo˜9~	Æ‚~Á(x9rÁ 6.€Á“`0BäÆ@ f	„™p      voP ÂäDx Î²81hÂäDâp™½“‰Ã    a   !   A,      P„P  3’oÃL ù6ÌDHH¾ƒÃ1 ƒ‚1 Ôoc<!(#ş- Â1Q0bp,@ş Ë¹$èBÆ1   }‚T—p       Æo€ÄTˆÙ½A“™½“‰Ã      a   (   A,      „P 3‚oÃL ø6ÌDH¾3‚oÃ`qÀ`Ä` õÛOŒÁˆ€„pBFÁ PÈñ„@Œ¹` H Ä`D %ã  fŒ7”Ü»ƒÁ 	/á@  	   Æo`¼ÀBvoP ÂäDfo€ ÂäDâpÙ¾ÁQ,€!     a      A,      „P 3‚oÃL ø6FÅ FÄ Ğ¾ñ„€Œè·` ’\Â     voP ÂäDfo€ ÂäDâp       a      A,      „P%T  3‚oÃL ø6FÇ FÆ P¿–q‚P1Æ‚tI#‚a häÆxB F”\0 É.á@   voP ÂäDfo€ ÂäDâp       a   '   A,      „P%T  3‚oÃL ø6ÌDH¾ƒ2 ƒÂ1 äoc<!8#@. Â1Q@"7. X
ÄBÉo(9w	Æ‚wy#b (åÆxB F¬\0 )/á@      ÖoĞ8ÓADš09‘8\voP ÂäDfo€ ÂäDâp      a      A,      „P 3‚oÃL ø6FÅ FÄ ä     voP ÂäDfo€ ÂäDâp       a   (   A,      „P 3‚oÃL ø6ÌDH¾3‚oÃ`qÀ`Ä` õÛOŒÁˆ€„pBFÁ PÈñ„@Œ¹` H Ä`D %ã  fŒ7„Ü»ƒÁ 	/á@  	   Æo`¼ÀBvoP ÂäDfo€ ÂäDâpÙ¾ÁQ,€!     a   5   A,      4PCD%PEPRe  3¢oÃL ú6ÌDHˆ¾ƒ3 ƒÂ2 $rc<!H#H. Â1Q@Å1   |2ÆxƒÉ½K0ŞÀËsÁR * ´j#ˆ@ ¨ã-g/ÁxCp/Ô`D` Ac¼æò%oôÅŒ² iŒ7Ì¿ãA¿`ƒ¿@úK8    xĞ8ÓADš09‘8\voP ÂäDfo€ ÂäDâp      a   &   A,      4PCD%PEPRe  3¢oÃL ú6FË FÊ 0F  Ÿ€„1Ş¨KrÁR *p´g#ˆ@ ã¼4ƒÁ3 ¤Œñ†@^œÁˆ  bÆxC@/Ï`DP/õ      voP ÂäDfo€ ÂäDâp       a       C,      4P5P„P   3²oÃL û6FÈ FÇ ½‰
ŒÀ·@ ßÄ2Ü¤Ì2B0±oé" ³Âˆ’ /”.Iº¤Kº,KªK8   voP ÂäDfo€ ÂäDâp       a   „   L,      4P%PåQEV(„PEPÅP5Pd…P¬   3òoÃL ÿ6ÌDÈ¿	3òoÂLü›0A ÿ&ÌDüòoÃ`Ä‘À`„ ™œŒŒ ìE æÆKŒH ™ã	5QsÁ Ğ".@r9q‚X0„à‚Œ¹@ HæÄ2ÜÌ2B0Qs$# ³Âˆ’ jD2f@c@2$cƒÉÀ,Á@“¸ A†‚fˆ$ K\€ ã)§2Á`„ Yc¼!`3 @\€ Ã„Á,Cq´ñ† fb†q‚7m ³ÆŒñ†ÀfÜ€q‚Œñ†@gè€q‚Œñ†Àgê€q‚ĞÏM‚Xp!18 à†ä‚€â`Œ7g
ƒÁ  „w‚è`Œ7j#
ƒÁ  ”vÓ? Á@y0Æ‚·1…Áˆ`€Áˆ>€˜%Hf	òQA,À`(0K0Ğˆá†@nÂ`–aQA¥'F”Ø¥Yd!‚º¹…Y‚%í&     ÖxÀ8ËpR	H!™ãÁáTD´ ˜1$2+Ğ„İ€09‘-ˆÙ €09‘8\¦x`(€t     a      A,      „P%T  3‚oÃL ø6FÇ FÆ P0Æ‚r)#‚b ò     voP ÂäDfo€ ÂäDâp       a      A,      „P…TJåS   3‚oÃL ø6FÉ FÈ P0Æ‚s9(DŒñ†@]’Áˆ` 2ÆxCÀ.Ê`D @¶K8    voP ÂäDfo€ ÂäDâp       a      A,      „P¥T>  3‚oÃL ø6FÇ FÆ P0Æ‚r)(DŒñ† ]Áˆ`€L—p     voP ÂäDfo€ ÂäDâp       a   =   C,      „PEP2Äk‹ù8`‹99 3‚oÃL ø6ÌDH¾3‚oÃ`±À`Ä  …ÜO”Áˆ‘€„pBFÁ PÉ–q‚F$Á PÊñ„ ŒX¹` F €ßÆpC0/a0Ë9cÄ€  ÿ	f	zÆxCËÙK0ŞÜ‹EÁ1   „šÆ0r 5F ¡`Ä` €lÄ€ €ê’_Â  
   öoĞ8ÓADš09‘8\voP ÂäDxpLÄ5‰Ãeö LN$      a      A,      4P„P  3’oÃL ù6FÆ FÅ ¼‰

Œ ·@ ²\Â      voP ÂäDfo€ ÂäDâp       a   #   A,      „PÄk‹ù8`‹99    3‚oÃL ø6ÌDH¾ƒ2 ƒÂ1 äoc<!8#@. Â1Q0b0 @BÅ1  Àv‚ƒ ’ ŞgIu	    voP ÂäDfo€ ÂäDâpY¿L     a   2   A,      4Pƒ„PEP ÈPVEQ"   3’oÃL ù6ÌDHH¾ƒC3 ƒ3 4rã‚¥@\€ ƒE0 trc<!p#R. BÆxC/Ï`Dğ )c¼!˜—‡‚AÌ0!=c¼!À—i0"€¢1Şè‹vÁR *ğt0b€¬1ŞüK6€Ì $È„      voP ÂäD&x€ˆ4@˜½“‰Ã      a   2   A,      4Pƒ„PEP HPVEQ"   3’oÃL ù6ÌDHH¾ƒC3 ƒ3 4rã‚¥@\€ ƒE0 trc<!p#R. BÆxC/Ï`Dğ )c¼!˜—‡‚AÌ0! =c¼!À—i0"€¢1Şè‹vÁR *ğt0b€¬1ŞüK6€Ì $È„      voP ÂäD&x€ˆ4@˜½“‰Ã      a   2   A,      4Pƒ„PEP ˆPX…Q"   3’oÃL ù6ÌDHH¾ƒC3 ƒ3 4rã‚¥@\€ ƒE0 trc<!p#R. BÆxC/Ï`Dğ )c¼!˜—‡‚AÌ0!=c¼!À—i0"€¢1Şè‹vÁR *ğt0b€¬1ŞüK6€Ì $È„      voP ÂäD&x€ˆ4@˜½“‰Ã      a   1   A,      4Pƒ„PEP …U% 3’oÃL ù6ÌDHH¾ƒ3 ƒÂ2 $rã‚¥@\€ ƒE0 drc<!h#P. BÆxC /Î`D/@Êoäå¡`3L@@ÏoîeŒ† hŒ7ù’]@°ˆ
:Œ kŒ7ş’Fÿ2 ù/á@      voP ÂäDx€ˆ4@˜½“‰Ã      a   +   E,      „PåQà 3‚oÃL ø6ÌDH¾ƒ2 ƒÂ1 äoc<!8#@. Â1Q@ÆoÔE¡`T°èpCĞ.a0Ë1cÄ€ €Ú	f	ZÆpC /a0Ë09c¼!‰‚QAµƒC0 ³DÖK8      voP ÂäDÖo@`˜½“‰Ã     a      A,      4P„P  3’oÃL ù6ÌDHH¾ƒÃ1 ƒ‚1 Ôoc<!(#ş- Â1Q@ÅŒ0·` #ÊM€L—p     Æo€HÑâpÙ½A“™½“‰Ã      a   +   D,      4P%@% 3¢oÃL ú6ÌDHˆ¾ƒ2 ƒÂ1 äoc<!(#@. Â1Q@ÅnÔ%f! dŒ7ìÂ.,¢H+€v0‚`–` gŒ7ò"/,¢K#†@ f	†´—p       voP ÂäDÖoÎ² â4fo€ ÂäDâp     a   A   F,      4P5TD%P    3ÂoÃL ü6ÌDH¿ƒÃ2 ƒ‚2 rc<!0#F. Â1Q@ÆoÚ¥]. X
D‘F Ğ2Æy‘—–QA¥ƒC  ôŒá†€ƒY†@HãA¾äËK¨ Ó
¸Œ ˜%(èÃÁ³6Æ‚	™–QAhd°ƒD  c¼!8™“¹€`)¨V;A0K@ÌÉ2á@     voP ÂäDxÎ² â4fo€ ÂäDâp     a   *   D,      „PET  3‚oÃL ø6ÌDH¾ƒ2 ƒÂ1 $Œ `(Œ‚ aŒ °BÁpC.a0Ëc¼!X—…‚A&7. X
Ä2Pƒ+À,Á@+7Æi0¢å‚˜%’^Â      ÖoTÀB,’voP ÂäDfo€ ÂäDâp     a      A,      4P%Qƒ„P  3²oÃL û6FÈ FÇ ¿ñ„€Œ ¹` Hc¼!Pu¹€`)U8Zs58Z°ƒF  /á@     voP ÂäDfo€ ÂäDâp       a   B   I,      „P44P„P0”Qa€ä’C$1”1`€ä‚oÄk‹É;`‹¹;`‹Ù;    3¢oÃL ú6FÌ FË Èñ„ Œ ¹` H Ä`º@è6†w	ƒY†€(İÄpCğ.a0Ë@9c¸!—0˜eˆ`Ä€  Ù‰F pF x#Ôm€Y„Üm7ô³GĞ»‰d¸!¸—0˜e0`Ä€ €Û±F F  #Ş€Á|Ã`–à˜%@_Â       voP ÂäDfo€ ÂäDâp       a   9   A,      „PEPeQ   3‚oÃL ø6ÌDH¾ƒƒ2 ƒB2 rc<!H#D. Â1Q@Åo7v	Æ‚vi
Ä2QnÁ 2ÆÎ-^‚ñ†@^&
Ä2‘nÁ Ğ3ÆØÍ^‚ñ†à^.
Ä2ÑnÁ Ğ»²ÆxCÀ/Û`D0 ÅÛ lŒ7ÿÒFÃ Ğ¼âÆxC 2ß`D0@L8    voP ÂäDöo€L (âp™½“‰Ã      a      A,      „P…   3‚oÃL ø6FÆ FÅ ¿ñ„ Œğ·` HÄ`D®@¹&.@\0 ƒ¼@®K8     voP ÂäDfo€ ÂäDâp       a      C,      „P 3‚oÃL ø6FÅ FÄ Ğ¾ñ„€Œè·` HÄ`Ä­@·&.@á† ]Ğ`–!‚Á]C˜%2]Â      voP ÂäDfo€ ÂäDâp       a   +   A,      „Pe   3‚oÃL ø6ÌDH¾3‚oÃ`À`Äp ùÛOÁ€„pBFÁ Èñ„`Œ ¹` H Ä`D %ƒ–1Ş`rïŒ7ğFÄ d¼„   
   ÆoĞ8ÓADš09‘8\voP ÂäDÖo,HA¼ÀBfo€ ÂäDâp    a   7   C,      „Pe   3‚oÃL ø6ÌDH¾3‚oÃ`À`Äp ùÛOÁ€„pBFÁ Èñ„`Œ ¹` H Ä`D %ƒ–1Ş`rïŒ7ğQ0,(B01@ĞoX9z	Æ‚z©(ÃÁ½ Á,C Tñ˜Ë—`¼!Ğm0"Ø—˜%r_Â 
   ÆoĞ8ÓADš09‘8\voP ÂäDÖo,HA¼ÀBfo€ ÂäDâp    a   .   A,      „P   3‚oÃL ø6ÌDH¾3‚oÃ`À`Äp ùÛOÁ€„pBFÁ Èñ„`Œ ¹` H Ä`D 1ƒ–AË fŒ7 \¼ã¼HŒƒ Rç0Š é%     ÆoĞ8ÓADš09‘8\voP ÂäDÖoĞHSD4Æt EˆLfo€ ÂäDâp     a   .   A,      „P0”Qi€ä’CÄk‹™<`‹©< 3‚oÃL ø6ÌD¾3‚oÃ`¡À`Ä ÜŒ‚ aŒ À7Á` ÃTrc<!#N. JÆˆ ¡Œ  :ÏˆÁ  ÎˆÁ  M¾K8   	   æoP0N…voP ÂäDöo€4 C°HF˜½“‰Ã       a      A,      „P 3‚oÃL ø6ÌDH¾ƒƒ1 ƒB1 Äoc<!(#ü- Â1Q@Å1(  ntIt	   ¶op0È€ˆÃe÷ LNdö LN$       a      C,      4P„PE3’oÃL ù6FÇ FÆ Ğ¬‰d¸!(Ğ`–!²5QAƒ¸À,é    voP ÂäDfo€ ÂäDâp       a   !   C,      P„P3’oÃL ù6ÌDHH¾ƒ2 ƒÂ1 äoc<!0#@. Â1Q@Ån4˜e„€1ŞoìFN ÌÙ.á@   voP ÂäDfo€ ÂäDâpY¿L     a   #   A,      „PE    3‚oÃL ø6ÌDH¾ƒÃ1 ƒ‚1 Ôoã‚¥@\€ ƒE0 rc<!H#F. :åÚ° Á`Ä®0Ş kí"FÄ ¤»„   Æo‡ƒ„8\voP ÂäDfo€ ÂäDâp     a   1   C,      „PEP2Äk‹ù8`‹99 3‚oÃL ø6ÌDH¾ƒƒ2 ƒB2 rã‚¥@\€ ƒE0 Drc<!`#L.€ƒ š·1Ü¸KÌ2B@Ë1   ‚Y–1ŞÄDÁ1  `jÆˆ |Fˆ½ÀˆÁ  Ñˆ ùS%½„     öo‡ƒ„8\voP ÂäDfo€ ÂäDâp     a   6   C,      „PEP2Äk‹ù8`‹9=`‹I=`‹99 3‚oÃL ø6ÌDH¾ƒ3 ƒÂ2 $rã‚¥@\€ ƒE0 drc<!p#P.€ƒ šƒ ª·1ÜÀKÌ2B@Ë1  `‚Y–1ŞÌ‹DÁ1   zÆ0Áo Ğ3F øŸ`Ä`  jÄ` €iÄ€ €şÉ_Â    voP ÂäDxpLÄ5‰Ãeö LN$       a   1   A,      4PCD%PEPR    3¢oÃL ú6ÌDHˆ¾ƒÃ2 ƒ‚2 rc<!@#F. Â1Q@Åo ¹v	Æwi. X
D’V í` 1ã‚Œ·@ Èã-g/ÁxCp/Ô`D` Ec¼æò%oôÅŒ²È}	    xĞ<Hc8ÒhÂäDvoP ÂäDfo€ ÂäDâp      a   '   C,      „P4P0”AH!93‚oÃL ø6ÌDH¾ƒ2 ƒÂ1 äoc<!8#@. Â1Q@Å1  €mJÂpCÀ.a0ËÁˆ’ 1Ä¬Ëº¬Ëº¬3K $»„   voP ÂäDÖo€, LˆÓ˜½“‰Ã      a      A,      „P 3‚oÃL ø6ÌDH¾ƒƒ1 ƒB1 Äoc<!(#ü- Â1Q@Å1   m‚D—p      voP ÂäD¶o€, LˆÓ˜½“‰Ã      a   "   C,      4PÈ„P…   3’oÃL ù6FÇ FÆ P¿ñ„ Œø·` H Í›¸ A,@pÁ FÜ[  toân3˜e„`0Bß ˜%ò]Â    voP ÂäDfo€ ÂäDâp       a   !   C,      „P 3‚oÃL ø6FÅ FÄ Ğ¾ñ„€Œè·` H Å›¸ A,BpÁ FÔ[  ToânØf!ŒÀ7v€Y!Û%      voP ÂäDfo€ ÂäDâp       a      A,      „P 3‚oÃL ø6FÅ FÄ Ğ¾ñ„€Œè·` HÄ`D¬@±&.@ È&Èt	      voP ÂäDfo€ ÂäDâp       a   +   A,      4P%P„PE@¼¶˜¶˜“    3²oÃL û6ÌDÈ¾	ƒ3 ƒÂ2 $rã‚¥@F PÉñ„@Œ8¹` È”Œ`Ä@I ’x— ‚F h( Èˆ mŒ ğ$½„      xLÄ5yÍavoP ÂäDfo€ ÂäDâp     a   4   A,      4P%P„PE@¼¶˜¶˜“    3²oÃL û6ÌDHÈ¾3²oÂ`ÑÀ`ÄÀ ÜO’Áˆ’€„pBFÁ ĞÉ–1@*7Æ‚g0‚å‚ E3.€%vèê¥^«1 @¢F\€ # ÈM0b0  •ù
   xĞ8ÓADš09‘8\&xLÄ5yÍavoP ÂäDfo€ ÂäDâp    a      A,      „PeSd…3‚oÃL ø6FÈ FÇ Ğ«ñ†À\ŒÁˆÀ Ê5q‚Xpˆà‚Œàµ@ r]Â       voP ÂäDfo€ ÂäDâp       a   #   A,      „PEP   3‚oÃL ø6ÌDH¾ƒ2 ƒÂ1 äoã‚¥@\€ ƒE0 $rc<!P#H. :%c¼!hf0"€–1b@ @Ùù.á@      Öo€4„¥5ÆBØ½A“™½“‰Ã      a      C,      4P„P5@¼¶˜å   3’oÃL ù6FÈ FÇ ¬‰d¸!0Â`–!‚ÁˆXK`0bÖ1 À1   }Y!Ñ%    voP ÂäDfo€ ÂäDâp       a      A,      „P0”Qa€ä’CÄk‹ù8`‹99 3‚oÃL ø6FÈ FÇ Œ @Œ p3Å`D«‘‹ Œ 0d¹„     voP ÂäDfo€ ÂäDâp       a   %   A,   
   „P,%@%@CeH!94”ár€ä’CÄk‹ù8`‹99   3’oÃL ù6FË FÊ Œ @« rÆ”ƒ ræ@F àd0BÖ1  Hu	    voP ÂäDfo€ ÂäDâp       a   '   A,      „P,%@CeH!94”Qi€ä’CCn H!9D¼¶˜¶˜“    3’oÃL ù6FË FÊ Œ @« rÆ”ƒ ræ@F
 ¸$Œµt€ƒ ŠT—p    voP ÂäDfo€ ÂäDâp       a      A,      „P0”Qa€ä’CÄk‹ù8`‹99 3‚oÃL ø6FÈ FÇ Œ @Œ  3Å`D«‘‹ Œ 0d¹„     voP ÂäDfo€ ÂäDâp       a   %   A,   
   „P,%@%@CeH!94”ár€ä’CÄk‹ù8`‹99   3’oÃL ù6FË FÊ Œ @« rÆ”ƒ ræ@F ¨d0BÖ1  Hu	    voP ÂäDfo€ ÂäDâp       a   '   A,      „P,%@%@CeH!94”Qi€ä’CCn H!9D¼¶˜¶˜“ 3’oÃL ù6FÌ FË Œ @Ğ« tÆ–ƒ tæ@F
 À™Œ˜5E F (r]Â    voP ÂäDfo€ ÂäDâp       a   -   A,      „PEQ…3‚oÃL ø6ÌDH¾3l€àÛ0A(01$@ 7Æ‚d0Bä‚ !\€ƒF0 dŒñ†‘c—`0â€1Ş¸‹CÁ eŒ7ñQ0¨ã½HŒ zæ ‚¼—p     æoĞ8ÓADš09‘8\voP ÂäDöo 8ÓADš09‘Ù €09‘8\        a      A,      „P 3‚oÃL ø6FÅ FÄ F Û0 ).á@   voP ÂäDfo€ ÂäDâp       a      A,      „P 3‚oÃL ø6FÅ FÄ F Û0 ).á@   voP ÂäDfo€ ÂäDâp       a   <   C,      „PEP2Äk‹ù8`‹99 3‚oÃL ø6ÌDH¾3‚oÃ`±À`Ä  …ÜO”Áˆ‘€„pBFÁ PÉ–q‚F$Á PÊñ„ ŒX¹` F €ßÆpC0/a0Ë9cÄ€  ÿ	f	zÆxCËÙK0ŞÜ‹EÁ1   „’Æˆ ¢F ›¾ÀˆÁ  ×ˆ ÿ³¥¾„ 
   öoĞ8ÓADš09‘8\x‡ƒ„8\voP ÂäDfo€ ÂäDâp    a   )   C,   
   „P0%@%@CeH!94”ár€ä’CÄk‹ù8`‹99   3’oÃL ù6FË FÊ Œ @« rÆ
71Ü¨KÌ2A0bP ÀÎ$Êˆ }£Ìƒ´¶ÀˆÁ  G²K8     voP ÂäDfo€ ÂäDâp       a      C,      „P0”Qa€ä’C  3‚oÃL ø6FÆ FÅ F¬š¸ éšnÆ%f„ 1  ÀnŠY!Ë%    voP ÂäDfo€ ÂäDâp       a   N   F,      ”[„P4P„P%S¥@CePH!9DCc H!şFCeH!9D¼¶˜¶˜Ó¶˜Ô¶˜É¶˜ú¶˜“ 3²oÃL û6ÌDHÈ¾ƒC5 ƒ5 # $# Ä2bP(€Ì<ÑˆÁ  Èˆ úãFÜš¼ -c0B`0‚‰`Ä€  ı™#p-€ƒ  d§1 à1  €tÆ`DÀ,A0b0 À1K Ğ­‰d¸!°—0˜e †€rM\€ ÃA¾„Á,1P‘v Ã,CP# 4¹/á@ 	   ¦x MÌó-€Ñ!Ò³ XK\“İ€09‘Ù €09‘8\       a   %   A,      „P5PÅ3‚oÃL ø6ÌDH¾ƒC2 ƒ2 ôoc<!@#B. Â1Q@ÆoÖEŒ˜ dŒ7í²FÎ P2ˆ#Ç„ğ.ñd¼„   voP ÂäDæop ÂˆÃeö LN$       a      A,      „P5    3‚oÃL ø6FÆ FÅ ¿ñ„ Œğ·` ²     voP ÂäDfo€ ÂäDâp       a      A,      4P…@%P6   3¢oÃL ú6FÈ FÇ Ğ«ñ†À\Š–Q¢(;A@µ6ÆvQ#‚v€ÁWcH&   voP ÂäDfo€ ÂäDâp       a   )   A,      4P 5@%P6EVâB¼¶˜ÿ   3¢oÃL ú6FÌ FË F¤2 ƒª†.@³6ÆuA#d #x€ÁU;€RMF€\  ƒ©Æ ¡š¸ A×ÆxCğ.Ê`D0ÀˆÁ  J>á@    voP ÂäDfo€ ÂäDâp       a      A,      „PÄk‹H    3‚oÃL ø6FÆ FÅ Œ 0ä¸„   voP ÂäDfo€ ÂäDâp       a      A,      „P 3‚oÃL ø6ÌDH¾ƒƒ1 ƒB1 Äoc<!(#ü- Â1Q@Å1  À_‚D—p      ¶oPL (voP ÂäDfo€ ÂäDâp    a      A,      „PåNPàˆ  3‚oÃL ø6FÈ FÇ Œ /1Œ €/åR.å2b` À½”K¹”Ú P# à‹œKK8      voP ÂäDfo€ ÂäDâp       a   *   A,   	   „PQ€>P€…{Q2(PËèPìÄk‹©<   3‚oÃL ø6FĞ FÏ ©2µ1bP €¿ÁˆÁ  Å`„©¹‹ Œ  Ğ/NÃ<Ïˆ üò.Ë»(É» # €Ìa¼Ëˆ ûå»„      voP ÂäDfo€ ÂäDâp       a   O   I,   	   „PP%PåŸPoP 0”A‘’CH‘ÄPÆ€’Cˆ¾3’oÃL ù6ÌDHH¾3’oÃL„„äÛ0Q@0A<@&7. X
Ä2Q@*7Æ‚g0‚å‚ TÃ„³3†f„" e7ø³ÄF4Ô Ì³5cÄ   ’	¨ F†Œ€‚Œˆ‚1  `d4Šµ1b` ÀÈğK`‘4†‚ÍfŒ#Œ˜¸˜%8ˆÖ†` ‚Á[€lm5×ÆˆÁ )32ƒÌ 92á@     6x€LÄ5±HFØ½A“YáÁ1×$—0qM›s­ˆqLfo€ ÂäDâp     a      A,      „PåŸPà    3‚oÃL ø6FÇ FÆ Fè¹ÀˆÂ èB.äBå2bp €º¹C’K8    voP ÂäDfo€ ÂäDâp       a      A,      „P 3‚oÃL ø6FÅ FÄ Fˆš¸@á@   voP ÂäDfo€ ÂäDâp       a   Q   I,      „PÒUP%TD0”q§€ä’CCu`
H!9 3’oÃL„„äÛ0!!ù6ÌD°’oÃ`Á c¼!äÔ%Œ‚ aŒ7ì¢P0ÈãÁ»8Œñ"ŒX¹` #˜i f	Z¹1¡oÁ Ëñ„€Œp¹` H Ä` Ac¸!ĞÒ`–A’Æxƒ«éK0ŞìËFÁ l5F
 „`0B`–€ mP6Æ‘	
Æˆ hD0K@Ğ7†“AƒY†ÂH…Áoèµ”	Æ•Q
Æˆ p”E0K`Ìtc¸!pƒ0˜e Ã    	   öo0Í` LNdö LN$—0’!Ï„>‚3          /** @file script.move.c
	@brief
	This file contains movies routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "script.move.h"
#include "scene.h"
#include "actor.h"
#include "movements.h"
#include "animations.h"
#include "scene.h"
#include "renderer.h"
#include "sound.h"
#include "redraw.h"
#include "lbaengine.h"

uint8 *scriptPtr;
int32 continueMove;
int32 scriptPosition;
ActorMoveStruct *move;
int32 numRepeatSample = 1;

typedef int32 ScriptMoveFunc(int32 actorIdx, ActorStruct *actor);

typedef struct ScriptMoveFunction {
	const uint8 *name;
	ScriptMoveFunc *function;
} ScriptMoveFunction;

#define MAPFUNC(name, func) {(uint8*)name, func}


/*0x00*/
int32 mEND(int32 actorIdx, ActorStruct *actor) {
	continueMove = 0;
	actor->positionInMoveScript = -1;
	return 0;
}

/*0x01*/
int32 mNOP(int32 actorIdx, ActorStruct *actor) {
	return 0;
}

/*0x02*/
int32 mBODY(int32 actorIdx, ActorStruct *actor) {
	int32 bodyIdx = *(scriptPtr);
	initModelActor(bodyIdx, actorIdx);
	actor->positionInMoveScript++;
	return 0;
}

/*0x03*/
int32 mANIM(int32 actorIdx, ActorStruct *actor) {
	int32 animIdx = *(scriptPtr++);
	if (initAnim(animIdx, 0, 0, actorIdx)) {
		actor->positionInMoveScript++;
	} else {
		actor->positionInMoveScript = scriptPosition;
		continueMove = 0;
	}
	return 0;
}

/*0x04*/
int32 mGOTO_POINT(int32 actorIdx, ActorStruct *actor) {
	int32 newAngle;

	actor->positionInMoveScript++;
	currentScriptValue = *(scriptPtr);

	destX = sceneTracks[currentScriptValue].X;
	destY = sceneTracks[currentScriptValue].Y;
	destZ = sceneTracks[currentScriptValue].Z;

	newAngle = getAngleAndSetTargetActorDistance(actor->X, actor->Z, destX, destZ);

	if (actor->staticFlags.bIsSpriteActor) {
		actor->angle = newAngle;
	} else {
		moveActor(actor->angle, newAngle, actor->speed, &actor->move);
	}

	if (targetActorDistance > 500) {
		continueMove = 0;
		actor->positionInMoveScript -= 2;
	}

	return 0;
}

/*0x05*/
int32 mWAIT_ANIM(int32 actorIdx, ActorStruct *actor) {
	if (!actor->dynamicFlags.bAnimEnded) {
		continueMove = 0;
		actor->positionInMoveScript--;
	} else {
		continueMove = 0;
		clearRealAngle(actor);
	}
	return 0;
}

/*0x06*/
int32 mLOOP(int32 actorIdx, ActorStruct *actor) {
	// TODO
	return -1;
}

/*0x07*/
int32 mANGLE(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript += 2;
	if (!actor->staticFlags.bIsSpriteActor) {
		currentScriptValue = *((int16 *)scriptPtr);
		if (actor->move.numOfStep == 0) {
			moveActor(actor->angle, currentScriptValue, actor->speed, move);
		}
		if (actor->angle == currentScriptValue) {
			clearRealAngle(actor);
			return 0;
		}
		continueMove = 0;
		actor->positionInMoveScript -= 3;
	}
	return 0;
}

/*0x08*/
int32 mPOS_POINT(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript++;
	currentScriptValue = *(scriptPtr);

	destX = sceneTracks[currentScriptValue].X;
	destY = sceneTracks[currentScriptValue].Y;
	destZ = sceneTracks[currentScriptValue].Z;

	if (actor->staticFlags.bIsSpriteActor) {
		actor->speed = 0;
	}

	actor->X = destX;
	actor->Y = destY;
	actor->Z = destZ;

	return 0;
}

/*0x09*/
int32 mLABEL(int32 actorIdx, ActorStruct *actor) {
	actor->labelIdx = *(scriptPtr);
	actor->positionInMoveScript++;
	actor->currentLabelPtr = actor->positionInMoveScript - 2;
	return 0;
}

/*0x0A*/
int32 mGOTO(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript = *((int16 *)scriptPtr);
	return 0;
}

/*0x0B*/
int32 mSTOP(int32 actorIdx, ActorStruct *actor) {
	continueMove = 0;
	actor->positionInMoveScript = -1;
	return 0;
}

/*0x0C*/
int32 mGOTO_SYM_POINT(int32 actorIdx, ActorStruct *actor) {
	int32 newAngle;

	actor->positionInMoveScript++;
	currentScriptValue = *(scriptPtr);

	destX = sceneTracks[currentScriptValue].X;
	destY = sceneTracks[currentScriptValue].Y;
	destZ = sceneTracks[currentScriptValue].Z;

	newAngle = 0x200 + getAngleAndSetTargetActorDistance(actor->X, actor->Z, destX, destZ);

	if (actor->staticFlags.bIsSpriteActor) {
		actor->angle = newAngle;
	} else {
		moveActor(actor->angle, newAngle, actor->speed, &actor->move);
	}

	if (targetActorDistance > 500) {
		continueMove = 0;
		actor->positionInMoveScript -= 2;
	}

	return 0;
}

/*0x0D*/
int32 mWAIT_NUM_ANIM(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript += 2;

	if (actor->dynamicFlags.bAnimEnded) {
		int32 animPos, animRepeats;
		
		animRepeats = *(scriptPtr);
		animPos = *(scriptPtr + 1);

		animPos++;

		if (animPos == animRepeats) {
			animPos = 0;
		} else {
			continueMove = 0;
		}

		*(scriptPtr + 1) = animPos;
	} else {
		continueMove = 0;
	}

	if (continueMove == 0) {
		actor->positionInMoveScript -= 3;
	}

	return 0;
}

/*0x0E*/
int32 mSAMPLE(int32 actorIdx, ActorStruct *actor) {
	int32 sampleIdx = *((int16 *)scriptPtr);
	playSample(sampleIdx, 0x1000, 1, actor->X, actor->Y, actor->Z, actorIdx);
	actor->positionInMoveScript += 2;
	return 0;
}

/*0x0F*/
int32 mGOTO_POINT_3D(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript++;

	if (actor->staticFlags.bIsSpriteActor) {
		currentScriptValue = *(scriptPtr);

		destX = sceneTracks[currentScriptValue].X;
		destY = sceneTracks[currentScriptValue].Y;
		destZ = sceneTracks[currentScriptValue].Z;

		actor->angle = getAngleAndSetTargetActorDistance(actor->X, actor->Z, destX, destZ);
		actor->animType = getAngleAndSetTargetActorDistance(actor->Y, 0, destY, targetActorDistance);

		if (targetActorDistance > 100) {
			continueMove = 0;
			actor->positionInMoveScript -= 2;
		} else {
			actor->X = destX;
			actor->Y = destY;
			actor->Z = destZ;
		}
	}

	return 0;
}

/*0x10*/
int32 mSPEED(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript += 2;
	actor->speed = *((int16 *)scriptPtr);

	if (actor->staticFlags.bIsSpriteActor) {
		setActorAngle(0, actor->speed, 50, move);
	}

	return 0;
}

/*0x11*/
int32 mBACKGROUND(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript++;

	if (*(scriptPtr) != 0) {
		if (!actor->staticFlags.bIsBackgrounded) {
			actor->staticFlags.bIsBackgrounded = 1;
			if (actor->dynamicFlags.bIsVisible) {
				reqBgRedraw = 1;
			}
		}	
	} else {
		if (actor->staticFlags.bIsBackgrounded) {
			actor->staticFlags.bIsBackgrounded = 0;
			if (actor->dynamicFlags.bIsVisible) {
				reqBgRedraw = 1;
			}
		}	
	}

	return 0;
}

/*0x12*/
int32 mWAIT_NUM_SECOND(int32 actorIdx, ActorStruct *actor) {
	int32 numSeconds, currentTime;
	actor->positionInMoveScript += 5;
	
	numSeconds  = *(scriptPtr++);
	currentTime = *((int32 *)scriptPtr);

	if (currentTime == 0) {
		currentTime = lbaTime + numSeconds * 50;
		*((int32 *)scriptPtr) = currentTime;
	}

	if (lbaTime < currentTime) {
		continueMove = 0;
		actor->positionInMoveScript -= 6;
	} else {
		*((int32 *)scriptPtr) = 0;
	}

	return 0;
}

/*0x13*/
int32 mNO_BODY(int32 actorIdx, ActorStruct *actor) {
	initModelActor(-1, actorIdx);
	return 0;
}

/*0x14*/
int32 mBETA(int32 actorIdx, ActorStruct *actor) {
	int16 beta;

	beta = *((int16 *)scriptPtr);
	actor->positionInMoveScript += 2;

	actor->angle = beta;

	if (actor->staticFlags.bIsSpriteActor) {
		clearRealAngle(actor);
	}

	return 0;
}

/*0x15*/
int32 mOPEN_LEFT(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript += 2;
	if (actor->staticFlags.bIsSpriteActor && actor->staticFlags.bUsesClipping) {
		actor->angle = 0x300;
		actor->doorStatus = *((int16 *)scriptPtr);
		actor->dynamicFlags.bIsSpriteMoving = 1;
		actor->speed = 1000;
		setActorAngle(0, 1000, 50, move);
	}
	return 0;
}

/*0x16*/
int32 mOPEN_RIGHT(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript += 2;
	if (actor->staticFlags.bIsSpriteActor && actor->staticFlags.bUsesClipping) {
		actor->angle = 0x100;
		actor->doorStatus = *((int16 *)scriptPtr);
		actor->dynamicFlags.bIsSpriteMoving = 1;
		actor->speed = 1000;
		setActorAngle(0, 1000, 50, move);
	}
	return 0;
}

/*0x17*/
int32 mOPEN_UP(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript += 2;
	if (actor->staticFlags.bIsSpriteActor && actor->staticFlags.bUsesClipping) {
		actor->angle = 0x200;
		actor->doorStatus = *((int16 *)scriptPtr);
		actor->dynamicFlags.bIsSpriteMoving = 1;
		actor->speed = 1000;
		setActorAngle(0, 1000, 50, move);
	}
	return 0;
}

/*0x18*/
int32 mOPEN_DOWN(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript += 2;
	if (actor->staticFlags.bIsSpriteActor && actor->staticFlags.bUsesClipping) {
		actor->angle = 0;
		actor->doorStatus = *((int16 *)scriptPtr);
		actor->dynamicFlags.bIsSpriteMoving = 1;
		actor->speed = 1000;
		setActorAngle(0, 1000, 50, move);
	}
	return 0;
}

/*0x19*/
int32 mCLOSE(int32 actorIdx, ActorStruct *actor) {
	if (actor->staticFlags.bIsSpriteActor && actor->staticFlags.bUsesClipping) {
		actor->doorStatus = 0;
		actor->dynamicFlags.bIsSpriteMoving = 1;
		actor->speed = -1000;
		setActorAngle(0, -1000, 50, move);
	}
	return 0;
}

/*0x1A*/
int32 mWAIT_DOOR(int32 actorIdx, ActorStruct *actor) {
	if (actor->staticFlags.bIsSpriteActor && actor->staticFlags.bUsesClipping) {
		if (actor->speed) {
			continueMove = 0;
			actor->positionInMoveScript--;
		}
	}
	return 0;
}

/*0x1B*/
int32 mSAMPLE_RND(int32 actorIdx, ActorStruct *actor) {
	int32 freq = Rnd(2048) + 2048;
	int32 sampleIdx = *((int16 *)scriptPtr);
	playSample(sampleIdx, freq, 1, actor->X, actor->Y, actor->Z, actorIdx);
	actor->positionInMoveScript += 2;
	return 0;
}

/*0x1C*/
int32 mSAMPLE_ALWAYS(int32 actorIdx, ActorStruct *actor) {
	int32 sampleIdx = *((int16 *)scriptPtr);
	if (getSampleChannel(sampleIdx) == -1) { // if its not playing
		playSample(sampleIdx, 0x1000, -1, actor->X, actor->Y, actor->Z, actorIdx);
	}
	actor->positionInMoveScript += 2;
	return 0;
}

/*0x1D*/
int32 mSAMPLE_STOP(int32 actorIdx, ActorStruct *actor) {
	int32 sampleIdx = *((int16 *)scriptPtr);
	stopSample(sampleIdx);
	actor->positionInMoveScript += 2;
	return 0;
}

/*0x1E*/
int32 mPLAY_FLA(int32 actorIdx, ActorStruct *actor) {
	// TODO
	return -1;
}

/*0x1F*/
int32 mREPEAT_SAMPLE(int32 actorIdx, ActorStruct *actor) {
	numRepeatSample = *((int16 *)scriptPtr);
	actor->positionInMoveScript += 2;
	return 0;
}

/*0x20*/
int32 mSIMPLE_SAMPLE(int32 actorIdx, ActorStruct *actor) {
	int32 sampleIdx = *((int16 *)scriptPtr);
	playSample(sampleIdx, 0x1000, numRepeatSample, actor->X, actor->Y, actor->Z, actorIdx);
	numRepeatSample = 1;
	actor->positionInMoveScript += 2;
	return 0;
}

/*0x21*/
int32 mFACE_HERO(int32 actorIdx, ActorStruct *actor) {
	actor->positionInMoveScript += 2;
	if (!actor->staticFlags.bIsSpriteActor) {
		currentScriptValue = *((int16 *)scriptPtr);
		if (currentScriptValue == -1 && actor->move.numOfStep == 0) {
			currentScriptValue = getAngleAndSetTargetActorDistance(actor->X, actor->Z, sceneHero->X, sceneHero->Z);
			moveActor(actor->angle, currentScriptValue, actor->speed, &actor->move);
			*((int16 *)scriptPtr) = currentScriptValue;
		}

		if (actor->angle != currentScriptValue) {
			continueMove = 0;
			actor->positionInMoveScript -= 3;
		} else {
			clearRealAngle(actor);
			*((int16 *)scriptPtr) = -1;
		}
	}
	return 0;
}

/*0x22*/
int32 mANGLE_RND(int32 actorIdx, ActorStruct *actor) {
	int32 newAngle;

	actor->positionInMoveScript += 4;
	if (!actor->staticFlags.bIsSpriteActor) {
		currentScriptValue = *((int16 *)scriptPtr + 2);

		if (currentScriptValue == -1 && actor->move.numOfStep == 0) {
			if (rand() & 1) {
				currentScriptValue = *((int16 *)scriptPtr);
				newAngle = actor->angle + 0x100 + (Abs(currentScriptValue) >> 1);
				currentScriptValue = (newAngle - Rnd(currentScriptValue)) & 0x3FF;
			} else {
				currentScriptValue = *((int16 *)scriptPtr);
				newAngle = actor->angle - 0x100 + (Abs(currentScriptValue) >> 1);
				currentScriptValue = (newAngle - Rnd(currentScriptValue)) & 0x3FF;
			}

			moveActor(actor->angle, currentScriptValue, actor->speed, &actor->move);
			*((int16 *)scriptPtr + 2) = currentScriptValue;
		}

		if (actor->angle != currentScriptValue) {
			continueMove = 0;
			actor->positionInMoveScript -= 5;
		} else {
			clearRealAngle(actor);
			*((int16 *)scriptPtr + 2) = -1;
		}
	}
	return 0;
}


static const ScriptMoveFunction function_map[] = {
	/*0x00*/ MAPFUNC("END", mEND),
	/*0x01*/ MAPFUNC("NOP", mNOP),
	/*0x02*/ MAPFUNC("BODY", mBODY),
	/*0x03*/ MAPFUNC("ANIM", mANIM),
	/*0x04*/ MAPFUNC("GOTO_POINT", mGOTO_POINT),
	/*0x05*/ MAPFUNC("WAIT_ANIM", mWAIT_ANIM),
	/*0x06*/ MAPFUNC("LOOP", mLOOP),
	/*0x07*/ MAPFUNC("ANGLE", mANGLE),
	/*0x08*/ MAPFUNC("POS_POINT", mPOS_POINT),
	/*0x09*/ MAPFUNC("LABEL", mLABEL),
	/*0x0A*/ MAPFUNC("GOTO", mGOTO),
	/*0x0B*/ MAPFUNC("STOP", mSTOP),
	/*0x0C*/ MAPFUNC("GOTO_SYM_POINT", mGOTO_SYM_POINT),
	/*0x0D*/ MAPFUNC("WAIT_NUM_ANIM", mWAIT_NUM_ANIM),
	/*0x0E*/ MAPFUNC("SAMPLE", mSAMPLE),
	/*0x0F*/ MAPFUNC("GOTO_POINT_3D", mGOTO_POINT_3D),
	/*0x10*/ MAPFUNC("SPEED", mSPEED),
	/*0x11*/ MAPFUNC("BACKGROUND", mBACKGROUND),
	/*0x12*/ MAPFUNC("WAIT_NUM_SECOND", mWAIT_NUM_SECOND),
	/*0x13*/ MAPFUNC("NO_BODY", mNO_BODY),
	/*0x14*/ MAPFUNC("BETA", mBETA),
	/*0x15*/ MAPFUNC("OPEN_LEFT", mOPEN_LEFT),
	/*0x16*/ MAPFUNC("OPEN_RIGHT", mOPEN_RIGHT),
	/*0x17*/ MAPFUNC("OPEN_UP", mOPEN_UP),
	/*0x18*/ MAPFUNC("OPEN_DOWN", mOPEN_DOWN),
	/*0x19*/ MAPFUNC("CLOSE", mCLOSE),
	/*0x1A*/ MAPFUNC("WAIT_DOOR", mWAIT_DOOR),
	/*0x1B*/ MAPFUNC("SAMPLE_RND", mSAMPLE_RND),
	/*0x1C*/ MAPFUNC("SAMPLE_ALWAYS", mSAMPLE_ALWAYS),
	/*0x1D*/ MAPFUNC("SAMPLE_STOP", mSAMPLE_STOP),
	/*0x1E*/ MAPFUNC("PLAY_FLA", mPLAY_FLA),
	/*0x1F*/ MAPFUNC("REPEAT_SAMPLE", mREPEAT_SAMPLE),
	/*0x20*/ MAPFUNC("SIMPLE_SAMPLE", mSIMPLE_SAMPLE),
	/*0x21*/ MAPFUNC("FACE_HERO", mFACE_HERO),
	/*0x22*/ MAPFUNC("ANGLE_RND", mANGLE_RND)
};

/** Process actor move script
	@param actorIdx Current processed actor index */
void processMoveScript(int32 actorIdx) {
	int32 scriptOpcode;
	ActorStruct *actor;

	continueMove = 1;
	actor = &sceneActors[actorIdx];
	move  = &actor->move;

	do {
		scriptPosition = actor->positionInMoveScript;
		scriptPtr      = actor->moveScript + scriptPosition;
		scriptOpcode   = *(scriptPtr++);

		actor->positionInMoveScript++;

		function_map[scriptOpcode].function(actorIdx, actor);
	} while(continueMove);
}
/** @file script.move.h
	@brief
	This file contains movements routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef SCRIPTMOVE_H
#define SCRIPTMOVE_H

#include "sys.h"

/** Process actor move script
	@param actorIdx Current processed actor index */
void processMoveScript(int32 actorIdx);

#endif
BCÀŞ!  ”  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  ì   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØ@€mˆáÿÿÿÿ‚Êaæ¡àAÊaÒaÊ¡ÌÚ!È0‡p`‡y(€p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th€ä¡ÊÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú¡ÜáÜ¡Ø¡ÂÁ ÂŞ¡ÒÁÌaÚÀà¡Ú!è sv˜‡r wx‡6p‡pp‡yhs€‡6h‡p t Ì!ØaÊ æÂaÖ¡àAŞÊaèáä¡Ä¡ÌÁÊAÚ`ÒAÊÀ€¨w˜‡p0‡rhs€‡6h‡p t Ì!ØaÊ êaÊ¡æáÌÚÀØáÂ sv˜‡r 6Ä ˆÁ¢ la ¶¡6ÿÿÿÿ 	 v(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØ` ÿÿÿÿ? @  I  	   ‚`‚ &Ã¢ŒaBpL„	‚@L
Á˜    ‰   ‰   2"È	 d…“#¤„“#ã„¡LŒ„äLÄÃ` !æ *\$M%L>+‘:H3¡¡P($rÀgISD	“¯	“™NE°SD	"
…€´HÁaÒQÂä³0!Â· †ÄN%L(h\&M%L~‡5 ƒß;E”0¡ q4E”0ùó›:H3!¡P8Fš"J˜üùİœä4iŠ(aòµaZ„!¢˜ vŠ(aBÂ p’4E”0ùš09;E”0!;p<    0                                   …„&DI²	YÊ  Ps™4E”0ù¬!Ïd:ñQ0!Nƒ„A&G4´Iä€u9 @Ÿ$(PèiŠ(aòÆiQ(
§Pâ4>Ğ8
FISD	“?;ÁN%L¨8
¤B’•È”PB%6Á€T‰M  28 @¯œP,ç 4K Õ“¦ˆ&­ˆh°‘&vŠ(aBG¡P(
…T¸.¡ ¤Kñ²@@¾\0$LóA@Æt2¤L1A@Îd4$(P j) €‚ @×R    €²¥  €m‹@¥P· T      ô-µP(,(\ ‹  P¹T æ‚) :ƒ¤¡ °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:äH #DD ¤Ì ôÀIğ"8Ğ§Áz Lˆ”è3 =p Î ôÀÉ0#8Öe zà¬ œ5‚“3Ofzè	N=Á€8Ğg zàPŒëÒ`=P¬Jƒõ@i°(	^'Á‹à$xœ/‚“àEp¬Jƒõ@i°(Ö¥Áz á”èÓ`=P¬Jƒõ@i°(Ö¥Áz @œè3 =p¼N‚Á€8Ğg zà@œ"|‚R„OPŠğ	Jƒõ@i°(Ö¥Áz 4X”ëÒ`=P¬Jƒõ@i°(Ö¥Áz 4X”ëÒ`=P Nƒõ@i°(Ö¥Áz @œ'}‚2 =p¬Jƒõ@™â'Ö¥Áz 4X”ëÒ`=PVĞNƒõ@i°(ÖåÊŸàlœëÒ`=P¬Jƒõ@i°(Ö%Á‹à$xœ/‚“àEp¼Î ôÀi°(Ö¥Áz 4X”ëÒ`=P Î ôÀ€8]`§Áz @œ0¡‚ÒFpÊˆ
NšQÁiC*8mHg zà@œè3 =p¬Ê ôÀ€8Ğg zàÌ)”èÓ`=P¬J‚ÁIğ"8	^ç©à\œè3 =p Î ôÀ€8Öe zà;”>N%	  €J¨’  Àå‚TI  `‡òª$  °C	…àU’  € Ø¡ŒB0+I  @ ìPş X•$    v(¥èJ   ;”Qh%	  €J)»’  ÀåVI  `‡òA«$  °C9…ÀW’  € Ø¡¤Bğ+I  @ ìPV! —$    v(©€K   ;”Rx%	  €J(°’  À¥‚rI  `‡ò
¹$  °CùƒÀU’  € Ø¡ŒBP+I  @ ìPB!ˆ•$    v(¯œK   ;”Ql%	  €J)½’  Àe‚[I  `‡
¬$  °CI… \’  € Ø¡ÄB€.I  @ ìPf!H—$    v(©ˆK   ;”TÆ%	  €Ê(¸’  Àe‚\I  `È’     À%      €!K @     C[ @    €!K @     C\ `    €!K @     C] €    €!/ @    À%      €!‹/ @    À%      €!K @     C– €     †,      Y2      ²d      0dÉ      `È’     À%      €!8 @    À%      €!K @     Cq      €!K @     C– €     †,      Y2      ²d      0dÉ      `È’     À%      €!K @     C– €     †,      YÈ     †,      YÌ     †,      YĞ     †,      Y2      ²d      0dÉ      `È’     ÀÅ€ 0    `È‚       Ú   2˜$LŒ	&GÆCŒ ” 	F ¨0@ƒ¡Œ>¨	à<€óÊè› Î8¡Œ?¸	à<€óÊøœ Î8¡ŒPÈ	à<€óÊ Î8¡Œ?Ø	à<€óÊ( Î8¡ŒQè	à<€óÊ(Ÿ Î8¡Œ?ø	à<€óÊø° Î8¡ŒSà<€óÊH± Î8¡ŒUà<€óÊH² Î8¡ŒR(à<€óÊ³ Î8¡ŒV8à<€óÊx´ Î8¡Œ?Hà<€óÊµ Î8¡ŒPXà<€óÊx¶ Î8¡ŒQhà<€óÊ(· Î8¡ŒQxà<€óÊ¸ Î8¡ŒTˆà<€óÊˆ¹ Î8¡ŒY˜à<€óÊHº Î8¡ŒT¨à<€óÊ» Î8¡ŒQ¸à<€ó Ã !F H1@‹ ¢Œ e€4(¬Ã…»\(´Ó…‚;^(¼ó…¼`(Ä†‚<b(Ì+†=c(Ô;†‚=d(ÜK†>e(ä[†‚¾f(ìs†?h(ô‹†‚?i(ü›†@j(¬†‚@k(¼†Al(Ì†‚Am(ä†Bo($‡‚Âp(,‡Ãq(4$GƒŠ/bÌ¨q#Ç?‚)r$É’&O¢L©r%Ë–._ÂŒ)s&Íš6oRg€>#  Ó ¡F H5@¬ z Pl€f# T Ü éF ˆ·ƒwv;œhJ¾%6´“—ĞNÑ\¢DÑt	mÑ%ØM—Ø¼V#à* Ú¢ŠŠg»Ê¦q$¸¢îÙ­‚¦Şù¯"¶«°š™–Ş¿	75±ıµS47IQöOQñl7ASïüKïk7ASïü;>75±ı;]7ù4ÎûCoE7ÑN°ôşõìˆ¸…v‚¥·E©m^¹›z^·W¢¬GÆu@´EV6ÿÏ–ÛÀšØş§kşÚ)šÛ€h‹ş)*íwÛ°š™–Ş¯•°&³Û¬^êiíÏjfZzÛ°¢™–ŞÏjfZz¤\ƒÕÌ´ôˆ¹¬‰íºæÏzzväÜãDÿíä=ĞÔ;7%è.¬f¦¥÷³-š’t‘´Ôäÿ+5    y     C„tHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   ’  V@øÒ	u‘£5#Wº¢-šji\	Ğ Laä
£`éıëÙÙbÀTDN3½È@8UD ’,NED€•ˆ4v€Áp%Êz¶æ<‘“¤$³BD‰T9Zƒ0âpi ¸z,+¾á,À<±:T3r@Á°-šZbÀc9‘ò"álTQ‘HED3±B„<Ó,a90ÏB˜HÓ€Yo ‚4È¤5c‹$¡	“Iæà,ó¤!IÄ@˜}L9^3!–®h‹¦GZßÍ@D+b“İ0À<±L6P0%Š¦V 0)Êş)*­}¾4E5mÉ¢-ú³²ù§¨x¶f=‘#’d:Á
òL`øÒÕµ…¾4Eµm¢†/MQ}Ûh€áKSTãF`øÒÕ¹•¾4EµnÂ°@´À¢5ÆBØi€áKSTó†`øÒÕ½™¾4EõnKD@›±CX&€0'úoh'[Z…H®„4N9	!LˆÓ˜Ñs‘#oDáDÄ,‹u@1± ó,w MC,¶ÃH ó,Dº 1Øv Í`tÎã,ØJ4µØCX$Ì³ D#-Â–`øÒÙ´©¾4Evm«†/M‘mk€áKSdßÖ`øÒÙ¸¹¾4Evn¾¢-ú§¨x¶&Ğ,óhÂäDìD<`øÒÙ»½¾4E¶n²†/M‘İ[l€áKSdóÆ <€± ó,„)YED3-Øç,‹cƒ&LNdÓ³y­f$DÈ3¥„LˆÓ˜@"	òLé™#Ì³Rº Òf²	TÍ”:2!N#6›3`éµ@`YÎâP’&LN›–óDD…8”¤	“Éö=Q!%±ÑâpÙ–óDD…8”¤	“Í 	Tƒ+1D€µ9—Ù¾4E÷m=Š$‘x@Â¤¥&ÿ_©YÁ"	DC´ (’ı(’@4DHDÎl'KàL“Ã”D1Å†²Î49LI“l)KàL“Ã”D1Íæ£HÑ!9²Í9Ò„ÖÑÁm`š@EÑL–F@H1hÂäDâpÄ"=2-,„Ñ¾4Ewmµ†/MÑmÛP’9‘Q’9‘#[Q’9‘3Ûl€áKStÓv`øÒİ¸=41iÂäDZc,„MT"ÁB°BDÍJD3‘-«™ié"	DC˜”„¶$	TÍ¤	“‰Íì4„yUOä„$­ÎLˆÓl˜Ö Œı1ÑD´9Óä0v—<+ÑDôÖV²DähÂˆÃeÔAD×LÈ„i ¸z,+¾5$’@4DHDIÒÛÄ!ÀàX²QÒ5’#	DCœ£	“IF¥DähÂ„8<Å¬ÄC 0ÏBXÅ$ÀàXœ³,ˆ„8M‹=„)8¬‰íºæ¯¢i.@EÑL¬@4„8\v,D1™%-óˆME4“aâD0Æp,Ğ"a ÑADÖ Œ8\'ºšZiuKC1hñÑD\6°T,„&LNdlÎ9IêH3+DÑ˜$DÎ³9Óä0¬DcgĞ ÌFÕ†¶ ÂlTQ‘m60ÏBhL€ @q€Áh'Xzv 0hê‡Â§åAÀ<!±HF´@°&à0¬h¦¥÷³š™–‘aED3iÂäDZƒ0Ş5E@:EFT,ûDÈDˆÍ@\ÀN3!E˜NE˜”"	DC|`Hæ!DäxÍ„LX'²Üêµ]4 59š’„T„58ˆ¶èŸ¢âÙşwgÇ¢-jÎâ8GEÑL$YÙ¢Ø‘N‘%LÄ¤	“uˆ4@ÖóD@H’&LN”N‘ñŒvŠ¦)ŒSfPøÒÕvPøÒÙ†PøÒİ¦P0ÚÉ–PøÒá¦PøÒå¶PøÒéÆPøÒíÖPøÒñæPøÒõ†@0ŞÙÙ“#	DCœÓF€ HfP„4ÅvP„4É†P„4Í62DähÂˆÃÕ‰,·z­g1”ôDÈDlÕHclÎ•N‘ñ)ÑDTÅdSÉADéTÄ`ÕâPRHDÎF@…8TdÑâPRHDÖa~ID4µÎcŞÃjfZz?Û¢©…1ED3±ñÄ&ÆTÍÄNÄ#Û#PQD4;ÏlôDÈD°HF´@°æ¤HÑ³Ó’™= M$}ÀéYòDN’:RlnÈ9IêH²½!Oä$©#ÍF dÃ°BDQ(šzç_z_kÚÃjfZzÿzvfÑDälÄTˆCEóHO„L{ ƒc¥Sd{”0ÏBHé`HchÂäD’	8Å ÅJ`mÎexŒ0ÏBH-,„9›z^gÖƒ¦Şù»©11°(HchÂäD¦æ<‘“¤³BD(¬‰í¯¢ißŠ490ÏBØöD@HR	HÓêLÀ„8ÖaÑkbûŸ®ù³‡L©m^iPp A¬Ã¼@TÓõĞÄê8ÌDum-OCw A°Ñà0«—zZû³š™–éDÀ<a"MG, ¶6ƒ)@Eä4Ó‹„³QEAD¶à 2™Î@,š09‘1D’DS:B=-,„e(¬‰íß¡èj¹s¢©Á)N4N9IlqŠM‡“FN"›œâDÓá¤‘“ÌvDä¤„LˆÓ´ØC˜%PQD40Z+a]Ğ ‹dDa*Éä<+bSl+Éä<+b“l,Éä<+bÓlĞ³i	®¨{vVÕ<‘#’¤	“Åö1i±Z3°ÄÔ‘ALš09Q‡HĞ„Y5Oä„$iÂäD²]5Oä„$iÂäD³Ñ$1%b“%9! )ÒÒˆÃeåHö`=Q!%•ó¤!IÄ@˜qH9^3!¦µaéµ"gˆJ„Çd:”DXS#	DCœ3;!ÒVHDNlAHCX!9²	!a…DäÌ6£ Ës %b“q8«™iéıZ	k2kLA5Â„8ÍÏ …L9Zƒ0âpimXz­ÈYcÀ²8Îc:‘N‘(Ì§qŞz+jÀ	ãT„&LNd€Ò–Ø€ C´ĞH›sÙt‘ã52a'ºšZivQEDqqHL„dÕƒ¦Şù¯"¶f€@2 C    a      A,      (Ÿ    3€ÃLD Ç0!00á.(1 Œñ† %ŠÁˆ €T‰p    ¦.P ÂäD–.€ ÂäDâp       a      ÁLD  Ç0Qè1FÄ FÃ ¤I„      ¦.P ÂäD–.€ ÂäDâp       a       A,      ( 3€ÃLD Ç0 è1FÆ FÅ P»
Â€Œ ‚ bĞ1.(ÀˆAq z1„Œñ†à%
†0‚Áˆ!€”‰p     æ.pÎ€‰Ãeê LNdé LN$       a   ,   D,      ( 3€ÃLD Ç0 è1FÆ FÅ P»Œñ„ %#Ş% Â€Œ(‚ b2FÀa%X"n^"f! eŒ71ÑP0,	FÁ Ì„/ƒ1ŞØ„40Ñ/71 ³CŞD8     ¦.P ÂäDæ.p ÂˆÃeé LN$       a   `   F,      (Ÿ"(¢(Œ)´B? BQ”  3€ÃLD Ç0 è1FÏ FÎ 0Æ™p(Ì#†` H_á‚BFìK  ´/â€Œ7ğ‹NãÁNìâ€FüK0 2â€Œ7ˆXãAX€â€FL0 t2â€Œ7 ŒYãÁYˆâ€F¤L0 ´ñ†`-È€‚AŞoÜÂ(3ƒ`fŒ  Æ ƒc ‘Áoè‚..0,¢‚5À
Ö@‡»ƒY†@H±ÁoøÂ#‚a f	rƒ1ŞøP0ÉÁoD#(Tc¼!(=18  =cf	"›1ÜğÌ2E0á6¨1 ”c¼!HR `X`
!Œ‚˜%(’5Â     v/€4„¥5ÆB˜º@“Yº “‰Ã      a   &   D,      (Ÿ B”    3€ÃLD Ç0! 0@ÁoVB%.0,¢+@t¸!h‰0˜e‚`0â^bb ãL8FÁ ÌƒûR@Ì1  `/‚Y‚!m"      ¦.P ÂäD–.€ ÂäDâp       a      A,      ¨ 3€ÃLD Ç0!0C8      ¦.P ÂäD–.€ ÂäDâp       a   I   H,      (Ÿ"(B+‘2 BQ”  3€ÃLD  Ç0Qè1FÍ FÌ P0Æ˜`(4 Œ‚ bŒ74A–QAƒ4:ÜØDÌ2A@ÿ2.0,b0d gŒ7>q7?¡Q . ÈpC `0Ë Uc¼! ‚A)#. ic¼!H‹0 `ÊŒƒ fã(„`–` oŒ7mq’q@†† fˆ" 2# àF0qs ³Ç`DÎÌÅ PŒñ†€.à€‚aA„`0b`–ÀŒXƒ» €Y‚ƒÖ d    ¦.P ÂäD–.€ ÂäDâp       a   H   C,      (Ÿ"(‘¢(‹Â BQ”  3€ÃLD Ç0!00,@Áo^b¡`X  Œ‚ {„
1/ ¾ˆ 2Ş/7Œ78ˆ 2Á/Á ¿ˆ 2Şğ/=Œ7>Ñˆ 22Á Éˆ 2ŞP2cŒ7dñQ . È`„É@ÚoĞ-.0,¢‚0À
Â@‡µƒY†@(ÆxCği0ÀÅ Ì3ƒÈ`Œ7r±ƒÁ0 43ƒÎ`Œ7uÑƒÁ0 T3ƒÔ`Œ7xñƒÁ0 ™á@     ¦.P ÂäD–.€ ÂäDâp       a   "   A,      (Ÿ2*‚B3€ÃLD Ç0! 0@ï2( ‚ˆ1Ş¸D2@Æo`‚¡`X Œ‚ eŒ74Q0,€B@Îop"Œ†Èœ    ¦.P ÂäD–.€ ÂäDâp       a      A,      ( 3€ÃLD Ç0!0@ì2.0,â€P1Æ–@#‚a ²%Â    ¦.P ÂäD–.€ ÂäDâp       a      A,      (Ÿ    3€ÃLD Ç0!00á.(1 Œñ† %ŠÁˆ €T‰p    ¦.P ÂäD–.€ ÂäDâp       a   b   F,      (Ÿ"(¢(ŒD(‘B+ô*E	   3€ÃLD Ç0 è1FĞ FÏ 0Æ‚™x(Ğ#†` h_á‚BFğK  Ä/â€Œ7ôËNãOğâ€F€L0 $2â€Œ7ŒLXãX„â€F”L0 „2â€Œ7¤ÌYãZŒâ€F¨L0 ´ñ†€-Ê€‚AŞoŞâ($3ƒbfŒ °Æ ¶#È  *ƒ1ŞØ…]\`X
Dl€°7x³Ğjƒ1ŞøFÃ Ìôc¼! = `Pšƒ1Ş†P0ÈÆxCp|0bp À{ÆÌd6c¸!è3˜e Š`0nTc HÆxC°§@Á° B010KP¤k„    †/€4„¥5ÆB˜º@“Yº “‰Ã      a   H   I,      (Ÿ"(*A	  3€ÃLD Ç0 è1ÌD zƒÄ2 ƒƒ2 4Œñ†À%
†#†` èãLÄÄ†¥@Tà`74³AP¿
Â€Œx‚ ã	ÁNP. Ä` QÃ‚Ÿ Á`„ Yƒ¬1Ü `0Ë Á`DF0K@F¨YÀ,AÙ¸@ ´2c<!0‹Áˆ`€Yc0ÂeĞb f	r™1Ü¤Ì2H@`0Æ‚µ8
†g‚Áˆ!€Y$İ" 
   &/p Â¤dê LNdóĞ ÌJ<0I–.€ ÂäDâp       a   *   A,      (Š²(Œ*Ÿ" 3€ÃLD Ç0 è1FË FÊ ¼ŒK¸  ƒE0 T:ÆxC0ƒ”1ŞØDDÁ fŒ791Q0(#
 ÜÅRíREc¼!è‰Š‚a‚Áˆ!€‹p       6/H ó,„8\¦.P ÂäD–.€ ÂäDâp     a   f   F,      (Ÿ"(ŠÂ(‹)±B BQ”  3€ÃLD Ç0!804@Áob¢¡`X  Œ‚ bŒ75Q–Qƒ0:ÜÜDÌ2E@ 3(b0"d  d¼AdÀ"oÂ",( d0¢d‚ “ d¼eÌ"oÎÂ,( d0Be‚ – d¼ÁeØ"oÚ( d0âe‚ 0ãA\¬ƒÈ`Œ7tÑº™A63F  cRƒ1ŞèEFÃ Œñ†€/è€‚A>3¨gÆˆÁ è1€†Œñ†@4ğ`0"€Âf7y`³ÂF¬Mi ÙÁoLC(ŒB#†` f	R›A{0Æ‚Õ(…Áˆ` b›A~0Æ×0…Áˆ` r›A¡0Æ‚ØP…Áˆ`€Yb– HÙ     ¦.P ÂäD–.€ ÂäDâp       a   ,   C,      (‘ò)*E	    3€ÃLD Ç0!(0$@ÁoZ¡`X€`0b€êe\`X
Ä ¡dŒ75FÃ Ğ2Æ‚›¸‰K¨`Â
&nr"f! iŒ7>¡Q0.( ùË18@/~BÈ‚Y!Å"     ¦.P ÂäD–.€ ÂäDâp       a   M   L,      (*”@iÔ `@! `     3€ÃLD Ç0!(0$@ÁoZ"¡`Xà Œ‚ z„ 1ÜÌDÌ2F@Éoj¢&.0,¢	+ t¸!¸‰0˜e(„€ 1ŞğO\`X
D˜Vpí` Yc¼!‹°¸À°ˆ
:¬ t¸! ‹0˜eˆ`0‚dÆ@ f	ˆY‚b–`¡nŒ7i‘–Q`h ÃÁZ„Á,Ã¡Dc¼!€¸¸À°ˆ
Ø@#†@ (ÆxCPtqa)ÀV@:ÜÜEÌ2 I0q3v  ³É,2K°ä^„    ¦.P ÂäD–.€ ÂäDâp       a   @   F,      (ŸR(²b 3€ÃLD Ç0 è1ÌD zƒ„2 ƒC2 4Œñ† %
†
#†` ¨^ÆxB ƒ÷ 	á@F(Á P¾ŒKÁŒ`‚ f78³½L‚†•l@0!@Ò ‘v0"`–@ }™dá!@ƒY†#Rf,€´1ŞP0,øB010KPËŒ;¤Å Ì™á@  
   &/°TÍÔ"aê LNdé LN$—Å(Å°„à4ƒ     a      A,      ¨ 3€ÃLD Ç0!0@Â¸  #ÅÔEdJ„     ¦.P ÂäD–.€ ÂäDâp       a   +   C,      (Ÿ"(*E	  3€ÃLD Ç0a è!FÊ FÉ P¼ŒKŒ  bŒ70ÁP0,h@01@ˆ¸  ´Œñ†À& Áˆ` jÆxC€8qa)PX¥ÃN„Á,C D H#˜%ò'Â    ¦.P ÂäD&/@ÄXº “‰Ã     a   B   D,      (Ÿ"(d(¯)è*”@Q”A`@A?   3€ÃLD Ç0!H0D@Áoj"¢`X `0b€Š1ŞäDN\`X
DV é€n~"f‚! fŒ7a–QÁ…hz †‚³ƒYa¨ãAZŒÁ`D0@/3.0,â€Ğ6Æ‚·8ƒÁˆ` êÆxCpqa)˜V`;A@c0Æ‚»pƒÁˆÀ€jfŒ	v‘hÌ™á@   ¦.P ÂäD–.€ ÂäDâp       a   B   D,      (Ÿ"($(¯)è*”@Q”A`@A?   3€ÃLD Ç0!H0D@Áoj"¢`X `0b€Š1ŞäDN\`X
DV é€n~"f‚! fŒ7a–QÁ…hz †‚³ƒYa¨ãAZŒÁ`D0@/3.0,â€Ğ6Æ‚·8ƒÁˆ` êÆxCpqa)˜V`;A@c0Æ‚»pƒÁˆÀ€jfŒ	v‘hÌ™á@   ¦.P ÂäD–.€ ÂäDâp       a   B   D,      (Ÿ"(D(¯)è*”@Q”A`@A?   3€ÃLD Ç0!H0D@Áoj"¢`X `0b€Š1ŞäDN\`X
DV é€n~"f‚! fŒ7a–QÁ…hz †‚³ƒYa¨ãAZŒÁ`D0@/3.0,â€Ğ6Æ‚·8ƒÁˆ` êÆxCpqa)˜V`;A@c0Æ‚»pƒÁˆÀ€jfŒ	v‘hÌ™á@   ¦.P ÂäD–.€ ÂäDâp       a   A   D,      (Ÿ"(ò*‘‚~ B	EÔ`@ôC‘ 3€ÃLD Ç0!D0@@Áoh¢`X`0b€Š1ŞàN\`X
DV é€n|"f‚! fŒ7`–QÁ…hz †³ƒYa¨ãZˆÁ`D@.3.0,â€Ğ6Æ·8ƒÁˆ` êÆxC oqa)˜V`;A@c0Æ»pƒÁˆÀ€hfŒ	 u‘hÌ‰á@   ¦.P ÂäD–.€ ÂäDâp       a   5   D,      (¯©è*”@Q”A`@E?  3€ÃLD Ç0!804@Áob"&.0,¢+pô@77³ÁP2Æ‚œÈ‰K¨`Â
,½ ÃÁO„Á,ƒ0ñ† ,ºÁˆ@,€¦1ŞŒ…X\`X
DœVÀí` ec¼!H2ŒÈ` èdÆˆÁ‘ £ŸÌ¹á@   ¦.P ÂäD–.€ ÂäDâp       a   0   F,      (‘ò©*”@Q”    3€ÃLD Ç0!(0$@ÁoZ¢%.0,¢+Pô@73³AP2Æ‚š¨‰K¨àÁ
$½ ÃÁN„Á,ƒPñ† '2
ÆpCğa0Ë0Á`„É€Å P5Æ‚°à(t Œ‚˜% f	Š$‹p       ¦.P ÂäD–.€ ÂäDâp       a   2   A,      (@¢(‹Â(Ÿ" 3€ÃLD Ç0 è1ÌD zƒ3 ƒÃ2 # èD‹YÀ€`0¢€ìe\`X
Ä Œ@‚ d2ˆãNLzÆxC°ƒ¤1ŞøÄEÁ kŒ( ÀÌH!dñ†@,4
†#†` ²,Â   	   F/H ó,„8\¦.P ÂäD–.€ ÂäDâpÙ¼ QD       a   0   C,      ¨¢(‹Â(@ ò)   3€ÃLD Ç0 è1FÌ FË Ğ¼ŒK¸  ƒE0 TŒ z"n 0˜e„€AÊonB¢`P3Æ (ñ† ',
QcÄ@€½X0)„`–@ jŒ7aQ0,È@01d      F/H ó,„8\¦.P ÂäD–.€ ÂäDâp     a       A,      (Ÿ"    3€ÃLD Ç0 è1FÇ FÆ »ŒK¸  ƒE0 TŒ l" cŒ7/±P0,`@012   ö.H ó,„8\¦.P ÂäD–.€ ÂäDâp     a      A,      ¨ 3€ÃLD Ç0!0C8      ¦.P ÂäD–.€ ÂäDâp       a      A,      (Ÿ"    3€ÃLD Ç0!0@í2.0,â€FÌK0 TŒñ† %
†
#†` &Â     ¦.P ÂäD–.€ ÂäDâp       a   ,   A,      (Š²(Œ*Ÿ" 3€ÃLD Ç0 è1FË FÊ ¼ŒK¸  ƒE0 TÊ—AÈoh¢`Ğ2Æ‚›(äŒñ†@'(
IcÄ@ ¼`¬)„`0‚dxb HãOX.FÁ dX„     6/H ó,„8\¦.P ÂäD–.€ ÂäDâp     a   `   I,      (Ÿ"(´¢(Œ©)*E	Ô    3€ÃLD Ç0!@0<@Áofâ¡`X `0b€Š1ŞÜÄM\`X
DVĞèpCa0Ë€‰Ì¸À°ˆÁˆ‘	€FF\ á† ƒYHãYxãAY€â€7h³6Æµ
mc¼!h‹2 `PÊŒñ† .Ò€‚A,3Æ‚¹X
ÆˆÁ ½¡DpA#t& 2ƒ1ŞàÅP0¨gÄ ¡5ãA_ÈƒÜ`Œ7 ¡#  b‘ ³v0"`–€ 9ãAiğƒÔF\ á†!ƒY†Â#àF5€ò`Œ7«q
B!ƒC0 ³õÁ1  €>¢›qa#Q€Y‚c– ÉØ    ¦.P ÂäD–.€ ÂäDâp       a   ‰   L,      (‚)ŸB+@‚ò(„(‘R BQ”@    3€ÃLD Ç0 è1FÒ FÑ 0Æ‚šx(4 Œ‚ cŒ79‘–Qƒ8:ÜìDÌ2,A@$3.0ìxBĞQ #L& 2q@†f„# jŒ7gãZâ€7k³ÃŒ €°…7n³DÍŒKŒ¨™@ ÆxC0n@Á° @@9#. Èˆ¡ zT€iE ‚Á4€Ğ`Œ €6â€Ô˜A*À½  ƒfÀ,Ah3.0,b0"m :ãÁiˆÃ‚Pµ¸  #„¸FPk¤#ø  âƒ1b0  oİˆ RC`V!¨€ô‚FèM  ³•Âopc(Ô7â€*Œñ† 7b‚A­0ÆğÈ…ƒ P1†€HGĞéŒ;€Ã`D@À,ÁA³0Æó
­¸  ÃC³HFÄÎz åÂoØÃ(„C#†` f	ê…1b@ @T;ãÃ'î0Œƒ Ì(³KÎG8     ¦/€4„¥5ÆB˜º@“Yº “‰Ã      a   ;   D,      (ŸB+   3€ÃLD  Ç0Qè1FÇ F¼J c¼a\T"Œ‚ aŒ7,F¨K0 ³c¼!p‰…‚1A/Á 2Æ‚˜`(t/c<A#ô% Ò—1ÔÄ`¿@B¸ ƒR0 ñ†@'.
†;‚Áˆ! ²Æxƒ½øD0Şü„OP0h¤ƒ !˜%HeÆpCPa0Ë†   ö.P ÂäD–.€ ÂäDâp™» #	òLè#8           /** @file sdlengine.c
	@brief
	This file contains SDL engine routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <SDL/SDL.h>
#include <SDL/SDL_thread.h>
#ifndef MACOSX
#include <SDL/SDL_mixer.h>
#else
#include <SDL_mixer/SDL_mixer.h>
#endif

#ifdef GAMEMOD
#ifndef MACOSX
#include <SDL/SDL_ttf.h>
#else
#include <SDL_ttf/SDL_ttf.h>
#endif

#endif

#include "sdlengine.h"
#include "main.h"
#include "screens.h"
#include "music.h"
#include "lbaengine.h"
#include "debug.h"
#include "keyboard.h"
#include "redraw.h"

/** SDL exit callback */
//static void atexit_callback(void);

/** Original audio frequency */
#define ORIGINAL_GAME_FREQUENCY		11025
/** High quality audio frequency */
#define HIGH_QUALITY_FREQUENCY		44100

/** Main SDL screen surface buffer */
SDL_Surface *screen = NULL;
/** Auxiliar SDL screen surface buffer */
SDL_Surface *screenBuffer = NULL;
/** SDL screen color */
SDL_Color screenColors[256];
/** Auxiliar surface table  */
SDL_Surface *surfaceTable[16];

#ifdef GAMEMOD
TTF_Font *font;
#endif

#ifdef EMSCRIPTEN
#define SDL_GetKeyState SDL_GetKeyboardState
#endif

/** SDL exit callback */
//static void atexit_callback(void) {
//	sdlClose();
//}

void sdlClose() {
	stopTrackMusic();
	stopMidiMusic();
	Mix_CloseAudio();
#ifdef GAMEMOD
	TTF_Quit();
#endif
	SDL_Quit();
	exit(0);
}


/** SDL initializer
	@return SDL init state */
int sdlInitialize() {
	uint8 *keyboard;
	int32 size;
	int32 i;
	int32 freq;
	//SDL_Surface* icon;

	Uint32 rmask, gmask, bmask;
//	Uint32 amask;

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
	rmask = 0xff000000;
	gmask = 0x00ff0000;
	bmask = 0x0000ff00;
#else
	rmask = 0x000000ff;
	gmask = 0x0000ff00;
	bmask = 0x00ff0000;
#endif

	printf("Initialising SDL device. Please wait...\n");

	if (SDL_Init(SDL_INIT_EVERYTHING) < 0) {
		fprintf(stderr, "Couldn't initialize SDL: %s\n", SDL_GetError());
		exit(1);
	}
	
#ifdef GAMEMOD
	if (TTF_Init() < 0) {
		fprintf(stderr, "Couldn't initialize TTF: %s\n", SDL_GetError());
		exit(1);
	}

	font = TTF_OpenFont("FreeMono.ttf", 12);

	if (font == NULL) {
		fprintf(stderr, "Couldn't load %d pt font from %s: %s\n", 12, "FreeMono.ttf", SDL_GetError());
		exit(2);
	}

	TTF_SetFontStyle(font, 0);
#endif


	/*icon = SDL_LoadBMP("icon.bmp");
	SDL_WM_SetIcon(icon, NULL);*/

#ifndef EMSCRIPTEN
	if (cfgfile.Debug) {
		SDL_version compile_version;
		const SDL_version *link_version;
		SDL_VERSION(&compile_version);
		printf("Compiled with SDL version: %d.%d.%d\n", compile_version.major, compile_version.minor, compile_version.patch);
		link_version = SDL_Linked_Version();
		printf("Running with SDL version: %d.%d.%d\n\n", link_version->major, link_version->minor, link_version->patch);
	}
#endif

	printf("Initialising Sound device. Please wait...\n\n");

	// Verify if we want to use high quality sounds
	if (cfgfile.Sound > 1)
		freq = HIGH_QUALITY_FREQUENCY;
	else
		freq = ORIGINAL_GAME_FREQUENCY;

	if (Mix_OpenAudio(freq, AUDIO_S16, 2, 256) < 0) {
		printf("Mix_OpenAudio: %s\n", Mix_GetError());
		exit(1);
	}

	Mix_AllocateChannels(32);

	SDL_WM_SetCaption("Little Big Adventure: TwinEngine", "twin-e");
	SDL_PumpEvents();

	keyboard = SDL_GetKeyState(&size);

	keyboard[SDLK_RETURN] = 0;

	screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, 32, SDL_SWSURFACE);

	if (screen == NULL) {
		fprintf(stderr, "Couldn't set 640x480x8 video mode: %s\n\n", SDL_GetError());
		exit(1);
	}

	for (i = 0; i < 16; i++) {
		surfaceTable[i] = SDL_CreateRGBSurface(SDL_SWSURFACE, SCREEN_WIDTH, SCREEN_HEIGHT, 32, rmask, gmask, bmask, 0);
	}

	atexit(SDL_Quit);

	return 0;
}

/** Frames per second sdl delay
	@param fps frames per second */
void fpsCycles(int32 fps) {
	SDL_Delay(1000 / (fps));
}

/** Deplay certain seconds till proceed
	@param time time in seconds to delay */
void sdldelay(uint32 time) {
	SDL_Delay(time);
}

/** Deplay certain seconds till proceed - Can skip delay
	@param time time in seconds to delay */
void delaySkip(uint32 time) {
	uint32 startTicks = SDL_GetTicks();
	uint32 stopTicks = 0;
	skipIntro = 0;
	do {
		readKeys();
		if (skipIntro == 1)
			break;
		stopTicks = SDL_GetTicks() - startTicks;
		SDL_Delay(1);
		//lbaTime++;
	} while (stopTicks <= time);
}

/** Set a new palette in the SDL screen buffer
	@param palette palette to set */
void setPalette(uint8 * palette) {
	SDL_Color *screenColorsTemp = (SDL_Color *) palette;

	SDL_SetColors(screenBuffer, screenColorsTemp, 0, 256);
	SDL_BlitSurface(screenBuffer, NULL, screen, NULL);
	SDL_UpdateRect(screen, 0, 0, 0, 0);
}

/** Fade screen from black to white */
void fadeBlackToWhite() {
	int32 i;

	SDL_Color colorPtr[256];

	SDL_UpdateRect(screen, 0, 0, 0, 0);

	for (i = 0; i < 256; i += 3) {
		memset(colorPtr, i, 1024);
		SDL_SetPalette(screen, SDL_PHYSPAL, colorPtr, 0, 256);
	}
}

/** Blit surface in the screen */
void flip() {
	SDL_BlitSurface(screenBuffer, NULL, screen, NULL);
	SDL_UpdateRect(screen, 0, 0, 0, 0);
}

/** Blit surface in the screen in a determinate area
	@param left left position to start copy
	@param top top position to start copy
	@param right right position to start copy
	@param bottom bottom position to start copy */
void copyBlockPhys(int32 left, int32 top, int32 right, int32 bottom) {
	SDL_Rect rectangle;

	rectangle.x = left;
	rectangle.y = top;
	rectangle.w = right - left + 1 ;
	rectangle.h = bottom - top + 1 ;

	SDL_BlitSurface(screenBuffer, &rectangle, screen, &rectangle);
	SDL_UpdateRect(screen, left, top, right - left + 1, bottom - top + 1);
}

/** Create SDL screen surface
	@param buffer screen buffer to blit surface
	@param width screen width size
	@param height screen height size */
void initScreenBuffer(uint8 *buffer, int32 width, int32 height) {
	screenBuffer = SDL_CreateRGBSurfaceFrom(buffer, width, height, 8, SCREEN_WIDTH, 0, 0, 0, 0);
}

/** Cross fade feature
	@param buffer screen buffer
	@param palette new palette to cross fade */
void crossFade(uint8 *buffer, uint8 *palette) {
	int32 i;
	SDL_Surface *backupSurface;
	SDL_Surface *newSurface;
	SDL_Surface *tempSurface;
	Uint32 rmask, gmask, bmask;
//	Uint32 amask;

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
	rmask = 0xff000000;
	gmask = 0x00ff0000;
	bmask = 0x0000ff00;
#else
	rmask = 0x000000ff;
	gmask = 0x0000ff00;
	bmask = 0x00ff0000;
#endif

	backupSurface = SDL_CreateRGBSurface(SDL_SWSURFACE, SCREEN_WIDTH, SCREEN_HEIGHT, 32, rmask, gmask, bmask, 0);
	newSurface = SDL_CreateRGBSurface(SDL_SWSURFACE | SDL_SRCALPHA, SCREEN_WIDTH, SCREEN_HEIGHT, 32, rmask, gmask, bmask, 0);

	tempSurface = SDL_CreateRGBSurfaceFrom(buffer, SCREEN_WIDTH, SCREEN_HEIGHT, 8, SCREEN_WIDTH, 0, 0, 0, 0);
	SDL_SetColors(tempSurface, (SDL_Color *) palette, 0, 256);

	SDL_BlitSurface(screen, NULL, backupSurface, NULL);
	SDL_BlitSurface(tempSurface, NULL, newSurface, NULL);

	for (i = 0; i < 8; i++) {
		SDL_BlitSurface(backupSurface, NULL, surfaceTable[i], NULL);
		SDL_SetAlpha(newSurface, SDL_SRCALPHA | SDL_RLEACCEL, i * 32);
		SDL_BlitSurface(newSurface, NULL, surfaceTable[i], NULL);
		SDL_BlitSurface(surfaceTable[i], NULL, screen, NULL);
		SDL_UpdateRect(screen, 0, 0, 0, 0);
		delaySkip(50);
	}

	SDL_BlitSurface(newSurface, NULL, screen, NULL);
	SDL_UpdateRect(screen, 0, 0, 0, 0);

	SDL_FreeSurface(backupSurface);
	SDL_FreeSurface(newSurface);
	SDL_FreeSurface(tempSurface);
}

/** Switch between window and fullscreen modes */
void toggleFullscreen() {
	cfgfile.FullScreen = 1 - cfgfile.FullScreen;
	SDL_FreeSurface(screen);

	reqBgRedraw = 1;

	if (cfgfile.FullScreen) {
		screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, 32, SDL_SWSURFACE);
		copyScreen(workVideoBuffer, frontVideoBuffer);
		SDL_ShowCursor(1);
	} else {
		screen = SDL_SetVideoMode(SCREEN_WIDTH, SCREEN_HEIGHT, 32, SDL_SWSURFACE | SDL_FULLSCREEN);
		copyScreen(workVideoBuffer, frontVideoBuffer);

#ifdef _DEBUG
		SDL_ShowCursor(1);
#else
		SDL_ShowCursor(0);
#endif
	}
}

/** Handle keyboard pressed keys */
void readKeys() {
	SDL_Event event;
	int32 localKey;
	int32 i, j, size;
	int32 find = 0;
	int16 temp;
	uint8 temp2;
	int8 found = 0;
	uint8 *keyboard;

	localKey = 0;
	skippedKey = 0;
	skipIntro = 0;

	SDL_PumpEvents();

	keyboard = SDL_GetKeyState(&size);

	while (SDL_PollEvent(&event)) {
		switch (event.type) {
		case SDL_QUIT:
			sdlClose();
			break;
		case SDL_MOUSEBUTTONDOWN:
			switch (event.button.button) {
			case SDL_BUTTON_RIGHT:
				rightMouse = 1;
				break;
			case SDL_BUTTON_LEFT:
				leftMouse = 1;
				break;
			}
			break;
		case SDL_KEYUP:
			pressedKey = 0;
			break;
		case SDL_KEYDOWN:
			switch (event.key.keysym.sym) {
			case SDLK_ESCAPE:
				localKey = 0x1;
				break;
			case SDLK_SPACE:
				localKey = 0x39;
				break;
			case SDLK_RETURN:
			case SDLK_KP_ENTER:
				localKey = 0x1C;
				break;
			case SDLK_LSHIFT:
			case SDLK_RSHIFT:
				localKey = 0x36;
				break;
			case SDLK_LALT:
			case SDLK_RALT:
				localKey = 0x38;
				break;
			case SDLK_LCTRL:
			case SDLK_RCTRL:
				localKey = 0x1D;
				break;
			case SDLK_PAGEUP:
				localKey = 0x49;
				break;
			case SDLK_p:  // pause
				localKey = 0x19;
				break;
			case SDLK_h:  // holomap
				localKey = 0x23;
				break;
			case SDLK_j:
				localKey = 0x24;
				break;
			case SDLK_w: // Especial key to do the action
				localKey = 0x11;
				break;
			case SDLK_F1:
				localKey = 0x3B;
				break;
			case SDLK_F2:
				localKey = 0x3C;
				break;
			case SDLK_F3:
				localKey = 0x3D;
				break;
			case SDLK_F4:
				localKey = 0x3E;
				break;
			case SDLK_F6:
				localKey = 0x40;
				break;
			case SDLK_F12:
				toggleFullscreen();
				break;
#ifdef GAMEMOD
			case SDLK_r:  // next room
				localKey = 0x13;
				break;
			case SDLK_f:  // previous room
				localKey = 0x21;
				break;
			case SDLK_t:  // apply celling grid
				localKey = 0x14;
				break;
			case SDLK_g:  // increase celling grid index
				localKey = 0x22;
				break;
			case SDLK_b:  // decrease celling grid index
				localKey = 0x30;
				break;
#endif
			default:
				break;
			}
			break;
		}
	}

	for (j = 0; j < size; j++) {
		if (keyboard[j]) {
			switch (j) {
			case SDLK_RETURN:
			case SDLK_KP_ENTER:
				localKey = 0x1C;
				break;
			case SDLK_SPACE:
				localKey = 0x39;
				break;
			case SDLK_UP:
			case SDLK_KP8:
				localKey = 0x48;
				break;
			case SDLK_DOWN:
			case SDLK_KP2:
				localKey = 0x50;
				break;
			case SDLK_LEFT:
			case SDLK_KP4:
				localKey = 0x4B;
				break;
			case SDLK_RIGHT:
			case SDLK_KP6:
				localKey = 0x4D;
				break;
			case SDLK_LCTRL:
			case SDLK_RCTRL:
				localKey = 0x1D;
				break;
			/*case SDLK_LSHIFT:
			case SDLK_RSHIFT:
				localKey = 0x36;
				break;*/
			case SDLK_LALT:
			case SDLK_RALT:
				localKey = 0x38;
				break;
			case SDLK_F1:
				localKey = 0x3B;
				break;
			case SDLK_F2:
				localKey = 0x3C;
				break;
			case SDLK_F3:
				localKey = 0x3D;
				break;
			case SDLK_F4:
				localKey = 0x3E;
				break;
#ifdef GAMEMOD
				// change grid camera
			case SDLK_s:
				localKey = 0x1F;
				break;
			case SDLK_x:
				localKey = 0x2D;
				break;
			case SDLK_z:
				localKey = 0x2C;
				break;
			case SDLK_c:
				localKey = 0x2E;
				break;
#endif
			}
		}

		for (i = 0; i < 28; i++) {
			if (pressedKeyMap[i] == localKey) {
				find = i;
				found = 1;
				break;
			}
		}

		if (found != 0) {
			temp = pressedKeyCharMap[find];
			temp2 = temp & 0x00FF;

			if (temp2 == 0) {
				// pressed valid keys
				if (!(localKey & 0x80)) {
					pressedKey |= (temp & 0xFF00) >> 8;
				} else {
					pressedKey &= -((temp & 0xFF00) >> 8);
				}
			}
			// pressed inactive keys
			else {
				skippedKey |= (temp & 0xFF00) >> 8;
			}
		}

		//if (found==0) {
			skipIntro = localKey;
		//}
	}
}

#ifdef GAMEMOD

/** Display SDL text in screen
	@param X X coordinate in screen
	@param Y Y coordinate in screen
	@param string text to display
	@param center if the text should be centered accoding with the giving positions */
void ttfDrawText(int32 X, int32 Y, int8 *string, int32 center) {
	SDL_Color white = { 0xFF, 0xFF, 0xFF, 0 };
	SDL_Color *forecol = &white;
	SDL_Rect rectangle;

	SDL_Surface *text;

	text = TTF_RenderText_Solid(font, string, *forecol);

	if (center)
		rectangle.x = X - (text->w / 2);
	else
		rectangle.x = X;
	rectangle.y = Y - 2;
	rectangle.w = text->w;
	rectangle.h = text->h;

	SDL_BlitSurface(text, NULL, screenBuffer, &rectangle);
	SDL_FreeSurface(text);
}

/** Gets SDL mouse positions
	@param mouseData structure that contains mouse position info */
void getMousePositions(MouseStatusStruct *mouseData) {
	SDL_GetMouseState(&mouseData->X, &mouseData->Y);

	mouseData->left = leftMouse;
	mouseData->right = rightMouse;

	leftMouse = 0;
	rightMouse = 0;
}

#endif
/** @file sdlengine.h
	@brief
	This file contains SDL engine routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef SCREEN_H
#define SCREEN_H

#include <SDL/SDL.h>

#include "sys.h"
#include "debug.h"

/** Main SDL screen surface buffer */
extern SDL_Surface *screen;

/** Close everything in the game */
void sdlClose();

/** SDL initializer
	@return SDL init state */
int sdlInitialize();

/** Frames per second sdl delay */
void fpsCycles(int32 fps);

/** Deplay certain seconds till proceed
	@param time time in seconds to delay */
void sdldelay(uint32 time);

/** Deplay certain seconds till proceed - Can also Skip this delay
	@param time time in seconds to delay */
void delaySkip(uint32 time);

/** Set a new palette in the SDL screen buffer
	@param palette palette to set */
void setPalette(uint8 * palette);

/** Fade screen from black to white */
void fadeBlackToWhite();

/** Blit surface in the screen */
void flip();

/** Blit surface in the screen in a determinate area
	@param left left position to start copy
	@param top top position to start copy
	@param right right position to start copy
	@param bottom bottom position to start copy */
void copyBlockPhys(int32 left, int32 top, int32 right, int32 bottom);

/** Create SDL screen surface
	@param buffer screen buffer to blit surface
	@param width screen width size
	@param height screen height size */
void initScreenBuffer(uint8 *buffer, int32 width, int32 height);

/** Cross fade feature
	@param buffer screen buffer
	@param palette new palette to cross fade*/
void crossFade(uint8 *buffer, uint8 *palette);

/** Switch between window and fullscreen modes */
void toggleFullscreen();

/** Handle keyboard pressed keys */
void readKeys();

/** Display SDL text in screen
	@param X X coordinate in screen
	@param Y Y coordinate in screen
	@param string text to display
	@param center if the text should be centered accoding with the giving positions */
void ttfDrawText(int32 X, int32 Y, int8 *string, int32 center);

/** Gets SDL mouse positions
	@param mouseData structure that contains mouse position info */
void getMousePositions(MouseStatusStruct *mouseData);

#endif
BCÀŞ!  2  ‚        #‘AÈI29’„%‹b€ EB’B28I
2D$H
!#ÄR€!r$Èb¨ ¨@Æğ   Q  ì   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l˜áÿÿÿÿ "Ø¡æaÚ ä¡Æ!æ¡ÚÀà¡Â sv˜‡r wx‡60y‡v(‡6€‡wHw ‡r‡6(vH‡v èAê¡€ÁŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ÚÀŞÁÚ€Ê!Ì ÜáÚ ÜÁæ¡ÌÚ ÂĞ0‡p`‡y(€p‡whww˜‡60xhƒvz@ÀÂæ¡ bè!ÆaÚ äáè¡ÆŞAÚ@êÁÌ¡ä¡æ!ô¡ < ˆzp‡ys(‡60xhƒvz@ÀÂæ¡ ¢æ¡Ú`ŞÁè¡ÌŞ!è0‡p`‡y(`A€l Š X6Æÿÿÿÿ€´8@6Èÿÿÿÿ@I     ‚`B L†	!L
c‚pdB@L  ‰   ´   2"
 d…$¤„$ã„¡LŒ„M”ÄÌ ISD	“ÏvåÏ9‹!"   €N’¦ˆ&ŸíÊ?bšD   A
ÂYÒQÂä³]ù§ÈE,Ÿ1À„&€‚€    €€€€€€€€ €
¸Gš"J˜|¶+ÿ•&D    œ$M%L>Û•ÿ¶ “	<c -œ$M%L>Û•?KE ˆ8   HH HP`  rÈ” ‚¸Gš"J˜ü_DÿO,½1€$h";¨"Yè"r à"iŠ(aò9§)ãC}                          ´‘Ô‘!ô‘’(4’T2G Ñ	%äÇ	©$ A ±$ B ¹@"$PL" ĞLœPMB? ĞÍYÒQÂäkÂäD¦SìQÂ„ˆ““ Ê9Lš"J˜|´"¢ÀJDšØ)¢„	'''''''©°C<	( @># % ¢  ÑP€ ¨¨ tT€J*  -Õ`"šJ@O¥  8  ¨2 %$ĞT`¨ª    tU        Ê*€m(ºJà0  @_¤P
 ‡0‡0+    ‘ÍÅ J  0£³b 8   PZ)€    h­@	  ÔV‡        z+€@ ÅÈææ@aà6iŠ(aòÙ®ü[‡i"ò*¢™P PWgggggwÕ Nã³]ù{ÑL(¸#¼" ä‘Ş@À Ü&M%L>Û•¿éP±QÓä4^E4R      èï"iŠ(aòÙ®üI“0  ' ‡ISD	“ÏvåOXà ÑàUD3¡      )    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD >Pæ%àJ¤D   ¤ÀÅ
T"	  €
¬D   ä ÀÅX"	  €
-‘  ÀE—H  `‡BÁK$  @LàDJÔI LÅÎTLàDJÔI DJÔI ´  W ÀTLàlÉÆ×L`|ÍFÔI DJÔI DÊTLà|ÍFXIà”ÑNZMà„•NXIà„•Î„I`DJÔI DJÔI DÊTLàLÅÎTLàLÅÎTLàDJÔI DJÔI DJ›M „•NÔI DJÔI DJÔI DJXIà„•ÎTLàÄİNNà„•NXIà„•NXIà„•NÔI „•NÔI DJXIà„•NXIà„•NXIà„•NÔI „•NXIà„•NXIàìåÊŸN`CQ       €!)      À…€     `È"
@     0d      ²˜     YP €     †,ª €     CV @    €!‹+      À€     `È"@     0da      ²Ğ     YD     †,¶ €     C\ @    €!‹.      À…€     `Èb
      0d1      ²˜      YL €     †,¨ €     C_       €!8      Àe€     `ÈR@     0d      ²      YÔ     †,¢  @     Cv       €!‹;      À€     `ÈB      0d‘      ²Ğ     YD €     †,´ €     CV @    €!‹(      Àe€        D   2˜ LŒ	&GÆC € : ‡ ‚P4HºÓôt˜§İgĞ”È‘Ëöô¸ìAÙåğ¼º‡Ót—Ë¥ 
å†ï:›ì>ÑAiwš³Óú2hJdê@¥¹‚.t’î4=f§çi÷4}×İd¹lOË.”]ÏË {8Mw¹\
u¨ÔLã¿OxÙ¬“Óo¨4WĞ‡‚3M§³Ë aú
’íe7½./ë@Ô{Ú]tŸÓî2…¨A¿§İ­2èßu6Ù}¢ƒæe:ÈFƒái8²§Éå7¨ı&—u Ò\¡ ’ J – r ˜ š š º œ â Ÿ   y     C~HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q     &×°]ù³ÄÄ9‹Ià°]ù³‡cqT$9‘¡4 59š’„T„ù …L ÀÆ—‘#I06¡<!IÄ@˜YÂĞ!‘	¾4EVä,ópTÍD˜¥AlWş,1½È@8¦3†GòØÃvå“ENdlIñH&,„d5ÔADÖ Œ8\éŠ¶hªq¤YEÁ>2b3—-0€@´@°Ö–°]ùwÄ`†F±]ùƒÄDXà ÑÀNÀD˜ÇÂ H“1M„¾4Eµ¾4E¶¾4E·!¾4E¸%¾4E¹)¾4Eº4lWş©³,^E4“ÙQËR1>C01ùğ>rÛFÑ<!IÄ@˜	<vµ8- V"Òd@S9Íô"álTQQ€HÆH
òˆÍ9ö–Ä`¬‚<6SDähÂˆÃ¥àê±¬øz¶¡<À²1ƒÑL9Zƒ0âpu"Ë­^ë™“Í@D%QL¶f q!“¥TODTˆCI!9q âP‘©DODTˆCI!9Zc,„A%ÑDÔ:9<–)/2ÎF—c"×Ï-DhÔ€8öMa,ÄG-‹$DÑØ³8Î“F„$I`&òHO„L‹dDa€Šà<+DÑØÃvåÏS
,Ä43DäxÍ„LXº¢-šjiOKD4­ˆqLÂTÍdR"XÂvå¯RÈdIJæ8+DÑÆò 1MÄ
nšù=lWş_D,€@˜Á!F,„ÕA0ÛJëÀ2vÒDälÄTˆCEFå4ƒ+1D€µ9—5,mÆJ`YÓs‘“F„$I`¶eD°ÓD¬à¦q”49Œ5‹ã<š09;¹!Ò°Ä`6`HÓ@D‘}5Ò°ˆ2!À‚d„…!lWşbƒL–…HÃÂ-DØTDN3½È@8UDd †$DÑXP$	A4¥ã(ÔÓÁBØÍ&PQD4SêHÈ„8ØlÎ€¥SÔ199iDH1fzÒ +DÑlTQ‘MIE'Å ÅJ`mÎetÛ•¿ûÀD¬„0Î8Óä0%QL±å,3MSÅ$›ÅvåÏE0+¸±TT aÑ’D$q™Àc:KàL“Ã”D1Íf±]ùÃæÏ<â4²HO„LDa;Éä<+bSl<Éä<+b“l=Éä<+bÓlHÕ€H@°¬D³ÑLDdKƒB`ÅDD3ÑæL“Ã‘õDD…8”T:Î“F„$I`f³DähÂˆÃesÛ•¿û<D´-Èd^q!“¹P9^3!¦àê±¬øz¡H
ò<Ä@˜ÒÉ!ÀàX²•Ò5[‹t‘ã52aZ–^+r¡DˆqL¦CI„m5Òä<&2 &%!‚å5‚ó`ÛâJz`’))ED3‘f{Û•?ÀD¬àÆRQÄ9Œ‘5&rıèC45 a1’DÃ9‹IÖÇ°]ù³Ä¤-Ï˜D²Åd:”D˜É$ÀàXœ³,ˆ„8M‹=„	 $Ivæ°]ù§óxÑL’‰Å!ÍT˜Q´8Î#6ÑLN„‰ÁØÏ±@‹0„Á1lWş 1µˆ HDähÂˆÃu¢«©•VµT,„&LNd2ÓADÖ Œ8\Z–^+r&´,ó˜NE¤Sd+9ÏæL“Ã°BD]°ÓDØÇÃ H“1MÄ
nšIICXbÑF@#mÎe`Æ!ÍTt‘ã52a'ºšZiËâJ
,Ä4¦‘<ÀÂQÒä0ÀHBDÍFYœ"S
,Ä4Ö1Q¡-5ÀD¤ÀBLaZ49O‚bR"Ø‹t‘ã52aÈr«×zVF™ÈõkËâÀDpĞ4Ä"   a      B,      $dK¤eK´# # # €ÂˆÁ  0b@€`Š   a   Š   N,      PT€
|PşÈP€€øåÿP$…[P¢¬EP€¥Q tRáÿ”0”a I $1” I $1”á I $1”@ IeˆA@Cd  $ÄPF$ $Áep@€X   3i èÄ0€N3p èÄ0€N3p èÄ0€N3p èÄ01l0!h0d0b@ @.$# äB6ÜÜÌ2B@y1F Ğ… xA ‚â Â¡tÄ€ €_ èÃÁ˜Á,Ã@ƒÍ7 ³Å`DãÀ,AAÍ18àÍë†P@ƒYãF ‡ƒ ÌAFˆH‡6Ğ ÄF
 ‡M1  F  ‡j0â
€®1ŒÁ`D`
0bp €8¼ÀÁ)F°F0 Äc¸!00˜e@’€VcŒ À# ¸ƒÁˆq óp:ÑµÂ Ì(Ôá†@Ğ`–aiêuƒº1b°  ;È‚äÁB 4c¼¡5h!Œ†˜%`¨†  ‚Áˆ3`–@1   ü!q!     &€(8@4Øm@a0€¤n@0€¤m@€Øl !!aµDÙH
     a      A,      Pı   3p ìÄ0@Á¨!  æ Àp       ¦0      a      A,      P 3p ìÄ0@Á1       ¦@LC      a   )   F,      P 3p ìÄ0ÀN3p ìÄ010b0 ÀFÁ FÜ FĞ„& ³ÁˆÁ  Ñ„¸ @†‚f„!˜%(F ˜:F	AF Á Œ Ë,AÈ e7AÌ2E€á@    æH“ó´ˆ HÖ HM-"(’iÂ     a   "   A,      PH@a#    3i ìÄ0áÀNƒ‚1 $Œv0b€Âb1F ! „ÈbYŒƒ è@P…ĞbŒ  PA”A”†     ö IBDç,N$µó˜fÀñ 1M        a   &   E,      PHP€EPd6  3p èÄ0ñ€N$cÄ €7¾ïû#†o f	ÆpC Á,ƒ@G$,ã‚ 1@ @†€qB‹1Ş€”AŒ  0B˜Á3K0Ğ2,p@0Ñ0K`8     €ÎâDéh@€       a      A,      6 ¤ƒxbŒ  ÂäcÄ €5¶mÛ a   =   A,      PEP  3p øÄ0€O3p øÄ0€O3á øÄ0Q00A,01(0!$@ÅoÆ`#a ÈãD,ƒ0 tR†	A,x@0Ş¨Á3@Ë g˜„À
ãÎLƒ0 4ƒêbŒ 0
BDtƒ®A× k6LB`ÁÒuÃ„ ŒF p…EIŠ Ã    
   ¶0LÎcFàL“ÃXi@Â4ÆB˜f ±ÅdœE„Ç       a      A,      PQ€
 3i ôÄ0@O3p ôÄ01$0! 0@Ã aĞ0F XƒACÄ@Ä`0Â,‚Àp    ¶PXÈ0Æ`b“iUD     a   ˆ   E,   
   P¨PÀTå?P€üˆÿP€€HP„€EFa#     3i ğÄ0‘ O3p ğÄ0ñ <1ÌD< O3ÀÃL <1ÌDÀÀÃL <1F$Ø F × FÑ FĞ FÏ Ğ0h4Œƒ V!°Ë„ #”` èt:ÆˆÁ ¯Pq›6AF4Á P4F  …Àë6ïîàî`0Â	€œAÓ¸``G h…!Ø@cP5F xA4ª]cÄà  Yº ŒØDa f	ÚÆpCph0Ë qƒ¼1Şğ¦P0F È‚2 04Ã8Á0b`$ -kPBƒ1Ş°P0F Â7 6ã­AƒtcŒ €Âs@¼1F H‡ r!raÄ€  w°ƒY‚ä`X 
 Œ ƒ` f	’ƒAà1F p!‚< ñ# ¼Cğ¿ğ¿@w0F 0‡€î`Œ pİÁ1       ÆĞ€ PKE P )æ°Ló°TT a­JCX,€@l@a0€¤Øj@€˜f€PEADöPD )¶p<ÀBL       a   '   D,      P¨PÀT ˆ@'%@0Cœà    K‚FÁ YŒ Î ŒÀ‰B ˆÃ„Á,C # ø³(c0Á NÒ‰1bP €Áˆ i Í# ˆô8Ì`[@>1È'ÆˆA n # ´Ìa   *     #   P…S€üQ@¥Q°E<QÌ<QÈEQö…Qú%Wp¥Sv…WzÅW€%Q‚ÈPePeSÂ¥<Q–PĞEPîåQŠÅV’%SF…T"P¤Q¢EQ …QÅQP–¥Pş(@%@'%   3ù è1€N3p èÄ0€N3p èÄ0€N3h è„0‘ :ÌD$€N3i èÄ0QøÂ F½ ƒ‰/À`„lğ‚ FØ/ÀˆÁ  û0b@ €>ƒB0 ³Áˆ à°7à³‚\³Œa èàbˆB.¹HF p‰Y‚îÀoÈ( Ä0uQè„1¡” Ìƒ¹A	À,Á1KĞFàF9À,AwÓà7è`ãA:Ìc˜6 ‚í.ŸX~‚/š¼hÂÂg,²xôÚ‹ˆ/¤¾˜ü‚*‹Ê,¬³¸Ğû‹4´Á«`–€Œ°La f	¸Á‹`–€Œ°Ü` f	¸Á«`–€Œ°Ha f	¸Á«`–€Œ°Ø` f	¸Ák`–€Œ°Ô` f	¸Á+`–€Œ°Fa f	¸ÁK`–€Œ°Ba f	¸Á`–€Œ°Ğ` f	¸ƒ àa–€›%àf	ºY‚`0‚Z‡˜%øˆDá!@ƒY0øƒ€®AÒO
ÂpCa0Ëo7†I pƒŸ°ŸÔ ƒÔ Õ(ƒÕ(Ö0ƒÖ0×8ƒ×8ƒ±@²@ƒ°H±Hƒ²P³Xƒ³`´hƒÁˆ¯`–À#¾W€Y7ŒøĞ` f	Ü`0â;ƒ˜%pƒÁˆÏ`–À#¾2€Y7ŒøZa f	Ü`0âs…˜%pƒÁˆ`–À#¾U€Y7ŒøTa f	Ü`0âK…˜%pƒY‚7Œğèa f	à€¼1ÜøÌ2ÄAc¼á<î!  \ Tc¸AÀ`–Aæ  3ƒdÀ`D¬A ÌÔÁ,ĞĞƒiÀ,Ğ„ d¸!‰0˜e°ƒ>(Æxƒ|ŒD@ŒXƒ@ hÄ RÁè0áA „ b¸!X	0˜e¸ƒ=èF| ÃK„Á,CàA@u . 
òA+È‡$ HÃ^pƒ(À,Pˆ ¤‚Ğ
B"m'‚P‹ˆ ¤‚A/8Áˆ	`–@f	ø€LA\  ¨„V I8". 
†½à#x$€Y>˜%èš…qÁ	FˆI  ³~@³0,¨	FÔB0 ³†     Ö@H3v@ATD3Yv ²8°fŞÄD0… 
öPLóØ¦ ¶$Æ@HHFx@Q8T3          /** @file shadeangletab.h
	@brief
	This file contains shades angle table values

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef SHADEANGLETAB_H
#define SHADEANGLETAB_H

int16 shadeAngleTable[1024] = {
	0,		// tab1
	101,
	201,
	302,
	402,
	503,
	603,
	704,
	804,
	904,
	1005,
	1105,
	1205,
	1306,
	1406,
	1506,
	1606,
	1706,
	1806,
	1906,
	2006,
	2105,
	2205,
	2305,
	2404,
	2503,
	2603,
	2702,
	2801,
	2900,
	2999,
	3098,
	3196,
	3295,
	3393,
	3492,
	3590,
	3688,
	3786,
	3883,
	3981,
	4078,
	4176,
	4273,
	4370,
	4467,
	4563,
	4660,
	4756,
	4852,
	4948,
	5044,
	5139,
	5235,
	5330,
	5425,
	5520,
	5614,
	5708,
	5803,
	5897,
	5990,
	6084,
	6177,
	6270,
	6363,
	6455,
	6547,
	6639,
	6731,
	6823,
	6914,
	7005,
	7096,
	7186,
	7276,
	7366,
	7456,
	7545,
	7635,
	7723,
	7812,
	7900,
	7988,
	8076,
	8163,
	8250,
	8337,
	8423,
	8509,
	8595,
	8680,
	8765,
	8850,
	8935,
	9019,
	9102,
	9186,
	9269,
	9352,
	9434,
	9516,
	9598,
	9679,
	9760,
	9841,
	9921,
	10001,
	10080,
	10159,
	10238,
	10316,
	10394,
	10471,
	10549,
	10625,
	10702,
	10778,
	10853,
	10928,
	11003,
	11077,
	11151,
	11224,
	11297,
	11370,
	11442,
	11514,
	11585,
	11656,
	11727,
	11797,
	11866,
	11935,
	12004,
	12072,
	12140,
	12207,
	12274,
	12340,
	12406,
	12472,
	12537,
	12601,
	12665,
	12729,
	12792,
	12854,
	12916,
	12978,
	13039,
	13100,
	13160,
	13219,
	13279,
	13337,
	13395,
	13453,
	13510,
	13567,
	13623,
	13678,
	13733,
	13788,
	13842,
	13896,
	13949,
	14001,
	14053,
	14104,
	14155,
	14206,
	14256,
	14305,
	14354,
	14402,
	14449,
	14497,
	14543,
	14589,
	14635,
	14680,
	14724,
	14768,
	14811,
	14854,
	14896,
	14937,
	14978,
	15019,
	15059,
	15098,
	15137,
	15175,
	15213,
	15250,
	15286,
	15322,
	15357,
	15392,
	15426,
	15460,
	15493,
	15525,
	15557,
	15588,
	15619,
	15649,
	15679,
	15707,
	15736,
	15763,
	15791,
	15817,
	15843,
	15868,
	15893,
	15917,
	15941,
	15964,
	15986,
	16008,
	16029,
	16049,
	16069,
	16088,
	16107,
	16125,
	16143,
	16160,
	16176,
	16192,
	16207,
	16221,
	16235,
	16248,
	16261,
	16273,
	16284,
	16295,
	16305,
	16315,
	16324,
	16332,
	16340,
	16347,
	16353,
	16359,
	16364,
	16369,
	16373,
	16376,
	16379,
	16381,
	16383,
	16384,
	16384,	// tab2
	16384,
	16383,
	16381,
	16379,
	16376,
	16373,
	16369,
	16364,
	16359,
	16353,
	16347,
	16340,
	16332,
	16324,
	16315,
	16305,
	16295,
	16284,
	16273,
	16261,
	16248,
	16235,
	16221,
	16207,
	16192,
	16176,
	16160,
	16143,
	16125,
	16107,
	16088,
	16069,
	16049,
	16029,
	16008,
	15986,
	15964,
	15941,
	15917,
	15893,
	15868,
	15843,
	15817,
	15791,
	15763,
	15736,
	15707,
	15679,
	15649,
	15619,
	15588,
	15557,
	15525,
	15493,
	15460,
	15426,
	15392,
	15357,
	15322,
	15286,
	15250,
	15213,
	15175,
	15137,
	15098,
	15059,
	15019,
	14978,
	14937,
	14896,
	14854,
	14811,
	14768,
	14724,
	14680,
	14635,
	14589,
	14543,
	14497,
	14449,
	14402,
	14354,
	14305,
	14256,
	14206,
	14155,
	14104,
	14053,
	14001,
	13949,
	13896,
	13842,
	13788,
	13733,
	13678,
	13623,
	13567,
	13510,
	13453,
	13395,
	13337,
	13279,
	13219,
	13160,
	13100,
	13039,
	12978,
	12916,
	12854,
	12792,
	12729,
	12665,
	12601,
	12537,
	12472,
	12406,
	12340,
	12274,
	12207,
	12140,
	12072,
	12004,
	11935,
	11866,
	11797,
	11727,
	11656,
	11585,	// tab3
	11514,
	11442,
	11370,
	11297,
	11224,
	11151,
	11077,
	11003,
	10928,
	10853,
	10778,
	10702,
	10625,
	10549,
	10471,
	10394,
	10316,
	10238,
	10159,
	10080,
	10001,
	9921,
	9841,
	9760,
	9679,
	9598,
	9516,
	9434,
	9352,
	9269,
	9186,
	9102,
	9019,
	8935,
	8850,
	8765,
	8680,
	8595,
	8509,
	8423,
	8337,
	8250,
	8163,
	8076,
	7988,
	7900,
	7812,
	7723,
	7635,
	7545,
	7456,
	7366,
	7276,
	7186,
	7096,
	7005,
	6914,
	6823,
	6731,
	6639,
	6547,
	6455,
	6363,
	6270,
	6177,
	6084,
	5990,
	5897,
	5803,
	5708,
	5614,
	5520,
	5425,
	5330,
	5235,
	5139,
	5044,
	4948,
	4852,
	4756,
	4660,
	4563,
	4467,
	4370,
	4273,
	4176,
	4078,
	3981,
	3883,
	3786,
	3688,
	3590,
	3492,
	3393,
	3295,
	3196,
	3098,
	2999,
	2900,
	2801,
	2702,
	2603,
	2503,
	2404,
	2305,
	2205,
	2105,
	2006,
	1906,
	1806,
	1706,
	1606,
	1506,
	1406,
	1306,
	1205,
	1105,
	1005,
	904,
	804,
	704,
	603,
	503,
	402,
	302,
	201,
	101,
	0,
	-101,
	-201,
	-302,
	-402,
	-503,
	-603,
	-704,
	-804,
	-904,
	-1005,
	-1105,
	-1205,
	-1306,
	-1406,
	-1506,
	-1606,
	-1706,
	-1806,
	-1906,
	-2006,
	-2105,
	-2205,
	-2305,
	-2404,
	-2503,
	-2603,
	-2702,
	-2801,
	-2900,
	-2999,
	-3098,
	-3196,
	-3295,
	-3393,
	-3492,
	-3590,
	-3688,
	-3786,
	-3883,
	-3981,
	-4078,
	-4176,
	-4273,
	-4370,
	-4467,
	-4563,
	-4660,
	-4756,
	-4852,
	-4948,
	-5044,
	-5139,
	-5235,
	-5330,
	-5425,
	-5520,
	-5614,
	-5708,
	-5803,
	-5897,
	-5990,
	-6084,
	-6177,
	-6270,
	-6363,
	-6455,
	-6547,
	-6639,
	-6731,
	-6823,
	-6914,
	-7005,
	-7096,
	-7186,
	-7276,
	-7366,
	-7456,
	-7545,
	-7635,
	-7723,
	-7812,
	-7900,
	-7988,
	-8076,
	-8163,
	-8250,
	-8337,
	-8423,
	-8509,
	-8595,
	-8680,
	-8765,
	-8850,
	-8935,
	-9019,
	-9102,
	-9186,
	-9269,
	-9352,
	-9434,
	-9516,
	-9598,
	-9679,
	-9760,
	-9841,
	-9921,
	-10001,
	-10080,
	-10159,
	-10238,
	-10316,
	-10394,
	-10471,
	-10549,
	-10625,
	-10702,
	-10778,
	-10853,
	-10928,
	-11003,
	-11077,
	-11151,
	-11224,
	-11297,
	-11370,
	-11442,
	-11514,
	-11585,
	-11656,
	-11727,
	-11797,
	-11866,
	-11935,
	-12004,
	-12072,
	-12140,
	-12207,
	-12274,
	-12340,
	-12406,
	-12472,
	-12537,
	-12601,
	-12665,
	-12729,
	-12792,
	-12854,
	-12916,
	-12978,
	-13039,
	-13100,
	-13160,
	-13219,
	-13279,
	-13337,
	-13395,
	-13453,
	-13510,
	-13567,
	-13623,
	-13678,
	-13733,
	-13788,
	-13842,
	-13896,
	-13949,
	-14001,
	-14053,
	-14104,
	-14155,
	-14206,
	-14256,
	-14305,
	-14354,
	-14402,
	-14449,
	-14497,
	-14543,
	-14589,
	-14635,
	-14680,
	-14724,
	-14768,
	-14811,
	-14854,
	-14896,
	-14937,
	-14978,
	-15019,
	-15059,
	-15098,
	-15137,
	-15175,
	-15213,
	-15250,
	-15286,
	-15322,
	-15357,
	-15392,
	-15426,
	-15460,
	-15493,
	-15525,
	-15557,
	-15588,
	-15619,
	-15649,
	-15679,
	-15707,
	-15736,
	-15763,
	-15791,
	-15817,
	-15843,
	-15868,
	-15893,
	-15917,
	-15941,
	-15964,
	-15986,
	-16008,
	-16029,
	-16049,
	-16069,
	-16088,
	-16107,
	-16125,
	-16143,
	-16160,
	-16176,
	-16192,
	-16207,
	-16221,
	-16235,
	-16248,
	-16261,
	-16273,
	-16284,
	-16295,
	-16305,
	-16315,
	-16324,
	-16332,
	-16340,
	-16347,
	-16353,
	-16359,
	-16364,
	-16369,
	-16373,
	-16376,
	-16379,
	-16381,
	-16383,
	-16384,
	-16384,
	-16384,
	-16383,
	-16381,
	-16379,
	-16376,
	-16373,
	-16369,
	-16364,
	-16359,
	-16353,
	-16347,
	-16340,
	-16332,
	-16324,
	-16315,
	-16305,
	-16295,
	-16284,
	-16273,
	-16261,
	-16248,
	-16235,
	-16221,
	-16207,
	-16192,
	-16176,
	-16160,
	-16143,
	-16125,
	-16107,
	-16088,
	-16069,
	-16049,
	-16029,
	-16008,
	-15986,
	-15964,
	-15941,
	-15917,
	-15893,
	-15868,
	-15843,
	-15817,
	-15791,
	-15763,
	-15736,
	-15707,
	-15679,
	-15649,
	-15619,
	-15588,
	-15557,
	-15525,
	-15493,
	-15460,
	-15426,
	-15392,
	-15357,
	-15322,
	-15286,
	-15250,
	-15213,
	-15175,
	-15137,
	-15098,
	-15059,
	-15019,
	-14978,
	-14937,
	-14896,
	-14854,
	-14811,
	-14768,
	-14724,
	-14680,
	-14635,
	-14589,
	-14543,
	-14497,
	-14449,
	-14402,
	-14354,
	-14305,
	-14256,
	-14206,
	-14155,
	-14104,
	-14053,
	-14001,
	-13949,
	-13896,
	-13842,
	-13788,
	-13733,
	-13678,
	-13623,
	-13567,
	-13510,
	-13453,
	-13395,
	-13337,
	-13279,
	-13219,
	-13160,
	-13100,
	-13039,
	-12978,
	-12916,
	-12854,
	-12792,
	-12729,
	-12665,
	-12601,
	-12537,
	-12472,
	-12406,
	-12340,
	-12274,
	-12207,
	-12140,
	-12072,
	-12004,
	-11935,
	-11866,
	-11797,
	-11727,
	-11656,
	-11585,
	-11514,
	-11442,
	-11370,
	-11297,
	-11224,
	-11151,
	-11077,
	-11003,
	-10928,
	-10853,
	-10778,
	-10702,
	-10625,
	-10549,
	-10471,
	-10394,
	-10316,
	-10238,
	-10159,
	-10080,
	-10001,
	-9921,
	-9841,
	-9760,
	-9679,
	-9598,
	-9516,
	-9434,
	-9352,
	-9269,
	-9186,
	-9102,
	-9019,
	-8935,
	-8850,
	-8765,
	-8680,
	-8595,
	-8509,
	-8423,
	-8337,
	-8250,
	-8163,
	-8076,
	-7988,
	-7900,
	-7812,
	-7723,
	-7635,
	-7545,
	-7456,
	-7366,
	-7276,
	-7186,
	-7096,
	-7005,
	-6914,
	-6823,
	-6731,
	-6639,
	-6547,
	-6455,
	-6363,
	-6270,
	-6177,
	-6084,
	-5990,
	-5897,
	-5803,
	-5708,
	-5614,
	-5520,
	-5425,
	-5330,
	-5235,
	-5139,
	-5044,
	-4948,
	-4852,
	-4756,
	-4660,
	-4563,
	-4467,
	-4370,
	-4273,
	-4176,
	-4078,
	-3981,
	-3883,
	-3786,
	-3688,
	-3590,
	-3492,
	-3393,
	-3295,
	-3196,
	-3098,
	-2999,
	-2900,
	-2801,
	-2702,
	-2603,
	-2503,
	-2404,
	-2305,
	-2205,
	-2105,
	-2006,
	-1906,
	-1806,
	-1706,
	-1606,
	-1506,
	-1406,
	-1306,
	-1205,
	-1105,
	-1005,
	-904,
	-804,
	-704,
	-603,
	-503,
	-402,
	-302,
	-201,
	-101,
};


#endif
/** @file sound.c
	@brief
	This file contains music playing routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <SDL/SDL.h>
#ifndef MACOSX
#include <SDL/SDL_mixer.h>
#else
#include <SDL_mixer/SDL_mixer.h>
#endif

#include "sound.h"
#include "flamovies.h"
#include "main.h"
#include "resources.h"
#include "hqrdepack.h"
#include "movements.h"
#include "grid.h"
#include "collision.h"
#include "text.h"

/** SDL_Mixer channels */
int32 channel;
/** Samples chunk variable */
Mix_Chunk *sample;

int32 channelIdx = -1;

/** Sample volume
	@param channel sample channel
	@param volume sample volume number */
void sampleVolume(int32 channel, int32 volume) {
	Mix_Volume(channel, volume / 2);
}

/** Play FLA movie samples
	@param index sample index under flasamp.hqr file
	@param frequency frequency used to play the sample
	@param repeat number of times to repeat the sample
	@param x unknown x variable
	@param y unknown y variable */
void playFlaSample(int32 index, int32 frequency, int32 repeat, int32 x, int32 y) {
	if (cfgfile.Sound) {
		int32 sampSize = 0;
		int8 sampfile[256];
		SDL_RWops *rw;
		uint8* sampPtr;

		sprintf(sampfile, FLA_DIR "%s",HQR_FLASAMP_FILE);

		sampSize = hqrGetallocEntry(&sampPtr, sampfile, index);

		// Fix incorrect sample files first byte
		if (*sampPtr != 'C')
			*sampPtr = 'C';

		rw = SDL_RWFromMem(sampPtr, sampSize);
		sample = Mix_LoadWAV_RW(rw, 1);

		channelIdx = getFreeSampleChannelIndex();
		if (channelIdx != -1) {
			samplesPlaying[channelIdx] = index;
		}

		sampleVolume(channelIdx, cfgfile.WaveVolume);

		if (Mix_PlayChannel(channelIdx, sample, repeat - 1) == -1)
			printf("Error while playing VOC: Sample %d \n", index);

		/*if (cfgfile.Debug)
			printf("Playing VOC: Sample %d\n", index);*/

		free(sampPtr);
	}
}

void setSamplePosition(int32 channelIdx, int32 x, int32 y, int32 z) {
	int32 distance;
	distance = Abs(getDistance3D(newCameraX << 9, newCameraY << 8, newCameraZ << 9, x, y, z));
	distance = getAverageValue(0, distance, 10000, 255);
	if (distance > 255) { // don't play it if its to far away
		distance = 255;
	}

	Mix_SetDistance(channelIdx, distance);
}

/** Play samples
	@param index sample index under flasamp.hqr file
	@param frequency frequency used to play the sample
	@param repeat number of times to repeat the sample
	@param x unknown x variable
	@param y unknown y variable
	@param z unknown z variable */
void playSample(int32 index, int32 frequency, int32 repeat, int32 x, int32 y, int32 z, int32 actorIdx) {
	if (cfgfile.Sound) {
		int32 sampSize = 0;
		SDL_RWops *rw;
		uint8* sampPtr;

		sampSize = hqrGetallocEntry(&sampPtr, HQR_SAMPLES_FILE, index);

		// Fix incorrect sample files first byte
		if (*sampPtr != 'C')
			*sampPtr = 'C';

		rw = SDL_RWFromMem(sampPtr, sampSize);
		sample = Mix_LoadWAV_RW(rw, 1);

		channelIdx = getFreeSampleChannelIndex();

		// only play if we have a free channel, otherwise we won't be able to control the sample
		if (channelIdx != -1) {
			samplesPlaying[channelIdx] = index;
			sampleVolume(channelIdx, cfgfile.WaveVolume);

			if (actorIdx != -1) {
				setSamplePosition(channelIdx, x, y, z);

				// save the actor index for the channel so we can check the position
				samplesPlayingActors[channelIdx] = actorIdx;
			}

			if (Mix_PlayChannel(channelIdx, sample, repeat - 1) == -1)
				printf("Error while playing VOC: Sample %d \n", index);

			/*if (cfgfile.Debug)
				printf("Playing VOC: Sample %d\n", index);*/
		}

		free(sampPtr);
	}
}

/** Resume samples */
void resumeSamples() {
	if (cfgfile.Sound) {
		Mix_Resume(-1);
		/*if (cfgfile.Debug)
			printf("Resume VOC samples\n");*/
	}
}

/** Pause samples */
void pauseSamples() {
	if (cfgfile.Sound) {
		Mix_HaltChannel(-1);
		/*if (cfgfile.Debug)
			printf("Pause VOC samples\n");*/
	}
}

/** Stop samples */
void stopSamples() {
	if (cfgfile.Sound) {
		memset(samplesPlaying, -1, sizeof(int32) * NUM_CHANNELS);
		Mix_HaltChannel(-1);
		//clean up
		Mix_FreeChunk(sample);
		sample = NULL; //make sure we free it
		/*if (cfgfile.Debug)
			printf("Stop VOC samples\n");*/
	}
}

int32 getActorChannel(int32 index) {
	int32 c = 0;
	for (c = 0; c < NUM_CHANNELS; c++) {
		if (samplesPlayingActors[c] == index) {
			return c;
		}
	}
	return -1;
}

int32 getSampleChannel(int32 index) {
	int32 c = 0;
	for (c = 0; c < NUM_CHANNELS; c++) {
		if (samplesPlaying[c] == index) {
			return c;
		}
	}
	return -1;
}

void removeSampleChannel(int32 c) {
	samplesPlaying[c] = -1;
	samplesPlayingActors[c] = -1;
}

/** Stop samples */
void stopSample(int32 index) {
	if (cfgfile.Sound) {
		int32 stopChannel = getSampleChannel(index);
		if (stopChannel != -1) {
			removeSampleChannel(stopChannel);
			Mix_HaltChannel(stopChannel);
			//clean up
			Mix_FreeChunk(sample);
			sample = NULL; //make sure we free it
			/*if (cfgfile.Debug)
				printf("Stop VOC samples\n");*/
		}
	}
}

int32 isChannelPlaying(int32 channel) {
	if (channel != -1) {
		if(Mix_Playing(channel)) {
			return 1;
		} else {
			removeSampleChannel(channel);
		}
	}
	return 0;
}

int32 isSamplePlaying(int32 index) {
	int32 channel = getSampleChannel(index);
	return isChannelPlaying(channel);
}

int32 getFreeSampleChannelIndex() {
	int i = 0;
	for (i = 0; i < NUM_CHANNELS; i++) {
		if (samplesPlaying[i] == -1) {
			return i;
		}
	}
	//FIXME if didn't find any, lets free what is not in use
	for (i = 0; i < NUM_CHANNELS; i++) {
		if (samplesPlaying[i] != -1) {
			isChannelPlaying(i);
		}
	}
	return -1;
}

void playVoxSample(int32 index) {
	if (cfgfile.Sound) {
		int32 sampSize = 0;
		SDL_RWops *rw;
		uint8* sampPtr = 0;

		sampSize = hqrGetallocVoxEntry(&sampPtr, currentVoxBankFile, index, voxHiddenIndex);
		
		// Fix incorrect sample files first byte
		if (*sampPtr != 'C') {
			hasHiddenVox = *sampPtr;
			voxHiddenIndex++;
			*sampPtr = 'C';
		}

		rw = SDL_RWFromMem(sampPtr, sampSize);
		sample = Mix_LoadWAV_RW(rw, 1);

		channelIdx = getFreeSampleChannelIndex();
		
		// only play if we have a free channel, otherwise we won't be able to control the sample
		if (channelIdx != -1) {
			samplesPlaying[channelIdx] = index;
		
			sampleVolume(channelIdx, cfgfile.VoiceVolume - 1);

			if (Mix_PlayChannel(channelIdx, sample, 0) == -1)
				printf("Error while playing VOC: Sample %d \n", index);

			/*if (cfgfile.Debug)
				printf("Playing VOC: Sample %d\n", index);*/
		}

		free(sampPtr);
	}
}
/** @file sound.h
	@brief
	This file contains music playing routines

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef SOUND_H
#define SOUND_H

#include "sys.h"
#include "sys.h"

/** Total number of sprites allowed in the game */
#define NUM_SAMPLES 243
#define NUM_CHANNELS 32

/** Table with all loaded samples */
uint8* samplesTable[NUM_SAMPLES];
/** Table with all loaded samples sizes */
uint32 samplesSizeTable[NUM_SAMPLES];

/** Samples playing at the same time */
int32 samplesPlaying[NUM_CHANNELS];

/** Samples playing at a actors position */
int32 samplesPlayingActors[NUM_CHANNELS];

/** Sample volume
	@param channel sample channel
	@param volume sample volume number */
void sampleVolume(int32 channel, int32 volume);

/** Play FLA movie samples
	@param index sample index under flasamp.hqr file
	@param frequency frequency used to play the sample
	@param repeat number of times to repeat the sample
	@param x unknown x variable
	@param y unknown y variable */
void playFlaSample(int32 index, int32 frequency, int32 repeat, int32 x, int32 y);

/** Update sample position in channel */
void setSamplePosition(int32 channelIdx, int32 x, int32 y, int32 z);

/** Play samples
	@param index sample index under flasamp.hqr file
	@param frequency frequency used to play the sample
	@param repeat number of times to repeat the sample
	@param x unknown x variable
	@param y unknown y variable
	@param z unknown z variable */
void playSample(int32 index, int32 frequency, int32 repeat, int32 x, int32 y, int32 z, int32 actorIdx);

/** Pause samples */
void pauseSamples();

void resumeSamples();

/** Stop samples */
void stopSamples();

/** Get the channel where the actor sample is playing */
int32 getActorChannel(int32 index);

/** Get the channel where the sample is playing */
int32 getSampleChannel(int32 index);

/** Stops a specific sample */
void stopSample(int32 index);

/** Find a free channel slot to use */
int32 getFreeSampleChannelIndex();

/** Remove a sample from the channel usage list */
void removeSampleChannel(int32 index);

/** Check if a sample is playing */
int32 isSamplePlaying(int32 index);

/** Play VOX sample */
void playVoxSample(int32 index);

#endif
BCÀŞ!  Ö  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  ì   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l¨áÿÿÿÿ@(‚Êaæ¡àAÊaÒaÊ¡ÌÚ!È0‡p`‡y(€p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th€ä¡ÊÜáÚÀä!Ú¡Ú Ş!ÜÊAÚ Ø!Ú¡ÜáÜ¡Ø¡ÂÁ ÂŞ¡ÒÁÌaÚÀà¡Ú!è sv˜‡r wx‡6p‡pp‡yhs€‡6h‡p t Ì!ØaÊ æÂaÖ¡àAŞÊaèáä¡Ä¡ÌÁÊAÚ`ÒAÊÀ€¨w˜‡p0‡rhs€‡6h‡p t Ì!ØaÊ êaÊ¡æáÌÚÀØáÂ sv˜‡r 6„ ˆÁ¢€eaüÿÿÿÿ HŒãÿÿÿÿ@(   I     ‚`B L†	!L
cBpL    ‰   œ   2"È	 d…“#¤„“#ã„¡LŒ„äLèÃ` IA.’¦ˆ&Ÿsš1>d!Ğ7                       €
y  	(q4E”0ù&rıÜA5
" 	€€ÄH 9²D@$çDÉù  Y~@@˜9ˆ4É! NZÈ“¥€D)¡!Rr$È” B%r@‚T‰  VhÈ•‚Ã¤)¢„Ég'`B„o‰"J˜P »Lš"J˜ük ¾0$vŠ(aBìiŠ(aòç7ufB‚FsŒ4E”0ùó»9f³ÙYÒQÂäkÂäD¦SìQÂ„F8Mš"J˜|­A˜aˆ¨&€"J˜ œ$M%L¾&LNÄN%LÈb2    $ 	                   €              ­f£áÎ’¦ˆ&ß»¦(ib§ˆ&i4F£©i4 ÑhRFG»ÓPo ? €€e   $,Æ    D¬ ‘ c! Š€4-@	 Ğ² e  f JzŞ"M%L>Ğ8‰Ä)Tƒ84Nƒ‚èAÒQÂä³]ù¯°óHÈ`:P€´Ê€¨e`(d- À  [@‚´Eø%ˆ[Š   ·  Ë     €Ä¥     ‘Ë  È\      B—àGê"ü Ä#ŠñK  7½‹ğcP¼ š— H  T å   °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD Ô¦ v(HPI  @ P l¸ÎÇ[à;”(€‹$    Hœ´ÀHœ
 àã-pNâc -pÒgE.p^æ§¢-pfèã$.0nØå†-PnØå†-PnØå†-PnØå†-PnØå†-PnØå†-Pvìãç.0†ğã(/pÒgI/PÒçi/p¦øçª/p¶üg -pÒg -p&Öã†-PnØå†-PnØå†-P*Ú§¢-p*Ú§¢-p*Úç†-PnØå†-PnØå†-P¾şe -pnØå†-PnØå†-PnØå†-PnØå†-PnØå†-PnØe4pnØå†-PnØe -pÒg -pÒ§¢-pnØå†-PòBg -pÒg -pÒg -pÒg -pÒg -p*Ú§¢-pÒg -pÒg -pÒg -pÒg -pÒg -pÒg -pÒg -pÒç$.0Nâ£¢-p*Úg -pÒg -pÒg -pÒg -p*Úg -pÒg -pÒ§O4PÒg -pÒg -pÒ²„      YF     †,¥  @     C–S @    €!K*      À¥€     `Èr@     0dÉ      ²ì     Yz     †,¿  @     C–p `    €!Ë8      À¥€     `Èr@     0dI      ²¬      YÚ     †,ë  @     C–p @    €!Ë:      À€ (    `È"@     0d	      ²„      YÚ €     †,í  @     C–p       €!K8      À%      `ÈB      0di      ²Ø     d #   2˜ LŒ	&GÆCŒ Ô 	F H3@‰ bŒ c€ JE¹ü-İÑivg‡ói÷d}u i¸g—A%2HA’ ¢Œ e€0# tPÃÌ¿JsâŒ g€@# $ Ò ™F 5@ª b k€p# ´ Ş    y     C„{HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q     F± CpğLDdD„Á4 59š’„T„])‚³,ˆ„8MlXŠà,"!N#Ûe@Å,À<!™ áKSd%“0w8ˆ@H,1MHcH–Ğ<€}ÀÌ³QC‡D6	Tu°´Ä5yÍaÖCDähÂˆÃ•®h‹¦Gšc e"×Ÿ. Æ@ÓK‹0Ä`YŠà,"!N3ÛÒóD@H’&LN”N‘}(”„4ajÏ€ KK\Óæ\%QLfĞ<€½ÎÅÌ³fPøÒÕFğÄ¤UDÄ,aÒTD39vRH6² Cp‡ƒ„dkÎ€ KK\Óæ\­óg µ,ã3#“ÿĞï#·mOÓD1iÂäD"M@#¦=‘#’Ä9Ë‚HˆÓÄ¶=‘#’Ä9Ë‚HˆÓÈÆ=‘#’Ä9Ë‚HˆÓÌv!1€°,umÕ„E,-qMìä<œ³8‘íT9Zƒ0âpi ¸z,+¾LÁ8ÁÌ³Ü4±˜Qr‘c:1Ït‘£5#W'²Üêµ±A,-qM›s­ˆqLGTQ›P…m1ÕâPRHDÎF@…8TdT%±,Hc€2˜LôDD…8”‘£5ÆBXf ó ”D° ó,„d€0%Ò[D Jl*ôDÈD°HF´@° Ğ4Ä"—áL9^3!–®h‹¦GÚhÀb"×Ÿ. †4†À<a^@EÑL-qMĞ(FÖ°p± VÖ°´Ä5qÎâDæ°´Ä5mÎ•ÀÔö°´Ä5mÎ•ÀØÖA!ME4“a&` Bê Í$YÀ!F,„mPHSÍäDØI1%Òæ\öÒDälÄTˆCE–&°´Ä5mTQ‹d„-PÀ<!¥€!¡	“Ivâ ME4“a-,„}@1± ó,w MC,fÂ‡ƒ„ÖHÙ#Ì³Ra"TDº  CXƒS9WˆÑˆÍ@\IÄÄÌ³©#!â4Vç<ÒL-qMüDµM-ÁâÊF™óDH3µÄ5ñ/Ùvç<ÒL-qMüD·…(Òä<,À<aÒTD39vRLI …d] P¡	“u „å9O„4SK\ÿQnzÎ!ÍÔ×Ä¿@¤ÛßóDH3µÄ5ÕôDµñ9O„4SK\ÿo(ÒTD39Æ"ÑÁB4 ÀÒ×ÄNÄÃ"a–Ê³ 0ÏBXßÒ0ÄD¸ù-a C¼@”b€b"×ÿ:ÅVàH ó,„”. †4†ılED3¥„LˆÓˆÍæX:E-“óDD…8”¤	“Å¦ğ˜Èõ‡À2qĞ4ÄbMÎâP’&LN$›“óDD…8”¤	“ÍFğ 0ÏB¤€!a{SëÅíÏQQD4SILÉ†7µ^ÜşED3•Ä4Ql@KàL“Ã”D1Å´Î49LI“lBKàL“Ã”D1Íâ ME4“aß’1HED3½Îµò!abÌ€ KK\‹d„14lWş+üEcŒa(&rı+!Qa)‹ôDÈD´@°VÁ0€°,âpÔ! ±EÀ [eÀc"×ÏS‡HĞ„LÄ,‹#¼Îå5S„™bÀ!=ÒL…µE,-qM›smÎ49Œ-@Ä,‹#xÍa6”LÎ³"Æ1ÅF”LÎ³"Æ1Év 4„Å±!(aq CD€l	JCXÀ0‰ÒPw8ˆ@Hf•×%"M†Ô<‘#’¤	“ÅV”LÎ³"Æ1Í–Ô<‘#’¤	“É†Ñ0€%Q‹8\ç<ÒL-qM/Õ·)5Oä„$iÂäD³I@ ™Ïr‘£5#—ÕH9^3!¦µaéµ"g6ÔAD×LÈ„i ¸z,+¾­ÒË!ÀàX²µÒ5Ûd@cS‡HĞÄİ™Ô! ³)9š0!NcP¨®ÿWj¬f¦ÿ'–……ÓLéY`@ñL¼„a@Ô×Ô!ÀÒ×ä5S„™gÀc“&LNÄ@Ó‹¹LÒÅ9Ë‚HˆÓ´ØCØ$PQÔ!ÀÒ×Ä"a…’t8V‡ ‹cPÄFÁBØa #Ì³¯³Pa›‹490ÏBH¦!!ME4“a'Å€t’…0‡³8ğ|`H–DähÂˆÃu¢«©•Öà˜Èõ—0ÀÚû¯°90 …È0Íë\¦3DähÂˆÃ¥µaéµ"g‰0Ä· †d‰\ÿwPb¢"qĞ4Ä’. †4†Í@Bä<›3MÃ
A4f!1€°,'ÅlÕ„U9±,Hc€2ˆÃeI± UDd‚Û!ÍÔ×Ä§ñ ±QEAD/Ùf&°´Ä5±Mœ³8‘A,ìÄFLA4öTu°´Ä5¥SdsÎ!ÍÔ×Ä§STÛc€ñDH3FDäxÍ„LØ‰®¦VZi@fÓ0ÏBpĞ4Ä"6q$Ì³‹dDa†‡p MC,–!ME4“a'Å&óDH3µÄ5ñéÙ¦ …êú³š™–ûbéÙt‘ã52aÈr«×z   a      A,      ("    3@ÃLD Æ0!0@Â aTPĞˆA £0     6`TÎB1„	Â4±        a   n   I,      (")Ã€’ AP`(Ã ´ Tc(Ã ´ PƒCˆ  €C‘ € 3pÃLD œÆ0 §1ÌDÀi3pÃLD œÆ01§ÌDàpÃL„œÆ0‘\0X0qT0aP0QL@Ìnä f$Œ0æ` ÆŠ9˜Ê1b` À,O0Ş€ØĞ3F ¨D#˜` („ 1Üla0Ë 5c0"Ø`–` g4F
 à!Œ‚ iŒ ĞÁFœG0 # ˜Â`{@ì1†RƒY¢Èôc¼a=P!Œ†˜%((>™Á1( €„€æc|ƒaÁ„`Äà €t †À†‚W ƒYã(ÆˆA ë°Á,ÁAc0F `‡`– Áp     F`DÄC “$ED@Ñ˜Y À<²†pH ó¤SdÂÒÄeÅÁeÆfÕˆ0‹d„]‘       a   6   C,      (ò(‰‚(PÎ     3`ÃLD ˜Æ0 ¦1ÌD€i3`Ã`DáÀ`ÑÀ`ÄÀÀ`„° ¥Æ¨ 9RQr´£‚æH¤RÆˆA ¦€Ä #„ B0Á@Ì18  è ªÁ' rÆpCp™Á,C ƒ6 ³Qƒ¢q FŠh…!Àp  	   6\F`Vdö€ˆ4@˜p€"@Ó‹8\        a   y   K,   
   (")Ã€’ AP`(Ã ´ Xc(Ã ´ TƒC‘ € 3ÃLD ¤Æ0 ©1ÌD@j3ÃLD ¤Æ0 ©1ÌD@j3ø ¤Æ0¡ ©1F(Ù F$Ø F × FÖ FÕ FÔ FÓ 3†:ƒY†@	#Š: šAÍ10 €
!Œ@‚ cP. ÄpC€…Á,ƒ0¤ŒÁˆ €Y‚–AÎ1( `„`0â	€1bP  /`0aÁ Œ P
ƒë ­ÇnF!fˆ$ n{Œñõ8…`0"€àcĞŒƒ ÖAhÃ*„Á,CaDƒÂ`P
ƒ1bp À9ƒPÊ1Şğ²FÃ Ì´ƒğcê # Ä1¶0ÜÜÌ2H@p0F
 ˜9f	Y‚„Ò`Œ @Á,‚á@      F`DÄC “$ED@Ñ˜iÀ<é™p@4qYq@p™q@€Ùq@v "ÌÃ"aÈ LN$—e‘       a      C,      (
e€€h    Œá† ƒY†@F pƒn–@@   a      C,      (
e€€h    Œá† ƒY†@F `ƒn–@@   a      C,      (’(r  (aû( ÀP† hˆ Œá†@Â`–!‚ Ş€(Ã1   Ä€PcŒ  Á`Dj€Á Ìa   %   H,      (   30ÃLD ŒÆ0 £1FÆ F`0 ƒÀ,A@Án
4˜eŒ€†1Ş cP0èÃB ³2#–  f	Y‚‚’a‚Áˆ%€Y‚`0¢I ˜%8¨„   v&P Í@\     a   %   H,      (   30ÃLD ŒÆ0 £1FÆ F`0 ƒÀ,A@Án
4˜eŒ€†1Ş`cP0èÃB ³2#–  f	Y‚‚’a‚Áˆ%€Y‚`0¢I ˜%8¨„   v&P Í@\     a      A,      ( 30Ã`D0 c¼!4¼`0"ğ€†1ŞĞ`F`0     &        a   &   E,      ("¡ÀP† h  30ÃLD ŒÆ0!@ÃnÂ f" bŒ ÀÁ`D c¸! ƒ0˜e†€1b@ À„Œ ì  Ö# ÔA0áe0 ³Ã,á@     &P Í@\v°H“ópĞ4Ä     a      G,      ( 30ÃLD ŒÆ0@Án¼0˜eŠ€†1b@ €Ã„Á,ƒ0ƒ ³cÄ€  6f	ˆY‚b0! ˜%0„     &pĞ4Ä       a      A,      ( 30ÃLD ŒÆ0!@Â1   ‚Áˆ! Æˆ gd     &P Í@\VpĞ4Ä    a   1   N,      (   3 ÃLD ˆÆ0x0x0KP0†f# aŒ7FŒá†@À`–a :Æ`D À,A3KP2,`@0¡0KF(g0 ³)c¸!hĞ`–abÆxCk¨A@ÁnÖ f% hŒ @Á,2K°4,°@0A0KpFTp  ³U ƒp    V         a   [   I,      (")Ã€¢ AP`(Ã ´ Lc(Ã ´ HƒC €C‘ € 30ÃLD ŒÆ0Àh3
0Ã`á c¸!Hƒ0˜e`0¢PƒŒÌ` ÈdcÄà €6(!Œ@‚ cP. ÄpC0…Á,ƒ0¤
Â€Œp` è5†#b# zÆ`D€À,Á@Ğ iŒ PB0A@Ô1( À0Œ ` F øƒÁˆò€Êc7}³ÄĞ6=Æxy„B0@ê1h†i‚ƒ Ìa¨=©Ç18  „àLa¸!80˜e(Œ€Ê`Œ 0gÌ³‘Á1  €‚YÃ    öpH ó¤SdÂÒÄeÎBdYs "ÌÃ"          /** @file sys.c
	@brief
	This file contains system types definitions

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "sys.h"

// Little endian

FORCEINLINE uint16 READ_LE_UINT16(const void *ptr) {
	const uint8 *b = (const uint8 *)ptr;
	return (b[1] << 8) | b[0];
}

FORCEINLINE int16 READ_LE_INT16(const void *ptr) {
	return (int16)READ_LE_UINT16(ptr);
}

FORCEINLINE uint32 READ_LE_UINT32(const void *ptr) {
	const uint8 *b = (const uint8 *)ptr;
	return (b[3] << 24) | (b[2] << 16) | (b[1] << 8) | (b[0]);
}

FORCEINLINE int32 READ_LE_INT32(const void *ptr) {
	return (int32)READ_LE_UINT32(ptr);
}

FORCEINLINE void WRITE_LE_UINT16(void *ptr, uint16 value) {
	uint8 *b = (uint8 *)ptr;
	b[0] = (uint8)(value >> 0);
	b[1] = (uint8)(value >> 8);
}

FORCEINLINE void WRITE_LE_INT16(void *ptr, int16 value) {
	WRITE_LE_UINT16(ptr, (uint16)value);
}

FORCEINLINE void WRITE_LE_UINT32(void *ptr, uint32 value) {
	uint8 *b = (uint8 *)ptr;
	b[0] = (uint8)(value >>  0);
	b[1] = (uint8)(value >>  8);
	b[2] = (uint8)(value >> 16);
	b[3] = (uint8)(value >> 24);
}

FORCEINLINE void WRITE_LE_INT32(void *ptr, int32 value) {
	WRITE_LE_UINT32(ptr, (uint32)value);
}

// TODO: big endian

// Main endian functions

FORCEINLINE uint8 READ_BYTE(const void *ptr) {
	return *((const uint8 *)ptr);
}

FORCEINLINE uint16 READ_UINT16(const void *ptr) {
	return READ_LE_UINT16(ptr);
}

FORCEINLINE int16 READ_INT16(const void *ptr) {
	return READ_LE_INT16(ptr);
}

FORCEINLINE uint32 READ_UINT32(const void *ptr) {
	return READ_LE_UINT32(ptr);
}

FORCEINLINE int32 READ_INT32(const void *ptr) {
	return READ_LE_INT32(ptr);
}

FORCEINLINE void WRITE_UINT16(void *ptr, uint16 value) {
	WRITE_LE_UINT16(ptr, value);
}

FORCEINLINE void WRITE_INT16(void *ptr, int16 value) {
	WRITE_LE_INT16(ptr, value);
}

FORCEINLINE void WRITE_UINT32(void *ptr, uint32 value) {
	WRITE_LE_UINT32(ptr, value);
}

FORCEINLINE void WRITE_INT32(void *ptr, int32 value) {
	WRITE_LE_INT32(ptr, value);
}
/** @file sys.h
	@brief
	This file contains system types definitions

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef SYS_H
#define SYS_H

#include <stdlib.h>
#include <math.h>

#define Rnd(x) rand()%x
#define Abs(x) abs(x)

// TYPES

typedef unsigned char byte;

typedef unsigned char uint8;
typedef char int8;

typedef unsigned short uint16;
typedef short int16;

typedef unsigned int uint32;
typedef int int32;

typedef float int64;

// ENDIAN

#ifdef UNIX
#define FORCEINLINE static __inline__
#elif MINGW32
#define FORCEINLINE inline
#else
#define FORCEINLINE __forceinline
#endif

#endif
BCÀŞ!  x   ‚        #‘AÈI29’„%‹b€EB’B$28I
2D$H
!#ÄR€!r$ÈHb¨ ¨@Æğ   ‰   	   2"H d…“ ¤„“ ã„¡L‚Œ„$L    °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€y   C X ;„ƒ;œØC9ÈÃ<¤Ã;¸ÌĞŒPØì¡Ü È¡Ü¦     y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p        /** @file text.c
	@brief
	This file contains dialogues processing.
	It contains text and font functions.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include <math.h>

#include "text.h"
#include "main.h"
#include "hqrdepack.h"
#include "resources.h"
#include "sdlengine.h"
#include "menu.h"
#include "interface.h"
#include "lbaengine.h"
#include "keyboard.h"
#include "screens.h"
#include "renderer.h"
#include "sound.h"

// RECHECK THIS LATER
int32 currentBankIdx = -1; // textVar1
uint8 textVar2[256];
uint8 textVar3;

/** Dialogue text pointer */
uint8 *dialTextPtr;  // bufText
/** Dialogue entry order pointer */
uint8 *dialOrderPtr; // bufOrder
/** Number of dialogues text entries */
int16 numDialTextEntries;

// TODO: refactor this
int32 wordSizeChar;
int32 wordSizePixel;

int16 spaceChar = 0x20;

/** FLA movie extension */
#define VOX_EXT ".vox"
/** Common movie directory */
#define VOX_DIR "vox/"

int8 * LanguagePrefixTypes[] = {
	"EN_",
	"FR_",
	"DE_",
	"SP_",
	"IT_"
};

int8 * LanguageSufixTypes[] = {
	"sys",
	"cre",
	"gam",
	"000",
	"001",
	"002",
	"003",
	"004",
	"005",
	"006",
	"007",
	"008",
	"009",
	"010",
	"011"
};


void initVoxBank(int32 bankIdx) {
	// get the correct vox hqr file
	memset(currentVoxBankFile, 0, sizeof(int8));
	sprintf(currentVoxBankFile, VOX_DIR);
	strcat(currentVoxBankFile, LanguagePrefixTypes[cfgfile.LanguageId]);
	strcat(currentVoxBankFile, LanguageSufixTypes[bankIdx]);
	strcat(currentVoxBankFile, VOX_EXT);

	// TODO check the rest to reverse
}


int32 initVoxToPlay(int32 index) { // setVoxFileAtDigit
	int32 i = 0;
	int32 currIdx = 0;
	int32 orderIdx = 0;

	int16 *localOrderBuf = (int16 *) dialOrderPtr;

	voxHiddenIndex = 0;
	hasHiddenVox = 0;

	// choose right text from order index
	for (i = 0; i < numDialTextEntries; i++) {
		orderIdx = *(localOrderBuf++);
		if (orderIdx == index) {
			currIdx = i;
			break;
		}
	}

	currDialTextEntry = currIdx;

	playVoxSample(currDialTextEntry);

	return 1;
}

int32 playVox(int32 index) {
	if (cfgfile.LanguageCDId && index) {
		if (hasHiddenVox && !isSamplePlaying(index)) {
			playVoxSample(index);
			return 1;
		}
	}

	return 0;
}

int32 playVoxSimple(int32 index) {
	if (cfgfile.LanguageCDId && index) {
		playVox(index);

		if (isSamplePlaying(index)) {
			return 1;
		}
	}

	return 0;
}

void stopVox(int32 index) {
	hasHiddenVox = 0;
	stopSample(index);
}



/** Initialize dialogue
	@param bankIdx Text bank index*/
void initTextBank(int32 bankIdx) { // InitDial
	int32 langIdx;
	int32 hqrSize;

	// don't load if we already have the dialogue text bank loaded
	if (bankIdx == currentBankIdx)
		return;

	currentBankIdx = bankIdx;
	// RECHECK THIS LATER
	textVar2[0] = textVar3;

	// get index according with language
	langIdx = (cfgfile.LanguageId * 14) * 2  + bankIdx * 2;

	hqrSize = hqrGetallocEntry(&dialOrderPtr, HQR_TEXT_FILE, langIdx);

	numDialTextEntries = hqrSize / 2;

	hqrSize = hqrGetallocEntry(&dialTextPtr, HQR_TEXT_FILE, ++langIdx);

	if (cfgfile.LanguageCDId) {
		initVoxBank(bankIdx);
	}
}

/** Draw a certain character in the screen
	@param x X coordinate in screen
	@param y Y coordinate in screen
	@param character ascii character to display */
void drawCharacter(int32 x, int32 y, uint8 character) { // drawCharacter
	uint8 sizeX;
	uint8 sizeY;
	uint8 param1;
	uint8 param2;
	uint8 *data;
	uint8 *screen;

	// int temp=0;
	int32 toNextLine;
	uint8 index;

	// char color;
	uint8 usedColor;
	uint8 number;
	uint8 jump;

	int32 i;

	int32 tempX;
	int32 tempY;

	data = fontPtr + *((int16 *)(fontPtr + character * 4));

	dialTextSize = sizeX = *(data++);
	sizeY = *(data++);

	param1 = *(data++);
	param2 = *(data++);

	x += param1;
	y += param2;

	usedColor = dialTextColor;

	screen = frontVideoBuffer + screenLookupTable[y] + x;

	tempX = x;
	tempY = y;

	toNextLine = SCREEN_WIDTH - sizeX;

	do {
		index = *(data++);
		do {
			jump = *(data++);
			screen += jump;
			tempX += jump;
			if (--index == 0) {
				screen += toNextLine;
				tempY++;
				tempX = x;
				sizeY--;
				if (sizeY <= 0) {
					return;
				}
				break;
			} else {
				number = *(data++);
				for (i = 0; i < number; i++) {
					if (tempX >= SCREEN_TEXTLIMIT_LEFT && tempX < SCREEN_TEXTLIMIT_RIGHT && tempY >= SCREEN_TEXTLIMIT_TOP && tempY < SCREEN_TEXTLIMIT_BOTTOM)
						frontVideoBuffer[SCREEN_WIDTH*tempY + tempX] = usedColor;

					screen++;
					tempX++;
				}

				if (--index == 0) {
					screen += toNextLine;
					tempY++;
					tempX = x;

					sizeY--;
					if (sizeY <= 0) {
						return;
					}
					break;
				}
			}
		} while (1);
	} while (1);

}

/** Draw character with shadow
	@param x X coordinate in screen
	@param y Y coordinate in screen
	@param character ascii character to display
	@param color character color */
void drawCharacterShadow(int32 x, int32 y, uint8 character, int32 color) { // drawDoubleLetter
	int32 left, top, right, bottom;

	if (character != 0x20)
	{
		// shadow color
		setFontColor(0);
		drawCharacter(x + 2, y + 4, character);

		// text color
		setFontColor(color);
		drawCharacter(x, y, character);

		left = x;
		top = y;
		// FIXME: get right font size
		right = x + 32;
		bottom = y + 38;

		copyBlockPhys(left, top, right, bottom);
	}
}

/** Display a certain dialogue text in the screen
	@param x X coordinate in screen
	@param y Y coordinate in screen
	@param dialogue ascii text to display */
void drawText(int32 x, int32 y, int8 *dialogue) { // Font
	uint8 currChar;

	if (fontPtr == 0)   // if the font is not defined
		return;

	do {
		currChar = (uint8) * (dialogue++); // read the next char from the string

		if (currChar == 0) // if the char is 0x0, -> end of string
			break;

		if (currChar == 0x20)  // if it's a space char
			x += dialCharSpace;
		else {
			dialTextSize = *(fontPtr + (*((int16 *)(fontPtr + currChar * 4))));  // get the length of the character
			drawCharacter(x, y, currChar); // draw the character on screen
			// add the length of the space between 2 characters
			x += dialSpaceBetween;
			// add the length of the current character
			x += dialTextSize;
		}
	} while (1);
}

/** Gets dialogue text width size
	@param dialogue ascii text to display */
int32 getTextSize(int8 *dialogue) {  // SizeFont
	uint8 currChar;
	dialTextSize = 0;

	do {
		currChar = (uint8) * (dialogue++);

		if (currChar == 0)
			break;

		if (currChar == 0x20) {
			dialTextSize += dialCharSpace;
		} else {
			dialTextSize += dialSpaceBetween;
			dialTextSize += *(fontPtr + *((int16 *)(fontPtr + currChar * 4)));
		}
	} while (1);

	return (dialTextSize);
}

void initDialogueBox() { // InitDialWindow
	blitBox(dialTextBoxLeft, dialTextBoxTop, dialTextBoxRight, dialTextBoxBottom, (int8*)workVideoBuffer, dialTextBoxLeft, dialTextBoxTop, (int8*)frontVideoBuffer);

	if (newGameVar4 != 0) {
		drawBox(dialTextBoxLeft, dialTextBoxTop, dialTextBoxRight, dialTextBoxBottom);
		drawTransparentBox(dialTextBoxLeft + 1, dialTextBoxTop + 1, dialTextBoxRight - 1, dialTextBoxBottom - 1, 3);
	}

	copyBlockPhys(dialTextBoxLeft, dialTextBoxTop, dialTextBoxRight, dialTextBoxBottom);
	printText8Var3 = 0;
	blitBox(dialTextBoxLeft, dialTextBoxTop, dialTextBoxRight, dialTextBoxBottom, (int8*)frontVideoBuffer, dialTextBoxLeft, dialTextBoxTop, (int8*)workVideoBuffer);
}

void initInventoryDialogueBox() { // SecondInitDialWindow
	blitBox(dialTextBoxLeft, dialTextBoxTop, dialTextBoxRight, dialTextBoxBottom, (int8*)workVideoBuffer, dialTextBoxLeft, dialTextBoxTop, (int8*)frontVideoBuffer);
	copyBlockPhys(dialTextBoxLeft, dialTextBoxTop, dialTextBoxRight, dialTextBoxBottom);
	printText8Var3 = 0;
}

// TODO: refactor this code
void initText(int32 index) { // initText
	printTextVar13 = 0;

	if (!getText(index)) {
		return;
	}

	printText8Ptr1 = buf1;
	printText8Ptr2 = buf2;

	printTextVar13 = 1;

	printText8Var1 = 0;
	buf1[0] = 0;
	buf2[0] = 0;
	printText8Var2 = index;
	printText8Var3 = 0;
	TEXT_CurrentLetterX = dialTextBoxLeft + 8;
	printText8Var5 = 0;
	printText8Var6 = 0;
	TEXT_CurrentLetterY = dialTextBoxTop + 8;
	printText8Var8 = currDialTextPtr;

	// lba font is get while engine start
	setFontParameters(2, 7);
}

void initProgressiveTextBuffer() {
	int32 i = 0;

	buf2[0] = 0;

	while (i < dialTextBufferSize) {
		strcat((char*)buf2, " ");
		i++;
	};

	printText8Ptr2 = buf2;
	addLineBreakX = 16;
	printText8Var1 = 0;
}

void printText8Sub4(int16 a, int16 b, int16 c) {
	int32 temp;
	int32 counter2 = 0;
	int32 var1;
	int32 var2;

	if (printText8Var3 < 32) {
		temp = printText8Var3 * 3;
		pt8s4[temp] = c;
		pt8s4[temp+1] = a;
		pt8s4[temp+2] = b;

		printText8Var3++;
	} else {
		while (counter2 < 31) {
			var1 = (counter2 + 1) * 3;
			var2 = counter2 * 3;
			pt8s4[var2] = pt8s4[var1];
			pt8s4[var2+1] = pt8s4[var1+1];
			pt8s4[var2+2] = pt8s4[var1+2];
			counter2++;
		};
		pt8s4[93] = c;
		pt8s4[94] = a;
		pt8s4[95] = b;
	}
}

void getWordSize(uint8 *arg1, uint8 *arg2) {
	int32 temp = 0;
	uint8 *arg2Save = arg2;

	while (*arg1 != 0 && *arg1 != 1 && *arg1 != 0x20) {
		temp++;
		*arg2++ = *arg1++;
	}

	wordSizeChar = temp;
	*arg2 = 0;
	wordSizePixel = getTextSize((int8*)arg2Save);
}

void processTextLine() {
	int16 var4;
	uint8 *buffer;
	uint8 *temp;

	buffer = printText8Var8;
	dialCharSpace = 7;
	var4 = 1;

	addLineBreakX = 0;
	printText8PrepareBufferVar2 = 0;
	buf2[0] = 0;

	for (;;)
	{
		if (*buffer == 0x20) {
			buffer++;
			continue;
		}

		if (*buffer != 0) {
			printText8Var8 = buffer;
			getWordSize(buffer, buf1);
			if (addLineBreakX + dialCharSpace + wordSizePixel < dialTextBoxParam2) {
				temp = buffer + 1;
				if (*buffer == 1) {
					var4 = 0;
					buffer = temp;
				} else {
					if (*buf1 == 0x40) {
						var4 = 0;
						buffer = temp;
						if (addLineBreakX == 0) {
							addLineBreakX = 7;
							*((int16 *)buf2) = spaceChar;
						}
						if (buf1[1] == 0x50) {
							printText8Var1 = dialTextBoxParam1;
							buffer++;
						}
					} else {
						buffer += wordSizeChar;
						printText8Var8 = buffer;
						strcat((char*)buf2, (char*)buf1);
						strcat((char*)buf2, " ");  // not 100% accurate
						printText8PrepareBufferVar2++;

						addLineBreakX += wordSizePixel + dialCharSpace;
						if (*printText8Var8 != 0) {
							printText8Var8++;
							continue;
						}
					}
				}
			}
		}
		break;
	}

	if (printText8PrepareBufferVar2 != 0)
		printText8PrepareBufferVar2--;

	if (*printText8Var8 != 0 && var4 == 1) {
		dialCharSpace += (dialTextBoxParam2 - addLineBreakX) / printText8PrepareBufferVar2;
		printText10Var1 = dialTextBoxParam2 - addLineBreakX - dialTextBoxParam2 - addLineBreakX;  // stupid... recheck
	}

	printText8Var8 = buffer;

	printText8Ptr2 = buf2;

}

// draw next page arrow polygon
void printText10Sub() { // printText10Sub()
	vertexCoordinates[0] = dialTextStopColor;
	vertexCoordinates[1] = dialTextBoxRight - 3;
	vertexCoordinates[2] = dialTextBoxBottom - 24;
	vertexCoordinates[3] = dialTextStopColor;
	vertexCoordinates[4] = dialTextBoxRight - 24;
	vertexCoordinates[5] = dialTextBoxBottom - 3;
	vertexCoordinates[6] = dialTextStartColor;
	vertexCoordinates[7] = vertexCoordinates[1];
	vertexCoordinates[8] = vertexCoordinates[5];

	polyRenderType = 0; // POLYGONTYPE_FLAT
	numOfVertex = 3;

	if (computePolygons())
	{
		renderPolygons(polyRenderType, dialTextStopColor);
	}

	copyBlockPhys(dialTextBoxRight - 24, dialTextBoxBottom - 24, dialTextBoxRight - 3, dialTextBoxBottom - 3);
}

void printText10Sub2() { // printText10Sub2()
	int32 currentLetter;
	int32 currentIndex;
	int32 counter;
	int32 counter2;
	int16 *ptr;

	currentLetter = printText8Var3;
	currentLetter--;

	currentIndex = currentLetter * 3;

	ptr = pt8s4 + currentIndex;

	sdldelay(15);

	counter = printText8Var3;
	counter2 = dialTextStartColor;

	while (--counter >= 0) {
		setFontColor(counter2);
		drawCharacterShadow(*(ptr + 1), *(ptr + 2), (uint8)*ptr, counter2);
		counter2 -= dialTextStepSize;
		if (counter2 > dialTextStopColor)
			counter2 = dialTextStopColor;
		ptr -= 3;
	};

}

void TEXT_GetLetterSize(uint8 character, int32 *pLetterWidth, int32 *pLetterHeight, uint8 * pFont) { // TEXT_GetLetterSize
	uint8 *temp;

	temp = (uint8*) (pFont + *((int16 *)(pFont + character * 4)));
	*pLetterWidth = *(temp);
	*pLetterHeight = *(temp + 1);
}

// TODO: refactor this code
int printText10() { // printText10()
	int32 charWidth, charHeight; // a, b

	if (printTextVar13 == 0) {
		return 0;
	}

	if (*(printText8Ptr2) == 0) {
		if (printText8Var5 != 0) {
			if (newGameVar5 != 0) {
				printText10Sub();
			}
			printTextVar13 = 0;
			return 0;
		}
		if (printText8Var6 != 0) {
			blitBox(dialTextBoxLeft, dialTextBoxTop, dialTextBoxRight, dialTextBoxBottom, (int8*)workVideoBuffer, dialTextBoxLeft, dialTextBoxTop, (int8*)frontVideoBuffer);
			copyBlockPhys(dialTextBoxLeft, dialTextBoxTop, dialTextBoxRight, dialTextBoxBottom);
			printText8Var3 = 0;
			printText8Var6 = 0;
			TEXT_CurrentLetterX = dialTextBoxLeft + 8;
			TEXT_CurrentLetterY = dialTextBoxTop + 8;
		}
		if (*(printText8Var8) == 0) {
			initProgressiveTextBuffer();
			printText8Var5 = 1;
			return 1;
		}
		processTextLine();
	}

	// RECHECK this later
	if (*(printText8Ptr2) == 0) {
		return 1;
	}

	printText8Sub4(TEXT_CurrentLetterX, TEXT_CurrentLetterY, *printText8Ptr2);
	printText10Sub2();
	TEXT_GetLetterSize(*printText8Ptr2, &charWidth, &charHeight, (uint8*)fontPtr);

	if (*(printText8Ptr2) != 0x20) {
		TEXT_CurrentLetterX += charWidth + 2;
	} else {
		if (printText10Var1 != 0) {
			TEXT_CurrentLetterX++;
			printText10Var1--;
		}
		TEXT_CurrentLetterX += dialCharSpace;
	}

	// next character
	printText8Ptr2++;

	if (*(printText8Ptr2) != 0)
		return 1;

	TEXT_CurrentLetterY += 38;
	TEXT_CurrentLetterX = dialTextBoxLeft + 8;

	if (printText8Var6 == 1 && printText8Var5 == 0) {
	  printText10Sub();
	  return 2;
	}

	printText8Var1++;
	if (printText8Var1 < dialTextBoxParam1) {
		return 1;
	}

	initProgressiveTextBuffer();
	printText8Var6 = 1;

	if (*(printText8Var8) == 0) {
		printText8Var5 = 1;
	}

	return 1;
}

// TODO: refactor this code
void drawTextFullscreen(int32 index) { // printTextFullScreen
	int32 printedText;
	int32 skipText = 0;

	saveClip();
	resetClip();
	copyScreen(frontVideoBuffer, workVideoBuffer);

	// get right VOX entry index
	if (cfgfile.LanguageCDId) {
		initVoxToPlay(index);
	}
	
	// if we don't display text, than still plays vox file
	if (cfgfile.FlagDisplayText) {
		initText(index);
		initDialogueBox();

		do {
			readKeys();
			printedText = printText10();
			playVox(currDialTextEntry);

			if (printedText == 2) {
				do {
					readKeys();
					if (skipIntro == 0 && skippedKey == 0 && pressedKey == 0) {
						break;
					}
					playVox(currDialTextEntry);
					sdldelay(1);
				} while(1);

				do {
					readKeys();
					if (skipIntro != 0 || skippedKey != 0 || pressedKey != 0) {
						break;
					}
					playVox(currDialTextEntry);
					sdldelay(1);
				} while(1);
			}

			if (skipIntro == 1) {
				skipText = 1;
			}
			
			if (!printedText && !isSamplePlaying(currDialTextEntry)) {
				break;
			}

			sdldelay(1);
		} while(!skipText);

		hasHiddenVox = 0;

		if (cfgfile.LanguageCDId && isSamplePlaying(currDialTextEntry)) {
			stopVox(currDialTextEntry);
		}

		printTextVar13 = 0;

		if (printedText != 0) {
			loadClip();
			return;
		}

		if (skipText != 0) {
			loadClip();
			return;
		}

		// RECHECK this later
		// wait displaying text
		do {
			readKeys();
			sdldelay(1);
		} while(skipIntro || skippedKey || pressedKey);

		// RECHECK this later
		// wait key to display next text
		do {
			readKeys();
			if (skipIntro != 0) {
				loadClip();
				return;
			}
			if (skippedKey != 0) {
				loadClip();
				return;
			}
			sdldelay(1);
		} while(!pressedKey);
	} else { // RECHECK THIS
		while (playVox(currDialTextEntry) && skipIntro != 1 );
		hasHiddenVox = 0;
		voxHiddenIndex = 0;
	}

	if (cfgfile.LanguageCDId && isSamplePlaying(currDialTextEntry)) {
		stopVox(currDialTextEntry);
	}

	loadClip();
}

void setFont(uint8 *font, int32 spaceBetween, int32 charSpace) {
	fontPtr = font;
	dialCharSpace = charSpace;
	dialSpaceBetween = spaceBetween;
}

/** Set font type parameters
	@param spaceBetween number in pixels of space between characters
	@param charSpace number in pixels of the character space */
void setFontParameters(int32 spaceBetween, int32 charSpace) {
	dialSpaceBetween = spaceBetween;
	dialCharSpace = charSpace;
}

/** Set the font cross color
	@param color color number to choose */
void setFontCrossColor(int32 color) { // TestCoulDial
	dialTextStepSize = -1;
	dialTextBufferSize = 14;
	dialTextStartColor = color << 4;
	dialTextStopColor = (color << 4) + 12;
}

/** Set the font color
	@param color color number to choose */
void setFontColor(int32 color) {
	dialTextColor = color;
}

/** Set font color parameters to process cross color display
	@param stopColor color number to stop
	@param startColor color number to start
	@param stepSize step size to change between those colors */
void setTextCrossColor(int32 stopColor, int32 startColor, int32 stepSize) {
	dialTextStartColor = startColor;
	dialTextStopColor = stopColor;
	dialTextStepSize = stepSize;
	dialTextBufferSize = ((startColor - stopColor) + 1) / stepSize;
}

/** Get dialogue text into text buffer
	@param index dialogue index */
int32 getText(int32 index) { // findString
	int32 currIdx = 0;
	int32 orderIdx = 0;
	int32 numEntries;
	int32 ptrCurrentEntry;
	int32 ptrNextEntry;

	int16 *localTextBuf = (int16 *) dialTextPtr;
	int16 *localOrderBuf = (int16 *) dialOrderPtr;

	numEntries = numDialTextEntries;

	// choose right text from order index
	do {
		orderIdx = *(localOrderBuf++);
		if (orderIdx == index)
			break;
		currIdx++;
	} while (currIdx < numDialTextEntries);

	if (currIdx >= numEntries)
		return 0;

	ptrCurrentEntry = localTextBuf[currIdx];
	ptrNextEntry = localTextBuf[currIdx + 1];

	currDialTextPtr = (dialTextPtr + ptrCurrentEntry);
	currDialTextSize = ptrNextEntry - ptrCurrentEntry;
	numDialTextEntries = numEntries;

	// RECHECK: this was added for vox playback
	currDialTextEntry = currIdx;

	return 1;
}

/** Copy dialogue text
	@param src source text buffer
	@param dst destination text buffer
	@param size text size */
void copyText(int8 *src, int8 *dst, int32 size) { // copyStringToString
	int32 i;
	for (i = 0; i < size; i++)
		*(dst++) = *(src++);
}

/** Gets menu dialogue text
	@param index text index to display
	@param dialogue dialogue text buffer to display */
void getMenuText(int32 index, int8 *text) { // GetMultiText
	if (index == currMenuTextIndex) {
		if (currMenuTextBank == currentTextBank) {
			strcpy(text, currMenuTextBuffer);
			return;
		}
	}
	if (!getText(index)) {
		// if doesn't have text
		text[0] = 0;
		return;
	}

	if ((currDialTextSize - 1) > 0xFF)
		currDialTextSize = 0xFF;

	copyText((int8 *) currDialTextPtr, text, currDialTextSize);
	currDialTextSize++;
	copyText(text, currMenuTextBuffer, currDialTextSize);

	currMenuTextIndex = index;
	currMenuTextBank = currentTextBank;
}

void textClipFull() { // newGame2
	dialTextBoxLeft = 8;
	dialTextBoxTop = 8;
	dialTextBoxRight = 631;

	dialTextBoxBottom = 471;
	dialTextBoxParam1 = 11;
	dialTextBoxParam2 = 607;
}

void textClipSmall() { // newGame4
	dialTextBoxLeft = 16;
	dialTextBoxTop = 334;
	dialTextBoxRight = 623;
	dialTextBoxBottom = 463;
	dialTextBoxParam1 = 3;
	dialTextBoxParam2 = 591;
}

void drawAskQuestion(int32 index) { // MyDial
	int32 textStatus = 1;

	// get right VOX entry index
	if (cfgfile.LanguageCDId) {
		initVoxToPlay(index);
	}

	initText(index);
	initDialogueBox();

	do {
		readKeys();
		textStatus = printText10();
		
		if (textStatus == 2) {
			do {
				readKeys();
				playVox(currDialTextEntry);
				sdldelay(1);
			} while(skipIntro || skippedKey || pressedKey);

			do {
				readKeys();
				playVox(currDialTextEntry);
				sdldelay(1);
			} while(!skipIntro && !skippedKey && !pressedKey);
		}

		sdldelay(1);
	} while(textStatus);

	if (cfgfile.LanguageCDId) {
		while(playVoxSimple(currDialTextEntry));

		hasHiddenVox = 0;
		voxHiddenIndex = 0;

		if(isSamplePlaying(currDialTextEntry)) {
			stopVox(currDialTextEntry);
		}
	}

	printTextVar13 = 0;
}
/** @file text.h
	@brief
	This file contains dialogues processing. It contains text and font functions.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2008-2013 Prequengine team
	Copyright (C) 2002-2007 The TwinEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef DIALOGUES_H
#define DIALOGUES_H

#include "sys.h"

//TODO: add all 14 colors here for future use
/** White color value */
#define WHITE_COLOR_0		0

/** Current text bank */
int32 currentTextBank;
/** Current dialogue text size */
int32 currDialTextSize;
/** Current dialogue text pointer */
uint8 *currDialTextPtr;

/** Font buffer pointer */
uint8 * fontPtr;

/** Dialogue text size */
int32 dialTextSize;
/** Pixel size between dialogue text */
int32 dialSpaceBetween;
/** Pixel size of the space character */
int32 dialCharSpace;
/** Dialogue text color */
int32 dialTextColor;

/** Dialogue text start color for cross coloring dialogues */
int32 dialTextStartColor;
/** Dialogue text stop color for cross coloring dialogues */
int32 dialTextStopColor;
/** Dialogue text step size for cross coloring dialogues */
int32 dialTextStepSize;
/** Dialogue text buffer size for cross coloring dialogues */
int32 dialTextBufferSize;

int32 dialTextBoxLeft;   // dialogueBoxLeft
int32 dialTextBoxTop;    // dialogueBoxTop
int32 dialTextBoxRight;  // dialogueBoxRight
int32 dialTextBoxBottom; // dialogueBoxBottom

int32 dialTextBoxParam1; // dialogueBoxParam1
int32 dialTextBoxParam2; // dialogueBoxParam2

// TODO: refactor all this variables and related functions
int32 printTextVar13;
uint8 buf1[256];
uint8 buf2[256];
uint8 *printText8Ptr1;
uint8 *printText8Ptr2;
int32 printText8Var1;
int32 printText8Var2;
int32 printText8Var3;
int32 TEXT_CurrentLetterX;
int32 printText8Var5;
int32 printText8Var6;
int32 TEXT_CurrentLetterY;
uint8 *printText8Var8;
int32 newGameVar4;
int32 newGameVar5;
int32 hasHiddenVox; // printTextVar5
int32 voxHiddenIndex;
int32 printText10Var1;
int32 addLineBreakX;
int16 pt8s4[96];
int32 printText8PrepareBufferVar2;

int32 currDialTextEntry; // ordered entry
int32 nextDialTextEntry; // ordered entry
int8 currentVoxBankFile[256];

int32 showDialogueBubble;


/** Initialize dialogue
	@param bankIdx Text bank index*/
void initTextBank(int32 bankIdx);

/** Display a certain dialogue text in the screen
	@param x X coordinate in screen
	@param y Y coordinate in screen
	@param dialogue ascii text to display */
void drawText(int32 x, int32 y, int8 *dialogue);

void drawTextFullscreen(int32 index);

/** Gets dialogue text width size
	@param dialogue ascii text to display */
int32 getTextSize(int8 *dialogue);

void initDialogueBox();
void initInventoryDialogueBox();

void initText(int32 index);
int printText10();

void setFont(uint8 *font, int32 spaceBetween, int32 charSpace);

/** Set font type parameters
	@param spaceBetween number in pixels of space between characters
	@param charSpace number in pixels of the character space */
void setFontParameters(int32 spaceBetween, int32 charSpace);

/** Set the font cross color
	@param color color number to choose */
void setFontCrossColor(int32 color);

/** Set the font color
	@param color color number to choose */
void setFontColor(int32 color);

/** Set font color parameters to precess cross color display
	@param stopColor color number to stop
	@param startColor color number to start
	@param stepSize step size to change between those colors */
void setTextCrossColor(int32 stopColor, int32 startColor, int32 stepSize);

/** Get dialogue text into text buffer
	@param index dialogue index */
int32 getText(int32 index);

/** Gets menu dialogue text
	@param index text index to display
	@param dialogue dialogue text buffer to display */
void getMenuText(int32 index, int8 *text);

void textClipFull();
void textClipSmall();

void drawAskQuestion(int32 index);

int32 playVox(int32 index);
int32 playVoxSimple(int32 index);
void stopVox(int32 index);
int32 initVoxToPlay(int32 index);

#endif
BCÀŞ!  0  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q  ¢   f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØ@°l †ÿÿÿÿ iClÿÿÿÿ?ìPó0m òPãóPm`ğĞá@€9„;ÌC9 „;¼C˜ƒ<„C;”CÀÃ;¤ƒ;ĞC9ÈC”;¤C; ô õPÀàïĞæ áĞåĞğğéàôPòĞåÀéĞmàïàmÀåæ îğmî`óĞæ mĞá@è ˜C8°Ã<”@¸Ã;´;„ƒ;ÌC˜<´A;„= `áÀóP 1ôã°m òğôPã@ï m õ`æPòĞóúP  D=¸Ã<„ƒ9”C˜<´A;„= `áÀóP QóPm0ï`ôĞæÀïô ˜C8°Ã<”°(@6F `ˆC °2 Ø"	 1   I     ‚`‚ b‚Pã@‚	BLŠ	ƒq ‚  ‰   `   2"È	 d…“#¤„“#ã„¡LŒ„äLÜÃ` "Á’*!„È‡)P€@Œ, #9@¸Hš"J˜|Îi
Äø…@ D                     ’Ğ!¡ TI]L@™Ğ&9ÔIË }Òƒ@¡T Ğ(%TJ’@©D8Ğ*‘ ÔJ½ò?@@±³¤)¢„É×„É‰L§"Ø)¢„	 @³4 P-t£AÎH—ó â%€|# E (8Gx   C"Öp8±‡ÃE  HY å  f!€  œ¥   AK   ’ ˆZÀ¬% ¶$@   8  Ò    â– ·@@@à2 × @äR 	ÀÌ% º@Rx  ˆ]    w!€‡€àe $˜     °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:ÄH #DD úæà?ÀŠˆH   ;#‘$    v(F@"I  @ ìPŒ D’  € Ø¡‰$  ÀÄšÀ;#8‘$    v(F€"I  @ ìPŒ E’  € Ø¡Š$  °C1‚I  `‡b,’  ÀÅZ$	  €Š¸H   ;#x‘$    v(F #I  @ ìPŒ F’  € Ø¡Œ$  °C1‚I  `‡b4’  ÀÅj$	   .Øf£M°Ê¸I   œ Àå	Ş$	   Rlg€?pøçÀ?PøçD06Ú# H±œÁàœşÀI±œ8ÁàœşÀàœşÀàœşÀI±œşÀàœşÀÙhŒÁÙhŒÁàœşÀàœşÀàœşÀI±œÁà|‡‚q’   üS#'(ü3À8ü3À8ü3À8ü“3'(üsà(ü3À8üsà(şrà(ü3À8ü3À8m‚1À8ü“b#8m‚qà(şrà(şrà(şrà(şrà(şrà(şÒC'Au‚Qd'Iw‚3À8Mx‚2À8Qy‚S¥'8Y{‚ÓÅ'8ü3À8üó "şrà(şrà(ş’b#8)6‚“b#8)6‚“b#8şrà(şrà(şÖ'(üsà(şrà(şrà(şRæ'(i‚3À8ü3À8ü3À8ü3À8ü3À8üsà(ş’b#8i‚3À8ü3À8ü3À8ş2À8şrà(ü3À8m ‚*q¡‚qà(şrà(ş’b#8q¡‚1À8şrà(şrà(şrà(ü3À8ü3À8ü3À8s!‚3"8w¢‚³7*8¤‚óG*øE      `ÈR
@     0d9      ²¤     YV €     †,¢ À     C–U       €!Ë* 0    Àe      `È"
      0d      ²ˆ      YZ€    †,¯       C–X  €    €!‹(      Àe€     `ÈR      0d¹      ²ä      Yv€    †,³ À     C–^ `    €!K.      ÀE      `È²
      0dù      ²ä      YÂ €    †,ã  @     C–\       €!K.      À¥€     `Èò@     0dÉ      ²ˆ     YÎ      †,é  @     CQ       €!Ë: 0    Àe€     `È2@     0dY      ²¬     YÚ €     †,¢  @     C–w       €!K<      Àe      `È’
@     0dÉ      ²ä      YD €     ²@   _   2˜$LŒ	&GÆCŒ Ô 	F 
ˆ# 4 ÂŞùïğ­ÿ÷ïÀ¦ÿbûï aÒBDì` Ì4Mï@Óõ4mï@Ó÷4ï@Óù4­ï@Óû4Íï@ÓıtMï@×5F †2Ø`?†2ŒØ`?†2Ø`?†2ŒØ`?†2Ø`?†2Ø`?†2ŒØ`?†2Ø`?†2ŒØ`?†2Ø`?†2ŒØ`?†2Ø`?†2ŒØ`?†2Ø`?†2ŒØ`?†2	Ø`?†2Œ	Ø`?†2
Ø`?†2Œ
Ø`?†2Ø`?…Å‹3j$>9vôødH‘#I–4yeJbŒ C	ûÿZÂ¯œ‹*# tÑ D™ ÚŒ Pg€>#  Ñ •F è4@© Z Pk€^#  Ù ÕF è6@º â o  y     CzHãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q     &pHÄô9Íd÷†4EÂƒ™~À3D€¥IŠJÒ„8	¾4E¦Ğ 2½ÎÕ:é`f@DähÂˆÃ•®h‹¦Gd Â8ae ‘@EQ‡ KK\“×LfÉ†4E0Ùe 4×#ÍàX›3Mch
%!ÁADØxÀbìD‹d„µ PÜ‚<vö ME4“a'Å€€d-Î€ KK\Óæ\­óXgÀTDN3½È@8UD ’PËR1>C01ùğ>rÛ&‚LÄ5½@d[2×ôÑmÔÓw  LDÄÀàX•H
òˆÍ9¦°´Ä5±“ópÎâDVà<‘“¤$³BD]H%Ğ`,U W‹=„dÜÒVô ÑL›sa@u‘£5#—‚«Ç²âëPEm6D@¶] CX-qM¦p2mÎe0åDÊ‹„³QEADöà,ó¤!IÄ@˜L9^3!–®h‹¦GšJ3 ÀÂ@Ä>€@ØÕ#PQD4SK\Ó4Š5¾4E5m†/MQ]ÛƒáKSTÛaøÒÕ·E¾4E5n†/MQÛ„áKSTëFaøÒÕ»U¾4E5o†/MQİ›…4ÑLN„™€©ƒ4“d‡P²$°´Ä5mTQ‹d„E,-qM›s¥@0¶Á9HSÍäDXaâÎ!ÍÔ×Ä³T€…4ÑLN„S@!mÎeHÑ€ KK\Óæ\)Lm«Ë,Ä4+¸i6Ğ`qÂDDöÆ‡ƒ„ÖHÙl@…H®„4N9	!LˆÓX‡S9WˆÑˆÍ@\àTÍ´"—á8O„4SK\ÿQm2Î!ÍÔ×Ä¿@t[“ó8¶Í@D-ö¶ã<ÒL-qMüD¹e¾4E6m†/M‘]ÛóDH3µÄ5ñ/ñdøÒÙ¶ÍD1}N3q‘#Iœ³8‘ñ8O„4SK\ÿ‘n£Íâ8&LNÄNÄcqÒTD39Æ"ÑÁBXóDH3µÄ5ñ/Ù³4„ñnPKCX À/å–ğ 2u°8ElÎeÄ0ÏBHé`HcbÀ&PQD4SêHÈ„8ØlÎ€¥SÔ,HƒL¯sm@£˜ÎÔzqûsTÍTÓDD±õL­·?GEÑL%1MD$[sÀƒH,À<‘. †4†8Ò„ÖÑÁmÛÇÖæ\fğóP‘:f8d‰KàL“Ã”D1Å¶°Î49LIÓliÒTD39ö-€!†$PQD4Óë\Ğ(²ö°´Ä5mÎµ9Óä0&·HO„LDa^ˆ°Ë"—=Òä<¯s™t t@HLÀ²8‚×Lf§ƒB`æD„DLÜ‚<FPˆÁ
A4+!ÍDD¦°Î49LI“lX’@E‘I4TK\ÓFYp@ò¬D3Ñ[ÛaÀr‘£5#—ıQ9^3!¦àê±¬øzFwH08Vlu‡t ƒcÉfwH08Öl˜ÔD\Œ4ƒcmÎ49T„Å ‹Ü‚<fĞÎƒm‹#(éIf TÍD˜UEE&ÑP-qMb3—İMÒÅ9Ë‚HˆÓ´ØCc9ÑÀ"Á@dZ’t8V‡ ‹cPÄFÁB˜h@´8Î#6ÑLN„‰ÁØf@²Åd:”D˜fÀ±@‹0„	D9Zƒ0âpèjj¥9-Å ÅKDq™s RˆÑ¼Îe\‰0Ä· †d¶Î9IêH3+DÑ$DÎ³9Óä0¬Dc‰ô Á@dLÒ€ KK\;ÑÄ9‹™jÀñ 1M„­@,ìÄFLA4Vã<ÒL-qM|:Eµİ8O„4SK\ŸN‘mV@E‘I4TK\Ó4Š=$ÈD0Zc,„D1}N3¥@0ÄDD’QHqM0ÒUÅÄaEåD‹dDŠ\ÄbbÒTD39vRI`’Ù,1™DCµÄ5`€t‘ã52aÈr«×z&ğ0 Ò¤ÀBL±‚›f]‹0w ÏDD–× ÔähFDHRöpÄÔ×dùÍD\· Ë Ëb[…0tHdn“0w8ˆ@H,1MHcHà,ópTÍD˜½,‹#()°ÓDË3 ÀÒ×´9WI“Å,€4)°ÓDØr@ó, ö:0ÏBØ@áKSTAáKSd[AáKSt›AáKS„BáKS”[BáKS¤›BáKS´ÛBáKSÄCáKSÔÛb Á"’94Ï`¯s±ó,„@À<!±HF´@°æ°´Ä5mÎµ"Æ1˜Ä "lÀ²hÔµ9T#æ€ 2µÄ5™k€ò ËJHÄDf0MÄ5ÁH38ÖŠÇÄa…ÓADÖ Œ8\Èr«×zæP„4ÉöP„4Í6Ò„êú·^ÜşŸXz&Ô ÃP"±E Ä¦W=Q!%…DälÄTˆCE¶=Q!%…Däh±F²°´Ä5¥Sd½Å@HSlsôDÈD°HF´@°ö Îƒ±BD4,-qMœ³8‘•(™ã0¬DcìÒVK\ÓG-‹$DÑn òDN’:’l“ÎD\Œ4ƒc•D1Ù‡ÔPL‡ KK\“×LBH–€<‘“¤4Ûm òDN’:RláÒ S9FDHR-qMUDdèÏ!ÍÔ×TÓ,Ø†×DälÄTˆCEV@I ó,„”. †4†&LN$Ùš#‘. FD'À&ÀH ó,„ÔÁB˜d@4×#ÍàX­ó°@EXjÀs‘“F„$I`¶Ñ8Oä$©#Å¬Dc¬Ñ,Ä4+¸i%McĞŠ490ÏBXY„4ÑLN„S@!yÀóD@HRK\S‰4„%=O„4SK\SM¿@T[z "Ë@, fİÒ “ØTD39Ö!Àâ±9—=A,-qMìD<,’†‘ÓL/2ÎFYy€óDH3µÄ5Õ4KV€ÎƒµÄ5YJ$	A4¥ã(ÔÓÁB3 À‚F¥Sd¨ÎADN’D$™	3 ÀÒ×Ä"aaˆP±ˆÃe3Î!ÍÔ×ôQ}›n€âDÓá¤‘“Ä¶ 8Ñt8iä$²ñ(N4N9ÉlCÅ3ñnÈ‡ôDH3ÆLÎ³"Æ1ÅÖLÎ³"Æ1ÉæLÎ³"Æ1ÍÖ¦4Ã"’E4qM0ÒÕ:1Ï`¯sh€õDD…8”T:Î“F„$I`&¥H
ò<Ä@˜ùI9^3!¦µaéµ"gØ‹AL-qM,’Æ DˆqL¦CI„•…ÓLé™z€ÔzqûƒÄTÓDD,’–5Ä5u°´Ä5yÍa¶°<ÒL-qM5mÑÒ SK\Ó4ŠQAE,-qM,’€D0&Ùy€Í@D©³`†ÓH6&!ME4“a'Å€t’©1‡³8ğ|`H†ÀLÄ5qò|Ô²Xu #Óç4ç,NdƒÓADÖ Œ8\Z–^+rv0•@cP€A¤Q W‹=„d_ˆ°ËrRÌæP@˜gÀ²8Îc:‘N‘mO„4SK\ŸFÄDÄF½@d›Ï#PQÔ!ÀÒ×”N‘õA9^3!v¢«©•Ö<ÀÂQÒä0¶UD4ç8Ñ€4ÀDHFIÄÔ×ÄE$qÎâDVğLÄ5ÁH38ÖŠÇd°%Ú2QLD
,Ä4–€@2 CØ”òD„$I`  a   %   A,      (" á †2Ø`?†2Ø`?†2Ø`?(0”1iÀ~ ¦ 3P*Ã`DÀˆ &Q¸‚# ”DAĞ0ÆP…
ÆˆA (‘dŒñ>Á…€‚1bP  K4ÁˆA -á0   F,p@£ˆÃ       a   >   G,      ( 3P*ÃLD ”Ê0 ¥2ÌD@©3y ”Ê0Q0AÀÂ F°0 ƒ, ½É¸`°ƒC0 ƒp"0ñ&²0 ƒ†,À,A@Æ 7 d¸aĞ`–A0:ÆxBĞF$Á  . È` 1ƒ 1Ü `0Ë0Ec0"
`–À˜%(HT Œ ‚˜%hƒ| ñÉ1  @&‚ÄÂ     †,pT‰ÃeÉˆD$—)4‹# D´Q…H3—      a   %   H,      (2 ÀPÆ¤û˜
  3P*ÃLD ”Ê0@Ãn`!f# a7²³‚œŒá†€Â`–a(:Æˆ $7·³2F H‰`0‚y `–à˜%0#˜\ €Y‚ƒA8   F,P Í@\     a   "   G,      (2 ÀPÆ¤û˜
  3P*ÃLD ”Ê0@Ãn`!f‚" a7²³BP1F ‰€1b@  IÃÁ-„Á,Ã@ƒ‹ ³Æ,A1±à Ì´€Â    F,P Í@\     a      A,      ( 3P*Ã`D0À`Dš°Â P0F À‡ Ã       F,P Í@\     a   =   E,   	   ("(2 ÀPÆ¤û˜ÊPÆ¤û 
†21 öØ 3P*ÃLD ”Ê0 ¥2FË Ğ0VÆpƒ€Á,C ³c0bV‚ 9	ƒI ´X ‰€–a$F4Á ĞrÆˆ **B0ñ@Ï¨ £0* PŸ¢†#¬` F ˆ‰?‚Á+ ÒÆpC a0Ë0icÄ€ €°f	   F,p@£ˆÃeÎÇE,’Ö,p,@cˆÃ      a   î   Y,      (T(„òO(ß"Ô k   3p*ÃLD œÊ0q §ÌDÀ©3p*ÁLÄœJ0q §ÌDPÀ©3p*ÃLD œÊ0q §ÌDÀ©3p*ÁLÄœJ0 §2ÌDÀ©3p*Ã`D´À`¤À`Ä“ éÉ =… a&‚ñ"¸`°ˆ 2ƒT0 Dñ„`#¬` Hƒ[  b0âT‚ lŒ'g0¡@BŒğ‚  mŒ'j0Ñ@BŒ ƒ  Èã	AF€A0 $„Á1€Æ \ Rƒa ‚Á6€Ì \ jƒa ‚Áˆ7€ne\@€Áˆ3€peŒñ†\9‰€‚1@tc<A#â  Êƒ1±Á PŒÁˆ5€ğ \ … ƒuÀ,A@w0ÆSŒÈƒ` HƒwÀ,@z0Æ‚TŒàƒ` Hƒw İA¸ äc<!#@! Úƒp h†#ú  …PÁ+À`)p †± ƒY†Áè¥ÂO„ÁˆU€FaX° Œ(…` ¨Æ`Ä)@²*ÈŒ …  ˆÂ€nÚ"fˆ"˜%Àf	,¢…1ŒÃ`„-@BŒ…  #`!.`–à X4á@7Ì2 O@³0†»8ƒY†¤	¨ÆpCh0Ë 4ÙÂnôâf–& \Ã; Á,Óôva˜<" _&  šã	00KĞP:Œñ„ #Ö! "‡aÁ>€`0Â‚˜%pè†ı ‚Áˆt`–à vèF¼C  b¸!h0˜e€¦€äa=Œñ„@Œ°‡` È†&‚Áx€@bFÈC0 Ô¡’€Áˆ€ş!\ ˆá† 7Ò`–!’‚Yl–Àš% f	ªYÁ:‰Y‚k–!ÀNÃ    f-`HBDMLmÔÆD c›¶€ÑPL@Dv- LÎI\S‰4„qˆ$ÂD€0‘uÁ<±yÁ<²e$”Dœ³8‘E’±I’²—˜U0†-P Í@\¶-@$ó       a   D   C,      (*‚B(&   3€*ÃLD  Ê0q ¨ÌD ª3€*ÃLD  Ê0 ¨2ÌD ªƒH4 ƒ4 ƒÆ ƒ…3 d„ 1Ü8a0ËÁˆ #Ñ´3,€@@M10@%! fŒ Eƒ¢AQ10À%! jFDÁ 5#¢` Èl Œ‚ kX `0b
€¬AÖ k5F ¨	b‚YÃ      &-0LÎcÔFàL“Ã±@pY±@€Y´ ±ÅdÆ‰p  LDdÓE„ÇdÇ…à,N    a      A,      ( 3P*Ã`D0 c0"L‚Àp       F,PÎâD     a   E   K,      (*Ö    3p*ÃLD œÊ0A§2ÌDÀ©ƒÄ2 ƒƒ2 ƒB2 ¤&c¸!Ø0˜e„`–@™%ˆã	Á2a@BŒ0‚  #\ ˆá†`À`–(‚Y…’p †‚fŒ# 8FHÁ Ì „'ƒòdP. „˜Æˆà‚ÁR . ÈxBP. Ä`Ä¨@Ş oPFŒÈ‰A(T‰Á°@ Á`@©2¨†#Î €Yd– ™e4Àp       F,\V,`f,€°8E˜³ "PQÄ@     a   7   I,      (*Ö    3P*ÃLÄ”J0!0Q&°0 ³	c<!8#ˆ` HƒD D„ 1ÜÔÌ2C0K€Ğ. ÄpCĞ€Á,Q¤&ƒŞdX €`0"N‚˜%0ˆMÉÉ°@ Á`@u2ÈNIá@Xp‰`<.,â€Œ'$á@¨FˆJ0 ³Æ,Á1Ë `@¢22     F,€°8E˜² "PQÄ@     a   .   C,      (2    ¤#ƒtdÒ‘A:2èGıÈ 2# Ğr1õÈnh!f! 2D&ƒÈd™Œƒ ò„€ĞdX€ÒdX0€ÔdXP…€ÖdXp…`Ä  8Š!¸f	‚“Ap2NÁÉ18 @%ˆA#Ü¤€èd¢“At2ˆOåÉ <t'cÄ` —@£ !@    a      áÈ „#ƒpdê‘A=2hLÆˆÁ ò€FAB@`2LÉ 0# è1Á`„ÔÂ    a   3   D,      (‚(‚r ÃPFCÀ~ û1”ÑØ°À~  3P*Ã`D€À`DÄÂ P0F p‡`¸!˜…0˜e‚`–`ŒĞc #p¤€ÁQ`0âFha #X€Áˆ€ˆ1q#Á FøH- ‘É°`Á`0q#·0 ƒ6r@e2,h@0q#Á ŒÁ	`Ä  €zpšY‚Ã      F,P Í@\     a   f   I,      ( 3P*ÃLD ”Ê0 ¥2ÌD@©3P*ÃLD ”Ê0 ¥2ÌDäP*ÃLD ¥2F Ë F´0 ƒ- ­É¸`°ƒD0 T'ã‚ÁFÁ ˆ 2±0KĞ1Æ‚h0"	€q@# ` 4á! ƒYaf	
¢†#¬` f	²Š¸  ÃC€³A6(ÃBp³ÆF|ê  ³uƒ²1ˆ 2ñ@b0,0Ğ7Æq@#È  b•Af0Æ„`0¢N‚ 3”Ã„ ƒb ±Á¸@ ƒ¹ ÁÁŒÈ•` #æ€ `– ¡9 „      †,pT‰ÃeÉˆD$—94‹# D´Q…10ÏÄ5yÍaF,P Í@\¦, 4ã5S„’-<ÏqTÍä5S„Y³ ³8°´Ä5mT    a      A,      ( 3`*ÃLD ˜Ê0!0@ÂŒø‘` Hƒa †   F,ÀH 1YÑX±@"@Ä>€@      a       D,      (¡ÃPFcÀ~ û1”…°À~ 3@*Ã`Dà
01¨B ÌR‘1Ü h0Ë ÁˆA #aTFÁ Ìƒ8’À`D‹(0q#´0     †,         a   m   G,      (2(‚*ŸÒ(Ş€ò ÁP†6
À~ ¬2”¡°@«eh£ ìà*    3p*ÂLÄ œŠ01 §"ÌDÀ©3p*ÃLD œÊ0 §2F• F” F“ F¾0 t&c¸!€Ğ`–!J“a%‚Á$ J%c¼GÈ!Œ G3,Ø@0Ş &èF„ P$t o v#B ÈN†b ‚Á<	`–À˜%ˆÃ Á,QdÌ ˜#°` ( #²` Hãor‚¸1Ş 'úFƒ Ğ7,€Œ7ÔI?ƒa€`¼!OB"Œ 3ÔÆø„$
¥Á° @0Ş *(F„ ü ƒpÀ,Á@r #ğ  ª1 PˆÁ<`–ÀÀp       F, V,f,f-€ÕLDd[µ 1Ìc×DDµaÙ        a   >   G,      (¢á     3`*ÃL˜Ê0 ¦2ÌDP€©ƒD2 ƒ2 ƒ‚, c0B`–  bP. ÄpC`a0Ë %ƒ‚p †‚'f" fP. ÄpC …Á,1Ğ1
d A ³…4,°@0!@ÔO°Á+ Yc<!Ø#°` #„! f	ºÆ`Ä@ÙŒÊ! # ´D0&Á `8      ¶,@Ló± DFmÅ¶1 @dØ,P        a   ¡   Z,      (r( (Ğ ” l6tÊhì Ø`?†2: öØ¡Œ†€ı He(`?€ı  3@*ÂLÊ0A¤2ĞŒŒÁˆ!€Áˆ4q`0‚P`0"Fpa #Z`0¡… ˜%h„ 1Ü@`0Ë c<! #’` f	Já@7á³ÄP3#~$ rÆˆA üLÔ#ƒìd˜€€zd˜€€zd7Ì2R@ÖOÆ`0â
€°AA¸ ÃÁ€Á,ƒqƒİ; mc0¢`– ¢0 b¸!@0˜e@š`0"æA èƒa ½Énîf%Œˆ7 ’1¡ Ì(tá@7n ³Ğ›ŒÁP	€Ğ`Œ'u0¡Á Ì0³ÙÉ 5ã	0ÑÁ PŒÁˆ?	`Ä  €º˜91( À.è HO†} ‚Á>	€údP®Ğ¨F”J0 „*ƒ‚p †‚—ƒYç	ˆUÆxB€
ƒ®À,A0K ÍD³Ò,Á4K@Ñ©Œá†`&Â`–¡²J•aM€`0bU‚˜%°HVá@79³W)ˆ 2ÜÌÌ2`Y@±2èV†	A¨VF	Ñ¼FÔK0 „+ƒ|e˜„€ve˜„€Äe˜„`0¢W‚˜%ÈÈÆ`º0/¼0      -@Ló´€PEADö,@T@„       a   K   C,      (ƒ‚)"(„R(†r(ep« ì`*CÜ* û¤ÊP·
À~ û1”Á­°À©ep« ì@*CÜ* û ÊP·
À~ ª2”Á­°Àªep« ìÀ*”¶-›    Ô"ãF( Ğš¬\ €Áˆ' j“a‚0ñ@52.À` ÍÉ° ÁŒ :„A.À`D íÈ¸@ ƒV  Ä‰Á+ âÄ`„À`„¸ƒ FôÈÀˆÁ  ÕpCa0Ë‰¸  T&cÄ  €”‚YDeXÀ! Q¸AÈT†q:•aÁ„`Äà  ±8Š!@  a   M   F,      (2("¨eh£ ì° 3@*ÃLD Ê0 ¤2ÌD ©3y Ê@=2#Œ` ÈÔ#` 8"ŒH‚ dŒ'0Á`Àˆ í ™ŒÁˆ% Z‘1±0K3,èF8Á 7¿p³B3F 8‰€œ1dˆ BÒO4
Ä !kP .  icÄà8 šH
! Ä„FxÁ 7HLÆpƒ˜Á,Ã@D&c0B‚˜% (ÆxB€ƒcÀ,A€á@    Æ,pÕLDdÍˆàPÍDD¶)4ED3•Ä4‘9ÏÙ² #PQD4“ØÄ       a   1   A,      (B    3€*ÁL„= ¨2ÌDØ€*ÃL Ê0A¨2FK FÊ FÉ FÈ 0ht„ a"‚ñ"¸`°ˆ 2ƒK0 ´
Â€ hFÂ Ğ3Æ‹‚p ¨ƒ0      V,À<%1MD#Ãt˜³ 1ÌcÇÅó9ÍdÆÍSÓDD!ÇdÄ‰p  LD       a   ª   ^,      (‚(‚*&   3@*ÃLD Ê0 ¤2PŒá†@À`–!‚Áˆb `– £„ 1ÜØÌ2L@72†\ƒYâˆDÆpC a0ËPÁˆÁ  ñ0K`FŒÉ.À`D³ 0KĞ‘Œá†€Â`–Ib“Al2ˆM±É 6'ƒâdĞŒƒ L9Œ‚„€èd¢“At2F p	b‚Á9I‡Œ@“t Â“a€`0‚M‚ <ˆ#Ö$€Y‚„ÒdP. ÄpC `0Ë ,ÁˆÁ  +1'h0 ƒc€ 0KĞ €³ÕÉ  \ ˆá†€À`–¡q‚Áˆ3` ˜%èÈNÆ :€údP.Äˆ 5aÁˆÁ  /A 2(D+cÄàH ˜àà•AA¸ Ã„Á,ÃDÃ‚< ™Ê°@ Á`ª0K0QŒá† %Â`–!’R•aA(€`0‚U‚ >¬#ş$€Y‰|eĞ«FÄJ0 ³ÑÊOPa0ÂV‚ [„ 1ÜÔDÌ2PU0
­  ³ÑÊ°@@0a+Á Ğ¹^ƒ» åÊndf,, ^ÃAO€Á,Ã…# ĞÅ`,Ì Ìt.Ã[ Á`Ä¸@ã2ˆVÆpƒ Á,C¦ƒµ  0KĞ Ğƒâ¢@¿2( b¸!00˜eØ¸`0â\|a f	¸Áˆ\ğ ˜%è(@á@     ¶, …b“)$ÂD02L       a   â   {     (2(…" á@P`(cÒ€ı Ne(cÒ€ı L…²¶kø Ûu|€íº=Àví  3P*ÃLD ”Ê0 ¥2FĞ F¹0 # # Ä&ƒÊdŒ pB@Ênx!f! cŒ ğÁ,@ÏnÀ!f8h# üC0b0  IÌ# @# ÈÃ` ùÉ1  `&rÆpCÁ,CA³ÆˆÁ  Åˆ¸  ÃA:€Á,Ã¡4#â€7ì ³ˆPˆ 2Ü¼Ì2$J0KÀĞªŒ À"1  €$Ğ`–`™e0˜1˜%hF  âq@†zƒYÈ	ÈGÄ nî!f ' 0 d¸!Ğ‡0˜e€¢`–`"[# ¬E0b@ ÀKÌÁ,4ËĞLn0K@Ñ™ˆ 2ÜÔÌ2TV0v0 ³¥ÁnB"f²+ ^# ÄE0ÜDÌ2dX0K° p{0K QŒá†À$Â <àYb#Ê%€î`7)³œP¹Œ ò"nX"f:/ t# èE0KàFØŠK İÁn^"f>0F èƒY= <ÃAL„Á,CˆA0b0 ÀÌèÁ,ÁŒ  
# *Ìñ‰¸  ÃM„Á,Ã”A@~". ÈpCpa0Ëpf¨ˆ 2ÜèDÌœÁ@Ç(àDàf0Ë0hÌ¤ÁˆÁ  ª@¦". ÈpCàa0Ë kŒ À
³z@¨". ÈpCa0ËÀmŒ ğ
³z0b@  ]àÂ,ªˆá† ,Â ‚ZàY†4xƒ`–Àf	â€@fŒ PÁpCpa0Ë s¬ˆ 2Ü€CÌÌÁ@Å(èEr0Ë@uÌÄÁ`DÊ°Å F¨[À,Ğ.Œá† -Â`–áò  ”# ôF0ÜÀEÌ2àAÄ2cÄ€  ßf	ò`Ä` €_˜%Ğ     F,P Í@\&-°<ÒLÄĞ×dÓˆ¤ OK\        a      A,      ( 3p*ÃLD œÊ0 §2FÇ FÆ FÅ Ğ0#Î$ Æ`Ä˜@ÄŒ“` 0     V,ÀH 1YÑ± Q8ÍdÆ‰p û        a      A,      („(Â 3`*Ã`D`À`Ä~¸Â F¨È0 Œ
ŒŒ ‘` h g‚Áˆ	 Ã      F,PÎâD     a   "   A,      ( 3p*ÃLD œÊ0 §2FÇ FÆ FÅ 0#@$ "Æ`Äˆ@ÃŒø` ¨t‚X €€QB@ƒ4 †    F,H“ópÎâDf,€Hñ°HFX±€"M@4qÎâD      a   '   E,      ( 3p*ÃLœÊ0 §2ÌDÀ©ƒ2 ƒÃ1 ƒ‚1 ƒA,À,A@Á a7Ì2D@ÇO’Áˆ$ %c<!`#–` #„! f	J†#–` f	     F,0H‘`ËbÅÃ Mf,@HHF       a   ;   J,      (ò ÃPFƒÀ~ û3`*ÃL˜Ê0!0@Â ûÃB ³~Â1Ü `0Ë cÄ  €]”Y‚d–€ eŒ PÁpC a0Ë`1c<!à…Áˆ `– !L!n&3˜e8`0âD¨˜%@¨GIƒRdŒ ƒŠ2F°H0 dj‘1b` @;Z@ÙŒp‘` ˆEÆ`„‹0K`8     V,@LÄ5±@4q      a      A,      (ˆrO(×ƒ²(ß    ƒ=RÀ`0±#Ä FèÈ0 ƒ!"À`„ˆ€ a      A,      (â,(ï„ò<(ƒòL  ƒ>bÀ`D0Á#Ä FìÈ0 ƒ""À`Äˆ€ a   n   [,      (2( Ô †2&ØÀT(k»†   3P*ÃLD ”Ê0!(0$@Änh!f! bŒ pÁ,@Æ1   ‚ƒ ôa–`1  1  #` èÃ³DÌ# ,d'cÄ€ €•F x‡i–À  d¸!ø…0˜eH€RD\ á†@Â`–!AZq@†‚rƒY‚d càà€C@f
%˜%XF ¸HTÆˆ 7Œ °ß,C3"†tƒY†§	ˆFÄpC a0Ëğ8ÕˆnØ!*%x:FÁS`g–a‚Y‚hÄ€ €‘8ƒY‰¾1ÜÈCÌ2S@d0†zƒYJf	*‚•1b@ ÀXÃÁ=„Á,ƒu³Õ`D­àÃ FØ
> ÍÊ1  à,‚á†@Â`–Ë²•1b@  Z³Ù,6A*ü0      F,P Í@\Ö, LÄ5±0Q          /** @file xmidi.c
	@brief
	This file contains MIDI-related routines.
	These routines were adapted from ScrummVM/Exult engine source code.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2013 The ScrummVM/ExultEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#include "xmidi.h"
#include "main.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//#define warning(...) if (cfgfile.Debug) { fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); }
//#define info(...) if (cfgfile.Debug) { fprintf(stderr, __VA_ARGS__); fprintf(stderr, "\n"); }
#define ARRAYSIZE(x) ((int)(sizeof(x) / sizeof(x[0])))

/**
 * Provides comprehensive information on the next event in the MIDI stream.
 * An EventInfo struct is instantiated by format-specific implementations
 * of MidiParser::parseNextEvent() each time another event is needed.
 *
 * Adapted from the ScummVM project
 */
struct EventInfo {
	uint8 * start; ///< Position in the MIDI stream where the event starts.
	              ///< For delta-based MIDI streams (e.g. SMF and XMIDI), this points to the delta.
	uint32 delta; ///< The number of ticks after the previous event that this event should occur.
	uint8 event; ///< Upper 4 bits are the command code, lower 4 bits are the MIDI channel.
	              ///< For META, event == 0xFF. For SysEx, event == 0xF0.
	union {
		struct {
			uint8 param1; ///< The first parameter in a simple MIDI message.
			uint8 param2; ///< The second parameter in a simple MIDI message.
		} basic;
		struct {
			uint8   type; ///< For META events, this indicates the META type.
			uint8 * data; ///< For META and SysEx events, this points to the start of the data.
		} ext;
	};
	uint32 length; ///< For META and SysEx blocks, this indicates the length of the data.
	               ///< For Note On events, a non-zero value indicates that no Note Off event
	               ///< will occur, and the MidiParser will have to generate one itself.
	               ///< For all other events, this value should always be zero.
};

// Adapted from the ScummVM project
struct XMIDI_info {
	uint8 num_tracks;
	uint8* tracks[120]; // Maximum 120 tracks
};

/* Linked list of saved note offs to be injected in the midi stream at a later
 * time. */
struct CachedEvent {
	struct EventInfo* eventInfo;
	uint32 time;
	struct CachedEvent* next;
};
static struct CachedEvent* cached_events = NULL;

/* 
 * Forward declarations
 */
static uint16 read2low(uint8** data);
static uint32 read4high(uint8** data);
static void write4high(uint8** data, uint32 val);
static void write2high(uint8** data, uint16 val);
static uint32 readVLQ2(uint8** data);
static uint32 readVLQ(uint8** data);
static int32 putVLQ(uint8* dest, uint32 value);

/* Returns an EventInfo struct if there is a cached event that should be
 * played between current_time and current_time + delta. The cached event
 * is removed from the internal list of cached events! */
static struct EventInfo* pop_cached_event(uint32 current_time, uint32 delta);
static void save_event(struct EventInfo* info, uint32 current_time);

static int32 read_event_info(uint8* data, struct EventInfo* info, uint32 current_time);
static int32 put_event(uint8* dest, struct EventInfo* info);
static int32 convert_to_mtrk(uint8* data, uint32 size, uint8* dest);
static int32 read_XMIDI_header(uint8* data, uint32 size, struct XMIDI_info* info);

// Adapted from the ScummVM project
static uint16 read2low(uint8** data)
{
	uint8* d = *data;
	uint16 value = (d[1] << 8) | d[0];
	*data = (d + 2);
	return value;
}

// Adapted from the ScummVM project
static uint32 read4high(uint8** data)
{
	uint8* d = *data;
	uint16 value = (d[0] << 24) | (d[1] << 16) | (d[2] << 8) | (d[3]);
	*data = (d + 4);
	return value;
}

// Adapted from the ScummVM project
static void write4high(uint8** data, uint32 val)
{
	uint8* d = *data;
	*d++ = (val >> 24) & 0xff;
	*d++ = (val >> 16) & 0xff;
	*d++ = (val >> 8) & 0xff;
	*d++ = val & 0xff;
	*data = d;
}

// Adapted from the ScummVM project
static void write2high(uint8** data, uint16 val)
{
	uint8* d = *data;
	*d++ = (val >> 8) & 0xff;
	*d++ = val & 0xff;
	*data = d;
}

// This is a special XMIDI variable length quantity
//
// Adapted from the ScummVM project
static uint32 readVLQ2(uint8** data)
{
	uint8* pos = *data;
	uint32 value = 0;
	while (!(pos[0] & 0x80)) {
		value += *pos++;
	}
	*data = pos;
	return value;
}

// This is the conventional (i.e. SMF) variable length quantity
//
// Adapted from the ScummVM project
static uint32 readVLQ(uint8** data) {
	uint8* d = *data;
	uint8 str;
	uint32 value = 0;
	int32 i;

	for (i = 0; i < 4; ++i) {
		str = *d++;
		value = (value << 7) | (str & 0x7F);
		if (!(str & 0x80))
			break;
	}
	*data = d;
	return value;
}

// PutVLQ
//
// Write a Conventional Variable Length Quantity
// 
// Code adapted from the Exult engine
static int32 putVLQ(uint8* dest, uint32 value)
{
	int32 buffer;
	int32 j, i = 1;

	buffer = value & 0x7F;
	while (value >>= 7)
	{
		buffer <<= 8;
		buffer |= ((value & 0x7F) | 0x80);
		i++;
	}
	if (!dest) return i;
	for (j = 0; j < i; j++)
	{
		*dest++ = buffer & 0xFF;
		buffer >>= 8;
	}
	return i;
}

static void save_event(struct EventInfo* info, uint32 current_time)
{
	uint32 delta = info->length;
	struct CachedEvent *prev, *next, *temp;

	temp = malloc(sizeof(struct CachedEvent));
	temp->eventInfo = info;
	temp->time = current_time + delta;
	temp->next = NULL;

	//info("Saving event to be stopped at %2X", temp->time);

	if (!cached_events) {
		cached_events = temp;
	}
	else {
		prev = NULL;
		next = cached_events;

		/* Find the proper time slot */
		while (next && next->time < current_time + delta) {
			prev = next;
			next = next->next;
		}

		if (!next) {
			prev->next = temp;
		}
		else {
			if (prev) {
				temp->next = prev->next;
				prev->next = temp;
			}
			else {
				temp->next = cached_events;
				cached_events = temp;
			}
		}
	}
}

static struct EventInfo* pop_cached_event(uint32 current_time, uint32 delta)
{
	struct EventInfo* info = NULL;
	struct CachedEvent* old;

	if (cached_events && cached_events->time < current_time + delta) {
		info = cached_events->eventInfo;
		info->delta = cached_events->time - current_time;
		old = cached_events;
		cached_events = cached_events->next;
		free(old);
	}
	
	return info;
}

// Adapted from the ScummVM project
static int32 read_event_info(uint8* data, struct EventInfo* info, uint32 current_time)
{
	struct EventInfo* injectedEvent;
	info->start = data;
	info->delta = readVLQ2(&data);
	info->event = *data++;

	/* Advance current time here, but not yet in the main conversion loop.
	 * This is so that cached events can still be injected correctly */
	current_time += info->delta;
	
	//info("%02X: Parsing event %02X", current_time, info->event);
	switch (info->event >> 4) {
	case 0x9: // Note On
		info->basic.param1 = *(data++);
		info->basic.param2 = *(data++);
		info->length = readVLQ(&data);
		if (info->basic.param2 == 0) {
			info->event = (info->event & 0x0F) | 0x80;
			info->length = 0;
		}
		else {
			//info("Found Note On with duration %X. Saving a Note Off for later", info->length);
			injectedEvent = malloc(sizeof(struct EventInfo));
			injectedEvent->event = 0x80 | (info->event & 0x0f);
			injectedEvent->basic.param1 = info->basic.param1;
			injectedEvent->basic.param2 = info->basic.param2;
			injectedEvent->length = info->length;
			save_event(injectedEvent, current_time);
		}
		break;

	case 0xC:
	case 0xD:
		info->basic.param1 = *(data++);
		info->basic.param2 = 0;
		break;

	case 0x8:
	case 0xA:
	case 0xE:
		info->basic.param1 = *(data++);
		info->basic.param2 = *(data++);
		break;

	case 0xB:
		info->basic.param1 = *(data++);
		info->basic.param2 = *(data++);

		// This isn't a full XMIDI implementation, but it should
		// hopefully be "good enough" for most things.

		switch (info->basic.param1) {
		// Simplified XMIDI looping.
		case 0x74: {	// XMIDI_CONTROLLER_FOR_LOOP
#if 0 // TODO
				uint8 *pos = data;
				if (_loopCount < ARRAYSIZE(_loop) - 1)
					_loopCount++;
				/*else
					warning("XMIDI: Exceeding maximum loop count %d", ARRAYSIZE(_loop));*/

				_loop[_loopCount].pos = pos;
				_loop[_loopCount].repeat = info->basic.param2;
#endif
				break;
			}

		case 0x75:	// XMIDI_CONTORLLER_NEXT_BREAK
#if 0 // TODO
			if (_loopCount >= 0) {
				if (info->basic.param2 < 64) {
					// End the current loop.
					_loopCount--;
				} else {
					// Repeat 0 means "loop forever".
					if (_loop[_loopCount].repeat) {
						if (--_loop[_loopCount].repeat == 0)
							_loopCount--;
						else
							data = _loop[_loopCount].pos;
					} else {
						data = _loop[_loopCount].pos;
					}
				}
			}
#endif
			break;

		case 0x77:	// XMIDI_CONTROLLER_CALLBACK_TRIG
#if 0 // TODO
			if (_callbackProc)
				_callbackProc(info->basic.param2, _callbackData);
#endif
			break;

		case 0x6e:	// XMIDI_CONTROLLER_CHAN_LOCK
		case 0x6f:	// XMIDI_CONTROLLER_CHAN_LOCK_PROT
		case 0x70:	// XMIDI_CONTROLLER_VOICE_PROT
		case 0x71:	// XMIDI_CONTROLLER_TIMBRE_PROT
		case 0x72:	// XMIDI_CONTROLLER_BANK_CHANGE
		case 0x73:	// XMIDI_CONTROLLER_IND_CTRL_PREFIX
		case 0x76:	// XMIDI_CONTROLLER_CLEAR_BB_COUNT
		case 0x78:	// XMIDI_CONTROLLER_SEQ_BRANCH_INDEX
		default:
			if (info->basic.param1 >= 0x6e && info->basic.param1 <= 0x78) {
				/*warning("Unsupported XMIDI controller %d (0x%2x)",
					info->basic.param1, info->basic.param1);*/
			}
		}

		// Should we really keep passing the XMIDI controller events to
		// the MIDI driver, or should we turn them into some kind of
		// NOP events? (Dummy meta events, perhaps?) Ah well, it has
		// worked so far, so it shouldn't cause any damage...

		break;

	case 0xF: // Meta or SysEx event
		switch (info->event & 0x0F) {
		case 0x2: // Song Position Pointer
			info->basic.param1 = *(data++);
			info->basic.param2 = *(data++);
			break;

		case 0x3: // Song Select
			info->basic.param1 = *(data++);
			info->basic.param2 = 0;
			break;

		case 0x6:
		case 0x8:
		case 0xA:
		case 0xB:
		case 0xC:
		case 0xE:
			info->basic.param1 = info->basic.param2 = 0;
			break;

		case 0x0: // SysEx
			info->length = readVLQ(&data);
			info->ext.data = data;
			data += info->length;
			break;

		case 0xF: // META event
			info->ext.type = *(data++);
			info->length = readVLQ(&data);
			info->ext.data = data;
			data += info->length;
			if (info->ext.type == 0x51 && info->length == 3) {
				// Tempo event. We want to make these constant 500,000.
				info->ext.data[0] = 0x07;
				info->ext.data[1] = 0xA1;
				info->ext.data[2] = 0x20;
			}
			break;

		default:
			//warning("MidiParser_XMIDI::parseNextEvent: Unsupported event code %x (delta: %X)", info->event, info->delta);
			return 0;
		}
	}

	return (data - info->start);
}

// Code adapted from the Exult engine
static int32 put_event(uint8* dest, struct EventInfo* info)
{
	int32 i = 0,j;
	int32 rc = 0;
	static uint8 last_event = 0;

	rc = putVLQ (dest, info->delta);
	if (dest) dest += rc;
	i += rc;

	if ((info->event != last_event) || (info->event >= 0xF0))
	{
		if (dest) *dest++ = (info->event);
		i++;
	}
	
	last_event = info->event;
	
	switch (info->event >> 4)
	{
		// 2 bytes data
		// Note off, Note on, Aftertouch, Controller and Pitch Wheel
		case 0x8: case 0x9: case 0xA: case 0xB: case 0xE:
		if (dest)
		{
			*dest++ = (info->basic.param1);
			*dest++ = (info->basic.param2);
		}
		i += 2;
		break;
		

		// 1 bytes data
		// Program Change and Channel Pressure
		case 0xC: case 0xD:
		if (dest) *dest++ = (info->basic.param1);
		i++;
		break;
		

		// Variable length
		// SysEx
		case 0xF:
		if (info->event == 0xFF)
		{
			if (dest) *dest++ = (info->basic.param1);
			i++;
		}

		rc = putVLQ (dest, info->length);
		if (dest) dest += rc;
		i += rc;
		
		if (info->length)
		{
			for (j = 0; j < (int)info->length; j++)
			{
				if (dest) *dest++ = (info->ext.data[j]); 
				i++;
			}
		}

		break;
		

		// Never occur
		default:
		//warning("Not supposed to see this");
		break;
	}

	return i;
}

// Code adapted from the Exult engine
static int32 convert_to_mtrk(uint8* data, uint32 size, uint8* dest)
{
	int32 time = 0;
	int32 lasttime = 0;
	int32 rc;
	uint32 	i = 8;
	uint8*	size_pos = NULL;
	uint8*	data_end = data + size;
	struct XMIDI_info xmidi_info;
	struct EventInfo info;
	struct EventInfo* cached_info;

	if (dest)
	{
		*dest++ =('M');
		*dest++ =('T');
		*dest++ =('r');
		*dest++ =('k');

		size_pos = dest;
		dest += 4;
	}

	rc = read_XMIDI_header(data, size, &xmidi_info);
	if (!rc) {
		//warning("Failed to read XMIDI header");
		return 0;
	}

	data = xmidi_info.tracks[0];

	while (data < data_end)
	{
		//info("=======================================================================");
		// We don't write the end of stream marker here, we'll do it later
		if (data[0] == 0xFF && data[1] == 0x2f) {
			//info("Got EOX");
//			lasttime = event->time;
			continue;
		}

		rc = read_event_info(data, &info, time);
		if (!rc) {
			//warning("Failed to read event info %ld bytes from the end!", data_end - data);
			return 0;
		}
		data += rc;

		cached_info = pop_cached_event(time, info.delta);
		while (cached_info) {
			//info("Injecting event %2X at time %2X", cached_info->event, time);
			rc = put_event(dest, cached_info);
			if (!rc) {
				//warning("Failed to save injected event!");
				return 0;
			}
			if (dest) dest += rc;
			i += rc;
			time += cached_info->delta;
			info.delta -= cached_info->delta;
			free(cached_info);
			cached_info = pop_cached_event(time, info.delta);
		}

		//info("Saving event %02X", info.event);
		rc = put_event(dest, &info);
		if (!rc) {
			//warning("Failed to save event!");
			return 0;
		}
		if (dest) dest += rc;
		i += rc;
		time += info.delta;
		if (info.event == 0xFF && info.ext.type == 0x2F) {
			//info("GOT EOX");
			data = data_end;
		}
	}

	// Write out end of stream marker
	if (lasttime > time) {
		rc = putVLQ (dest, lasttime-time);
		if (dest) dest += rc;
		i += rc;
	}
	else {
		rc = putVLQ (dest, 0);
		if (dest) dest += rc;
		i += rc;
	}
	if (dest) {
		*dest++ = (0xFF);
		*dest++ = (0x2F);
	}
	rc = putVLQ (dest, 0);
	i += 2+rc;

	if (dest)
	{
		dest += rc;
		write4high(&size_pos, i-8);
	}
	return i;
}

/* Code adapted from the ScummVM project, which originally adapted it from the
 * Exult engine */
static int32 read_XMIDI_header(uint8* data, uint32 size, struct XMIDI_info* info)
{
	uint32 i = 0;
	uint8 *start;
	uint32 len;
	uint32 chunkLen;
	char buf[32];
	uint8 *pos = data;
	int32 tracksRead = 0;

	if (!memcmp(pos, "FORM", 4)) {
		pos += 4;

		// Read length of
		len = read4high(&pos);
		start = pos;

		// XDIRless XMIDI, we can handle them here.
		if (!memcmp(pos, "XMID", 4)) {
			//warning("XMIDI doesn't have XDIR");
			pos += 4;
			info->num_tracks = 1;
		} else if (memcmp(pos, "XDIR", 4)) {
			// Not an XMIDI that we recognize
			//warning("Expected 'XDIR' but found '%c%c%c%c'", pos[0], pos[1], pos[2], pos[3]);
			return 0;
		} else {
			// Seems Valid
			pos += 4;
			info->num_tracks = 0;

			for (i = 4; i < len; i++) {
				// Read 4 bytes of type
				memcpy(buf, pos, 4);
				pos += 4;

				// Read length of chunk
				chunkLen = read4high(&pos);

				// Add eight bytes
				i += 8;

				if (memcmp(buf, "INFO", 4) == 0) {
					// Must be at least 2 bytes long
					if (chunkLen < 2) {
						//warning("Invalid chunk length %d for 'INFO' block", (int)chunkLen);
						return 0;
					}

					info->num_tracks = (uint8)read2low(&pos);
					pos += 2;

					if (chunkLen > 2) {
						//warning("Chunk length %d is greater than 2", (int)chunkLen);
						//pos += chunkLen - 2;
					}
					break;
				}

				// Must align
				pos += (chunkLen + 1) & ~1;
				i += (chunkLen + 1) & ~1;
			}

			// Didn't get to fill the header
			if (info->num_tracks == 0) {
				//warning("Didn't find a valid track count");
				return 0;
			}

			// Ok now to start part 2
			// Goto the right place
			pos = start + ((len + 1) & ~1);

			if (memcmp(pos, "CAT ", 4)) {
				// Not an XMID
				//warning("Expected 'CAT ' but found '%c%c%c%c'", pos[0], pos[1], pos[2], pos[3]);
				return 0;
			}
			pos += 4;

			// Now read length of this track
			len = read4high(&pos);

			if (memcmp(pos, "XMID", 4)) {
				// Not an XMID
				//warning("Expected 'XMID' but found '%c%c%c%c'", pos[0], pos[1], pos[2], pos[3]);
				return 0;
			}
			pos += 4;

		}

		// Ok it's an XMIDI.
		// We're going to identify and store the location for each track.
		if (info->num_tracks > ARRAYSIZE(info->tracks)) {
			//warning("Can only handle %d tracks but was handed %d", (int)ARRAYSIZE(info->tracks), (int)info->num_tracks);
			return 0;
		}

		while (tracksRead < info->num_tracks) {
			if (!memcmp(pos, "FORM", 4)) {
				// Skip this plus the 4 bytes after it.
				pos += 8;
			} else if (!memcmp(pos, "XMID", 4)) {
				// Skip this.
				pos += 4;
			} else if (!memcmp(pos, "TIMB", 4)) {
				// Custom timbres?
				// We don't support them.
				// Read the length, skip it, and hope there was nothing there.
				pos += 4;
				len = read4high(&pos);
				pos += (len + 1) & ~1;
			} else if (!memcmp(pos, "EVNT", 4)) {
				// Ahh! What we're looking for at last.
				info->tracks[tracksRead] = pos + 8; // Skip the EVNT and length bytes
				pos += 4;
				len = read4high(&pos);
				pos += (len + 1) & ~1;
				++tracksRead;
			} else {
				//warning("Hit invalid block '%c%c%c%c' while scanning for track locations", pos[0], pos[1], pos[2], pos[3]);
				return 0;
			}
		}

		return 1;
	}

	return 0;
}

/********************************* Public API *********************************/
// Code adapted from the Exult engine
uint32 convert_to_midi(uint8* data, uint32 size, uint8** dest)
{
	int32 len;
	uint8* d,* start;

	if (!dest)
		return 0;

	/* Do a dry run first so we know how much memory to allocate */
	len = convert_to_mtrk (data, size, NULL);
	if (!len) {
		//warning("Failed dummy conversion!");
		return 0;
	}

	//info("Allocating %d bytes of memory", len);
	d = malloc(len + 14);
	if (!d) {
		perror("Could not allocate memory");
		return 0;
	}
	start = d;

	*d++ = ('M');
	*d++ = ('T');
	*d++ = ('h');
	*d++ = ('d');
	
	write4high (&d, 6);

	write2high (&d, 0);
	write2high (&d, 1);
	write2high (&d, 60);	// The PPQN

	len = convert_to_mtrk(data, size, d);
	if (!len) {
		//warning("Failed to convert");
		free(d);
		return 0;
	}

	*dest = start;

	return len + 14;
}

/** @file xmidi.h
	@brief
	This file contains MIDI-related routines.
	These routines were adapted from ScrummVM/Exult engine source code.

	TwinEngine: a Little Big Adventure engine
	
	Copyright (C) 2013 The TwinEngine team
	Copyright (C) 2013 The ScrummVM/ExultEngine team

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License
	as published by the Free Software Foundation; either version 2
	of the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

#ifndef XMIDI_H
#define XMIDI_H

#include "sys.h"

/**
 * Credit where credit is due:
 * Most of code to convert XMIDI to MIDI is adapted from either the ScummVM
 * project or the Exult game engine.
 * //risca
 */

/*
 * Takes a pointer to XMIDI data of size 'size' and converts it to MIDI. The
 * result is allocated dynamically and saved to the 'dest' pointer. Returns
 * the size of the MIDI data or 0 on error.
 */
uint32 convert_to_midi(uint8* data, uint32 size, uint8** dest);

#endif // XMIDI_H
BCÀŞ!  ,	  ‚        #‘AÈI29’„%‹b€EB’Bä28I
2D$H
!#ÄR€!r$ÈÈb¨ ¨@Æğ   Q      f#øÿÿÿÿv(‡y˜‡6€y(‡qH‡y(‡60xh‡p ÀÂæ¡ ÂŞ¡ÌAÂ¡Ê¡àáÒÁè¡ä¡ÊÒ¡ z‡z(`p‡whs‡ph‡rhxx‡tpz(yhƒr`‡th‡6p‡wp‡6`‡rs wx‡6Hw0‡yhs€‡6h‡p t Ì!ØaÊ ÜáÚÀÂÁæ¡ÌÚ ÂĞ0‡p`‡y(€˜z‡qX‡6€yxz(‡q ‡w‡6‡z0s(yhƒyH}(  ¢ÜaÂÁÊ¡ÌÚ ÂĞ0‡p`‡y(€¨‡y(‡6˜‡w0zhs`‡wz Ì!ØaÊØÂÿÿÿÿ;”Ã<ÌCÀƒ<”Ã8¤Ã<”C˜<´C8`áÀóP áïĞæ áĞåĞğğéàôPòĞåÀéĞ =ÈC=”0¸Ã;´9ÈC8´C9´<¼C:¸=”ƒ<´A9°C:´C¸Ã;¸C°C9„ƒ9 „;¼C¤ƒ;˜Ã<´9ÀC´C8Ğ: æì0å îğmàáàóĞæ mĞá@è ˜C8°Ã<”@Ì=„Ã8¬CÀƒ<¼=”Ã8ĞÃ;ÈCˆC=˜ƒ9”ƒ<´Á<¤ƒ>”€ Qî0á`åĞæ mĞá@è ˜C8°Ã<”@ÔÃ<”CÌÃ;˜=´9°Ã;„= æì0å l ƒ Ë£€¨6Æÿÿÿÿ€´8 @   I     ‚`B L†`Â@Æá&Ã„à   ‰   C   2"È	 d…“#¤„“#ã„¡LŒ„äLŒÂ’ 
€s`p4E”0ù@ã4>ÀàªAœÆ§Aá iŠ(aò½Šh&±)T
€C´8Iš"J˜|bğ*¢™Ğ((H‘ j¢0(èQˆÂ 0 HšŒ ¡2 K*„aæ 2TÚ$Şà"iŠ(aòcSìÄi
	€y
Q>*Da(¨‰BHe(d*CaP T
R•¡’(«…Á @®9‚ •Á P€Q¬Í¨@„) JP‡d }@¿[¤)¢„É§A @A   °p˜‡vP‡yhƒzp‡up‡w¸whƒrh‡yyHx ‡rp‡áPmq x xĞé€z€z€mq`zv q`ms z0r s mv@z`t v@m`s z0r s m`v@z`t v@m z0r s z0rĞör€z0r q xĞî0rĞ³r€:„H #DD€Š€A   $a€s|™Ì;'ƒ$    v(N@I  @ ìPœ ’  € Ø¡8$  °Cq‚3H  `‡âh  ÀÅ	Ò 	  €! @     C	 †     †,     Y.      ²d 0    0dá `    `Èr     À% `    `È2 0    0d)     ²œ     YÒ  †     †,k  C     C–5 €!    €!K À    Àå€     `È² 0    0d‘      ²Ğ     d       2˜LŒ	&GÆCŒ P@³á»Î&ƒÜo:(Ìf¿ÇazÔ.·ßò<F H1@%>t5—ˆM±["îÄu	ñüP%†A*h‰V4·%¼÷l  y     C„:HãÀáàç öPò0éğî sàt #v`{h7Hr(w ‡)    y     3€Äáf=ˆC8„ÃŒB€yxs˜qæ íô€3BÂÁÎ¡f0=ˆC8„ƒÌ=ÈC=Œ=ÌxŒtp{yH‡ppzpvx‡p    q   F   vD0¼¥j[QDaà4Mÿäü2 PC‡DF=Îó€pÃOTD3 áKSdÆCMo©AáKST[AáKSd›AáKSt[EòPÓOTD3ÙAáKS„BáKS”›DÀğÇ¦Ø‰ÿA ™†ÁŒÀ<ÆğNSÑôOÎÏL‘bHD ƒ½8–%¾4Eº)¾4E»M<?QÍô#MáØ@# ÂA?QÍ$G¶,ã3#<˜ÿĞï?4ÂûÈmÆÀğ–ªe(P?QÍdID ~ Æa,‹#˜ƒñQäD&@=ÔôÑLşHÓOTD3„bEÈDØbö X2ø   a   m   J,      (Í€B(è€B Má• J` 8Š4# D ÁP† sPÌ    3vPÈÁ0Ar0ÌDØA!ÃLÄr0ÌDØA!ÃLQÈÁ0Ar0F× FÖ FÕ 1†%f„ ŒH ˜%H„Œ ğ@È`0	€1ÜLa0Ë@Á`„CÀ,ABÊ°€Áˆ |F0Á 3†‚5ƒY£F ğj0bÊ `– !gF8Á Ğ3Æn0"
`0Bƒ  hŒ'Ş`ÄÀ`„@@ÓOÀ`0¢
`0B(ƒ  jŒ'b0q0!˜A Œ `
ŒP
×7bP@)\d0bP@)\e@Û mP6F `…A#¸` ˆÃÁ„Á,rÔ V!Œƒ4 €Y‚„ºAa0#a (†k ‚Áˆ3 `– ¡3 „   ¶B„4™O0X
1 `*„„d„ıÒD“õÑ       a   1  g  	   (Í€B(ò€²¨ò¢B	Œ Dù”WBPb    3vPÈÁ0Ar0ÌDØA!ÃLQÈÁ0a…3vPÈÁ0a…3vPÈÁ0Ar0ÌD…3_!ÃLDRÈÁ0‘…ƒÌ7 ƒ‹7 ƒJ7 ƒI5 ƒH5 ƒ5 ƒ 1ƒ˜1 ƒG0 ÔŒá†€Â`–!zÆxBÀFDÁ Fc ñ„ÀŒ˜‚ŒÈ  hã	FTÁ Fe Tñ„@#®` #3 ºÆ`Ä ac<!ø#´` f	âqcÄÀ  T‚j0B€´1Ü¤AÌ2C0!j  ³f0Ş€©ÁŒ7k°ŒÁ2`–  2Ôá! ƒYCèÆxB„
1ÜÈÌ2I@l0Æ‚;  \Pˆá†ÀÀ`–I‚Y‚‚â`ĞŒ xAHƒ`0â‚ 7Ã„Á,Ã¢ƒwğ 0K`ƒî`Œ'Â`D@v0Æà`H‚1bP  9Á`„0KÀŒá† Â`–¡‘êƒAu0F
 @!Œèƒ` ¨ÆpCÀ
a0Ëğ8Á`D)´ Ì˜‰ÂnÂ!f ( PT
c<!#N!€Y‚ˆHa)Œ
Œ0…` (ÆxC`·@Á V0á
Á )Œñ†`x‚1Ş 
½àŒ
†Œ‚ VvÄ€  ’ÈÆx,Œ9P0F
  ‰!Œ…` f	Ú…1bP @I´0¡Á .Œá† Â`–š‚ÁqP ˜%0ú…1ÜøCÌ2TV@¾0HÆxB FC0 ³…Ã p01Á Œ7ü‚<ÌƒĞaT À`„:0Ş0ö „
1ÜÜÌ2\Y0Şpú@ğv¼!à~  \Pˆá†€À`–Ëz‡1Á Ìd³ÑÃ {ÃB`³›P>Â‡Aú0LB0bP @YÁ`Ä>@ş0†‚ƒY®¨…ÄO„Áˆ‘`– #£#D"€Y‚0 “# ¼E ƒ% ¡ÄnÎ"f>0è$­ÄO„Áˆ–`– H%©Ä¨@€Á–`– &ÆpCğa0Ë cLŒñ„à'#h"€ÁA,€hbŒ'a1aÁ Fc ³c@61F
 ø‹@,#j" ª‰a`€€lbT À`N@<1†‚½ƒY2(ƒ€vbĞOŒñ„@Œ‹` ¨'Fl# È†O³e@?1#Î" €Y3 ³ „      ¶B„42 ğÍ`@ÈHÓ„0„- Äğ#MáX	V¤\2 ?Ò	ˆ¥0¦BHHFØ"!ñ?dFÒıÂ      a   1   A,      T(ò(˜)  3wP¬Á0aÅ3D±Ã`Ä À`„ ƒ‚11@Ä¨ Á
½  tŒñ„àŒH‚Œ†  eTà`‘^  jÆxBPF<Á FC 4*˜°‚K/  Mc<!Ø#ª` #„! Èpz ã	FhÁ FC 6¨ƒ0     ¦2TÀb2Á`)Ä L        a   %   A,      T(ò( 3wP¬Á0ÑÅ3D±Ã`Ä€À`„p ƒ‚11@„¸  Y¢ €18ƒJ0 ƒÂ ´ˆ
Q¤ €œ1PƒP0 ƒÂ šÆ`D  †     ¦2TÀb0Á`)Ä L        a   (  k     (‚ P¡àŠ  ª J`€CRĞAACNRĞAACRĞAACÎQĞAACQĞAACQĞAACNQĞAA   3vPÌÁ0As0ÌDØA1ÃL„s0ÌDØA1ÃLQÌÁ0aÅ3vPÌÁ0
Å3D1ÃL„s0F(Ş F$İ F Ü FÓ 2#†` #j h# ¼Ağ\Ã³idŒñ„@Œ@‚1  @Á& JÆ`„ )cÄÀ  ;*o¸!èÂ`–ajÆxBƒO0 Tñ† Â`0"Pƒ ˜%¸(# ôAà•ÁpC@a0Ë@Á`DW 0K Dñ„ #¬` ˆã Á`Dğ0Ñ­Á ÌÔâÆpƒÁ,ÃñÇ–¸1b€ €)¼AP7Æ‚8Œø‚1   ¾Á1€Ê`T`0qÁ Œ7ŒÁÌÁˆ ®À7u ³HĞŒá†€È`–!Q‚Á8À ˜%Pƒâ ^á.  ½Áoö`#‚! hÆxB 
ƒm ½ÁnHAf&˜%`f	ŠƒQ(@¥ $c<!#è  ²ƒQÁ)@ª Ä£#ü €Y‡ü`TÀ
0
Á Ì
c¼!h…V  \Pˆá† À`–Š‚ÁˆTˆ ˜%P"…A¤0* ¨àt<#J! *…1b` @<´Ã.„Á,ƒ4ƒ± 0K „
c<!à…ÁU`Ä€  zP…ÁW€VaŒ p-üÂpCàa0Ë@UÁ`Ä-ü Ì¨¹ÂOÄa0‚˜%°f	.²…1Şˆƒ8P.(ÄpC°f0Ë€eÁ`„/˜ Ì¨Á,F´0ˆÆxC€è@A¸ ÃE€³´cÄÀ €“Îá†wƒY†ÈÆxB@ƒàÀ,Á8Œ X"Xznæ!f>/ qã	Á=F”C0 ³f@å0F ˆ‰ òa¸!À‡0˜e0ÆxBÀƒêÀˆ 4¡ƒî ¹Ã¨À ‚Pr‡1ƒğÀ,A<Œ x"	’nF"fÆ@š‡1¤ÑÃ ~ãJ¤ÄxCÃ`DP åÃOZb0b‚1   ,öa0â‚ ¼T Jÿ0Æa0"$‚ Ğ#D"€Y2Œ`	š €Y5˜%(ƒY3˜%8ƒYm0‚%j f	Ô`0‚%h f	Ô€Xd      V4<dFÊ‚"­0Ø"T£”Dc@b)Ä L€©’¶B MáÑP…ÒD“	Ñ        a   ‰  ^,      (‡ú( *Œ ”@B”GaDQGY @q|@I”FÁz@©”{@yx@‰y@™{@1”h     3vPÀÁ0Ap0ÌDäAÃL„p0ÌDäAÃ`q01˜Á Fe0 D"ÆxC0c00b@  tŒñ†ÀÊ`0"€”1œÁ` 	˜1Ş¬ÁFC 3Æ‚6`
A£#¤` hã¸á‚BT 9ÌT\uPøAaÆx`äÁAec<!°ƒÁˆ- mc¼!Ğ<¸@¸ãğÁ`DP ÁOú`0B‚ !Œñ† şàá7£ 
ƒA # ìÂĞŒñ†ÀFa0"€Ò`Œ7¨`
w¼!P…T  \Pˆá† À`–A‚ƒ1Ş¼Â*P.(D­  Â^  ºƒ1ŞØ‚,FC PŒñ† ja0"È…˜% F Ø‡T¸ ±ƒ{ õÁox(¢]Ğª…`/  ‰ÂoÆá#‚! ÈÆxCPãppÇ‚s8
¥ÂoÔ.îxCÀì0@¯0Æw`‡„;ŞÀÃ;PHÆxC0ñppÇ‚z ‡Áˆ  Â…1ŞÜ=P0(ÆxC ÷0@»0¨ÆˆA 3!³Ä,Gà0Æ‚~Œ‡` H$c¼!‰¸@¸ãÁHŒÄ`DP ™ÃoJb$.îxCp&1äD Ìp´c<!@‰Áˆv€„@í0Æ–P‰„;Ş¸„KFE <Œñ„à%#è! ÑÃof"&.îxCP410KÀQ>Œñ„À&#ö! íÃot'.îxCÀ<1@ 1Æ‚Œ‰` H$c¼!‹Ÿ¸@¸ãÁXˆÅ`DP ™ÄoÊb,.îxCpgAA¸ ÃdEÀ€
‰(({°ŒÂB
K),¦°œÂ‚
,³Ğ,4K Í0Äc¼!X‹´¸@¸ãA[´á‚B7dq³ÍĞLŒñ†@.àâá7tA„
1Ü¨EÌ28O0KğÌ@³éÄoò¢.(¢‚»Ğa®"Ğæ@Šƒ)(; î€Êª(< Ş ¢‹ÀbŒ'}1!Á H,ÆxCqpÇ‚ÑÁˆ  :‹1Æ`DZ@B ´ãj˜ÆÂoT#5#‚" f	6r‹1¬Æ`\@B ¸ãÁk´ÆÂob#6#‚" ˆ.ÆxC0±qpÇ‚Ú Áˆà<`–`#¼ãÁmÔÆÂor7#‚õ â‹1ŞìFn\ Üñ† 7zc0"x ˜%ØF ¨Ğ ĞãxôÆ`D0 ‘Æ ÒãÁx„Ç¼oÊƒ<#‚b 5ÆxCpäAÁ Öã	0áÁ Ìläc<!XÁØ€„@°1Æ‚÷hx;ŞÄG|FE Œ "µAµ1ÆúˆÁˆ` ÂA¸1Æ‚û¨x;Şä~FÅ oŒñ†`?ğƒ‚Aà1Æa0B<‚ ğãˆøÇ¼oDDD(b¸!P0˜e¸²€ĞcŒ7'B"Œá†àDÀ`–Ëb1Ş¬HŠ\ÀÛñ† EX„‚1¼È`D0#@ò1Æ‚y‘x;ŞÌˆŒP0ÆŒp$ ?ÆxCp#5roÇ‚Á
ÆxBp#ƒAÀ,A6K°F€ À,A7KÀÑú1ŞøˆP0(ä	…,!ˆÁˆ	 `– £„   	   ¶ÂTÍôOCØSƒ4	!LÄàUD3Y
1 `*Ò      a   6   D,      T(€" Ä   3vP¬Á0aÅ3yP¬Á0Ák0FÊ FÉ FÅ Œá†`
ƒY†`HÆxC ,J%£„ †ˆ€f„! <ãAQ0#œ` ˆÆxC@UšF	AĞ4Æ‚LŒ† QƒU0 D
c¼!à6
Æ`Ä)@Ø¸`°# ìA0K0Ğ62   –ÂTÍôOC˜J1ËX4…c2ƒ³     a   Ğ   _,      T("(ƒB(ğ‚(‰¢(‹â(ŒÒ(ò  3DÁÃLDl0ÌDØAÁÃL„l0ÌDØAÁÃ`DaÀ`QÀ`Ä@À`D@ ƒŠ1ŞXcÄ  €6 ‚Á# RÆpCPa0Ë!ƒš1ƒO0 ³-ƒœa ‚Á( ŠÆxC `@A¸ ä
á‚B7AÌ2C@ØoÒà(b¸!8ƒ3˜e €¼1ÜäAÌ2F@ßoàÀ(4c<!ƒÁˆ2`0B`–À 1Ğ#Ê €Y‚ƒÌ`Œ7wP„Áq€Ò`Œ7z€„
QAä0Stq€È2 u€ØÁr8ôc¸!P…0˜eH”€à`Œ7¡àw¼!…Q  Œñ„ #ğ €Áa ºƒ1Ş B)\ Üñ†@R‚@}0ÆVŒøƒ` #„! f	êƒaA+€`0â‚˜%ğ(ÆpCÀa0ËÀ4‰Âof.îxCPµ@A Tã	Á-F¨B0 ƒÂ ³¡Â° @0¡
Á Ìx´
c¼!à]  \Pˆá† À`–á‘Š…1Ü°CÌ2@Q@²0Æ‚q ‡„;Ş”C9PÆxBpƒºÀ`„0À,AD¸0,HFèB0 ³ñÂ ^ãA;¤cÄ   ’ ‚Áˆ^€Âa7ü³Ğ/"‡1ƒæÀ,Eâ0¨†#Î! B‡1ŞäC=P0†‚}ƒY†Š#Ô`–À"uÔc¼!ğ} `7Ì2\[@ò0†‚–ƒY,(ÑÃoJB$.àíxCp&AÁO
ñÃOVb0Â‚Œ† ˜%Èˆ†-‚Á`–@£~¼#ş!€Yk–€›%ğf	<‰‘A8    –B„4™	Æ Ö$¦B Má        a   J   K,      T(ò(ˆr(@ò 3vP¬Á0Ak0ÌDØA±ÃL„k0ÌDØA±ÃL„k0FÏ FÎ FÍ 1*ht0¢`–  cTÀà`ÀpCğ„Á,ƒ0„Œ
 ŒP‚ eT@iÑR3*v0â	€ša‚Áˆ'€Y‚€¦1ÜœAÌ2D@ÑŒ¸ ˜%P#&n f	šMc¸AĞ`–áHºFœ^  âÆxBPƒ^0 ƒÂ Ä
È #¼` f	ê†i ‚Áˆ/€Yƒ¼1A Ì(D ƒp     –B„4ÙM€XPEADf$¦RTÀB        a   (   D,      T(€ X  3wP¨Á0Aj0ÌDØA¡Ã`Ä€ ƒ‚1A01 0K1Æ‚„‚pA!*Xt¸!hÂ †g„! eŒ'Ñ`D 	á‚B3*`0
`–  hĞ4#a H„     ö2<d)Ä L€Á°P        a   6   G,      T(€B(‡ò(@   3wP¨Á0Aj0ÌD…3vP¨Á0a…ƒ3 T
Æ`„À`ÁÀ`ÄÀÀ,A@Ãn4˜eŒ€1@ƒJ0 $„Á% JFĞ.(D’ì`Ä Aá‚BTPépC …Á,1³Æ,AAÒ° Á`À,A@× lFÂ Ğ52     &3HSd)Ä L€ÑˆÍ°P      a   k   O,      T("(„Â Ø    3yP°Á0a3vP°Á0Ál0ÌD03LÁÃ`„áÀ`DÑ c¼!h
Æ`ÄÀˆ m°\ ØÁ# Zc¼!˜¦Áˆ` j5£„ ˆãvFÃ 3ÆŒÊ` hÆpC`a0Ë Ic0Â‚˜%p#*4 2…1Q0K0P5†5ƒY¢èã„ƒºAİ(!€á" ƒY‚b LaˆYãèƒa ÁoÖ (ƒcÀ,Á@c0†<ƒY†	ˆÁoâà#‚a f	Jƒ1ÜôAÌ2(K@k0Æ‚:˜
±ÁoğÀ#‚a ÈÅÁoö #‚a f	"‡Ar0Æ?àƒÁˆ` ¢ƒ1Á Ì0³Í,ƒá@  
   ¦ÂTÍôOC˜1Ìc3Å@,`)ÒÑODTVC4Ä5     a   *   A,      T(€‚)"(ˆ2(  3wP¨Á0Aj0ÌDôA¡Â`ÄÀ ƒ‚1A@ÄO
Â…¨à9JÆxB0Q.(DÓ•,=c<!¨(¢‚ëÊ–ª1d„
QE°h`0B€¶1xäÁˆ@ êÄ…È     6–BÀMQE      a   !   A,      T(‚(    3wP¨Á0Aj0ÌDôA¡Â`Ä€ ƒ‚1A@ÄO
Â…¨€9JÆxBĞP.(DÁ^ Á' zÆxB ‘4#a („    ö–BÀLQE          